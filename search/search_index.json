{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Informatica - CdL in Matematica (UniBa 20/21) \u00b6 Benvenuti! Indirizzi utili \u00b6 E-mail del docente: angelo.cardellicchio@uniba.it Contatto Skype: angelo_cardellicchio Orari del corso \u00b6 Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 . Ricevimento \u00b6 Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Nota A causa dell'emergenza COVID-19, il ricevimento deve essere necessariamente concordato a mezzo e-mail; \u00e8 inoltre preferibile evitare il ricevimento in presenza, optando per comunicazioni telematiche a mezzo e-mail, Skype o Microsoft Teams. Modalit\u00e0 di svolgimento delle lezioni \u00b6 Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica. Prerequisiti \u00b6 Non sono necessari particolari prerequisiti per l'accesso al Corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il Corso.","title":"Home"},{"location":"#informatica-cdl-in-matematica-uniba-2021","text":"Benvenuti!","title":"Informatica - CdL in Matematica (UniBa 20/21)"},{"location":"#indirizzi-utili","text":"E-mail del docente: angelo.cardellicchio@uniba.it Contatto Skype: angelo_cardellicchio","title":"Indirizzi utili"},{"location":"#orari-del-corso","text":"Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 .","title":"Orari del corso"},{"location":"#ricevimento","text":"Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Nota A causa dell'emergenza COVID-19, il ricevimento deve essere necessariamente concordato a mezzo e-mail; \u00e8 inoltre preferibile evitare il ricevimento in presenza, optando per comunicazioni telematiche a mezzo e-mail, Skype o Microsoft Teams.","title":"Ricevimento"},{"location":"#modalita-di-svolgimento-delle-lezioni","text":"Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica.","title":"Modalit\u00e0 di svolgimento delle lezioni"},{"location":"#prerequisiti","text":"Non sono necessari particolari prerequisiti per l'accesso al Corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il Corso.","title":"Prerequisiti"},{"location":"00_materiale/programma/","text":"Dispense e slides \u00b6 Il programma del Corso si articola come segue: Argomento Slides 00 - Introduzione al corso Parte 1: Teoria \u00b6 Argomento Dispense Slides 01 - Introduzione all'informatica 02 - Introduzione agli algoritmi 03 - Architettura dei calcolatori 04 - Reti di calcolatori 05 - Rappresentazione dei dati 06 - Linguaggi di programmazione 07 - Traduttori 08 - Variabili 09 - Programmazione strutturata 10 - Ricorsione 11 - Diagrammi di flusso 12 - Funzioni 13 - Strutture dati 14 - Complessit\u00e0 computazionale 15 - Algoritmi 1 - Ricerca su array 16 - Algoritmi 2 - Ordinamento 17 - Algoritmi 3 - Ricerca su grafi 18 - Macchina di Turing Parte 2: Cenni al linguaggio C \u00b6 Argomento Dispense Slides 01 - Hello, C! 02 - Alcune definizioni 03 - Visibilit\u00e0 di una variabile 04 - Operatori 05 - Array 06 - Puntatori 07 - I/O e file 08 - Typedef, Struct ed Union Parte 3: Cenni al linguaggio C++ \u00b6 Argomento Dispense Slides 01 - Dal C al C++ 02 - Programmazione orientata agli oggetti 03 - La Standard Template Library 04 - Templates Parte 4: Cenni al linguaggio Python \u00b6 Riferimenti esterni \u00b6 Testi di riferimento \u00b6 Nota Questi testi sono consigliati . Ci\u00f2 non implica che sia necessario seguirli in maniera pedissequa , ma che occorre intenderli come materiale da usare per motivi di approfondimento personale. Ci\u00f2 comporta due conseguenze: la prima \u00e8 che il corso non segue un testo di riferimento, quanto piuttosto le dispense e le slide proiettate a lezione; la seconda, pi\u00f9 rilevante per lo Studente, \u00e8 che per superare l'esame basta seguire queste ultime. Testi integrativi (per l'approfondimento della materia) \u00b6 Questi testi possono essere considerati come una buona integrazione, da usare per approfondire gli argomenti trattati a lezione. Tanenbaum, Architettura dei calcolatori. Un approccio strutturale Tanenbaum, Reti di calcolatori Deitel, Deitel, C++. Fondamenti di programmazione Testi online \u00b6 Questi testi sono da considerarsi al pari dei testi integrativi per l'approfondimento della materia, con la differenza che sono disponibili (liberamente) online. The Python Tutorial Python Data Science Handbook Testi consigliati (per la data science) \u00b6 Questi testi sono da considerarsi come dei buoni approfondimenti qualora si decida di approfondire, magari in futuro, degli aspetti legati ai principi matematici ed informatici della data science. Goodfellow, Deep Learning G\u00e9ron, Hands-On Machine Learning with Scikit-Learn and Tensorflow: Concepts, Tools, and Techniques to Build Intelligent Systems Esercizi di approfondimento \u00b6 Note Alcuni di questi esercizi fanno riferimento a materiale esterno al corso. Il Docente non \u00e8 responsabile per, n\u00e9 proprietario dei, contenuti presenti a questi link. Inoltre, questi esercizi non sono rappresentativi di tracce di esame, presenti, future o passate. Diagrammi di flusso \u00b6 Esercizi Svolti su Coding Creativo Programmi utili \u00b6 Visual Studio Community 2019 : IDE per lo sviluppo di programmi in C/C++/Python Visual Studio Code : IDE per lo sviluppo di programmi in C/C++/Python Guida ufficiale all'installazione e configurazione di Visual Studio Community 2019 Guida ufficiale all'installazione e configurazione di Visual Studio Code Interprete Python","title":"Slides proiettate a lezione"},{"location":"00_materiale/programma/#dispense-e-slides","text":"Il programma del Corso si articola come segue: Argomento Slides 00 - Introduzione al corso","title":"Dispense e slides"},{"location":"00_materiale/programma/#parte-1-teoria","text":"Argomento Dispense Slides 01 - Introduzione all'informatica 02 - Introduzione agli algoritmi 03 - Architettura dei calcolatori 04 - Reti di calcolatori 05 - Rappresentazione dei dati 06 - Linguaggi di programmazione 07 - Traduttori 08 - Variabili 09 - Programmazione strutturata 10 - Ricorsione 11 - Diagrammi di flusso 12 - Funzioni 13 - Strutture dati 14 - Complessit\u00e0 computazionale 15 - Algoritmi 1 - Ricerca su array 16 - Algoritmi 2 - Ordinamento 17 - Algoritmi 3 - Ricerca su grafi 18 - Macchina di Turing","title":"Parte 1: Teoria"},{"location":"00_materiale/programma/#parte-2-cenni-al-linguaggio-c","text":"Argomento Dispense Slides 01 - Hello, C! 02 - Alcune definizioni 03 - Visibilit\u00e0 di una variabile 04 - Operatori 05 - Array 06 - Puntatori 07 - I/O e file 08 - Typedef, Struct ed Union","title":"Parte 2: Cenni al linguaggio C"},{"location":"00_materiale/programma/#parte-3-cenni-al-linguaggio-c","text":"Argomento Dispense Slides 01 - Dal C al C++ 02 - Programmazione orientata agli oggetti 03 - La Standard Template Library 04 - Templates","title":"Parte 3: Cenni al linguaggio C++"},{"location":"00_materiale/programma/#parte-4-cenni-al-linguaggio-python","text":"","title":"Parte 4: Cenni al linguaggio Python"},{"location":"00_materiale/programma/#riferimenti-esterni","text":"","title":"Riferimenti esterni"},{"location":"00_materiale/programma/#testi-di-riferimento","text":"Nota Questi testi sono consigliati . Ci\u00f2 non implica che sia necessario seguirli in maniera pedissequa , ma che occorre intenderli come materiale da usare per motivi di approfondimento personale. Ci\u00f2 comporta due conseguenze: la prima \u00e8 che il corso non segue un testo di riferimento, quanto piuttosto le dispense e le slide proiettate a lezione; la seconda, pi\u00f9 rilevante per lo Studente, \u00e8 che per superare l'esame basta seguire queste ultime.","title":"Testi di riferimento"},{"location":"00_materiale/programma/#testi-integrativi-per-lapprofondimento-della-materia","text":"Questi testi possono essere considerati come una buona integrazione, da usare per approfondire gli argomenti trattati a lezione. Tanenbaum, Architettura dei calcolatori. Un approccio strutturale Tanenbaum, Reti di calcolatori Deitel, Deitel, C++. Fondamenti di programmazione","title":"Testi integrativi (per l'approfondimento della materia)"},{"location":"00_materiale/programma/#testi-online","text":"Questi testi sono da considerarsi al pari dei testi integrativi per l'approfondimento della materia, con la differenza che sono disponibili (liberamente) online. The Python Tutorial Python Data Science Handbook","title":"Testi online"},{"location":"00_materiale/programma/#testi-consigliati-per-la-data-science","text":"Questi testi sono da considerarsi come dei buoni approfondimenti qualora si decida di approfondire, magari in futuro, degli aspetti legati ai principi matematici ed informatici della data science. Goodfellow, Deep Learning G\u00e9ron, Hands-On Machine Learning with Scikit-Learn and Tensorflow: Concepts, Tools, and Techniques to Build Intelligent Systems","title":"Testi consigliati (per la data science)"},{"location":"00_materiale/programma/#esercizi-di-approfondimento","text":"Note Alcuni di questi esercizi fanno riferimento a materiale esterno al corso. Il Docente non \u00e8 responsabile per, n\u00e9 proprietario dei, contenuti presenti a questi link. Inoltre, questi esercizi non sono rappresentativi di tracce di esame, presenti, future o passate.","title":"Esercizi di approfondimento"},{"location":"00_materiale/programma/#diagrammi-di-flusso","text":"Esercizi Svolti su Coding Creativo","title":"Diagrammi di flusso"},{"location":"00_materiale/programma/#programmi-utili","text":"Visual Studio Community 2019 : IDE per lo sviluppo di programmi in C/C++/Python Visual Studio Code : IDE per lo sviluppo di programmi in C/C++/Python Guida ufficiale all'installazione e configurazione di Visual Studio Community 2019 Guida ufficiale all'installazione e configurazione di Visual Studio Code Interprete Python","title":"Programmi utili"},{"location":"01_esami/standard/","text":"Modalit\u00e0 Standard \u00b6 Prevede una prova scritta ed una prova orale . La prova scritta prevede tre \u2013 cinque domande sui diversi argomenti del corso. All\u2019interno della prova scritta possono esserci esercizi di programmazione da svolgersi direttamente sull\u2019elaborato . La prova scritta \u00e8 valutata in trentesimi. La prova orale \u00e8 obbligatoria se il risultato della prova scritta \u00e8 compreso tra 15 e 17 . Se il risultato della prova scritta \u00e8 maggiore o uguale a 18 , la prova orale \u00e8 a discrezione dello studente. Se il risultato della prova scritta \u00e8 minore o uguale a 14 , lo studente dovr\u00e0 ripetere la prova scritta a partire dall\u2019appello successivo Date di appello (provvisorie) \u00b6 Anno Accademico 2020/2021 \u00b6 Data Orario Note 25/01/2021 15:00-16:30 09/02/2021 09:00-10:30 26/02/2021 09:00-10:30","title":"Modalit\u00e0 standard"},{"location":"01_esami/standard/#modalita-standard","text":"Prevede una prova scritta ed una prova orale . La prova scritta prevede tre \u2013 cinque domande sui diversi argomenti del corso. All\u2019interno della prova scritta possono esserci esercizi di programmazione da svolgersi direttamente sull\u2019elaborato . La prova scritta \u00e8 valutata in trentesimi. La prova orale \u00e8 obbligatoria se il risultato della prova scritta \u00e8 compreso tra 15 e 17 . Se il risultato della prova scritta \u00e8 maggiore o uguale a 18 , la prova orale \u00e8 a discrezione dello studente. Se il risultato della prova scritta \u00e8 minore o uguale a 14 , lo studente dovr\u00e0 ripetere la prova scritta a partire dall\u2019appello successivo","title":"Modalit\u00e0 Standard"},{"location":"01_esami/standard/#date-di-appello-provvisorie","text":"","title":"Date di appello (provvisorie)"},{"location":"01_esami/standard/#anno-accademico-20202021","text":"Data Orario Note 25/01/2021 15:00-16:30 09/02/2021 09:00-10:30 26/02/2021 09:00-10:30","title":"Anno Accademico 2020/2021"},{"location":"01_esami/tema_anno/faq/","text":"Q : Mi \u00e8 stata assegnata la traccia XYZ. E' possibile richiedere un cambio di traccia? A : No, non \u00e8 possibile chiedere un cambio di traccia, n\u00e9 che la stessa venga modificata, a meno che non si verifichi che alcuni argomenti non siano oggettivamente alla portata di uno studente di Matematica del primo anno. Q : Ho notato delle imprecisioni nella traccia. Le segnalo? A : Assolutamente s\u00ec. Q : Ho notato che esistono delle condizioni che la traccia non tiene in considerazione. Posso trattarle nel corso del tema d'anno? A : Assolutamente s\u00ec; trattare condizioni non previste dalla traccia in maniera corretta permette una migliore valutazione complessiva dell'esame. Q: Come consegno il tema d'anno? A: Il tema d'anno andr\u00e0 consegnato sotto forma di file PDF/A (non modificabile) per le parti discorsive. Per la seconda e terza parte (sviluppate rispettivamente in C e C++), sar\u00e0 necessario consegnare al docente un file .EXE che possa essere eseguito su un computer Windows. Per la quarta parte (sviluppata in Python), sar\u00e0 necessario consegnare al docente un file con estensione .py. Per tutte le parti pratiche, sar\u00e0 inoltre necessario allegare un'eventuale guida utente che permetta di eseguire al docente le prove, accertando il funzionamento del software; inoltre, sar\u00e0 necessario allegare il codice sorgente usato. Q: Posso chiedere chiarimenti sulla traccia? A: Assolutamente s\u00ec. Ricevere un chiarimento ed un esempio di funzionamento \u00e8 pieno diritto dello studente. Q: Posso usare funzioni non trattate in aula? A: Assolutamente s\u00ec, tenendo presente che se si usano funzioni presenti nelle librerie standard dei diversi linguaggi non saranno eseguiti ulteriori controlli. Tuttavia, qualora si utilizzino librerie terze, sar\u00e0 verificata l'attendibilit\u00e0 delle suddette. Q: Per quello che riguarda lo pseudocodice, \u00e8 un problema se \"assomiglia\" troppo al codice finale? A: Assolutamente no.","title":"FAQ"},{"location":"01_esami/tema_anno/intro/","text":"Tema d'anno \u00b6 Cosa \u00e8 il tema d'anno? \u00b6 Durante il corso, gli studenti potranno decidere, in maniera autonoma o in gruppo composto al massimo da due componenti, di svolgere un tema d\u2019anno, articolato in quattro parti, valido per l\u2019esonero dalle prove scritta ed orale. Per accedere a questa modalit\u00e0, i gruppi/studenti dovranno essere comunicati al docente entro il termine massimo (improrogabile) stabilito dal docente via email all\u2019indirizzo angelo.cardellicchio@uniba.it . I temi d\u2019anno, in base al numero di gruppi/studenti, verranno proposti dal docente a partire dalla settimana successiva al termine di cui sopra . E' fortemente consigliata la partecipazione in gruppi di due studenti . Assegnazione dei temi \u00b6 Ciascun gruppo/studente dovr\u00e0 comunicare all\u2019email del docente quattro preferenze tra i temi proposti. Il primo tema indicato sar\u00e0 la prima scelta, il secondo tema indicato sar\u00e0 la seconda scelta, e cos\u00ec via fino all'ultima scelta . Si cercher\u00e0 in ogni caso di assegnare ad ogni gruppo la prima scelta, ripiegando eventualmente sulla seconda, poi sulla terza, ed infine sulla quarta. In caso di pi\u00f9 preferenze da diversi gruppi/studenti sullo stesso tema, quest\u2019ultimo sar\u00e0 assegnato secondo un criterio strettamente cronologico di arrivo della richiesta. Ad esempio: a. Tizio esprime preferenza il 17/11/2020 alle 08:35 per i Temi A (prima scelta), B (seconda scelta), C (terza scelta) ed E (quarta scelta). b. Caio esprime preferenza il 17/11/2020 alle 08:40 per i temi A (prima scelta), C (seconda scelta), D (terza scelta) ed F (quarta scelta). c. Sempronio esprime preferenza il 17/11/2020 alle ore 08:30 per i temi B (prima scelta), A (seconda scelta), E (terza scelta) e G (quarta scelta). d. A Tizio sar\u00e0 assegnato il Tema A, a Caio il tema C, a Sempronio il tema B. La scelta dei temi sar\u00e0 articolata in due round . Alla scadenza ( improrogabile ) del primo round, tutti i gruppi dovranno comunicare le prime quattro preferenze, che saranno assegnate come specificato ai punti 2 e 3. L'esito della prima assegnazione sar\u00e0 verificato e comunicato agli studenti entro due giorni dalla scadenza di cui sopra. I gruppi cui non dovesse essere stato possibile assegnare il tema d'anno al primo round, potranno partecipare al secondo, che si articoler\u00e0 secondo modalit\u00e0 analoghe al primo ma con un insieme di temi ridotto , dato dalle tracce non assegnate al primo turno. I gruppi cui non sar\u00e0 stato possibile assegnare un tema d'anno riceveranno una traccia di ufficio tra quelle proposte . Comunicazioni \u00b6 Le comunicazioni avverranno esclusivamente a mezzo mail istituzionale con il referente di ciascun gruppo.","title":"Introduzione"},{"location":"01_esami/tema_anno/intro/#tema-danno","text":"","title":"Tema d'anno"},{"location":"01_esami/tema_anno/intro/#cosa-e-il-tema-danno","text":"Durante il corso, gli studenti potranno decidere, in maniera autonoma o in gruppo composto al massimo da due componenti, di svolgere un tema d\u2019anno, articolato in quattro parti, valido per l\u2019esonero dalle prove scritta ed orale. Per accedere a questa modalit\u00e0, i gruppi/studenti dovranno essere comunicati al docente entro il termine massimo (improrogabile) stabilito dal docente via email all\u2019indirizzo angelo.cardellicchio@uniba.it . I temi d\u2019anno, in base al numero di gruppi/studenti, verranno proposti dal docente a partire dalla settimana successiva al termine di cui sopra . E' fortemente consigliata la partecipazione in gruppi di due studenti .","title":"Cosa \u00e8 il tema d'anno?"},{"location":"01_esami/tema_anno/intro/#assegnazione-dei-temi","text":"Ciascun gruppo/studente dovr\u00e0 comunicare all\u2019email del docente quattro preferenze tra i temi proposti. Il primo tema indicato sar\u00e0 la prima scelta, il secondo tema indicato sar\u00e0 la seconda scelta, e cos\u00ec via fino all'ultima scelta . Si cercher\u00e0 in ogni caso di assegnare ad ogni gruppo la prima scelta, ripiegando eventualmente sulla seconda, poi sulla terza, ed infine sulla quarta. In caso di pi\u00f9 preferenze da diversi gruppi/studenti sullo stesso tema, quest\u2019ultimo sar\u00e0 assegnato secondo un criterio strettamente cronologico di arrivo della richiesta. Ad esempio: a. Tizio esprime preferenza il 17/11/2020 alle 08:35 per i Temi A (prima scelta), B (seconda scelta), C (terza scelta) ed E (quarta scelta). b. Caio esprime preferenza il 17/11/2020 alle 08:40 per i temi A (prima scelta), C (seconda scelta), D (terza scelta) ed F (quarta scelta). c. Sempronio esprime preferenza il 17/11/2020 alle ore 08:30 per i temi B (prima scelta), A (seconda scelta), E (terza scelta) e G (quarta scelta). d. A Tizio sar\u00e0 assegnato il Tema A, a Caio il tema C, a Sempronio il tema B. La scelta dei temi sar\u00e0 articolata in due round . Alla scadenza ( improrogabile ) del primo round, tutti i gruppi dovranno comunicare le prime quattro preferenze, che saranno assegnate come specificato ai punti 2 e 3. L'esito della prima assegnazione sar\u00e0 verificato e comunicato agli studenti entro due giorni dalla scadenza di cui sopra. I gruppi cui non dovesse essere stato possibile assegnare il tema d'anno al primo round, potranno partecipare al secondo, che si articoler\u00e0 secondo modalit\u00e0 analoghe al primo ma con un insieme di temi ridotto , dato dalle tracce non assegnate al primo turno. I gruppi cui non sar\u00e0 stato possibile assegnare un tema d'anno riceveranno una traccia di ufficio tra quelle proposte .","title":"Assegnazione dei temi"},{"location":"01_esami/tema_anno/intro/#comunicazioni","text":"Le comunicazioni avverranno esclusivamente a mezzo mail istituzionale con il referente di ciascun gruppo.","title":"Comunicazioni"},{"location":"01_esami/tema_anno/valutazione/","text":"Le quattro differenti parti in cui \u00e8 strutturato il tema d'anno saranno valutate come segue. Parte Prima - Analisi del problema \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Descrizione del problema ...analisi e spiegazione dell'approccio usato 0 - 10 punti Individuazione di input ed output ...interpretazione degli input e comunicazione dei risultati i risultati 0 - 4 punti Diagramma di flusso e pseudocodice ...strutturazione della risoluzione del problema 0 - 10 punti Analisi computazionale a priori ...stima del costo di esecuzione dell'algoritmo 0 - 6 punti Parte Seconda - Implementazione in linguaggio C \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Parte Terza - Implementazione in linguaggio C++ \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C++ 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Parte Quarta - Implementazione in linguaggio Python \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio Python 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Il risultato finale sar\u00e0 dato dalla media delle valutazioni ottenute nelle quattro parti.","title":"Valutazione"},{"location":"01_esami/tema_anno/valutazione/#parte-prima-analisi-del-problema","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Descrizione del problema ...analisi e spiegazione dell'approccio usato 0 - 10 punti Individuazione di input ed output ...interpretazione degli input e comunicazione dei risultati i risultati 0 - 4 punti Diagramma di flusso e pseudocodice ...strutturazione della risoluzione del problema 0 - 10 punti Analisi computazionale a priori ...stima del costo di esecuzione dell'algoritmo 0 - 6 punti","title":"Parte Prima - Analisi del problema"},{"location":"01_esami/tema_anno/valutazione/#parte-seconda-implementazione-in-linguaggio-c","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti","title":"Parte Seconda - Implementazione in linguaggio C"},{"location":"01_esami/tema_anno/valutazione/#parte-terza-implementazione-in-linguaggio-c","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C++ 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti","title":"Parte Terza - Implementazione in linguaggio C++"},{"location":"01_esami/tema_anno/valutazione/#parte-quarta-implementazione-in-linguaggio-python","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio Python 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Il risultato finale sar\u00e0 dato dalla media delle valutazioni ottenute nelle quattro parti.","title":"Parte Quarta - Implementazione in linguaggio Python"},{"location":"01_esami/tema_anno/2020-2021/date/","text":"Per tutte le date rilevanti, consultare la tabella successiva. Data Evento Scaduto 09 novembre 2020 Termine adesioni esoneri 16 novembre 2020 Proposta temi d'anno 22 novembre 2020 Termine primo round assegnazioni 24 novembre 2020 Comunicazione esito primo round 27 novembre 2020 Termine secondo round assegnazioni 29 novembre 2020 Comunicazione esito secondo round 04 dicembre 2020 Consegna prima parte del tema d'anno (gruppi primo round) 10 dicembre 2020 Consegna prima parte del tema d'anno (gruppi secondo round) 17 dicembre 2020 Comunicazione esiti prima parte del tema d'anno (tutti i gruppi) Assegnazione seconda parte del tema d'anno (tutti i gruppi) 24 dicembre 2020 Consegna seconda parte del tema d'anno (tutti i gruppi) 07 gennaio 2021 Comunicazione esiti seconda parte tema d'anno (tutti i gruppi) Assegnazione terza parte del tema d'anno (tutti i gruppi) 15 gennaio 2021 Consegna terza parte tema d'anno (tutti i gruppi) 22 gennaio 2021 Comunicazione esiti terza parte del tema d'anno (tutti i gruppi) Assegnazione quarta parte tema d'anno (tutti i gruppi) 31 gennaio 2021 Consegna quarta parte tema d'anno (tutti i gruppi) 05 febbraio 2021 Comunicazione esiti quarta parte del tema d'anno (tutti i gruppi) Post Scriptum Il mancato rispetto delle date indicate prevede l\u2019esclusione automatica dalla modalit\u00e0 a tema d\u2019anno. Post Post Scriptum Ci\u00f2 non vale per il Docente, apparentemente, per\u00f2 questi giura che prover\u00e0 comunque a rispettare il Patto Inderogabile di Fiducia con gli Studenti .","title":"Date rilevanti"},{"location":"01_esami/tema_anno/2020-2021/documenti/","text":"Sono disponibili per la consultazione i seguenti documenti. Descrizione Link Elenco tracce Esito primo turno di assegnazione Esito secondo turno di assegnazione Gruppi e tracce assegnate Esiti prima prova Esiti seconda prova Esiti terza prova Esiti quarta prova","title":"Documenti"},{"location":"01_esami/tema_anno/esempio/parte_prima/","text":"Descrizione del problema \u00b6 Il problema concerne l'utilizzo della tecnica di selection sort per ordinare un vettore ad \\(n\\) elementi. Il selection sort \u00e8 un algoritmo base per l'ordinamento del vettore; pu\u00f2 essere applicato, ad esempio, per ordinare come segue il vettore \\([1,4,2,3]\\) : \\[ [1, 4, 2, 3] \\Rightarrow [1, 2, 4, 3] \\Rightarrow [1, 2, 3, 4] \\] Il selection sort opera suddividendo l'array in una sequenza ordinata (a sinistra) ed in una non ordinata; essendo un approccio iterativo, ad ogni iterazione viene sostituito l'elemento pi\u00f9 a destra della sequenza ordinata con il minore tra quelli nella sequenza ordinata. Sar\u00e0 quindi necessario usare un approccio iterativo come indicato nella sezione Diagramma di flusso e pseudocodice . Individuazione di input ed output \u00b6 Input: \u00e8 richiesto all'utente di inserire un vettore in input ad \\(n\\) elementi. Questo potr\u00e0 essere inserito in maniera ricorsiva (ad esempio, chiedendo all'utente di inserire un elemento alla volta da riga di comando), oppure chiedendo all'utente di inserire una stringa ed interpretandola di conseguenza, oppure ancora leggendo un file di testo. I valori del vettore saranno ovviamente numerici; saranno comunque trattati come numeri reali, e quindi sar\u00e0 usato il formato float . Output: l'utente si attende in uscita il vettore ordinato; in tal senso, potr\u00e0 scegliere se gli verr\u00e0 restituito sulla riga di comando oppure stampato su un file di testo. Diagramma di flusso e pseudocodice \u00b6 Lo pseudocodice \u00e8 il seguente: STEP 1: read(input); // Lettura dell'input dell'utente STEP 2: i = 0; // Contatore per indicare l'indice del sotto-vettore ordinato STEP 3: for (i; i < length(input) - 1; i++) // Aumento l'indice dell'ultimo elemento del sotto-vettore ordinato fino a che non sono sicuro di aver ordinato l'intero vettore STEP 4: j = i+1; // Contatore per indicare l'indice del sotto-vettore non ordinato STEP 4: for (j; j<= length(input); j++) // Controllo tutti i valori dimanenti dell'array STEP 5: if input[i] > input[j] // Effettuo l'operazione di swap se necessario STEP 6: input[i] = input[j] STEP 7: input[j] = input[i] end end end STEP 8: RETURN(input) Il diagramma di flusso \u00e8 mostrato nella figura seguente: Nota Nel diagramma di flusso le frecce in rosso sulle selezioni indicano un FALSE , mentre quelle in blu un TRUE . Analisi computazionale \u00b6 L'algoritmo nel caso peggiore ha un'analisi di complessit\u00e0 pari proprio a quella del selection sort, ovvero un \\(O(n^2)\\) .","title":"Parte Prima"},{"location":"01_esami/tema_anno/esempio/parte_prima/#descrizione-del-problema","text":"Il problema concerne l'utilizzo della tecnica di selection sort per ordinare un vettore ad \\(n\\) elementi. Il selection sort \u00e8 un algoritmo base per l'ordinamento del vettore; pu\u00f2 essere applicato, ad esempio, per ordinare come segue il vettore \\([1,4,2,3]\\) : \\[ [1, 4, 2, 3] \\Rightarrow [1, 2, 4, 3] \\Rightarrow [1, 2, 3, 4] \\] Il selection sort opera suddividendo l'array in una sequenza ordinata (a sinistra) ed in una non ordinata; essendo un approccio iterativo, ad ogni iterazione viene sostituito l'elemento pi\u00f9 a destra della sequenza ordinata con il minore tra quelli nella sequenza ordinata. Sar\u00e0 quindi necessario usare un approccio iterativo come indicato nella sezione Diagramma di flusso e pseudocodice .","title":"Descrizione del problema"},{"location":"01_esami/tema_anno/esempio/parte_prima/#individuazione-di-input-ed-output","text":"Input: \u00e8 richiesto all'utente di inserire un vettore in input ad \\(n\\) elementi. Questo potr\u00e0 essere inserito in maniera ricorsiva (ad esempio, chiedendo all'utente di inserire un elemento alla volta da riga di comando), oppure chiedendo all'utente di inserire una stringa ed interpretandola di conseguenza, oppure ancora leggendo un file di testo. I valori del vettore saranno ovviamente numerici; saranno comunque trattati come numeri reali, e quindi sar\u00e0 usato il formato float . Output: l'utente si attende in uscita il vettore ordinato; in tal senso, potr\u00e0 scegliere se gli verr\u00e0 restituito sulla riga di comando oppure stampato su un file di testo.","title":"Individuazione di input ed output"},{"location":"01_esami/tema_anno/esempio/parte_prima/#diagramma-di-flusso-e-pseudocodice","text":"Lo pseudocodice \u00e8 il seguente: STEP 1: read(input); // Lettura dell'input dell'utente STEP 2: i = 0; // Contatore per indicare l'indice del sotto-vettore ordinato STEP 3: for (i; i < length(input) - 1; i++) // Aumento l'indice dell'ultimo elemento del sotto-vettore ordinato fino a che non sono sicuro di aver ordinato l'intero vettore STEP 4: j = i+1; // Contatore per indicare l'indice del sotto-vettore non ordinato STEP 4: for (j; j<= length(input); j++) // Controllo tutti i valori dimanenti dell'array STEP 5: if input[i] > input[j] // Effettuo l'operazione di swap se necessario STEP 6: input[i] = input[j] STEP 7: input[j] = input[i] end end end STEP 8: RETURN(input) Il diagramma di flusso \u00e8 mostrato nella figura seguente: Nota Nel diagramma di flusso le frecce in rosso sulle selezioni indicano un FALSE , mentre quelle in blu un TRUE .","title":"Diagramma di flusso e pseudocodice"},{"location":"01_esami/tema_anno/esempio/parte_prima/#analisi-computazionale","text":"L'algoritmo nel caso peggiore ha un'analisi di complessit\u00e0 pari proprio a quella del selection sort, ovvero un \\(O(n^2)\\) .","title":"Analisi computazionale"},{"location":"01_esami/tema_anno/esempio/parte_seconda/","text":"Struttura del codice \u00b6 Il programma \u00e8 strutturato come segue: |---File di intestazione |------ioutils.h |------parsing.h |------sorting.h |---File di origine |------ioutils.c |------parsing.c |------sorting.c |------source.c |---File di risorse |------array.txt Descrizione sintetica dei file \u00b6 File di intestazione (header) \u00b6 Segue una breve descrizione dei singoli file di intestazione. File Descrizione ioutils.h Contiene delle utility di supporto all'I/O. parsing.h Contiene delle utility di supporto al parsing. sorting.h Contiene delle utility di supporto al selection sort. File di origine (sorgenti) \u00b6 Segue una breve descrizione dei singoli file di origine. File Descrizione ioutils.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. parsing.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. sorting.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. source.c Contiene il programma principale. File di risorse \u00b6 Segue una breve descrizione dei singoli file di risorce. File Descrizione array.txt Contiene un esempio per l'input di un vettore. Descrizione sintetica delle funzioni implementate \u00b6 ioutils \u00b6 Funzione Argomenti Output Descrizione read_file char* string N.D. Legge un file (chiesto in input all'interno della funzione) e va a popolare di conseguenza la stringa ( string ) passata come argomento. Contiene funzioni di verifica degli errori. print_array int array[], int length N.D. Permette di formattare a schermo un determinato array di interi. text_or_shell N.D. char input_mode Chiede all'utente di inserire un carattere tra f ed r per determinare se leggere da file o da riga di comando. parsing \u00b6 Funzione Argomenti Output Descrizione strstrp char* str_in, char* str_out, char strp, int length N.D. Legge la stringa str_in di lunghezza length , rimuove tutte le occorrenze del carattere strp e la salva nella stringa str_out . string_to_int_array char* string, int* buffer int numbers Converte la stringa di interi string , con interi separati da una virgola, nell'array buffer . Restituisce il numero di interi trovati. sorting \u00b6 Funzione Argomenti Output Descrizione swap int array[], int swap_l_idx, int swap_r_idx, int swap_val N.D. Sostituisce l'elemento all'indice swap l idx con l'elemento swap r idx nell'array di interi vector . selection_sort int vector[], int length N.D. Implementa l'algoritmo di selection sort sul vettore di interi vector . Funzionamento del programma \u00b6 Recarsi nella cartella dove \u00e8 posizionato l'eseguibile fornito usando PowerShell o la Command Prompt. cd folder_selection_sort Lanciare il programma. SelectionSort.exe Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento.","title":"Parte Seconda"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#struttura-del-codice","text":"Il programma \u00e8 strutturato come segue: |---File di intestazione |------ioutils.h |------parsing.h |------sorting.h |---File di origine |------ioutils.c |------parsing.c |------sorting.c |------source.c |---File di risorse |------array.txt","title":"Struttura del codice"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#descrizione-sintetica-dei-file","text":"","title":"Descrizione sintetica dei file"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#file-di-intestazione-header","text":"Segue una breve descrizione dei singoli file di intestazione. File Descrizione ioutils.h Contiene delle utility di supporto all'I/O. parsing.h Contiene delle utility di supporto al parsing. sorting.h Contiene delle utility di supporto al selection sort.","title":"File di intestazione (header)"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#file-di-origine-sorgenti","text":"Segue una breve descrizione dei singoli file di origine. File Descrizione ioutils.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. parsing.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. sorting.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. source.c Contiene il programma principale.","title":"File di origine (sorgenti)"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#file-di-risorse","text":"Segue una breve descrizione dei singoli file di risorce. File Descrizione array.txt Contiene un esempio per l'input di un vettore.","title":"File di risorse"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#descrizione-sintetica-delle-funzioni-implementate","text":"","title":"Descrizione sintetica delle funzioni implementate"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#ioutils","text":"Funzione Argomenti Output Descrizione read_file char* string N.D. Legge un file (chiesto in input all'interno della funzione) e va a popolare di conseguenza la stringa ( string ) passata come argomento. Contiene funzioni di verifica degli errori. print_array int array[], int length N.D. Permette di formattare a schermo un determinato array di interi. text_or_shell N.D. char input_mode Chiede all'utente di inserire un carattere tra f ed r per determinare se leggere da file o da riga di comando.","title":"ioutils"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#parsing","text":"Funzione Argomenti Output Descrizione strstrp char* str_in, char* str_out, char strp, int length N.D. Legge la stringa str_in di lunghezza length , rimuove tutte le occorrenze del carattere strp e la salva nella stringa str_out . string_to_int_array char* string, int* buffer int numbers Converte la stringa di interi string , con interi separati da una virgola, nell'array buffer . Restituisce il numero di interi trovati.","title":"parsing"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#sorting","text":"Funzione Argomenti Output Descrizione swap int array[], int swap_l_idx, int swap_r_idx, int swap_val N.D. Sostituisce l'elemento all'indice swap l idx con l'elemento swap r idx nell'array di interi vector . selection_sort int vector[], int length N.D. Implementa l'algoritmo di selection sort sul vettore di interi vector .","title":"sorting"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#funzionamento-del-programma","text":"Recarsi nella cartella dove \u00e8 posizionato l'eseguibile fornito usando PowerShell o la Command Prompt. cd folder_selection_sort Lanciare il programma. SelectionSort.exe Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento.","title":"Funzionamento del programma"},{"location":"01_esami/tema_anno/esempio/traccia/","text":"Esempio di tema d'anno \u00b6 Nota Il presente \u00e8 un esempio di tema d'anno svolto dal Docente. Tuttavia, non \u00e8 da considerarsi comparabile al livello di difficolt\u00e0 delle tracce assegnate per i temi d'anno; lo scopo, meramente illustrativo, \u00e8 quello di mostrare l'output atteso. Quesito \u00b6 Dato un vettore \\(n\\) , scrivere un programma che lo ordini mediante l'algoritmo di selection sort .","title":"Traccia"},{"location":"01_esami/tema_anno/esempio/traccia/#esempio-di-tema-danno","text":"Nota Il presente \u00e8 un esempio di tema d'anno svolto dal Docente. Tuttavia, non \u00e8 da considerarsi comparabile al livello di difficolt\u00e0 delle tracce assegnate per i temi d'anno; lo scopo, meramente illustrativo, \u00e8 quello di mostrare l'output atteso.","title":"Esempio di tema d'anno"},{"location":"01_esami/tema_anno/esempio/traccia/#quesito","text":"Dato un vettore \\(n\\) , scrivere un programma che lo ordini mediante l'algoritmo di selection sort .","title":"Quesito"},{"location":"02_dispense/01_introduttivi/01_intro/","text":"Una definizione di Informatica \u00b6 Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico. Il concetto di Informazione \u00b6 L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca. I sistemi Informatici \u00b6 Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0. Il ruolo dell'Informatico \u00b6 Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"01 - Introduzione all'Informatica"},{"location":"02_dispense/01_introduttivi/01_intro/#una-definizione-di-informatica","text":"Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico.","title":"Una definizione di Informatica"},{"location":"02_dispense/01_introduttivi/01_intro/#il-concetto-di-informazione","text":"L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca.","title":"Il concetto di Informazione"},{"location":"02_dispense/01_introduttivi/01_intro/#i-sistemi-informatici","text":"Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0.","title":"I sistemi Informatici"},{"location":"02_dispense/01_introduttivi/01_intro/#il-ruolo-dellinformatico","text":"Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"Il ruolo dell'Informatico"},{"location":"02_dispense/01_introduttivi/02_algoritmi/","text":"Formulare un problema \u00b6 Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio. Il problema come compito \u00b6 Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo . L' ente risolutore \u00b6 La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann. Gli elementi noti e le condizioni fissate \u00b6 La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore. Risolvere un problema \u00b6 La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi. Problemi e soluzioni \u00b6 Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione . Costruire la soluzione \u00b6 Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse. Operazioni atomiche \u00b6 Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.). Combinare operazioni atomiche \u00b6 Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori. Determinare l'insieme di operatori \u00b6 Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema. Da soluzione ad algoritmo \u00b6 La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema. Un esempio \u00b6 Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo. Formulazione del problema \u00b6 Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) . Dati \u00b6 Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo. Algoritmo risolutivo (in operazioni atomiche, o quasi) \u00b6 Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 . Esempio numerico \u00b6 Dati \u00b6 \\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\] Passi dell'algoritmo \u00b6 \\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) . Caratteristiche degli algoritmi risolutivi \u00b6 Le cinque caratteristiche principali \u00b6 Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico. Determinismo \u00b6 Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso. Input, Output e Variabili \u00b6 Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"02 - Gli Algoritmi"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#formulare-un-problema","text":"Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio.","title":"Formulare un problema"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#il-problema-come-compito","text":"Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo .","title":"Il problema come compito"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#lente-risolutore","text":"La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann.","title":"L'ente risolutore"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#gli-elementi-noti-e-le-condizioni-fissate","text":"La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore.","title":"Gli elementi noti e le condizioni fissate"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#risolvere-un-problema","text":"La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi.","title":"Risolvere un problema"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#problemi-e-soluzioni","text":"Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione .","title":"Problemi e soluzioni"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#costruire-la-soluzione","text":"Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse.","title":"Costruire la soluzione"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#operazioni-atomiche","text":"Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.).","title":"Operazioni atomiche"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#combinare-operazioni-atomiche","text":"Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori.","title":"Combinare operazioni atomiche"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#determinare-linsieme-di-operatori","text":"Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema.","title":"Determinare l'insieme di operatori"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#da-soluzione-ad-algoritmo","text":"La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema.","title":"Da soluzione ad algoritmo"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#un-esempio","text":"Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo.","title":"Un esempio"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#formulazione-del-problema","text":"Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) .","title":"Formulazione del problema"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#dati","text":"Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo.","title":"Dati"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#algoritmo-risolutivo-in-operazioni-atomiche-o-quasi","text":"Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 .","title":"Algoritmo risolutivo (in operazioni atomiche, o quasi)"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#esempio-numerico","text":"","title":"Esempio numerico"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#dati_1","text":"\\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\]","title":"Dati"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#passi-dellalgoritmo","text":"\\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) .","title":"Passi dell'algoritmo"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#caratteristiche-degli-algoritmi-risolutivi","text":"","title":"Caratteristiche degli algoritmi risolutivi"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#le-cinque-caratteristiche-principali","text":"Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico.","title":"Le cinque caratteristiche principali"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#determinismo","text":"Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso.","title":"Determinismo"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#input-output-e-variabili","text":"Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"Input, Output e Variabili"},{"location":"02_dispense/01_introduttivi/03_flow_chart/","text":"","title":"03 flow chart"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/","text":"Rappresentare il mondo in forma binaria \u00b6 Le informazioni contenute all'interno di un calcolatore, siano esse dati o istruzioni, sono rappresentate in forma binaria come sequenze finite di simboli 0 ed 1 . Questa notazione permette di definire una delle nozioni fondamentali su cui \u00e8 basata l'informatica, ovvero quella di bit , contrazione di binary digit (cifra binaria): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero). Conseguentemente, \u00e8 possibile definire un'altra nozione fondamentale, ovvero quella di byte , associata ad una sequenza (arbitraria) di otto bit. E' facile verificare che un byte pu\u00f2 assumere uno tra \\(2^8\\) possibili valori. Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso). I dati numerici \u00b6 Rappresentazione di numeri interi \u00b6 Finitezza \u00b6 I calcolatori sono dispositivi reali , ed in grado quindi di elaborare esclusivamente informazioni finite ; pi\u00f9 nello specifico, laddove il mondo reale \u00e8 analogico , e quindi continuo , il mondo \"comprensibile\" dai calcolatori \u00e8 digitale , e quindi \u00e8 una versione discretizzata del mondo reale. Ci\u00f2 comporta che, parlando di numeri interi rappresentabili in un calcolatore, si sta in realt\u00e0 parlando di un'approssimazione finita dell'insieme dei numeri naturali \\(\\mathbb{N}\\) : l'estensione di questa rappresentazione dipende dall'architettura del calcolatore. Ad esempio, la maggior parte dei calcolatori odierni accetta come limite massimo il valore di \\(2^64\\) , pari \\(18.446.744.073.709.551.616\\) (abbastanza per rappresentare il numero massimo di amici che potete avere su Facebook, plausibilmente). Da decimale a binario \u00b6 Siamo abituati a pensare (ed usare) i numeri interi usando una notazione di tipo decimale e posizionale . Ci\u00f2 significa che: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato. Un esempio \u00b6 In generale, sia \\(N\\) un generico numero intero composto da \\(n\\) simboli. Usando la notazione decimale e posizionale \u00e8 possibile esprimerlo come segue: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n * b^n + a_{n-1} * b^{n-1} + ... + a_1 * b + a_0 \\] Per fare un semplice esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\] Conversione \u00b6 Supponiamo di voler rappresentare \\(N = 485\\) in forma binaria (ovvero in base \\(2\\) ). Dovremo procedere dividendo \\(N\\) per la nostra base \\(b = 2\\) , valutare il resto \\(r\\) , che sar\u00e0 di volta in volta il valore meno significativo del nostro numero in forma binaria, e reiterare l'operazione usando il quoziente \\(q\\) . Otteniamo quindi: \\[ \\begin{eqnarray} 485/2 &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ 242/2 &\\Rightarrow q = 121 & r = 0 \\\\ 121/2 &\\Rightarrow q = 60 & r = 1 \\\\ 60/2 &\\Rightarrow q = 30 & r = 0 \\\\ 30/2 &\\Rightarrow q = 15 & r = 0 \\\\ 15/2 &\\Rightarrow q = 7 & r = 1 \\\\ 7/2 &\\Rightarrow q = 3 & r = 1 \\\\ 3/2 &\\Rightarrow q = 1 & r = 1 \\\\ 1/2 &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo). Segno \u00b6 E' importante ricordare che i numeri interi possono essere dotati di segno; questo \u00e8, ovviamente, un fattore di cui va tenuto conto nella rappresentazione del numero stesso, ed \u00e8 legato al fatto che il calcolatore pu\u00f2 contenere solo un quantitativo finito di infomrazione. Immaginiamo infatti che il computer utilizzi una word di \\(W\\) bit per memorizzare gli interi; ci\u00f2 significa che sar\u00e0 possibile memorizzare al pi\u00f9 \\(2^W\\) valori. Nel caso si considerino tutti i valori positivi (includendo nel conteggio \"per convenzione\" anche lo \\(0\\) ), il calcolatore potr\u00e0 rappresentare tutti i numeri che vanno da \\(0\\) a \\(2^W-1\\) . Questa situazione, per\u00f2, cambia nel caso si voglia considerare il segno del numero. Infatti, supponendo di suddividere l'intervallo considerato in valori negativi e valori positivi, il calcolatore sar\u00e0 in grado di rappresentare sempre \\(2^W\\) valori, ma met\u00e0 di questi saranno negativi, mentre l'altra met\u00e0 sar\u00e0 composta da valori positivi. Ci\u00f2 ha come diretta conseguenza il fatto che il range dei numeri rappresentati varia da \\(-2^{W-1}\\) a \\(2^{W-1}-1\\) . Per fare un esempio pratico, supponendo un valore di \\(W = 8\\) , avremo che: se consideriamo solo gli interi positivi, potremo rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^8-1\\) ; se consideriamo anche i valori negativi, potremo rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{W-1}\\) e \\(127 = -2^{W-1}-1\\) . Rappresentazione di numeri reali \u00b6 Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) pu\u00f2 essere rappresentato all'interno di un calcolatore esclusivamente mediante un'approssimazione finita. Per trovare quest'approssimazione, occorre considerare che ogni numero reale \u00e8 composto da una parte intera \\(r\\) ed una parte frazionaria \\(f\\) . Rappresentazione a virgola fissa \u00b6 Supponiamo di avere a disposizione parole composte da \\(W\\) bit. Nella rappresentazione a virgola fissa (o fixed point ) di un numero \\(N\\) , usiamo un numero fisso di bit (ovvero \\(W_r\\) ) per la parte intera di \\(N\\) , ed i rimanenti bit ( \\(W_f\\) ) per la rappresentazione della parte frazionaria. Ovviamente, questa rappresentazione ha lo svantaggio di essere poco flessibile, e le viene spesso preferita quella a virgola mobile . Rappresentazione a virgola mobile \u00b6 La modalit\u00e0 di rappresentazione di un numero reale maggiormente diffusa \u00e8 quella a virgola mobile ( floating point ), che si basa sui concetti di mantissa , ovvero la parte frazionaria di un numero, e caratteristica , o esponente . In particolare, la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_i\\) : \\[ M = n - n_i \\] Ad esempio, la mantissa di \\(5.2\\) \u00e8 pari a \\(0.2\\) . E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . Ne consegue che un numero \\(a\\) \u00e8 rappresentabile in una data base \\(b\\) mediante la seguente relazione: \\[ a = M * b^e \\] Rappresentazione di caratteri \u00b6 Anche i caratteri (ovvero quelli che troviamo normalmente sulle nostre tastiere) possono essere rappresentati in binario. Pi\u00f9 in generale, il concetto di \"carattere\" \u00e8 assimilabile a quello di simbolo , in quanto i calcolatori sono in grado di comprendere simboli che indicano, tra le altre cose, le cifre decimali, la punteggiatura, ed una vasta serie di caratteri speciali (ad esempio, l'underscore, la \"chiocciola\", e via dicendo). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra ogni carattere ed un numero intero. Tale corrispondenza \u00e8 stabilita da standard ben precisi, tra i quali vale la pena di ricordare lo standard ASCII e quello UNICODE. Quest'ultimo \u00e8 particolarmente potente (ed esteso), in quanto permette di codificare la maggior parte dei caratteri conosciuti, compresi quelli di alcune lingue ormai considerate morte (come ad esempio il greco antico). Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri. Essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"04 - Rappresentazione dei dati"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentare-il-mondo-in-forma-binaria","text":"Le informazioni contenute all'interno di un calcolatore, siano esse dati o istruzioni, sono rappresentate in forma binaria come sequenze finite di simboli 0 ed 1 . Questa notazione permette di definire una delle nozioni fondamentali su cui \u00e8 basata l'informatica, ovvero quella di bit , contrazione di binary digit (cifra binaria): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero). Conseguentemente, \u00e8 possibile definire un'altra nozione fondamentale, ovvero quella di byte , associata ad una sequenza (arbitraria) di otto bit. E' facile verificare che un byte pu\u00f2 assumere uno tra \\(2^8\\) possibili valori. Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso).","title":"Rappresentare il mondo in forma binaria"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#i-dati-numerici","text":"","title":"I dati numerici"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-di-numeri-interi","text":"","title":"Rappresentazione di numeri interi"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#finitezza","text":"I calcolatori sono dispositivi reali , ed in grado quindi di elaborare esclusivamente informazioni finite ; pi\u00f9 nello specifico, laddove il mondo reale \u00e8 analogico , e quindi continuo , il mondo \"comprensibile\" dai calcolatori \u00e8 digitale , e quindi \u00e8 una versione discretizzata del mondo reale. Ci\u00f2 comporta che, parlando di numeri interi rappresentabili in un calcolatore, si sta in realt\u00e0 parlando di un'approssimazione finita dell'insieme dei numeri naturali \\(\\mathbb{N}\\) : l'estensione di questa rappresentazione dipende dall'architettura del calcolatore. Ad esempio, la maggior parte dei calcolatori odierni accetta come limite massimo il valore di \\(2^64\\) , pari \\(18.446.744.073.709.551.616\\) (abbastanza per rappresentare il numero massimo di amici che potete avere su Facebook, plausibilmente).","title":"Finitezza"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#da-decimale-a-binario","text":"Siamo abituati a pensare (ed usare) i numeri interi usando una notazione di tipo decimale e posizionale . Ci\u00f2 significa che: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato.","title":"Da decimale a binario"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#un-esempio","text":"In generale, sia \\(N\\) un generico numero intero composto da \\(n\\) simboli. Usando la notazione decimale e posizionale \u00e8 possibile esprimerlo come segue: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n * b^n + a_{n-1} * b^{n-1} + ... + a_1 * b + a_0 \\] Per fare un semplice esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\]","title":"Un esempio"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#conversione","text":"Supponiamo di voler rappresentare \\(N = 485\\) in forma binaria (ovvero in base \\(2\\) ). Dovremo procedere dividendo \\(N\\) per la nostra base \\(b = 2\\) , valutare il resto \\(r\\) , che sar\u00e0 di volta in volta il valore meno significativo del nostro numero in forma binaria, e reiterare l'operazione usando il quoziente \\(q\\) . Otteniamo quindi: \\[ \\begin{eqnarray} 485/2 &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ 242/2 &\\Rightarrow q = 121 & r = 0 \\\\ 121/2 &\\Rightarrow q = 60 & r = 1 \\\\ 60/2 &\\Rightarrow q = 30 & r = 0 \\\\ 30/2 &\\Rightarrow q = 15 & r = 0 \\\\ 15/2 &\\Rightarrow q = 7 & r = 1 \\\\ 7/2 &\\Rightarrow q = 3 & r = 1 \\\\ 3/2 &\\Rightarrow q = 1 & r = 1 \\\\ 1/2 &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo).","title":"Conversione"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#segno","text":"E' importante ricordare che i numeri interi possono essere dotati di segno; questo \u00e8, ovviamente, un fattore di cui va tenuto conto nella rappresentazione del numero stesso, ed \u00e8 legato al fatto che il calcolatore pu\u00f2 contenere solo un quantitativo finito di infomrazione. Immaginiamo infatti che il computer utilizzi una word di \\(W\\) bit per memorizzare gli interi; ci\u00f2 significa che sar\u00e0 possibile memorizzare al pi\u00f9 \\(2^W\\) valori. Nel caso si considerino tutti i valori positivi (includendo nel conteggio \"per convenzione\" anche lo \\(0\\) ), il calcolatore potr\u00e0 rappresentare tutti i numeri che vanno da \\(0\\) a \\(2^W-1\\) . Questa situazione, per\u00f2, cambia nel caso si voglia considerare il segno del numero. Infatti, supponendo di suddividere l'intervallo considerato in valori negativi e valori positivi, il calcolatore sar\u00e0 in grado di rappresentare sempre \\(2^W\\) valori, ma met\u00e0 di questi saranno negativi, mentre l'altra met\u00e0 sar\u00e0 composta da valori positivi. Ci\u00f2 ha come diretta conseguenza il fatto che il range dei numeri rappresentati varia da \\(-2^{W-1}\\) a \\(2^{W-1}-1\\) . Per fare un esempio pratico, supponendo un valore di \\(W = 8\\) , avremo che: se consideriamo solo gli interi positivi, potremo rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^8-1\\) ; se consideriamo anche i valori negativi, potremo rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{W-1}\\) e \\(127 = -2^{W-1}-1\\) .","title":"Segno"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-di-numeri-reali","text":"Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) pu\u00f2 essere rappresentato all'interno di un calcolatore esclusivamente mediante un'approssimazione finita. Per trovare quest'approssimazione, occorre considerare che ogni numero reale \u00e8 composto da una parte intera \\(r\\) ed una parte frazionaria \\(f\\) .","title":"Rappresentazione di numeri reali"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-a-virgola-fissa","text":"Supponiamo di avere a disposizione parole composte da \\(W\\) bit. Nella rappresentazione a virgola fissa (o fixed point ) di un numero \\(N\\) , usiamo un numero fisso di bit (ovvero \\(W_r\\) ) per la parte intera di \\(N\\) , ed i rimanenti bit ( \\(W_f\\) ) per la rappresentazione della parte frazionaria. Ovviamente, questa rappresentazione ha lo svantaggio di essere poco flessibile, e le viene spesso preferita quella a virgola mobile .","title":"Rappresentazione a virgola fissa"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-a-virgola-mobile","text":"La modalit\u00e0 di rappresentazione di un numero reale maggiormente diffusa \u00e8 quella a virgola mobile ( floating point ), che si basa sui concetti di mantissa , ovvero la parte frazionaria di un numero, e caratteristica , o esponente . In particolare, la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_i\\) : \\[ M = n - n_i \\] Ad esempio, la mantissa di \\(5.2\\) \u00e8 pari a \\(0.2\\) . E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . Ne consegue che un numero \\(a\\) \u00e8 rappresentabile in una data base \\(b\\) mediante la seguente relazione: \\[ a = M * b^e \\]","title":"Rappresentazione a virgola mobile"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-di-caratteri","text":"Anche i caratteri (ovvero quelli che troviamo normalmente sulle nostre tastiere) possono essere rappresentati in binario. Pi\u00f9 in generale, il concetto di \"carattere\" \u00e8 assimilabile a quello di simbolo , in quanto i calcolatori sono in grado di comprendere simboli che indicano, tra le altre cose, le cifre decimali, la punteggiatura, ed una vasta serie di caratteri speciali (ad esempio, l'underscore, la \"chiocciola\", e via dicendo). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra ogni carattere ed un numero intero. Tale corrispondenza \u00e8 stabilita da standard ben precisi, tra i quali vale la pena di ricordare lo standard ASCII e quello UNICODE. Quest'ultimo \u00e8 particolarmente potente (ed esteso), in quanto permette di codificare la maggior parte dei caratteri conosciuti, compresi quelli di alcune lingue ormai considerate morte (come ad esempio il greco antico). Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri. Essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"Rappresentazione di caratteri"},{"location":"02_dispense/02_hardware/01_architettura/","text":"Un po' di storia \u00b6 Le origini del concetto di calcolatore (o, nell'accezione comune del termine, computer ) possono essere fatte risalire alla storia antica, con invenzioni come l' abaco , ovvero dei veri e propri strumenti di supporto che permettevano all'operatore umano di svolgere in maniera pi\u00f9 rapida calcoli anche complessi. Il calcolatore si \u00e8 poi evoluto in et\u00e0 moderna: si \u00e8 passati dalle prime sperimentazioni, come le macchine di Pascal e di Leibniz, alle prime calcolatrici , per arrivare al primo modello (teorico) di dispositivo programmabile , ovvero in grado di adattarsi a compiti anche molto diversi tra loro, che si deve al matematico britannico Charles Babbage con la sua Macchina Analitica, progettata nel 1833, e considerata il primo progetto di computer nella storia. Nei decenni successivi, vennero introdotti diversi tipi di calcolatori analogici. Successivamente, si pass\u00f2 alla concettualizzazione della macchina di Turing , per poi arrivare ai computer meccanici ed elettromeccanici, ed infine alle architetture digitali ed elettroniche, basate su transistor e circuiti integrati ad altissima densit\u00e0. Le prossime frontiere sono probabilmente quelle dettate dal quantum computing , che potrebbero rivoluzionare completamente l'idea attuale di elaborazione, rendedo vetusta qualsiasi applicazione dell'informatica odierna. Tuttavia, nessuno degli scenari verificatisi negli ultimi 80 anni si sarebbe potuto realizzare se John von Neumann (un altro matematico) non avesse proposto la sua architettura . L'architettura di von Neumann \u00b6 Il modello proposto da John von Neumann \u00e8 unanimamente riconosciuto come la base sulla quale sono basate le moderne architetture dei calcolatori. Elaborato negli anni '40 del secolo scorso, prevede la presenza di quattro entit\u00e0 principali: la Central Processing Unit ( CPU ); la memoria ; i dispositivi di input/output ; il bus di comunicazione . SCHEMA MACCHINA DI VON NEUMANN Le informazioni viaggiano tra i diversi componenti mediante un \"canale\" chiamato bus . Vediamo nel dettaglio le singole parti. Central Processing Unit \u00b6 Componenti fondamentali \u00b6 La CPU \u00e8 il \"cuore\" della macchina di von Neumann, ed \u00e8 a sua volta divisa in due parti: una control unit , responsabile per il prelievo (fetch) e decodifica (decode) delle istruzioni; una processing unit , responsabile dell'esecuzione delle operazioni aritmetiche e logiche. La control unit contiene al suo interno due registri (ovvero piccole sezioni di memoria rapidamente accessibili) fondamentali, ovvero: il Current Instruction Register ( CIR ), che contiene l'istruzione attualmente in esecuzione; il Program Counter , che contiene l'indirizzo dell'istruzione successiva del programma in esecuzione. La processing unit \u00e8 invece composta da: una Arithmetic Logic Unit ( ALU ), ovvero l'unit\u00e0 delegata alla gestione delle operazioni aritmetiche e logiche; una serie di registri che memorizzano le operazioni fondamentali e pi\u00f9 utilizzate dalla macchina. Alcune varianti della CPU prevedono anche la presenza di un segnale di clock. Memoria \u00b6 Rappresenta la memoria \"centrale\" del sistema, di lavoro. Il suo ruolo \u00e8 assimilabile a quello delle RAM , in quanto contiene tutti i dati e le istruzioni necessarie alla corretta esecuzione del programma attuale. E' importante non confondere questa memoria con la memoria di massa (ovvero gli hard disk o gli SSD), nella quale sono immagazzinati i dati ed i programmi quando questi non sono in uso. La memoria dialoga principalmente con la CPU, ed il suo compito consiste nell'agire da \"magazzino\", accessibile in maniera rapida (anche se non tanto rapida quanto i registri) dalla CPU, allo scopo di recuperare i dati necessari all'esecuzione del programma attuale. Dispositivi di Input/Output \u00b6 Sono i dispositivi con cui, rispettivamente, sono forniti dati e programmi alla CPU (Input) e vengono restituiti dalla CPU i risultati dell'elaborazione . E' interessante notare come una memoria di massa possa fungere sia da dispositivo di input, sia da dispositivo di output. Bus \u00b6 Il bus \u00e8 il mezzo con cui i vari componenti della macchina di von Neumann comunicano tra loro. TODO: Funzionamento \u00b6 Esecuzione di programmi \u00b6 La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina - per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite Ciclo Fetch-Decode-Execute \u00b6 L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati FINE TODO: L'importanza della macchina di von Neumann \u00b6 I primi computer \u00b6 I primi computer non avevano una memoria propriamente intesa: i programmi infatti erano spesso \"cablati\" nella logica della macchina. Di conseguenza, un computer progettato per eseguire (ad esempio) determinati calcoli matematici, non poteva essere usato per scrivere, a meno di riprogrammarlo . Questo significava ovviamente imbarcarsi in una procedura lunga, tediosa e complessa, spesso con implicazioni anche di tipo meccanico (ovvero, necessit\u00e0 di ricablare i collegamenti tra le diverse parti della macchina). Per fare un esempio, modificare il programma in esecuzione su una macchina ENIAC (il primo computer general-purpose ) richiedeva circa tre settimane. La macchina di von Neumann permise di superare questo limite introducendo il concetto di stored-program computer , inteso come calcolatore in grado di memorizzare le istruzioni da eseguire in forma elettronica, ottica, o comunque facilmente accessibile . Questo, ovviamente, derivava dalla struttura stessa della macchina, che non implicava una completa integrazione di CPU e memoria, le quali erano bens\u00ec separate ed indipendenti. Va da s\u00e9 che riscrivere la memoria non comportava la riprogrammazione completa della CPU, con un notevole vantaggio in termini di accessibilit\u00e0 e riprogrammabilit\u00e0 del calcolatore. Il collo di bottiglia di von Neumann \u00b6 La macchina di von Neumann soffre di un notevole limite, legato principalmente al rapporto tra la velocit\u00e0 della CPU ed il transfer rate della memoria. Il problema principale \u00e8 legato al fatto che, nel corso del tempo, la velocit\u00e0 delle CPU \u00e8 aumentata seguendo per molti anni la cosiddetta legge di Moore , mentre le evoluzioni delle memorie si sono concentrate sulla loro densit\u00e0 (ovvero sul quantitativo di memoria disponibile) piuttosto che sul throughput (ovvero sul quantitativo di dati che \u00e8 possibile trasferire dalla memoria verso la CPU). Questo fenomeno \u00e8 detto collo di bottiglia di von Neumann , o von Neumann bottleneck . La conseguenza di questo fenomeno sta nel fatto che le CPU elaborano troppe informazioni rispetto a quelle che la memoria pu\u00f2 inviare , e quindi i processori si ritrovano a \"dover attendere\" le istruzioni fornite dalla memoria, lasciando che preziosi cicli di clock passino inutilizzati. Per mitigare questo fenomeno, nel tempo sono stati elaborati diversi approcci, come: creare delle memorie cache , di dimensioni limitate rispetto alle RAM, ma comunque molto pi\u00f9 veloci; fare in modo che dati ed istruzioni viaggino su percorsi differenti, riducendo la congestione sul bus; usare degli algoritmi di branch prediction , che tentano di prevedere quali istruzioni saranno usate successivamente, precaricandole dalla memoria. Nonostante questi \"escamotage\", per\u00f2, la soluzione al von Neumann bottleneck arriv\u00f2 introducendo un'altra architettura. L'architettura Harvard \u00b6 Inizialmente implementata sulla macchina Harvard Mark I , l' architettura Harvard venne introdotta per superare i limiti imposti dal modello di von Neumann, separando la memoria dedicata ai programmi ( instruction memory ) da quella dedicata ai dati ( data memory ). Differenze con l'architettura di von Neumann \u00b6 L'architettura Harvard permette di superare il collo di bottiglia intrinseco nell'architettura di von Neumann permettendo alla CPU di leggere un'istruzione contemporaneamente all'accesso ai dati, anche senza utilizzare una cache; ci\u00f2 significa che, al costo di una complessit\u00e0 circuitale superiore, un computer basato su architettura Harvard \u00e8 pi\u00f9 veloce di uno basato sull'architettura di von Neumann. L'architettura Harvard modificata \u00b6 Una architettura Harvard modificata \u00e8 definita in modo molto vago, ma vi sono tre diverse possibilit\u00e0. Queste architetture sono la Split Cache , access Instruction Memory as Data , e Read Instructions from Data Memory . Access Instruction Memory as Data \u00b6 Questa architettura ricorda l'architettura Harvard standard, ma con uno speciale insieme di istruzioni che permettono di leggere le costanti dalla memoria legata A modified Harvard architecture machine is very much like a Harvard architecture machine, but it relaxes the strict separation between instruction and data while still letting the CPU concurrently access two (or more) memory buses. The most common modification includes separate instruction and data caches backed by a common address space. While the CPU executes from cache, it acts as a pure Harvard machine. When accessing backing memory, it acts like a von Neumann machine (where code can be moved around like data, which is a powerful technique). This modification is widespread in modern processors, such as the ARM architecture, Power ISA and x86 processors. It is sometimes loosely called a Harvard architecture, overlooking the fact that it is actually \"modified\".","title":"01 architettura"},{"location":"02_dispense/02_hardware/01_architettura/#un-po-di-storia","text":"Le origini del concetto di calcolatore (o, nell'accezione comune del termine, computer ) possono essere fatte risalire alla storia antica, con invenzioni come l' abaco , ovvero dei veri e propri strumenti di supporto che permettevano all'operatore umano di svolgere in maniera pi\u00f9 rapida calcoli anche complessi. Il calcolatore si \u00e8 poi evoluto in et\u00e0 moderna: si \u00e8 passati dalle prime sperimentazioni, come le macchine di Pascal e di Leibniz, alle prime calcolatrici , per arrivare al primo modello (teorico) di dispositivo programmabile , ovvero in grado di adattarsi a compiti anche molto diversi tra loro, che si deve al matematico britannico Charles Babbage con la sua Macchina Analitica, progettata nel 1833, e considerata il primo progetto di computer nella storia. Nei decenni successivi, vennero introdotti diversi tipi di calcolatori analogici. Successivamente, si pass\u00f2 alla concettualizzazione della macchina di Turing , per poi arrivare ai computer meccanici ed elettromeccanici, ed infine alle architetture digitali ed elettroniche, basate su transistor e circuiti integrati ad altissima densit\u00e0. Le prossime frontiere sono probabilmente quelle dettate dal quantum computing , che potrebbero rivoluzionare completamente l'idea attuale di elaborazione, rendedo vetusta qualsiasi applicazione dell'informatica odierna. Tuttavia, nessuno degli scenari verificatisi negli ultimi 80 anni si sarebbe potuto realizzare se John von Neumann (un altro matematico) non avesse proposto la sua architettura .","title":"Un po' di storia"},{"location":"02_dispense/02_hardware/01_architettura/#larchitettura-di-von-neumann","text":"Il modello proposto da John von Neumann \u00e8 unanimamente riconosciuto come la base sulla quale sono basate le moderne architetture dei calcolatori. Elaborato negli anni '40 del secolo scorso, prevede la presenza di quattro entit\u00e0 principali: la Central Processing Unit ( CPU ); la memoria ; i dispositivi di input/output ; il bus di comunicazione . SCHEMA MACCHINA DI VON NEUMANN Le informazioni viaggiano tra i diversi componenti mediante un \"canale\" chiamato bus . Vediamo nel dettaglio le singole parti.","title":"L'architettura di von Neumann"},{"location":"02_dispense/02_hardware/01_architettura/#central-processing-unit","text":"","title":"Central Processing Unit"},{"location":"02_dispense/02_hardware/01_architettura/#componenti-fondamentali","text":"La CPU \u00e8 il \"cuore\" della macchina di von Neumann, ed \u00e8 a sua volta divisa in due parti: una control unit , responsabile per il prelievo (fetch) e decodifica (decode) delle istruzioni; una processing unit , responsabile dell'esecuzione delle operazioni aritmetiche e logiche. La control unit contiene al suo interno due registri (ovvero piccole sezioni di memoria rapidamente accessibili) fondamentali, ovvero: il Current Instruction Register ( CIR ), che contiene l'istruzione attualmente in esecuzione; il Program Counter , che contiene l'indirizzo dell'istruzione successiva del programma in esecuzione. La processing unit \u00e8 invece composta da: una Arithmetic Logic Unit ( ALU ), ovvero l'unit\u00e0 delegata alla gestione delle operazioni aritmetiche e logiche; una serie di registri che memorizzano le operazioni fondamentali e pi\u00f9 utilizzate dalla macchina. Alcune varianti della CPU prevedono anche la presenza di un segnale di clock.","title":"Componenti fondamentali"},{"location":"02_dispense/02_hardware/01_architettura/#memoria","text":"Rappresenta la memoria \"centrale\" del sistema, di lavoro. Il suo ruolo \u00e8 assimilabile a quello delle RAM , in quanto contiene tutti i dati e le istruzioni necessarie alla corretta esecuzione del programma attuale. E' importante non confondere questa memoria con la memoria di massa (ovvero gli hard disk o gli SSD), nella quale sono immagazzinati i dati ed i programmi quando questi non sono in uso. La memoria dialoga principalmente con la CPU, ed il suo compito consiste nell'agire da \"magazzino\", accessibile in maniera rapida (anche se non tanto rapida quanto i registri) dalla CPU, allo scopo di recuperare i dati necessari all'esecuzione del programma attuale.","title":"Memoria"},{"location":"02_dispense/02_hardware/01_architettura/#dispositivi-di-inputoutput","text":"Sono i dispositivi con cui, rispettivamente, sono forniti dati e programmi alla CPU (Input) e vengono restituiti dalla CPU i risultati dell'elaborazione . E' interessante notare come una memoria di massa possa fungere sia da dispositivo di input, sia da dispositivo di output.","title":"Dispositivi di Input/Output"},{"location":"02_dispense/02_hardware/01_architettura/#bus","text":"Il bus \u00e8 il mezzo con cui i vari componenti della macchina di von Neumann comunicano tra loro. TODO:","title":"Bus"},{"location":"02_dispense/02_hardware/01_architettura/#funzionamento","text":"","title":"Funzionamento"},{"location":"02_dispense/02_hardware/01_architettura/#esecuzione-di-programmi","text":"La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina - per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite","title":"Esecuzione di programmi"},{"location":"02_dispense/02_hardware/01_architettura/#ciclo-fetch-decode-execute","text":"L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati FINE TODO:","title":"Ciclo Fetch-Decode-Execute"},{"location":"02_dispense/02_hardware/01_architettura/#limportanza-della-macchina-di-von-neumann","text":"","title":"L'importanza della macchina di von Neumann"},{"location":"02_dispense/02_hardware/01_architettura/#i-primi-computer","text":"I primi computer non avevano una memoria propriamente intesa: i programmi infatti erano spesso \"cablati\" nella logica della macchina. Di conseguenza, un computer progettato per eseguire (ad esempio) determinati calcoli matematici, non poteva essere usato per scrivere, a meno di riprogrammarlo . Questo significava ovviamente imbarcarsi in una procedura lunga, tediosa e complessa, spesso con implicazioni anche di tipo meccanico (ovvero, necessit\u00e0 di ricablare i collegamenti tra le diverse parti della macchina). Per fare un esempio, modificare il programma in esecuzione su una macchina ENIAC (il primo computer general-purpose ) richiedeva circa tre settimane. La macchina di von Neumann permise di superare questo limite introducendo il concetto di stored-program computer , inteso come calcolatore in grado di memorizzare le istruzioni da eseguire in forma elettronica, ottica, o comunque facilmente accessibile . Questo, ovviamente, derivava dalla struttura stessa della macchina, che non implicava una completa integrazione di CPU e memoria, le quali erano bens\u00ec separate ed indipendenti. Va da s\u00e9 che riscrivere la memoria non comportava la riprogrammazione completa della CPU, con un notevole vantaggio in termini di accessibilit\u00e0 e riprogrammabilit\u00e0 del calcolatore.","title":"I primi computer"},{"location":"02_dispense/02_hardware/01_architettura/#il-collo-di-bottiglia-di-von-neumann","text":"La macchina di von Neumann soffre di un notevole limite, legato principalmente al rapporto tra la velocit\u00e0 della CPU ed il transfer rate della memoria. Il problema principale \u00e8 legato al fatto che, nel corso del tempo, la velocit\u00e0 delle CPU \u00e8 aumentata seguendo per molti anni la cosiddetta legge di Moore , mentre le evoluzioni delle memorie si sono concentrate sulla loro densit\u00e0 (ovvero sul quantitativo di memoria disponibile) piuttosto che sul throughput (ovvero sul quantitativo di dati che \u00e8 possibile trasferire dalla memoria verso la CPU). Questo fenomeno \u00e8 detto collo di bottiglia di von Neumann , o von Neumann bottleneck . La conseguenza di questo fenomeno sta nel fatto che le CPU elaborano troppe informazioni rispetto a quelle che la memoria pu\u00f2 inviare , e quindi i processori si ritrovano a \"dover attendere\" le istruzioni fornite dalla memoria, lasciando che preziosi cicli di clock passino inutilizzati. Per mitigare questo fenomeno, nel tempo sono stati elaborati diversi approcci, come: creare delle memorie cache , di dimensioni limitate rispetto alle RAM, ma comunque molto pi\u00f9 veloci; fare in modo che dati ed istruzioni viaggino su percorsi differenti, riducendo la congestione sul bus; usare degli algoritmi di branch prediction , che tentano di prevedere quali istruzioni saranno usate successivamente, precaricandole dalla memoria. Nonostante questi \"escamotage\", per\u00f2, la soluzione al von Neumann bottleneck arriv\u00f2 introducendo un'altra architettura.","title":"Il collo di bottiglia di von Neumann"},{"location":"02_dispense/02_hardware/01_architettura/#larchitettura-harvard","text":"Inizialmente implementata sulla macchina Harvard Mark I , l' architettura Harvard venne introdotta per superare i limiti imposti dal modello di von Neumann, separando la memoria dedicata ai programmi ( instruction memory ) da quella dedicata ai dati ( data memory ).","title":"L'architettura Harvard"},{"location":"02_dispense/02_hardware/01_architettura/#differenze-con-larchitettura-di-von-neumann","text":"L'architettura Harvard permette di superare il collo di bottiglia intrinseco nell'architettura di von Neumann permettendo alla CPU di leggere un'istruzione contemporaneamente all'accesso ai dati, anche senza utilizzare una cache; ci\u00f2 significa che, al costo di una complessit\u00e0 circuitale superiore, un computer basato su architettura Harvard \u00e8 pi\u00f9 veloce di uno basato sull'architettura di von Neumann.","title":"Differenze con l'architettura di von Neumann"},{"location":"02_dispense/02_hardware/01_architettura/#larchitettura-harvard-modificata","text":"Una architettura Harvard modificata \u00e8 definita in modo molto vago, ma vi sono tre diverse possibilit\u00e0. Queste architetture sono la Split Cache , access Instruction Memory as Data , e Read Instructions from Data Memory .","title":"L'architettura Harvard modificata"},{"location":"02_dispense/02_hardware/01_architettura/#access-instruction-memory-as-data","text":"Questa architettura ricorda l'architettura Harvard standard, ma con uno speciale insieme di istruzioni che permettono di leggere le costanti dalla memoria legata A modified Harvard architecture machine is very much like a Harvard architecture machine, but it relaxes the strict separation between instruction and data while still letting the CPU concurrently access two (or more) memory buses. The most common modification includes separate instruction and data caches backed by a common address space. While the CPU executes from cache, it acts as a pure Harvard machine. When accessing backing memory, it acts like a von Neumann machine (where code can be moved around like data, which is a powerful technique). This modification is widespread in modern processors, such as the ARM architecture, Power ISA and x86 processors. It is sometimes loosely called a Harvard architecture, overlooking the fact that it is actually \"modified\".","title":"Access Instruction Memory as Data"},{"location":"02_dispense/02_hardware/02_reti/","text":"Reti di telecomunicazione: cosa sono ed a che servono? \u00b6 Nell'ultima lezione, abbiamo introdotto le principali caratteristiche dell'architettura interna di un calcolatore. Il naturale step successivo \u00e8 quindi chiedersi come possano comunicare tra loro due (o pi\u00f9) calcolatori . Ed \u00e8 a questo scopo che sono state introdotte le reti di telecomunicazione . Alcune definizioni \u00b6 Commutazione di circuito vs. commutazione di pacchetto \u00b6 Le reti a commutazione di circuito stabiliscono una connessione fisica tra il mittente ed il destinatario. Un esempio di rete a commutazione di circuito sono le vecchie reti telefoniche, nelle quali veniva creato appunto un circuito fisico tra i due capi della comunicazione. Le reti a commutazione di pacchetto invece non stabiliscono una connessione fisica tra il mittente ed il destinatario, ma fanno s\u00ec che siano i dispositivi di rete ad instradare i dati, opportunamente suddivisi in pacchetti , tra il mittente ed il destinatario. Topologia di rete \u00b6 Standardizzazione \u00b6 Affinch\u00e9 due calcolatori scambino dati (il che, nel gergo comune, significa \" affinch\u00e8 due computer parlino tra loro \") \u00e8 necessario che entrambi si adeguino ad uno standard di comunicazione. Pensiamoci un attimo: saremmo forse in grado di capire ci\u00f2 che dice il nostro docente di Informatica se non avessimo un protocollo di comunicazione comune? Nota Se alla domanda precedente avete risposto di no , la colpa \u00e8 sicuramente vostra e non del docente di Informatica, che risulta essere chiaro, comprensibile, affabile e disponibile. Lo scambio di dati tra due computer \u00e8 inoltre molto pi\u00f9 complesso rispetto alla comunicazione verbale: infatti, prevede che ciascuno dei due computer sia in grado di: presentare i dati scambiati all'utente finale; identificare sia il mittente sia il destinatario dei dati stessi; codificare i dati sotto forma di segnale fisico da inviare su degli opportuni canali di comunicazione fisici. E' inoltre necessario che la comunicazione sia indipendente dal tipo di dispositivo utilizzato: se ci pensate, alcuni di voi seguono le lezioni da un iPad, altri dal proprio smartphone, altri ancora dal proprio laptop o PC desktop. Abbiamo quindi una serie di vincoli da rispettare affinch\u00e9 due o pi\u00f9 dispositivi comunichino. Ed \u00e8 stato proprio questo il punto di partenza dal quale \u00e8 stato definito un modello concettuale volto a caratterizzare e standardizzare la comunicazione tra dispositivi, indipendentemente dalle tecnologie adottate, ovvero il modello ISO/OSI . Il modello ISO/OSI \u00b6 OSI \u00e8 un acronimo che sta per Open Systems Interconnection , ed indica un modello sviluppato tenendo come obiettivo finale l'interoperabilit\u00e0 di diversi sistemi di comunicazione grazie a protocolli di comunicazione standardizzati . La storia del modello OSI nasce negli anni '70, in cui venne sviluppato per supportare la standardizzazione dei diversi tipi di rete di calcolatori emergenti. Negli anni '80, il modello venne adottato dall' International Organization for Standardization ( ISO ), ed assunse il nome di modello ISO/OSI . Il modello ISO/OSI suddivide il flusso dei dati in un sistema di comunicazione in sette diversi livelli ad astrazione crescente, partendo dall'implementazione fisica della trasmissione dei bit sul canale comunicativo, per arrivare alla rappresentazione dei dati ad alto livello (ovvero quello che viene \"presentato\" all'utente). E' importante sottolineare alcune caratteristiche del modello ISO/OSI. In primis, per quello che riguarda una singola macchina, ogni layer comunica esclusivamente con: il livello sottostante, di cui sfrutta le funzionalit\u00e0; il livello sovrastante, cui fornisce una serie di funzionalit\u00e0; Nella comunicazione tra due macchine, invece, ogni layer comunica con il suo pari ( peer ): ad esempio, il layer fisico della macchina A parler\u00e0 soltanto con il layer fisico della macchina B; il layer di rete della macchina A solo con quello di rete della macchina B, e via dicendo. I livelli del modello ISO/OSI \u00b6 Diamo ora una panoramica dei diversi livelli descritti dal modello. Livello 1: Livello fisico \u00b6 Il layer fisico \u00e8 responsabile per la trasmissione e ricezione di dati grezzi ( raw ) tra due dispositivi. Per farlo, sfrutta un mezzo di trasmissione fisico (come ad esempio una guida d'onda o delle onde radio). La sua funzione principale \u00e8 quella di convertire i bit digitali in segnali di tipo elettrico, radio od ottico. Le specifiche del layer includono caratteristiche come livelli di tensione da utilizzare, bit rate, distanza massima di trasmissione, schema di modulazione dei dati e via dicendo. Permette inoltre di definire tre modalit\u00e0 di trasmissione su un canale: simplex : in questo caso, la trasmissione \u00e8 monodirezionale, senza che il ricevitore si alterni con il trasmettitore (e viceversa); half-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, ma il ricevitore si alterna con il trasmettitore (ovvero, la comunicazione non pu\u00f2 avvenire contemporaneamente in entrambe le direzioni); full-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, e la comunicazione pu\u00f2 avvenire contemporaneamente in entrambe le direzioni. Questi includono dei pin, tensioni, impedenze di linea, specifiche dei cavi, timing del segmale e frequenza per i dispositivi wireless. Il controllo del bit rate \u00e8 fatto a livello fisico e pu\u00f2 definire delle modalit\u00e0 di trasmissione come simplex , half-duplex o full duplex. Livello 2: Livello data link \u00b6 Il livello data link \u00e8 quello che si occupa di stabilire un \"collegamento\" tra due diversi nodi. In particolare: individua e corregge gli errori che avvengono a livello fisico; definisce come vengono instaurate e terminate le connessioni; controlla il flusso dati. Il progetto IEEE 802 \u00b6 Il progetto IEEE 802 definisce, relativamente soprattutto al livello data link, un insieme di standard per le reti locali, in inglese Local Area Networks ( LAN ). In tal senso, la definizione data dal progetto IEEE 802 di rete locale \u00e8 la seguente: Quote Una LAN \u00e8 un sistema di comunicazione che permette ad apparecchiature indipendenti di comunicare fra loro entro un'area delimitata usando un canale fisico a velocit\u00e0 elevata e con basso tasso di errore. Notiamo che la LAN non \u00e8 quindi limitata nell'ambito (domestico, commerciale, industriale) n\u00e9 nelle tecnologie utilizzate: gli unici limiti sono l'area di interesse (giocoforza limitata), velocit\u00e0 ed affidabilit\u00e0 della comunicazione. Il progetto IEEE 802 ha quindi suddiviso il livello data link in due diversi sottolivelli: il livello Medium Access Control ( MAC ) verifica come i dispositivi di rete accedono al mezzo fisico; il livello Logical Link Control ( LLC ) controlla gli errori e sincronizza i frame. Concretamente, esistono diversi protocolli definiti nell'ambito del progetto IEEE 802, che sono usati nelle comunicazioni di tutti i giorni. Un esempio sono le reti Ethernet, che aderiscono allo standard 802.3, e le reti WiFi, che aderiscono a diverse versioni dello standard 802.11 (arrivato di recente alla revisione p ). Livello 3: livello di rete \u00b6 Il livello di rete definisce come trasferire sequenze di lunghezza arbitraria ( pacchetti ) tra due nodi connessi in reti differenti, laddove per rete si potrebbe intendere sia una singola LAN, sia l'interconnessione di diverse LAN. E' sul concetto di rete che \u00e8 necessario focalizzarsi. Infatti, ogni dispositivo in rete \u00e8 comunemente detto nodo , e pu\u00f2 trasferire messaggi agli altri nodi semplicemente specificando l'indirizzo degli stessi (oltre che ovviamente il messaggio); saranno i dispositivi di rete a trovar eil modo di consegnare il messaggio al destiantario, magari instradandolo attraverso i nodi intermedi. Notiamo anche che la consegna dei messaggi a livello di rete non \u00e8 strettamente affidabile ; questo comporta quindi che i messaggi potrebbero essere persi, ed \u00e8 quindi necessario prevedere altri meccanismi per garantire l'affidabilit\u00e0 della comunicazione. Livello 4: livello di trasporto \u00b6 Il livello di trasporto \u00e8 quello delegato a garantire questa affidabilit\u00e0 mediante opportuni meccanismi di controllo di flusso e di errore. Il modello ISO/OSI definisce cinque classi di protocolli a livello di trasporto, in base ai tipi di meccanismi di controllo dell'affidabilit\u00e0. Si va dalla classe TP0 , progettata per essere implementata su connessioni supposte error-free , ed i cui protocolli non forniscono alcun meccanismo per la gestione degli errori, fino alla classe TP4 , che \u00e8 quella che ricorda pi\u00f9 da vicino i protocolli maggiormente usati a livello di trasporto in Internet. Livello 5: livello di sessione \u00b6 Il livello di sessione si occupa di controllare il \"dialogo\", ovvero le connessioni , tra i diversi computer, gestendone, tra le altre cose, l'inizializzazione e la chiusura. Livello 6: livello di presentazione \u00b6 Nel modello ISO/OSI, il livello di presentazione si occupa di stabilire un contesto tra due diverse entit\u00e0, all'interno del quale le due possono comunicare pur usando semantica e sentassi differenti . Il livello di presentazione funziona quindi un po' come un traduttore : fa in modo che due applicazioni, anche differenti, siano in grado di comunicare tra loro, fornendo una sorta di \"dizionario\" (o, pi\u00f9 correttamente, mappatura ) tra i linguaggi da loro compresi. E' anche per questo motivo che alle volte il livello di presentazione \u00e8 anche chiamato syntax layer . Oltre alla funzione di mapping, il livello di presentazione ne offre anche di altre, tra cui quella pi\u00f9 importante \u00e8 quella delegata alla compressione dei dati. Livello 7: Livello applicativo \u00b6 Il livello applicativo \u00e8 quello pi\u00f9 vicino all'utente, ed interagisce direttamente con gli applicativi software da questo utilizzati. E' importante sottolineare che la specifica di questi programmi ricade al di fuori dell'ambito del modello ISO/OSI ; di conseguenza, le specifiche (ad esempio) del browser o di un'app per smartphone non saranno mai dettate dallo standard. Quest'ultima considerazione ci permette di distinguere tra applicazione ed entit\u00e0 legata all'applicazione: ad esempio, in un sito di prenotazione degli alberghi ci possono essere due entit\u00e0, una che usa un protocollo a livello applicativo per comunicare con gli utenti, ed un'altra che usa un protocollo a livello applicativo per salvare i dati su un database remoto. Nessuna di queste due entit\u00e0 ha per\u00f2 a che fare con l'applicazione stessa, che \u00e8 definita dalla logica di business (in questo caso, la prenotazione degli alberghi). Lo standard del mondo reale: lo stack TCP/IP \u00b6 Il modello ISO/OSI non trova riscontro diretto nelle applicazioni reali: piuttosto, \u00e8 l' Internet Protocol Suite , o stack TCP/IP , lo stack protocollare usato ed implementato su Internet. Come vedremo, la denominazione stack TCP/IP deriva direttamente dal nome dei due principali protocolli su cui \u00e8 basato lo stack, ovvero il Transmission Control Protocol ( TCP ) e l' Internet Protocol ( IP ). I livelli dello stack TCP/IP \u00b6 A differenza del modello ISO/OSI, lo stack TCP/IP \u00e8 organizzato in quattro diversi livelli, pi\u00f9 o meno riconducibili a quelli dell'ISO/OSI. Questi sono, dal pi\u00f9 basso al pi\u00f9 alto, il livello link , il livello internet , il livello trasporto ed il livello applicativo . Vediamoli di seguito. Livello 1: Livello link \u00b6 Il livello link si occupa di gestire la connessione limitatamente all'ambito della rete locale cui un host \u00e8 collegato. Il link , o collegamento , include quindi tutti gli host che \u00e8 possibile raggiungere senza dover coinvolgere un router (che \u00e8 il dispositivo che permette la connessione tra diverse reti locali). Va da s\u00e9 che la dimensione del link \u00e8 determinata dal progetto della rete stessa. Nel confronto con il modello ISO/OSI, il livello link racchiude le funzionalit\u00e0 corrispondenti a quelle del secondo layer (ovvero il data link ). E' importante sottolieare come l'effettiva implementazione del progetto IEEE 802 sia avvenuta proprio a questo livello. Livello 2: Livello internet \u00b6 La comunicazione tra diverse reti richiede che i dati siano correttamente instradati dalla rete iniziale a quella di destinazione, secondo un processo chiamato routing e supportato dall'identificazione degli indirizzi degli host coinvolti mediante il sistema degli indirizzi IP . Il livello internet fornisce una comunicazione non affidabile su reti differenti, garantendo l'inoltro dei pacchetti mediante dei dispositivi chiamati router. Il livello permette quindi l'interoperabilit\u00e0 di reti eterogenee, e definisce Internet nel modo in cui la conosciamo oggi. Il protocollo principale usato a questo livello \u00e8 l' Internet Protocol , che definisce due diversi sistemi di indirizzamento per l'identificazione degli host sulla rete. Il sistema originario di indirizzamento \u00e8 chiamato Internet Protocol version 4 ( IPv4 ), ed usa un indirizzo a 32 bit per identificare un numero massimo di \\(2^32\\) host. Ovviamente, con il progressivo diffondersi delle reti di telecomunicazione, questo valore ha rappresentato un limite, che \u00e8 stato dapprima arginato inserendo diverse classi di indirizzi riservati alle macchine interne ad ogni LAN, per poi essere superato nel 1998 mediante la standardizzazione dell'Internet Protocol version 6 (IPv6), che usa indirizzi a 128 bit. Tuttavia, nonostante le schede di rete in grado di supportare IPv6 esistano dal 2006 circa, l'IPv4 \u00e8 ancora il protocollo di comunicazione maggiormente utilizzato. Livello 3: Livello di trasporto \u00b6 Il livello di trasporto permette di creare dei \"canali dati\", che le applicazioni usano per lo scambio di messaggi specifici per determinati task. La connettivit\u00e0 pu\u00f2 essere implementata sia come connection-oriented , mediante il protocollo TCP, o connectionless , mediante il protocollo UDP. E' possibile fornire canali di trasmissione specifici per diversi processi mediante il concetto di porta di rete , ovvero la creazione di un costrutto logico numerico allocato specificamente per ognuno dei canali di comunicazione necessari. E' importante notare come, per molti servizi, questi numeri di porta siano stati standardizzati, in modo che i computer client possano indirizzare servizi specifici senza necessitare di tecniche di service discovery . Ad esempio, l'utilizzo standard del protocollo HTTP prevede il coinvolgimento della porta 80, mentre il protocollo SSH la porta 22. Il layer di trasporto dello stack TCP/IP corrisponde approssimativamente al quarto livello del modello OSI, chiamato transport layer. Trasmission Control Protocol \u00b6 Il protocollo TCP \u00e8 un protocollo connection-oriented che risolve i problemi di affidabilit\u00e0 che possono riscontrarsi nella fornitura di un flusso di byte affidabile. In particolare, il TCP garantisce che: i dati arrivino in ordine; i dati siano correttamente ricevuti; i dati duplicati siano scartati; i pacchetti persi o scartati siano nuovamente inviati; la congestione del traffico sia adeguatamente controllata. User Datagram Protocol \u00b6 Il protocollo UDP ( User Datagram Protocol ) \u00e8, a differenza del TCP, un protocollo connectionless , e si occupa di fornire una trasmissione dati non affidabile ma, non includendo il controllo degli errori tipico di TCP, pi\u00f9 veloce. L'UDP \u00e8 tipicamente usato per applicazioni legate allo streaming (audio, video e VoIP), dove l'arrivo in tempo dei dati \u00e8 pi\u00f9 importante dell'effettiva consegna degli stessi. Altri tipi di applicazioni sono quelle che prevedono esclusivamente semplici cicli di richiesta/risposta. Livello 4: Livello applicativo \u00b6 Il livello applicativo include i protocolli usati dalla maggior part edelle applicazioni per fornire servizi all'utente. Questi possono includere servizi di supporto di rete, come protocolli per il routing e la configurazione di rete. Un esempio di protocollo a livello applicativo sono l*Hypertext Transfer Protocol* ( HTTP ). I dati codificati secondo i protocolli a livello applicativo vengono quindi incapsulati in unit\u00e0 a livello di trasporto (ad esempio, in formato TCP o UDP), per poi venire ulteriormente incapsulati man mano che si scende verso il layer fisico. E' interessante notare come lo stack TCP/IP non specifichi la formattazione e la presentazione dei dati, e non definisca dei layer aggiuntivi tra quello applicativo e di trasporto. Per quello che riguarda la comunicazione con il livello di trasporto (e quelli sottostanti), il livello applicativo tratta quest'ultimo come una black box : non si occupa quindi dei dettagli implementativi dello stesso, anche se \u00e8 a conoscenza di alcune informazioni fondamentali come indirizzo IP e numero di porta utilizzati. Dal punto di vista del confronto con il modello ISO/OSI, possiamo dire che il layer applicativo del modello TCP/IP \u00e8 spesso comparato ad una combinazione dei livelli di sessione, presentazione ed applicazione del primo.","title":"02 reti"},{"location":"02_dispense/02_hardware/02_reti/#reti-di-telecomunicazione-cosa-sono-ed-a-che-servono","text":"Nell'ultima lezione, abbiamo introdotto le principali caratteristiche dell'architettura interna di un calcolatore. Il naturale step successivo \u00e8 quindi chiedersi come possano comunicare tra loro due (o pi\u00f9) calcolatori . Ed \u00e8 a questo scopo che sono state introdotte le reti di telecomunicazione .","title":"Reti di telecomunicazione: cosa sono ed a che servono?"},{"location":"02_dispense/02_hardware/02_reti/#alcune-definizioni","text":"","title":"Alcune definizioni"},{"location":"02_dispense/02_hardware/02_reti/#commutazione-di-circuito-vs-commutazione-di-pacchetto","text":"Le reti a commutazione di circuito stabiliscono una connessione fisica tra il mittente ed il destinatario. Un esempio di rete a commutazione di circuito sono le vecchie reti telefoniche, nelle quali veniva creato appunto un circuito fisico tra i due capi della comunicazione. Le reti a commutazione di pacchetto invece non stabiliscono una connessione fisica tra il mittente ed il destinatario, ma fanno s\u00ec che siano i dispositivi di rete ad instradare i dati, opportunamente suddivisi in pacchetti , tra il mittente ed il destinatario.","title":"Commutazione di circuito vs. commutazione di pacchetto"},{"location":"02_dispense/02_hardware/02_reti/#topologia-di-rete","text":"","title":"Topologia di rete"},{"location":"02_dispense/02_hardware/02_reti/#standardizzazione","text":"Affinch\u00e9 due calcolatori scambino dati (il che, nel gergo comune, significa \" affinch\u00e8 due computer parlino tra loro \") \u00e8 necessario che entrambi si adeguino ad uno standard di comunicazione. Pensiamoci un attimo: saremmo forse in grado di capire ci\u00f2 che dice il nostro docente di Informatica se non avessimo un protocollo di comunicazione comune? Nota Se alla domanda precedente avete risposto di no , la colpa \u00e8 sicuramente vostra e non del docente di Informatica, che risulta essere chiaro, comprensibile, affabile e disponibile. Lo scambio di dati tra due computer \u00e8 inoltre molto pi\u00f9 complesso rispetto alla comunicazione verbale: infatti, prevede che ciascuno dei due computer sia in grado di: presentare i dati scambiati all'utente finale; identificare sia il mittente sia il destinatario dei dati stessi; codificare i dati sotto forma di segnale fisico da inviare su degli opportuni canali di comunicazione fisici. E' inoltre necessario che la comunicazione sia indipendente dal tipo di dispositivo utilizzato: se ci pensate, alcuni di voi seguono le lezioni da un iPad, altri dal proprio smartphone, altri ancora dal proprio laptop o PC desktop. Abbiamo quindi una serie di vincoli da rispettare affinch\u00e9 due o pi\u00f9 dispositivi comunichino. Ed \u00e8 stato proprio questo il punto di partenza dal quale \u00e8 stato definito un modello concettuale volto a caratterizzare e standardizzare la comunicazione tra dispositivi, indipendentemente dalle tecnologie adottate, ovvero il modello ISO/OSI .","title":"Standardizzazione"},{"location":"02_dispense/02_hardware/02_reti/#il-modello-isoosi","text":"OSI \u00e8 un acronimo che sta per Open Systems Interconnection , ed indica un modello sviluppato tenendo come obiettivo finale l'interoperabilit\u00e0 di diversi sistemi di comunicazione grazie a protocolli di comunicazione standardizzati . La storia del modello OSI nasce negli anni '70, in cui venne sviluppato per supportare la standardizzazione dei diversi tipi di rete di calcolatori emergenti. Negli anni '80, il modello venne adottato dall' International Organization for Standardization ( ISO ), ed assunse il nome di modello ISO/OSI . Il modello ISO/OSI suddivide il flusso dei dati in un sistema di comunicazione in sette diversi livelli ad astrazione crescente, partendo dall'implementazione fisica della trasmissione dei bit sul canale comunicativo, per arrivare alla rappresentazione dei dati ad alto livello (ovvero quello che viene \"presentato\" all'utente). E' importante sottolineare alcune caratteristiche del modello ISO/OSI. In primis, per quello che riguarda una singola macchina, ogni layer comunica esclusivamente con: il livello sottostante, di cui sfrutta le funzionalit\u00e0; il livello sovrastante, cui fornisce una serie di funzionalit\u00e0; Nella comunicazione tra due macchine, invece, ogni layer comunica con il suo pari ( peer ): ad esempio, il layer fisico della macchina A parler\u00e0 soltanto con il layer fisico della macchina B; il layer di rete della macchina A solo con quello di rete della macchina B, e via dicendo.","title":"Il modello ISO/OSI"},{"location":"02_dispense/02_hardware/02_reti/#i-livelli-del-modello-isoosi","text":"Diamo ora una panoramica dei diversi livelli descritti dal modello.","title":"I livelli del modello ISO/OSI"},{"location":"02_dispense/02_hardware/02_reti/#livello-1-livello-fisico","text":"Il layer fisico \u00e8 responsabile per la trasmissione e ricezione di dati grezzi ( raw ) tra due dispositivi. Per farlo, sfrutta un mezzo di trasmissione fisico (come ad esempio una guida d'onda o delle onde radio). La sua funzione principale \u00e8 quella di convertire i bit digitali in segnali di tipo elettrico, radio od ottico. Le specifiche del layer includono caratteristiche come livelli di tensione da utilizzare, bit rate, distanza massima di trasmissione, schema di modulazione dei dati e via dicendo. Permette inoltre di definire tre modalit\u00e0 di trasmissione su un canale: simplex : in questo caso, la trasmissione \u00e8 monodirezionale, senza che il ricevitore si alterni con il trasmettitore (e viceversa); half-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, ma il ricevitore si alterna con il trasmettitore (ovvero, la comunicazione non pu\u00f2 avvenire contemporaneamente in entrambe le direzioni); full-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, e la comunicazione pu\u00f2 avvenire contemporaneamente in entrambe le direzioni. Questi includono dei pin, tensioni, impedenze di linea, specifiche dei cavi, timing del segmale e frequenza per i dispositivi wireless. Il controllo del bit rate \u00e8 fatto a livello fisico e pu\u00f2 definire delle modalit\u00e0 di trasmissione come simplex , half-duplex o full duplex.","title":"Livello 1: Livello fisico"},{"location":"02_dispense/02_hardware/02_reti/#livello-2-livello-data-link","text":"Il livello data link \u00e8 quello che si occupa di stabilire un \"collegamento\" tra due diversi nodi. In particolare: individua e corregge gli errori che avvengono a livello fisico; definisce come vengono instaurate e terminate le connessioni; controlla il flusso dati.","title":"Livello 2: Livello data link"},{"location":"02_dispense/02_hardware/02_reti/#il-progetto-ieee-802","text":"Il progetto IEEE 802 definisce, relativamente soprattutto al livello data link, un insieme di standard per le reti locali, in inglese Local Area Networks ( LAN ). In tal senso, la definizione data dal progetto IEEE 802 di rete locale \u00e8 la seguente: Quote Una LAN \u00e8 un sistema di comunicazione che permette ad apparecchiature indipendenti di comunicare fra loro entro un'area delimitata usando un canale fisico a velocit\u00e0 elevata e con basso tasso di errore. Notiamo che la LAN non \u00e8 quindi limitata nell'ambito (domestico, commerciale, industriale) n\u00e9 nelle tecnologie utilizzate: gli unici limiti sono l'area di interesse (giocoforza limitata), velocit\u00e0 ed affidabilit\u00e0 della comunicazione. Il progetto IEEE 802 ha quindi suddiviso il livello data link in due diversi sottolivelli: il livello Medium Access Control ( MAC ) verifica come i dispositivi di rete accedono al mezzo fisico; il livello Logical Link Control ( LLC ) controlla gli errori e sincronizza i frame. Concretamente, esistono diversi protocolli definiti nell'ambito del progetto IEEE 802, che sono usati nelle comunicazioni di tutti i giorni. Un esempio sono le reti Ethernet, che aderiscono allo standard 802.3, e le reti WiFi, che aderiscono a diverse versioni dello standard 802.11 (arrivato di recente alla revisione p ).","title":"Il progetto IEEE 802"},{"location":"02_dispense/02_hardware/02_reti/#livello-3-livello-di-rete","text":"Il livello di rete definisce come trasferire sequenze di lunghezza arbitraria ( pacchetti ) tra due nodi connessi in reti differenti, laddove per rete si potrebbe intendere sia una singola LAN, sia l'interconnessione di diverse LAN. E' sul concetto di rete che \u00e8 necessario focalizzarsi. Infatti, ogni dispositivo in rete \u00e8 comunemente detto nodo , e pu\u00f2 trasferire messaggi agli altri nodi semplicemente specificando l'indirizzo degli stessi (oltre che ovviamente il messaggio); saranno i dispositivi di rete a trovar eil modo di consegnare il messaggio al destiantario, magari instradandolo attraverso i nodi intermedi. Notiamo anche che la consegna dei messaggi a livello di rete non \u00e8 strettamente affidabile ; questo comporta quindi che i messaggi potrebbero essere persi, ed \u00e8 quindi necessario prevedere altri meccanismi per garantire l'affidabilit\u00e0 della comunicazione.","title":"Livello 3: livello di rete"},{"location":"02_dispense/02_hardware/02_reti/#livello-4-livello-di-trasporto","text":"Il livello di trasporto \u00e8 quello delegato a garantire questa affidabilit\u00e0 mediante opportuni meccanismi di controllo di flusso e di errore. Il modello ISO/OSI definisce cinque classi di protocolli a livello di trasporto, in base ai tipi di meccanismi di controllo dell'affidabilit\u00e0. Si va dalla classe TP0 , progettata per essere implementata su connessioni supposte error-free , ed i cui protocolli non forniscono alcun meccanismo per la gestione degli errori, fino alla classe TP4 , che \u00e8 quella che ricorda pi\u00f9 da vicino i protocolli maggiormente usati a livello di trasporto in Internet.","title":"Livello 4: livello di trasporto"},{"location":"02_dispense/02_hardware/02_reti/#livello-5-livello-di-sessione","text":"Il livello di sessione si occupa di controllare il \"dialogo\", ovvero le connessioni , tra i diversi computer, gestendone, tra le altre cose, l'inizializzazione e la chiusura.","title":"Livello 5: livello di sessione"},{"location":"02_dispense/02_hardware/02_reti/#livello-6-livello-di-presentazione","text":"Nel modello ISO/OSI, il livello di presentazione si occupa di stabilire un contesto tra due diverse entit\u00e0, all'interno del quale le due possono comunicare pur usando semantica e sentassi differenti . Il livello di presentazione funziona quindi un po' come un traduttore : fa in modo che due applicazioni, anche differenti, siano in grado di comunicare tra loro, fornendo una sorta di \"dizionario\" (o, pi\u00f9 correttamente, mappatura ) tra i linguaggi da loro compresi. E' anche per questo motivo che alle volte il livello di presentazione \u00e8 anche chiamato syntax layer . Oltre alla funzione di mapping, il livello di presentazione ne offre anche di altre, tra cui quella pi\u00f9 importante \u00e8 quella delegata alla compressione dei dati.","title":"Livello 6: livello di presentazione"},{"location":"02_dispense/02_hardware/02_reti/#livello-7-livello-applicativo","text":"Il livello applicativo \u00e8 quello pi\u00f9 vicino all'utente, ed interagisce direttamente con gli applicativi software da questo utilizzati. E' importante sottolineare che la specifica di questi programmi ricade al di fuori dell'ambito del modello ISO/OSI ; di conseguenza, le specifiche (ad esempio) del browser o di un'app per smartphone non saranno mai dettate dallo standard. Quest'ultima considerazione ci permette di distinguere tra applicazione ed entit\u00e0 legata all'applicazione: ad esempio, in un sito di prenotazione degli alberghi ci possono essere due entit\u00e0, una che usa un protocollo a livello applicativo per comunicare con gli utenti, ed un'altra che usa un protocollo a livello applicativo per salvare i dati su un database remoto. Nessuna di queste due entit\u00e0 ha per\u00f2 a che fare con l'applicazione stessa, che \u00e8 definita dalla logica di business (in questo caso, la prenotazione degli alberghi).","title":"Livello 7: Livello applicativo"},{"location":"02_dispense/02_hardware/02_reti/#lo-standard-del-mondo-reale-lo-stack-tcpip","text":"Il modello ISO/OSI non trova riscontro diretto nelle applicazioni reali: piuttosto, \u00e8 l' Internet Protocol Suite , o stack TCP/IP , lo stack protocollare usato ed implementato su Internet. Come vedremo, la denominazione stack TCP/IP deriva direttamente dal nome dei due principali protocolli su cui \u00e8 basato lo stack, ovvero il Transmission Control Protocol ( TCP ) e l' Internet Protocol ( IP ).","title":"Lo standard del mondo reale: lo stack TCP/IP"},{"location":"02_dispense/02_hardware/02_reti/#i-livelli-dello-stack-tcpip","text":"A differenza del modello ISO/OSI, lo stack TCP/IP \u00e8 organizzato in quattro diversi livelli, pi\u00f9 o meno riconducibili a quelli dell'ISO/OSI. Questi sono, dal pi\u00f9 basso al pi\u00f9 alto, il livello link , il livello internet , il livello trasporto ed il livello applicativo . Vediamoli di seguito.","title":"I livelli dello stack TCP/IP"},{"location":"02_dispense/02_hardware/02_reti/#livello-1-livello-link","text":"Il livello link si occupa di gestire la connessione limitatamente all'ambito della rete locale cui un host \u00e8 collegato. Il link , o collegamento , include quindi tutti gli host che \u00e8 possibile raggiungere senza dover coinvolgere un router (che \u00e8 il dispositivo che permette la connessione tra diverse reti locali). Va da s\u00e9 che la dimensione del link \u00e8 determinata dal progetto della rete stessa. Nel confronto con il modello ISO/OSI, il livello link racchiude le funzionalit\u00e0 corrispondenti a quelle del secondo layer (ovvero il data link ). E' importante sottolieare come l'effettiva implementazione del progetto IEEE 802 sia avvenuta proprio a questo livello.","title":"Livello 1: Livello link"},{"location":"02_dispense/02_hardware/02_reti/#livello-2-livello-internet","text":"La comunicazione tra diverse reti richiede che i dati siano correttamente instradati dalla rete iniziale a quella di destinazione, secondo un processo chiamato routing e supportato dall'identificazione degli indirizzi degli host coinvolti mediante il sistema degli indirizzi IP . Il livello internet fornisce una comunicazione non affidabile su reti differenti, garantendo l'inoltro dei pacchetti mediante dei dispositivi chiamati router. Il livello permette quindi l'interoperabilit\u00e0 di reti eterogenee, e definisce Internet nel modo in cui la conosciamo oggi. Il protocollo principale usato a questo livello \u00e8 l' Internet Protocol , che definisce due diversi sistemi di indirizzamento per l'identificazione degli host sulla rete. Il sistema originario di indirizzamento \u00e8 chiamato Internet Protocol version 4 ( IPv4 ), ed usa un indirizzo a 32 bit per identificare un numero massimo di \\(2^32\\) host. Ovviamente, con il progressivo diffondersi delle reti di telecomunicazione, questo valore ha rappresentato un limite, che \u00e8 stato dapprima arginato inserendo diverse classi di indirizzi riservati alle macchine interne ad ogni LAN, per poi essere superato nel 1998 mediante la standardizzazione dell'Internet Protocol version 6 (IPv6), che usa indirizzi a 128 bit. Tuttavia, nonostante le schede di rete in grado di supportare IPv6 esistano dal 2006 circa, l'IPv4 \u00e8 ancora il protocollo di comunicazione maggiormente utilizzato.","title":"Livello 2: Livello internet"},{"location":"02_dispense/02_hardware/02_reti/#livello-3-livello-di-trasporto","text":"Il livello di trasporto permette di creare dei \"canali dati\", che le applicazioni usano per lo scambio di messaggi specifici per determinati task. La connettivit\u00e0 pu\u00f2 essere implementata sia come connection-oriented , mediante il protocollo TCP, o connectionless , mediante il protocollo UDP. E' possibile fornire canali di trasmissione specifici per diversi processi mediante il concetto di porta di rete , ovvero la creazione di un costrutto logico numerico allocato specificamente per ognuno dei canali di comunicazione necessari. E' importante notare come, per molti servizi, questi numeri di porta siano stati standardizzati, in modo che i computer client possano indirizzare servizi specifici senza necessitare di tecniche di service discovery . Ad esempio, l'utilizzo standard del protocollo HTTP prevede il coinvolgimento della porta 80, mentre il protocollo SSH la porta 22. Il layer di trasporto dello stack TCP/IP corrisponde approssimativamente al quarto livello del modello OSI, chiamato transport layer.","title":"Livello 3: Livello di trasporto"},{"location":"02_dispense/02_hardware/02_reti/#trasmission-control-protocol","text":"Il protocollo TCP \u00e8 un protocollo connection-oriented che risolve i problemi di affidabilit\u00e0 che possono riscontrarsi nella fornitura di un flusso di byte affidabile. In particolare, il TCP garantisce che: i dati arrivino in ordine; i dati siano correttamente ricevuti; i dati duplicati siano scartati; i pacchetti persi o scartati siano nuovamente inviati; la congestione del traffico sia adeguatamente controllata.","title":"Trasmission Control Protocol"},{"location":"02_dispense/02_hardware/02_reti/#user-datagram-protocol","text":"Il protocollo UDP ( User Datagram Protocol ) \u00e8, a differenza del TCP, un protocollo connectionless , e si occupa di fornire una trasmissione dati non affidabile ma, non includendo il controllo degli errori tipico di TCP, pi\u00f9 veloce. L'UDP \u00e8 tipicamente usato per applicazioni legate allo streaming (audio, video e VoIP), dove l'arrivo in tempo dei dati \u00e8 pi\u00f9 importante dell'effettiva consegna degli stessi. Altri tipi di applicazioni sono quelle che prevedono esclusivamente semplici cicli di richiesta/risposta.","title":"User Datagram Protocol"},{"location":"02_dispense/02_hardware/02_reti/#livello-4-livello-applicativo","text":"Il livello applicativo include i protocolli usati dalla maggior part edelle applicazioni per fornire servizi all'utente. Questi possono includere servizi di supporto di rete, come protocolli per il routing e la configurazione di rete. Un esempio di protocollo a livello applicativo sono l*Hypertext Transfer Protocol* ( HTTP ). I dati codificati secondo i protocolli a livello applicativo vengono quindi incapsulati in unit\u00e0 a livello di trasporto (ad esempio, in formato TCP o UDP), per poi venire ulteriormente incapsulati man mano che si scende verso il layer fisico. E' interessante notare come lo stack TCP/IP non specifichi la formattazione e la presentazione dei dati, e non definisca dei layer aggiuntivi tra quello applicativo e di trasporto. Per quello che riguarda la comunicazione con il livello di trasporto (e quelli sottostanti), il livello applicativo tratta quest'ultimo come una black box : non si occupa quindi dei dettagli implementativi dello stesso, anche se \u00e8 a conoscenza di alcune informazioni fondamentali come indirizzo IP e numero di porta utilizzati. Dal punto di vista del confronto con il modello ISO/OSI, possiamo dire che il layer applicativo del modello TCP/IP \u00e8 spesso comparato ad una combinazione dei livelli di sessione, presentazione ed applicazione del primo.","title":"Livello 4: Livello applicativo"},{"location":"02_dispense/03_linguaggi/01_linguaggi/","text":"Il Linguaggio Naturale \u00b6 Il Linguaggio Naturale \u00e8 usato per la comunicazione (scritta ed orale) tra gli esseri umani. Ovviamente, il linguaggio naturale presenta diverse fonti di ambiguit\u00e0, tra cui: evoluzione del linguaggio : molto spesso, termini arcaici o neologismi potrebbero non essere ben compresi, come atavico o skippare ; polisemia : esistono termini che hanno un significato diverso a seconda del contesto (ad esempio, i principi non hanno principi ); ambiguit\u00e0 intrinseca : frasi e termini che per essere interpretati hanno necessariamente bisogno del contesto ( una vecchia porta la sbarra ). Questi motivi, oltre all'enorme variabilit\u00e0, fanno s\u00ec che il linguaggio naturale non sia adatto a permettere la comunicazione tra uomo e macchina. E' quindi l'umano a doversi giocoforza adattare. Definizione formale di Linguaggio \u00b6 Iniziamo dando una definizione (pi\u00f9 o meno) formale di linguaggio. Linguaggio Un linguaggio \u00e8 l'insieme di parole ottenute applicando le regole di una data grammatica. La grammatica, a sua volta, \u00e8 definita come segue: Grammatica Una grammatica \u00e8 un formalismo atto a definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle parole. E' chiaro come le due definizioni siano strettamente correlate tra loro, in quanto l'una discende direttamente dall'altra. Sintassi e semantica (nel linguaggio naturale) \u00b6 Le parole di un linguaggio possono essere analizzate da due diversi punti di vista: sintattico : comporta la verifica della correttezza della forma linguistica in cui \u00e8 codificato; semantico : comporta la verifica del significato associato alla forma linguistica. In realt\u00e0, esiste anche l'analisi pragmatica del testo, che ne prevede l'analisi nel contesto dell'utilizzo comune; quest'ultima, tuttavia, esula dai nostri obiettivi, e l'eventuale approfondimento \u00e8 demandato al lettore. Una frase scorretta dal punto di vista sintattico \u00e8 la seguente: Io ho andato a scuola. Una frase corretta dal punto di vista sintattico, ma semanticamente inconsistente \u00e8 la seguente: Tu hai suonato il cellulare al contrario. I Linguaggi di Programmazione \u00b6 I Linguaggi di Programmazione definiscono una notazione specificamente pensata per definire degli algoritmi . La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). Ci\u00f2 \u00e8 possibile usando appositi traduttori (ci ritorneremo pi\u00f9 avanti). Livelli di astrazione \u00b6 In generale, comunque, i linguaggi di programmazione sfruttano appieno il concetto di astrazione delle risorse della macchina su cui viene eseguito un programma. Questo \u00e8 un concetto ricorrente in informatica; ne abbiamo infatti avuto un \"assaggio\" quando abbiamo parlato del modello ISO/OSI, nel quale ogni layer rappresenta una ulteriore \"astrazione\" rispetto a quello sottostante, in modo da rendere il messaggio pi\u00f9 facilmente comprensibile da parte di un utente umano. Nell'ambito dei linguaggi di programmazione, astrarre significa mettere a disposizione i canali fisici di elaborazione dei dati (ovvero, i circuiti) ad un'entit\u00e0 (lo sviluppatore) che parla un linguaggio naturale. Diversi linguaggi di programmazione offrono diversi livelli di astrazione. Linguaggi ad alto livello \u00b6 In generale, i linguaggi ad alto livello , come ad esempio Python, sono molto \"vicini\" al linguaggio parlato da un essere umano, ed astraggono l'accesso alle risorse del calcolatore. Ad esempio, Python non richiede che sia lo sviluppatore a gestire la (tediosa e complessa) operazione di gestione della memoria, ma la gestisce in automatico mediante tecniche di garbage collection . Ci\u00f2 comporta vantaggi e svantaggi: da un lato, \u00e8 pi\u00f9 semplice scrivere programmi in un linguaggio ad alto livello; dall'altro, per\u00f2, vi \u00e8 una certa \"mancanza di controllo\" sulle operazioni compiute dalla macchina che, nonostante non risulti essere un problema nella maggior parte dei casi, pu\u00f2 essere necessaria in caso di applicazioni che richiedono delle procedure di ottimizzazione specifiche. Linguaggi a basso livello \u00b6 A differenza dei linguaggi ad alto livello, quelli a basso livello sono pi\u00f9 vicini al linguaggio parlato dalla macchina. In tal senso, i linguaggi di questo tipo delegano allo sviluppatore operazioni di gestione diretta delle risorse del calcolatore, ed i programmi scritti in questi linguaggi sono contestualmente pi\u00f9 complessi, richiedendo un grado di attenzione ed ottimizzazione pi\u00f9 elevato rispetto a quelli scritti in linguaggi ad alto livello. Ci\u00f2 lascia per\u00f2 spazio al programmatore esperto, che potr\u00e0 ottimizzare in maniera pi\u00f9 granulare le proprie applicazioni, senza dover sottostare ai meccanismi di astrazione delle risorse usati dai linguaggi ad alto livello. Nota sulla gestione delle risorse I meccanismi di gestione delle risorse dei linguaggi ad alto livello non sono \"poco efficienti\". Tutt'altro: essendo scritti da ottimi programmatori, sono molto spesso estremamente pi\u00f9 performanti rispetto a quelli che scriverebbe lo sviluppatore quadratico medio. Tuttavia, questi meccanismi sono, giocoforza, generici , dato che devono adattarsi all'intero ventaglio dei possibili algoritmi implementabili dal linguaggio di programmazione. La genericit\u00e0 determina, in specifiche e limitate circostanze, uno svantaggio, che potrebbe rendere preferibile un maggior controllo sulle risorse della macchina. E' importante sottolineare comunque come la maggior parte dei linguaggi di programmazione ad alto livello offra metodi specifici per gestire questo tipo di situazioni. Linguaggi imperativi vs. linguaggi dichiarativi \u00b6 In generale, \u00e8 possibile operare un'ulteriore distinzione tra linguaggi di programmazione, in base alle modalit\u00e0 con cui viene definita la serie di operazioni che il programma dovr\u00e0 eseguire. Nella programmazione imperativa (o procedurale ), \u00e8 possibile controllare lo stato del programma, specificando il flusso di esecuzione delle istruzioni. Tipici esempi di linguaggi procedurali sono Python, C e C++. Nella programmazione dichiarativa (o non procedurale ), invece, viene semplicemente indicato al programma il risultato che vogliamo ottenere. Esempi di linguaggi di questo tipo sono SQL e Prolog. Facciamo un esempio. In un linguaggio imperativo, \"imponiamo\" al programma le istruzioni da compiere; specifichiamo quindi come ottenere un risultato. Ad esempio: x = 12 y = x * 2 print ( \"Il valore di x \u00e8: {} \" . format ( x )) Nell'esempio precedente, scritto in Python, indichiamo al programma che deve valutare il valore di x , moltiplicarlo per 2, assegnarlo ad y e mostrarlo a schermo. Un esempio di programmazione dichiarativa \u00e8 invece quello che usiamo quando interroghiamo un database mediante istruzioni SQL. Ad esempio: SELECT * FROM TABLE STUDENTI ; In questo caso, \u00e8 chiaro come non si stia specificando come interrogare il database, ma soltanto quello che ci si aspetta da esso (il cosa ). Espressitiv\u00e0 \u00b6 In generale, un linguaggio \u00e8 una rappresentazione scritta o verbale di una serie di concetti ; la quantit\u00e0 e qualit\u00e0 di questa rappresentazione \u00e8 determinata dalla potenza espressiva di un linguaggio. Per quello che riguarda i linguaggi di programmazione, l'espressivit\u00e0 \u00e8 associata ai problemi che sono in grado di risolvere e, di conseguenza, agli algoritmi che sono in grado di rappresentare . In particolare, i linguaggi di programmazione pi\u00f9 comuni sono spesso definiti come Turing-completi , in quanto possono implementare tutti gli algoritmi risolvibili da una macchina di Turing universale (torneremo pi\u00f9 avanti su questo concetto). I linguaggi di markup, come ad esempio HTML ed XML, non sono normalmente considerati linguaggi di programmazione. Sintassi e semantica (nei linguaggi di programmazione) \u00b6 Come nei linguaggi naturali, anche per i linguaggi di programmazione sono essenziali i concetti di sintassi e semantica . In particolare, la sintassi specifica le regole con le quali un'istruzione viene ritenuta valida. In generale, queste variano da linguaggio a linguaggio (rimanendo pur sempre abbastanza \"affini\"), e sono estremamente rigide : un programma non conforme alle regole sintattiche indicate per il linguaggio non potr\u00e0 in alcun modo essere eseguito. Per fortuna, queste regole sono poche , semplici e ben definite per ogni linguaggio. Neanche lontanamente complesse come l'uso dei congiuntivi, quindi. Anche la semantica ha un rapporto estremamente \"stretto\" con l'analogo concetto usato nei linguaggi naturali, dato che ci permette di valutare il contenuto informativo di un programma. In particolare, ci sono tre metodi per trattare formalmente la semantica di un programma, allo scopo di caratterizzarne il comportamento: nella semantica operazionale si specifica come i costrutti del linguaggio vengano eseguiti su di una macchina astratta; nella semantica denotazionale si specifica come interpretare il significato dei costrutti scritti in un linguaggio; nella semantica assiomatica si specifica come determinare il significato dei costrutti scritti in un linguaggio usando degli assiomi (ovvero regole di \"correttezza\" data una certa logica).","title":"01 linguaggi"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#il-linguaggio-naturale","text":"Il Linguaggio Naturale \u00e8 usato per la comunicazione (scritta ed orale) tra gli esseri umani. Ovviamente, il linguaggio naturale presenta diverse fonti di ambiguit\u00e0, tra cui: evoluzione del linguaggio : molto spesso, termini arcaici o neologismi potrebbero non essere ben compresi, come atavico o skippare ; polisemia : esistono termini che hanno un significato diverso a seconda del contesto (ad esempio, i principi non hanno principi ); ambiguit\u00e0 intrinseca : frasi e termini che per essere interpretati hanno necessariamente bisogno del contesto ( una vecchia porta la sbarra ). Questi motivi, oltre all'enorme variabilit\u00e0, fanno s\u00ec che il linguaggio naturale non sia adatto a permettere la comunicazione tra uomo e macchina. E' quindi l'umano a doversi giocoforza adattare.","title":"Il Linguaggio Naturale"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#definizione-formale-di-linguaggio","text":"Iniziamo dando una definizione (pi\u00f9 o meno) formale di linguaggio. Linguaggio Un linguaggio \u00e8 l'insieme di parole ottenute applicando le regole di una data grammatica. La grammatica, a sua volta, \u00e8 definita come segue: Grammatica Una grammatica \u00e8 un formalismo atto a definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle parole. E' chiaro come le due definizioni siano strettamente correlate tra loro, in quanto l'una discende direttamente dall'altra.","title":"Definizione formale di Linguaggio"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#sintassi-e-semantica-nel-linguaggio-naturale","text":"Le parole di un linguaggio possono essere analizzate da due diversi punti di vista: sintattico : comporta la verifica della correttezza della forma linguistica in cui \u00e8 codificato; semantico : comporta la verifica del significato associato alla forma linguistica. In realt\u00e0, esiste anche l'analisi pragmatica del testo, che ne prevede l'analisi nel contesto dell'utilizzo comune; quest'ultima, tuttavia, esula dai nostri obiettivi, e l'eventuale approfondimento \u00e8 demandato al lettore. Una frase scorretta dal punto di vista sintattico \u00e8 la seguente: Io ho andato a scuola. Una frase corretta dal punto di vista sintattico, ma semanticamente inconsistente \u00e8 la seguente: Tu hai suonato il cellulare al contrario.","title":"Sintassi e semantica (nel linguaggio naturale)"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#i-linguaggi-di-programmazione","text":"I Linguaggi di Programmazione definiscono una notazione specificamente pensata per definire degli algoritmi . La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). Ci\u00f2 \u00e8 possibile usando appositi traduttori (ci ritorneremo pi\u00f9 avanti).","title":"I Linguaggi di Programmazione"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#livelli-di-astrazione","text":"In generale, comunque, i linguaggi di programmazione sfruttano appieno il concetto di astrazione delle risorse della macchina su cui viene eseguito un programma. Questo \u00e8 un concetto ricorrente in informatica; ne abbiamo infatti avuto un \"assaggio\" quando abbiamo parlato del modello ISO/OSI, nel quale ogni layer rappresenta una ulteriore \"astrazione\" rispetto a quello sottostante, in modo da rendere il messaggio pi\u00f9 facilmente comprensibile da parte di un utente umano. Nell'ambito dei linguaggi di programmazione, astrarre significa mettere a disposizione i canali fisici di elaborazione dei dati (ovvero, i circuiti) ad un'entit\u00e0 (lo sviluppatore) che parla un linguaggio naturale. Diversi linguaggi di programmazione offrono diversi livelli di astrazione.","title":"Livelli di astrazione"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#linguaggi-ad-alto-livello","text":"In generale, i linguaggi ad alto livello , come ad esempio Python, sono molto \"vicini\" al linguaggio parlato da un essere umano, ed astraggono l'accesso alle risorse del calcolatore. Ad esempio, Python non richiede che sia lo sviluppatore a gestire la (tediosa e complessa) operazione di gestione della memoria, ma la gestisce in automatico mediante tecniche di garbage collection . Ci\u00f2 comporta vantaggi e svantaggi: da un lato, \u00e8 pi\u00f9 semplice scrivere programmi in un linguaggio ad alto livello; dall'altro, per\u00f2, vi \u00e8 una certa \"mancanza di controllo\" sulle operazioni compiute dalla macchina che, nonostante non risulti essere un problema nella maggior parte dei casi, pu\u00f2 essere necessaria in caso di applicazioni che richiedono delle procedure di ottimizzazione specifiche.","title":"Linguaggi ad alto livello"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#linguaggi-a-basso-livello","text":"A differenza dei linguaggi ad alto livello, quelli a basso livello sono pi\u00f9 vicini al linguaggio parlato dalla macchina. In tal senso, i linguaggi di questo tipo delegano allo sviluppatore operazioni di gestione diretta delle risorse del calcolatore, ed i programmi scritti in questi linguaggi sono contestualmente pi\u00f9 complessi, richiedendo un grado di attenzione ed ottimizzazione pi\u00f9 elevato rispetto a quelli scritti in linguaggi ad alto livello. Ci\u00f2 lascia per\u00f2 spazio al programmatore esperto, che potr\u00e0 ottimizzare in maniera pi\u00f9 granulare le proprie applicazioni, senza dover sottostare ai meccanismi di astrazione delle risorse usati dai linguaggi ad alto livello. Nota sulla gestione delle risorse I meccanismi di gestione delle risorse dei linguaggi ad alto livello non sono \"poco efficienti\". Tutt'altro: essendo scritti da ottimi programmatori, sono molto spesso estremamente pi\u00f9 performanti rispetto a quelli che scriverebbe lo sviluppatore quadratico medio. Tuttavia, questi meccanismi sono, giocoforza, generici , dato che devono adattarsi all'intero ventaglio dei possibili algoritmi implementabili dal linguaggio di programmazione. La genericit\u00e0 determina, in specifiche e limitate circostanze, uno svantaggio, che potrebbe rendere preferibile un maggior controllo sulle risorse della macchina. E' importante sottolineare comunque come la maggior parte dei linguaggi di programmazione ad alto livello offra metodi specifici per gestire questo tipo di situazioni.","title":"Linguaggi a basso livello"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#linguaggi-imperativi-vs-linguaggi-dichiarativi","text":"In generale, \u00e8 possibile operare un'ulteriore distinzione tra linguaggi di programmazione, in base alle modalit\u00e0 con cui viene definita la serie di operazioni che il programma dovr\u00e0 eseguire. Nella programmazione imperativa (o procedurale ), \u00e8 possibile controllare lo stato del programma, specificando il flusso di esecuzione delle istruzioni. Tipici esempi di linguaggi procedurali sono Python, C e C++. Nella programmazione dichiarativa (o non procedurale ), invece, viene semplicemente indicato al programma il risultato che vogliamo ottenere. Esempi di linguaggi di questo tipo sono SQL e Prolog. Facciamo un esempio. In un linguaggio imperativo, \"imponiamo\" al programma le istruzioni da compiere; specifichiamo quindi come ottenere un risultato. Ad esempio: x = 12 y = x * 2 print ( \"Il valore di x \u00e8: {} \" . format ( x )) Nell'esempio precedente, scritto in Python, indichiamo al programma che deve valutare il valore di x , moltiplicarlo per 2, assegnarlo ad y e mostrarlo a schermo. Un esempio di programmazione dichiarativa \u00e8 invece quello che usiamo quando interroghiamo un database mediante istruzioni SQL. Ad esempio: SELECT * FROM TABLE STUDENTI ; In questo caso, \u00e8 chiaro come non si stia specificando come interrogare il database, ma soltanto quello che ci si aspetta da esso (il cosa ).","title":"Linguaggi imperativi vs. linguaggi dichiarativi"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#espressitiva","text":"In generale, un linguaggio \u00e8 una rappresentazione scritta o verbale di una serie di concetti ; la quantit\u00e0 e qualit\u00e0 di questa rappresentazione \u00e8 determinata dalla potenza espressiva di un linguaggio. Per quello che riguarda i linguaggi di programmazione, l'espressivit\u00e0 \u00e8 associata ai problemi che sono in grado di risolvere e, di conseguenza, agli algoritmi che sono in grado di rappresentare . In particolare, i linguaggi di programmazione pi\u00f9 comuni sono spesso definiti come Turing-completi , in quanto possono implementare tutti gli algoritmi risolvibili da una macchina di Turing universale (torneremo pi\u00f9 avanti su questo concetto). I linguaggi di markup, come ad esempio HTML ed XML, non sono normalmente considerati linguaggi di programmazione.","title":"Espressitiv\u00e0"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#sintassi-e-semantica-nei-linguaggi-di-programmazione","text":"Come nei linguaggi naturali, anche per i linguaggi di programmazione sono essenziali i concetti di sintassi e semantica . In particolare, la sintassi specifica le regole con le quali un'istruzione viene ritenuta valida. In generale, queste variano da linguaggio a linguaggio (rimanendo pur sempre abbastanza \"affini\"), e sono estremamente rigide : un programma non conforme alle regole sintattiche indicate per il linguaggio non potr\u00e0 in alcun modo essere eseguito. Per fortuna, queste regole sono poche , semplici e ben definite per ogni linguaggio. Neanche lontanamente complesse come l'uso dei congiuntivi, quindi. Anche la semantica ha un rapporto estremamente \"stretto\" con l'analogo concetto usato nei linguaggi naturali, dato che ci permette di valutare il contenuto informativo di un programma. In particolare, ci sono tre metodi per trattare formalmente la semantica di un programma, allo scopo di caratterizzarne il comportamento: nella semantica operazionale si specifica come i costrutti del linguaggio vengano eseguiti su di una macchina astratta; nella semantica denotazionale si specifica come interpretare il significato dei costrutti scritti in un linguaggio; nella semantica assiomatica si specifica come determinare il significato dei costrutti scritti in un linguaggio usando degli assiomi (ovvero regole di \"correttezza\" data una certa logica).","title":"Sintassi e semantica (nei linguaggi di programmazione)"},{"location":"02_dispense/03_linguaggi/02_traduttori/","text":"Traduttori \u00b6 Parlando dei linguaggi di programmazione, abbiamo detto che: Il Docente, o, alternativamente, Queste Dispense. La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). L'esecuzione di questo task \u00e8 delegato ad un apposito programma chiamato traduttore , che si occupa di tradurre il codice scritto in un linguaggio (chiamato linguaggio sorgente ) in codice scritto in un altro linguaggio (chiamato linguaggio obiettivo ). Normalmente, il linguaggio sorgente \u00e8 ad un livello di astrazione pi\u00f9 alto rispetto al linguaggio obiettivo: ad esempio, il linguaggio sorgente potrebbe essere il C, mentre il linguaggio obiettivo potrebbe essere Assembly. Il traduttore ha diversi compiti: per prima cosa, si occupa di verificare la correttezza sintattica del codice scritto in linguaggio sorgente. Per fare un esempio, il traduttore valider\u00e0 questa istruzione: a = 1 + 2 ma non questa: a = = 2 + 'pippo' Una volta validata la correttezza sintattica delle istruzioni analizzate, attribuir\u00e0 a ciascuna di esse un opportuno significato , associando le corrispondenti istruzioni nel linguaggio obiettivo. E' importante sottolinare come l'interpretazione debba essere univoca , onde garantire la propriet\u00e0 di non ambiguit\u00e0 degli algoritmi. Esistono principalmente due categorie di traduttori: i compilatori e gli interpreti . Compilatori \u00b6 Il termine compilatore viene usato per indicare i traduttori che si occupano di tradurre direttamente il codice da un linguaggio sorgente ad alto livello ad un linguaggio obiettivo a basso livello, come assembly, codice oggetto o codice macchina. Nota Il fatto che un compilatore traduca direttamente il codice da linguaggio ad alto livello a codice oggetto/macchina implica che quest'ultimo sia specifico per un certo tipo di hardware e software. Ci\u00f2 comporta che, in molte situazioni, non saremo in grado di eseguire il codice compilato per i nostri PC su dispositivi come Arduino o i nostri smartphone! Tipologie di compilatore (alcuni esempi) \u00b6 Esistono diversi tipi di compilatore. Ad esempio, se il programma compilato pu\u00f2 essere eseguito su un computer le cui caratteristiche hardware o software sono diverse da quelle del computer sul quale il programma \u00e8 stato compilato, siamo di fronte ad un cross-compilatore . Nota Per \"caratteristiche hardware o software\" si intendono prevalentemente CPU (ed il suo instruction set) e sistema operativo (ed i driver che comandano i diversi dispositivi). Il programma duale di un compilatore \u00e8 chiamato decompilatore , ed \u00e8, prevedibilmente, un programma che traduce il codice da un linguaggio sorgente a basso livello ad un linguaggio obiettivo a pi\u00f9 alto livello. Un altro esempio di compilatore \u00e8 il transcompilatore , che traduce un programma scritto in un sorgente ad alto livello in codice scritto in un obiettivo sempre ad alto livello. Operazioni di un compilatore \u00b6 La maggior parte dei compilatori odierni segue un percorso articolato in tre diverse fasi ( three-stage compilers ), chiamate rispettivamente front end , middle end e back end . Front end \u00b6 Lo scopo del front end \u00e8 quello di analizzare il codice scritto in liguaggio sorgente, creando una rappresentazione intermedia del programma. Il processo supportato dalla fase di front end si articola in quattro diverse fasi. Preprocessing \u00b6 La fase di preprocessing (in italiano pre-elaborazione ) si occupa di sostituire alcune direttive specifiche per il linguaggio (ad esempio, le direttive #define in C) con il corrispondente codice sorgente. Analisi lessicale \u00b6 La fase di analisi lessicale prevede la lettura del sorgente come un'unica stringa, e la successiva suddivisione della stessa in \"parti\" dette token , i quali sono delimitati da caratteri come segni di interpunzione (ad esempio, virgole, punti, etc.), operatori matematici (ad esempio, i segni + , - , etc.), parentesi, o anche nomi di variabile e parole riservate. Un esempio di tokenizzazione \u00e8 il seguente. il codice sorgente: if ( x > 0.0 ) { y = 1.0 ; } diventa: if ( x > 0.0 ) y = 1.0 ; che produce i token if , ( , x , > , 0.0 , ) , y , = , 1.0 . Analisi sintattica \u00b6 La fase di analisi sintattica , comunemente nota anche come parsing , prevede l'analisi dei singoli token allo scopo di valutarne la correttezza sintattica , ovvero l'adesione alle regole grammaticali stabilite per quel linguaggio. L'analisi sintattica crea una struttura ad albero costruita a partire dalle regole formali del linguaggio, chiamata albero di parsing ( parse tree ). Analisi semantica \u00b6 La fase di analisi semantica integra le informazioni immagazzinate nel parse tree con informazioni di tipo semantico, come ad esempio il type checking , che controlla la coerenza tra i diversi tipi assunti dalle variabili. Middle End \u00b6 Lo scopo del middle end \u00e8 quello di ottimizzare la rappresentazione intermedia ottenuta dal front end. Per far questo, sono implementate delle tecniche di analisi del programma (ad esempio, mediante l'analisi del flusso di esecuzione, allo scopo di valutare e la presenza di eventuali ridondanze) ed ottimizzazione (ad esempio, rimuovendo le ridondanze individuate nella fase precedente). Un esempio di ridondanza \u00e8 il seguente: int main ( void ) { int a = 0 ; // Codice ridondante! if ( 1 == 0 ) { a = 1 ; } return a ; } Il codice all'interno dell'istruzione condizionale non \u00e8 raggiungibile , in quanto la condizione di uguaglianza tra uno e zero non \u00e8, per le conoscenze attuali, mai verificata. Back End \u00b6 Lo scopo del back end \u00e8 quello di inserire (opzionalmente) delle ottimizzazioni specifiche per l'architettura corrente (ovvero per il processore per il quale il codice sta venendo compilato), e generare il codice oggetto . Nota Il codice oggetto non \u00e8 il programma eseguibile. Generare l'eseguibile \u00e8 compito di un altro programma, spesso integrato in quelli che generalmente sono indicati come compilatori, chiamato linker . Interpreti \u00b6 L'altro tipo di traduttore comunemente utilizzato al giorno d'oggi \u00e8 chiamato interprete . L'approccio usato dall'interprete si differenzia da quello usato dal compilatore principalmente per un dettaglio: laddove il compilatore fa in modo che l'intero processo di traduzione da codice sorgente a programma eseguibile avvenga prima dell'esecuzione del programma, in un lasso di tempo chiamato compile time , l'interprete esegue un'istruzione immediatamente ; in teoria, ogni istruzione in un linguaggio interpretata potrebbe essere eseguita immediatamente dopo la sua scrittura. Non vi \u00e8 quindi una netta separazione, almeno dal punto di vista dell'utente, tra compile time e run time (con quest'ultimo il lasso di tempo in cui il programma \u00e8 in esecuzione). Gli step di interpetazione sono quindi essenzialmente tre: controllo dell'istruzione sul codice sorgente; traduzione in linguaggio macchina; esecuzione dell'istruzione tradotta. Ne consegue che un programma interpretato potrebbe interrompersi \"al volo\" (ovvero a run time), proprio perch\u00e9 l'interprete non \u00e8 in grado di anticipare eventuali errori sul sorgente. Compilatore vs. Interprete \u00b6 Di seguito una tabella comparativa di vantaggi e svantaggi legati all'adozione di un compilatore o di un interprete. Compilatore Interpete Vantaggi Ottimizzazione del codice Maggiore velocit\u00e0 di esecuzione Controllo sintattico e semantico Compile time nullo o ridotto Maggiore portabilit\u00e0 tra architettura Possibilit\u00e0 di debug con granularit\u00e0 a livello di singola istruzione Svantaggi Minore portabilit\u00e0 tra architetture Debug complesso da effettuare Minore velocit\u00e0 di esecuzione Performance non ottimizzate Possibili errori imprevisti a run time Linguaggi compilati e linguaggi interpretati \u00b6 Per linguaggio compilato si intende un linguaggio di programmazione le cui implementazioni sono tipicamente compilate ; di converso, un linguaggio interpretato prevede l'uso estensivo di interpeti. La distinzione \u00e8 per\u00f2 alquanto vaga. Infatti, almeno in linea di principio, qualunque linguaggio pu\u00f2 essere implementato indifferentemente mediante un compilatore od un itnerprete. E' anche possibile combinare entrambe le soluzioni: un compilatore pu\u00f2 ad esempio occuparsi della traduzione del codice sorgente nella rappresentazione intermedia, chiamata in questi casi bytecode , che viene passata ad un interprete che la esegue. E' questo ad esempio il caso di Java, che utilizza questo tipo di soluzione per passare il bytecode alla Java Virtual Machine , di cui esiste un'implementazione per la maggior parte delle architetture esistenti.","title":"02 traduttori"},{"location":"02_dispense/03_linguaggi/02_traduttori/#traduttori","text":"Parlando dei linguaggi di programmazione, abbiamo detto che: Il Docente, o, alternativamente, Queste Dispense. La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). L'esecuzione di questo task \u00e8 delegato ad un apposito programma chiamato traduttore , che si occupa di tradurre il codice scritto in un linguaggio (chiamato linguaggio sorgente ) in codice scritto in un altro linguaggio (chiamato linguaggio obiettivo ). Normalmente, il linguaggio sorgente \u00e8 ad un livello di astrazione pi\u00f9 alto rispetto al linguaggio obiettivo: ad esempio, il linguaggio sorgente potrebbe essere il C, mentre il linguaggio obiettivo potrebbe essere Assembly. Il traduttore ha diversi compiti: per prima cosa, si occupa di verificare la correttezza sintattica del codice scritto in linguaggio sorgente. Per fare un esempio, il traduttore valider\u00e0 questa istruzione: a = 1 + 2 ma non questa: a = = 2 + 'pippo' Una volta validata la correttezza sintattica delle istruzioni analizzate, attribuir\u00e0 a ciascuna di esse un opportuno significato , associando le corrispondenti istruzioni nel linguaggio obiettivo. E' importante sottolinare come l'interpretazione debba essere univoca , onde garantire la propriet\u00e0 di non ambiguit\u00e0 degli algoritmi. Esistono principalmente due categorie di traduttori: i compilatori e gli interpreti .","title":"Traduttori"},{"location":"02_dispense/03_linguaggi/02_traduttori/#compilatori","text":"Il termine compilatore viene usato per indicare i traduttori che si occupano di tradurre direttamente il codice da un linguaggio sorgente ad alto livello ad un linguaggio obiettivo a basso livello, come assembly, codice oggetto o codice macchina. Nota Il fatto che un compilatore traduca direttamente il codice da linguaggio ad alto livello a codice oggetto/macchina implica che quest'ultimo sia specifico per un certo tipo di hardware e software. Ci\u00f2 comporta che, in molte situazioni, non saremo in grado di eseguire il codice compilato per i nostri PC su dispositivi come Arduino o i nostri smartphone!","title":"Compilatori"},{"location":"02_dispense/03_linguaggi/02_traduttori/#tipologie-di-compilatore-alcuni-esempi","text":"Esistono diversi tipi di compilatore. Ad esempio, se il programma compilato pu\u00f2 essere eseguito su un computer le cui caratteristiche hardware o software sono diverse da quelle del computer sul quale il programma \u00e8 stato compilato, siamo di fronte ad un cross-compilatore . Nota Per \"caratteristiche hardware o software\" si intendono prevalentemente CPU (ed il suo instruction set) e sistema operativo (ed i driver che comandano i diversi dispositivi). Il programma duale di un compilatore \u00e8 chiamato decompilatore , ed \u00e8, prevedibilmente, un programma che traduce il codice da un linguaggio sorgente a basso livello ad un linguaggio obiettivo a pi\u00f9 alto livello. Un altro esempio di compilatore \u00e8 il transcompilatore , che traduce un programma scritto in un sorgente ad alto livello in codice scritto in un obiettivo sempre ad alto livello.","title":"Tipologie di compilatore (alcuni esempi)"},{"location":"02_dispense/03_linguaggi/02_traduttori/#operazioni-di-un-compilatore","text":"La maggior parte dei compilatori odierni segue un percorso articolato in tre diverse fasi ( three-stage compilers ), chiamate rispettivamente front end , middle end e back end .","title":"Operazioni di un compilatore"},{"location":"02_dispense/03_linguaggi/02_traduttori/#front-end","text":"Lo scopo del front end \u00e8 quello di analizzare il codice scritto in liguaggio sorgente, creando una rappresentazione intermedia del programma. Il processo supportato dalla fase di front end si articola in quattro diverse fasi.","title":"Front end"},{"location":"02_dispense/03_linguaggi/02_traduttori/#preprocessing","text":"La fase di preprocessing (in italiano pre-elaborazione ) si occupa di sostituire alcune direttive specifiche per il linguaggio (ad esempio, le direttive #define in C) con il corrispondente codice sorgente.","title":"Preprocessing"},{"location":"02_dispense/03_linguaggi/02_traduttori/#analisi-lessicale","text":"La fase di analisi lessicale prevede la lettura del sorgente come un'unica stringa, e la successiva suddivisione della stessa in \"parti\" dette token , i quali sono delimitati da caratteri come segni di interpunzione (ad esempio, virgole, punti, etc.), operatori matematici (ad esempio, i segni + , - , etc.), parentesi, o anche nomi di variabile e parole riservate. Un esempio di tokenizzazione \u00e8 il seguente. il codice sorgente: if ( x > 0.0 ) { y = 1.0 ; } diventa: if ( x > 0.0 ) y = 1.0 ; che produce i token if , ( , x , > , 0.0 , ) , y , = , 1.0 .","title":"Analisi lessicale"},{"location":"02_dispense/03_linguaggi/02_traduttori/#analisi-sintattica","text":"La fase di analisi sintattica , comunemente nota anche come parsing , prevede l'analisi dei singoli token allo scopo di valutarne la correttezza sintattica , ovvero l'adesione alle regole grammaticali stabilite per quel linguaggio. L'analisi sintattica crea una struttura ad albero costruita a partire dalle regole formali del linguaggio, chiamata albero di parsing ( parse tree ).","title":"Analisi sintattica"},{"location":"02_dispense/03_linguaggi/02_traduttori/#analisi-semantica","text":"La fase di analisi semantica integra le informazioni immagazzinate nel parse tree con informazioni di tipo semantico, come ad esempio il type checking , che controlla la coerenza tra i diversi tipi assunti dalle variabili.","title":"Analisi semantica"},{"location":"02_dispense/03_linguaggi/02_traduttori/#middle-end","text":"Lo scopo del middle end \u00e8 quello di ottimizzare la rappresentazione intermedia ottenuta dal front end. Per far questo, sono implementate delle tecniche di analisi del programma (ad esempio, mediante l'analisi del flusso di esecuzione, allo scopo di valutare e la presenza di eventuali ridondanze) ed ottimizzazione (ad esempio, rimuovendo le ridondanze individuate nella fase precedente). Un esempio di ridondanza \u00e8 il seguente: int main ( void ) { int a = 0 ; // Codice ridondante! if ( 1 == 0 ) { a = 1 ; } return a ; } Il codice all'interno dell'istruzione condizionale non \u00e8 raggiungibile , in quanto la condizione di uguaglianza tra uno e zero non \u00e8, per le conoscenze attuali, mai verificata.","title":"Middle End"},{"location":"02_dispense/03_linguaggi/02_traduttori/#back-end","text":"Lo scopo del back end \u00e8 quello di inserire (opzionalmente) delle ottimizzazioni specifiche per l'architettura corrente (ovvero per il processore per il quale il codice sta venendo compilato), e generare il codice oggetto . Nota Il codice oggetto non \u00e8 il programma eseguibile. Generare l'eseguibile \u00e8 compito di un altro programma, spesso integrato in quelli che generalmente sono indicati come compilatori, chiamato linker .","title":"Back End"},{"location":"02_dispense/03_linguaggi/02_traduttori/#interpreti","text":"L'altro tipo di traduttore comunemente utilizzato al giorno d'oggi \u00e8 chiamato interprete . L'approccio usato dall'interprete si differenzia da quello usato dal compilatore principalmente per un dettaglio: laddove il compilatore fa in modo che l'intero processo di traduzione da codice sorgente a programma eseguibile avvenga prima dell'esecuzione del programma, in un lasso di tempo chiamato compile time , l'interprete esegue un'istruzione immediatamente ; in teoria, ogni istruzione in un linguaggio interpretata potrebbe essere eseguita immediatamente dopo la sua scrittura. Non vi \u00e8 quindi una netta separazione, almeno dal punto di vista dell'utente, tra compile time e run time (con quest'ultimo il lasso di tempo in cui il programma \u00e8 in esecuzione). Gli step di interpetazione sono quindi essenzialmente tre: controllo dell'istruzione sul codice sorgente; traduzione in linguaggio macchina; esecuzione dell'istruzione tradotta. Ne consegue che un programma interpretato potrebbe interrompersi \"al volo\" (ovvero a run time), proprio perch\u00e9 l'interprete non \u00e8 in grado di anticipare eventuali errori sul sorgente.","title":"Interpreti"},{"location":"02_dispense/03_linguaggi/02_traduttori/#compilatore-vs-interprete","text":"Di seguito una tabella comparativa di vantaggi e svantaggi legati all'adozione di un compilatore o di un interprete. Compilatore Interpete Vantaggi Ottimizzazione del codice Maggiore velocit\u00e0 di esecuzione Controllo sintattico e semantico Compile time nullo o ridotto Maggiore portabilit\u00e0 tra architettura Possibilit\u00e0 di debug con granularit\u00e0 a livello di singola istruzione Svantaggi Minore portabilit\u00e0 tra architetture Debug complesso da effettuare Minore velocit\u00e0 di esecuzione Performance non ottimizzate Possibili errori imprevisti a run time","title":"Compilatore vs. Interprete"},{"location":"02_dispense/03_linguaggi/02_traduttori/#linguaggi-compilati-e-linguaggi-interpretati","text":"Per linguaggio compilato si intende un linguaggio di programmazione le cui implementazioni sono tipicamente compilate ; di converso, un linguaggio interpretato prevede l'uso estensivo di interpeti. La distinzione \u00e8 per\u00f2 alquanto vaga. Infatti, almeno in linea di principio, qualunque linguaggio pu\u00f2 essere implementato indifferentemente mediante un compilatore od un itnerprete. E' anche possibile combinare entrambe le soluzioni: un compilatore pu\u00f2 ad esempio occuparsi della traduzione del codice sorgente nella rappresentazione intermedia, chiamata in questi casi bytecode , che viene passata ad un interprete che la esegue. E' questo ad esempio il caso di Java, che utilizza questo tipo di soluzione per passare il bytecode alla Java Virtual Machine , di cui esiste un'implementazione per la maggior parte delle architetture esistenti.","title":"Linguaggi compilati e linguaggi interpretati"},{"location":"02_dispense/04_programmazione/01_strutturata/","text":"Dal GOTO alla Programmazione Strutturata \u00b6 Il teorema di Bohm-Jacopini \u00b6 TODO: RIVEDERE Il teorema di Bohm-Jacopini dice che: orema di B\u00f6hm-Jacopini, enunciato nel 1966[1] dagli informatici Corrado B\u00f6hm e Giuseppe Jacopini, \u00e8 un teorema di informatica teorica il quale afferma che qualunque algoritmo pu\u00f2 essere implementato in fase di programmazione (in diagramma di flusso, pseudocodice o codice sorgente) utilizzando tre sole strutture dette strutture di controllo: la sequenza, la selezione ed il ciclo (iterazione), da applicare ricorsivamente alla composizione di istruzioni elementari (ad esempio, istruzioni eseguibili con il modello di base della macchina di Turing). Le implicazioni sono ovviamente importanti. Questo teorema ha un interesse anche teorico, in quanto i linguaggi di programmazione tendono a dotarsi di pi\u00f9 tipi di istruzioni di larga portata per evitare che i programmatori debbano occuparsi di istruzioni di portata molto minuta e quindi dispersive per quanto attiene alla padronanza delle finalit\u00e0 dell'algoritmo (esistono per\u00f2 linguaggi minimalisti, come Brainfuck, che si attengono alla lettera al teorema). Il suo valore va visto nella sua capacit\u00e0 di fornire indicazioni generali per le attivit\u00e0 di progettazione di nuovi linguaggi e di strategie di programmazione. In effetti, esso ha contribuito alla critica dell'uso sconsiderato delle istruzioni go to e alla definizione delle linee guida della programmazione strutturata che si sono avuti intorno al 1970. I diagrammi di flusso sono delle rappresentazioni grafiche del flusso di esecuzione di un algoritmo imperativo. Flussi \u00b6 Analizziamo adesso tre diversi tipi di flusso dati, ovvero la sequenza , la selezione ed il ciclo . Sequenza \u00b6 Il concetto di sequenza prevede una serie di istruzioni che siano realizzate l'una in cascata all'altra. Ad esempio, nel montaggio di un mobile IKEA, abbiamo normalmente una sequenza di istruzioni che portano al collegamento in maniera (sperabilmente) univoca dei vari pezzi tra loro. Per comprendere al meglio il concetto di sequenza, immaginiamo la seguente funzione (in Python). def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Valutazione della differenza tra punto_a_x e punto_b_x 3 > Valutazione del quadrato della differenza calcolata al punto 2 4 > Valutazione della differenza tra punto_a_y e punto_b_y 5 > Valutazione del quadrato della differenza calcolata al punto 4 6 > Estrazione della radice quadrata del valore calcolato al punto 5 Graficamente: TODO: rappresentare Selezione \u00b6 La selezione prevede invece la scelta tra due istruzioni che possono essere realizzate in maniera mutualmente esclusiva. Questo si traduce nella struttura IF - THEN - ELSE, che pu\u00f2 essere riassunta in linguaggio naturale come: Cite IF una data condizione \u00e8 verificata THEN esegui queste istruzioni ELSE esegui queste altre istruzioni. Immaginiamo ad esempio di inserire dei controlli alla precedente istruzione per verificare che i punti di cui vogliamo calcolare la distanza non coincidano. def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): if ( punto_a_x == punto_b_x and punto_a_y == punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 else : distanza = 0.0 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Se le coordinate di a e di b coincidono... 3a > ...valutazione della differenza tra punto_a_x e punto_b_x 4a > Valutazione del quadrato della differenza calcolata al punto 2 5a > Valutazione della differenza tra punto_a_y e punto_b_y 6a > Valutazione del quadrato della differenza calcolata al punto 4 7a > Estrazione della radice quadrata del valore calcolato al punto 5 ...altrimenti... 3b > Assegna a distanza il valore 0.0 8 > Restituisci il valore di distanza Graficamente: TODO: rappresentare Istruzione switch \u00b6 TODO: ricordare che lo switch non \u00e8 sempre presente in tutti i linguaggi TODO: perch\u00e9 switch e non struttura gerarchica di IF Ciclo \u00b6 L'ultimo tipo di struttura di controllo che esiste \u00e8 il ciclo , o iterazione . Anche comprendere come si strutturi l'iterazione \u00e8 intuitivo: in particolare, il ciclo prevede che siano reiterate pi\u00f9 volte una o pi\u00f9 istruzioni, fino a che non sia verificata una condizione. Istruzione For \u00b6 Istruzione While \u00b6","title":"01 strutturata"},{"location":"02_dispense/04_programmazione/01_strutturata/#dal-goto-alla-programmazione-strutturata","text":"","title":"Dal GOTO alla Programmazione Strutturata"},{"location":"02_dispense/04_programmazione/01_strutturata/#il-teorema-di-bohm-jacopini","text":"TODO: RIVEDERE Il teorema di Bohm-Jacopini dice che: orema di B\u00f6hm-Jacopini, enunciato nel 1966[1] dagli informatici Corrado B\u00f6hm e Giuseppe Jacopini, \u00e8 un teorema di informatica teorica il quale afferma che qualunque algoritmo pu\u00f2 essere implementato in fase di programmazione (in diagramma di flusso, pseudocodice o codice sorgente) utilizzando tre sole strutture dette strutture di controllo: la sequenza, la selezione ed il ciclo (iterazione), da applicare ricorsivamente alla composizione di istruzioni elementari (ad esempio, istruzioni eseguibili con il modello di base della macchina di Turing). Le implicazioni sono ovviamente importanti. Questo teorema ha un interesse anche teorico, in quanto i linguaggi di programmazione tendono a dotarsi di pi\u00f9 tipi di istruzioni di larga portata per evitare che i programmatori debbano occuparsi di istruzioni di portata molto minuta e quindi dispersive per quanto attiene alla padronanza delle finalit\u00e0 dell'algoritmo (esistono per\u00f2 linguaggi minimalisti, come Brainfuck, che si attengono alla lettera al teorema). Il suo valore va visto nella sua capacit\u00e0 di fornire indicazioni generali per le attivit\u00e0 di progettazione di nuovi linguaggi e di strategie di programmazione. In effetti, esso ha contribuito alla critica dell'uso sconsiderato delle istruzioni go to e alla definizione delle linee guida della programmazione strutturata che si sono avuti intorno al 1970. I diagrammi di flusso sono delle rappresentazioni grafiche del flusso di esecuzione di un algoritmo imperativo.","title":"Il teorema di Bohm-Jacopini"},{"location":"02_dispense/04_programmazione/01_strutturata/#flussi","text":"Analizziamo adesso tre diversi tipi di flusso dati, ovvero la sequenza , la selezione ed il ciclo .","title":"Flussi"},{"location":"02_dispense/04_programmazione/01_strutturata/#sequenza","text":"Il concetto di sequenza prevede una serie di istruzioni che siano realizzate l'una in cascata all'altra. Ad esempio, nel montaggio di un mobile IKEA, abbiamo normalmente una sequenza di istruzioni che portano al collegamento in maniera (sperabilmente) univoca dei vari pezzi tra loro. Per comprendere al meglio il concetto di sequenza, immaginiamo la seguente funzione (in Python). def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Valutazione della differenza tra punto_a_x e punto_b_x 3 > Valutazione del quadrato della differenza calcolata al punto 2 4 > Valutazione della differenza tra punto_a_y e punto_b_y 5 > Valutazione del quadrato della differenza calcolata al punto 4 6 > Estrazione della radice quadrata del valore calcolato al punto 5 Graficamente: TODO: rappresentare","title":"Sequenza"},{"location":"02_dispense/04_programmazione/01_strutturata/#selezione","text":"La selezione prevede invece la scelta tra due istruzioni che possono essere realizzate in maniera mutualmente esclusiva. Questo si traduce nella struttura IF - THEN - ELSE, che pu\u00f2 essere riassunta in linguaggio naturale come: Cite IF una data condizione \u00e8 verificata THEN esegui queste istruzioni ELSE esegui queste altre istruzioni. Immaginiamo ad esempio di inserire dei controlli alla precedente istruzione per verificare che i punti di cui vogliamo calcolare la distanza non coincidano. def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): if ( punto_a_x == punto_b_x and punto_a_y == punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 else : distanza = 0.0 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Se le coordinate di a e di b coincidono... 3a > ...valutazione della differenza tra punto_a_x e punto_b_x 4a > Valutazione del quadrato della differenza calcolata al punto 2 5a > Valutazione della differenza tra punto_a_y e punto_b_y 6a > Valutazione del quadrato della differenza calcolata al punto 4 7a > Estrazione della radice quadrata del valore calcolato al punto 5 ...altrimenti... 3b > Assegna a distanza il valore 0.0 8 > Restituisci il valore di distanza Graficamente: TODO: rappresentare","title":"Selezione"},{"location":"02_dispense/04_programmazione/01_strutturata/#istruzione-switch","text":"TODO: ricordare che lo switch non \u00e8 sempre presente in tutti i linguaggi TODO: perch\u00e9 switch e non struttura gerarchica di IF","title":"Istruzione switch"},{"location":"02_dispense/04_programmazione/01_strutturata/#ciclo","text":"L'ultimo tipo di struttura di controllo che esiste \u00e8 il ciclo , o iterazione . Anche comprendere come si strutturi l'iterazione \u00e8 intuitivo: in particolare, il ciclo prevede che siano reiterate pi\u00f9 volte una o pi\u00f9 istruzioni, fino a che non sia verificata una condizione.","title":"Ciclo"},{"location":"02_dispense/04_programmazione/01_strutturata/#istruzione-for","text":"","title":"Istruzione For"},{"location":"02_dispense/04_programmazione/01_strutturata/#istruzione-while","text":"","title":"Istruzione While"},{"location":"02_dispense/04_programmazione/02_ricorsione/","text":"La ricorsione \u00e8 una tecnica che permette di progettare un algoritmo per risolvere un problema risolvendo delle istanze pi\u00f9 piccole dello stesso, fino a quando il problema non \u00e8 cos\u00ec piccolo che possiamo risolverlo direttamente. Per il primo esempio, vediamo come calcolare la funzione fatoriale. Indichiamo il fattoriale di \\(n\\) con \\(n!\\) . Il fattoriale \u00e8 definito come il prodotto degli interi che vanno da \\(1\\) ad \\(n\\) . Ad esempio, \\(5!\\) \u00e8 pari a \\(1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5\\) , ovvero \\(120\\) . Ci si potrebbe chiedere perch\u00e9 ci dovrebbe interessare la funzione fattoriale. E' molto utile per quando stiamo provando a contare quanti diversi modi di combinare diverse cose ci sono. Immaginiamo ad esempio di dover combinare \\(n\\) cose. Abbiamo \\(n\\) modi di disporre la prima cosa. Per la seconda, ce ne rimangono \\(n-1\\) ; combinandoli, abbiamo che i modi possibili per disporre le due cose sono \\(n \\cdot (n - 1)\\) . Ovvaimente, il concetto pu\u00f2 essere espanso, ed avremo che alla fine il modo di disporrre le \\(n\\) cose sar\u00e0 pari ad \\(n \\cdot (n - 1) \\cdot (n - 2) \\cdot ... \\cdot 2 \\cdot 1\\) . Il fattoriale \u00e8 definito per tutti gli interi positivi, assieme allo 0, con \\(0! = 1\\) . Calcolare il fattoriale in maniera iterativa \u00b6 Calcolare il fattoriale in maniera iterativa \u00e8 molto semplice. Infatti: STEP 1 -> RES = 1; STEP 2 -> FOR I = 1; I <= N; I++ RES = RES * I; STEP 3 -> RETURN N_FATT; L'implementazione \u00e8 in realt\u00e0 abbastanza semplice: si tratta, nella pratica, di fare una serie di moltiplicazioni: \\[ n! = n \\cdot (n - 1) \\ldot 2 \\cdot 1 \\] Notiamo per\u00f2 che \\((n - 1) ! = (n - 1) \\ldot 2 \\cdot 1\\) , per cui possiamo scrivere che: \\[ n! = n \\cdot (n - 1)! \\] In questa situazione, \\((n - 1)!\\) diventa un sottoproblema che dobbiamo risolvere per calcolare \\(n!\\) . Ad esempio: \\[ 5! = 5 * 4! \\] Estendendo il concetto, e minimizzando le dimensioni del sottoproblema, abbiamo che: \\[ 5! = 5 * 4! = 5 * 4 * 3! = 5 * 4 * 3 * 2! = 5 * 4 * 3 * 2 * 1! = 5 * 4 * 3 * 2 * 1 * 0! \\] Usando la propriet\u00e0 commutativa: \\[ \\begin{eqnarray} 0! * 1 &= 1 &= 1! &\\Rightarrow \\\\ 1! * 2 &= 2 &= 2! &!Rightarrow \\\\ 2! * 3 &= 2 &= 3! &!Rightarrow \\\\ 3! * 4 &= 2 &= 4! &!Rightarrow \\\\ 4! * 5 &= 2 &= 5! \\end{eqnarray} \\] Risulta che: nel caso n = 0, allora n! = 1 (caso base); nel caso n > 0, allora possiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\) Possiamo quindi rivedere la nostra funzione utilizzando un approccio ricorsivo . STEP 1 -> IF N = 0 return 1 ELSE return n * factorial(n - 1) Note \u00b6 Affinch\u00e9 un algoritmo ricorsivo funzioni, deve essere ricorsivamente condotto al caso base. Ad esempio, quando si calcola \\(n!\\) in maniera ricorsiva, il sottoproblema diventa sempre pi\u00f9 piccolo fino a che no si arriva al caso base. Usare algoritmi ricorsivi nel senso opposto potrebbe non portare mai a convergenza.","title":"02 ricorsione"},{"location":"02_dispense/04_programmazione/02_ricorsione/#calcolare-il-fattoriale-in-maniera-iterativa","text":"Calcolare il fattoriale in maniera iterativa \u00e8 molto semplice. Infatti: STEP 1 -> RES = 1; STEP 2 -> FOR I = 1; I <= N; I++ RES = RES * I; STEP 3 -> RETURN N_FATT; L'implementazione \u00e8 in realt\u00e0 abbastanza semplice: si tratta, nella pratica, di fare una serie di moltiplicazioni: \\[ n! = n \\cdot (n - 1) \\ldot 2 \\cdot 1 \\] Notiamo per\u00f2 che \\((n - 1) ! = (n - 1) \\ldot 2 \\cdot 1\\) , per cui possiamo scrivere che: \\[ n! = n \\cdot (n - 1)! \\] In questa situazione, \\((n - 1)!\\) diventa un sottoproblema che dobbiamo risolvere per calcolare \\(n!\\) . Ad esempio: \\[ 5! = 5 * 4! \\] Estendendo il concetto, e minimizzando le dimensioni del sottoproblema, abbiamo che: \\[ 5! = 5 * 4! = 5 * 4 * 3! = 5 * 4 * 3 * 2! = 5 * 4 * 3 * 2 * 1! = 5 * 4 * 3 * 2 * 1 * 0! \\] Usando la propriet\u00e0 commutativa: \\[ \\begin{eqnarray} 0! * 1 &= 1 &= 1! &\\Rightarrow \\\\ 1! * 2 &= 2 &= 2! &!Rightarrow \\\\ 2! * 3 &= 2 &= 3! &!Rightarrow \\\\ 3! * 4 &= 2 &= 4! &!Rightarrow \\\\ 4! * 5 &= 2 &= 5! \\end{eqnarray} \\] Risulta che: nel caso n = 0, allora n! = 1 (caso base); nel caso n > 0, allora possiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\) Possiamo quindi rivedere la nostra funzione utilizzando un approccio ricorsivo . STEP 1 -> IF N = 0 return 1 ELSE return n * factorial(n - 1)","title":"Calcolare il fattoriale in maniera iterativa"},{"location":"02_dispense/04_programmazione/02_ricorsione/#note","text":"Affinch\u00e9 un algoritmo ricorsivo funzioni, deve essere ricorsivamente condotto al caso base. Ad esempio, quando si calcola \\(n!\\) in maniera ricorsiva, il sottoproblema diventa sempre pi\u00f9 piccolo fino a che no si arriva al caso base. Usare algoritmi ricorsivi nel senso opposto potrebbe non portare mai a convergenza.","title":"Note"},{"location":"02_dispense/04_programmazione/03_variabili/","text":"Abbiamo gi\u00e0 accennato al concetto di variabile nella parte introduttiva del corso, dove lo abbiamo definito come dato di supporto . Questo suggerisce che una variabile non sia n\u00e9 un dato di ingresso al nostro programma, n\u00e9 un risultato atteso; \u00e8 piuttosto una rappresentazione dello stato interno dell'algoritmo ad un dato istante. E' facile osservare come le variabili siano di un'utilit\u00e0 estrema. Pensiamo ad esempio alla possibilit\u00e0 di inserire un contatore all'interno del nostro programma, che conti (ad esempio) il numero di operazioni eseguite, oppure ad una variabile di supporto, che ci permetta di modellare dei valori intermedi durante l'esecuzione di calcoli complessi. La variabile, come indica il nome stesso, pu\u00f2 variare durante l'esecuzione del programma. Ne esiste quindi una \"controparte\", assimilabile per\u00f2 dal punto di vista concettuale, chiamata costante : questa, ovviamente, non varia durante l'esecuzione del programma, ed \u00e8 utilizzata per caratterizzare (ad esempio) delle costanti matematiche come il \\(\\pi\\) . Nota sulle costanti Normalmente, le costanti matematiche sono gi\u00e0 caratterizzate all'interno del linguaggio di programmazione. Tuttavia, l'uso delle costanti deve essere valutato a seconda del programma, tenendo presente che la scelta tra variabile e costante \u00e8, molto spesso, soltanto da intendersi come aiuto al programmatore. Dichiarazione ed inizializzazione \u00b6 La procedura per poter utilizzare una variabile si articola in due step fondamentali. Il primo \u00e8 la dichiarazione della variabile, operazione mediante la quale il computer \"viene a conoscenza\" dell'esistenza della variabile, associandovi un identificatore (o nome ) ed un tipo (ci ritorneremo a breve). Per esempio, ecco come \u00e8 possibile dichiarare una variabile chiamata numero che rappresenta un numero intero in linguaggio C: int numero ; Una volta dichiarata la variabile, \u00e8 necessario associarle un valore. Per farlo, si usa la procedura di inizializzazione , sfruttando l'operatore di assegnamento = . Ad esempio, assegnamo alla variabile numero il valore 1 : numero = 1 ; E' possibile combinare le procedure di dichiarazione ed inizializzazione in un'unica istruzione: int altro_numero = 2 ; Tipo della variabile \u00b6 Per tipo della variabile si intende il formato associato alla stessa, che ne influenza di conseguenza i valori che questa pu\u00f2 rappresentare. I linguaggi di programmazione utilizzano quindi questo tipo di soluzione per differenziare (ad esempio) valori numerici di tipo intero da valori numerici di tipo reale, oppure ancora valori booleani da caratteri. Importanza del tipo \u00b6 Tenere in conto il tipo di dato durante lo sviluppo di un programma \u00e8 estremamente importante principalmente per due ragioni. 1. Flusso logico del programma \u00b6 La prima \u00e8 legata alla gestione del flusso logico del programma . Immaginiamo, infatti, di dover sommare due numeri reali x ed y , e di voler associare il valore risultante da questa operazione alla variabile z , che per\u00f2 \u00e8 di tipo intero: float x = 1.1 ; float y = 1.2 ; int z ; z = x + y ; E' facile comprendere come, nonostante il valore atteso di z sia pari a 2.3 , avremo in realt\u00e0 2 a causa del fatto che z \u00e8 un valore intero, con un errore di troncamento pari a 0.3 . Questo, ovviamente, nel caso in cui il programma venga comunque compilato: infatti, se il linguaggio impone un controllo stringente sul tipo di dato, \u00e8 probabile che la procedura di compilazione non vada a buon fine. Strani errori e come trovarli \u00b6 E' importante stare attenti a situazioni nelle quali si sommano degli interi a dei caratteri. Ricordiamo infatti che ogni carattere ha una rappresentazione numerica associata in un determinato formato; quindi, in un linguaggio \"particolarmente\" permissivo, potrebbe essere concesso sommare un intero ad un char , ottenendo per\u00f2 risultati inaspettati. Ad esempio, provando ad eseguire questa addizione: int x = 1 ; char y = '1' ; int z = x + y ; il valore di z ottenuto non sar\u00e0 pari a 2, ma a 50! 2. Quantit\u00e0 di memoria allocata per la variabile \u00b6 Il tipo di dato ha forti implicazioni sulla quantit\u00e0 di memoria utilizzata da ogni variabile, e quindi sul numero di valori che \u00e8 possibile rappresentare. La seguente tabella riporta queste associazioni per alcuni tipi di dato comunemente utilizzati. Denominazione Spazio occupato Descrizione short 16 bit Rappresenta un tipo di dato intero con precisione a 16 bit. int 32 bit Rappresenta un dato di tipo intero con segno. uint 32 bit Rappresenta un tipo di dato intero senza segno ( unsigned ) long 64 bit Rappresenta un tipo di dato intero con precisione a 64 bit. float 32 bit Rappresenta un tipo di dato reale con precisione a 32 bit. double 64 bit Rappresenta un tipo di dato reale con precisione a 64 bit. bool 1 bit Rappresenta un valore nell'algebra booleana (ovvero uno 0 o un 1 ). char 1 byte Rappresenta un singolo carattere. E' quindi importante scegliere il tipo di dato adatto alla specifica situazione. Se siamo sicuri, ad esempio, che tratteremo solo interi inferiori al 100, potremmo scegliere un formato di tipo short per risparmiare quanta pi\u00f9 memoria possibile. Cosa accadrebbe per\u00f2 se \"infrangessimo\" il limite massimo di valori degli short, ovvero \\(2^{16}\\) ? In questo caso, ovviamente, il tipo di dato (e quindi il quantitativo di memoria riservato per la variabile) non cambierebbe; ci\u00f2 significa che avremmo un errore di troncamento legato al fatto che ogni valore superiore a \\(2^{16}\\) (per la cronaca, 65.536) sarebbe approssimato (o meglio, troncato ) proprio a quest'ultimo. Tipizzazione forte e debole E' importante porre particolare attenzione alla tipizzazione offerta dal linguaggio in uso. In un linguaggio a tipizzazione forte, come il C, \u00e8 sempre necessario specificare il tipo della variabile, ed \u00e8 opportuno tenerne strettamente conto durante l'intero arco di esecuzione del programma. I linguaggi a tipizzazione debole, invece, come il Python, sono pi\u00f9 permissivi da questo punto di vista. Tuttavia, laddove scrivere un programma in un linguaggio a tipizzazione debole pu\u00f2 essere pi\u00f9 semplice, \u00e8 comunque facile ritrovarsi in situazioni inattese, in quanto al programmatore non verranno date indicazioni a priori sulla correttezza del flusso di esecuzione del programma.","title":"11 - Variabili"},{"location":"02_dispense/04_programmazione/03_variabili/#dichiarazione-ed-inizializzazione","text":"La procedura per poter utilizzare una variabile si articola in due step fondamentali. Il primo \u00e8 la dichiarazione della variabile, operazione mediante la quale il computer \"viene a conoscenza\" dell'esistenza della variabile, associandovi un identificatore (o nome ) ed un tipo (ci ritorneremo a breve). Per esempio, ecco come \u00e8 possibile dichiarare una variabile chiamata numero che rappresenta un numero intero in linguaggio C: int numero ; Una volta dichiarata la variabile, \u00e8 necessario associarle un valore. Per farlo, si usa la procedura di inizializzazione , sfruttando l'operatore di assegnamento = . Ad esempio, assegnamo alla variabile numero il valore 1 : numero = 1 ; E' possibile combinare le procedure di dichiarazione ed inizializzazione in un'unica istruzione: int altro_numero = 2 ;","title":"Dichiarazione ed inizializzazione"},{"location":"02_dispense/04_programmazione/03_variabili/#tipo-della-variabile","text":"Per tipo della variabile si intende il formato associato alla stessa, che ne influenza di conseguenza i valori che questa pu\u00f2 rappresentare. I linguaggi di programmazione utilizzano quindi questo tipo di soluzione per differenziare (ad esempio) valori numerici di tipo intero da valori numerici di tipo reale, oppure ancora valori booleani da caratteri.","title":"Tipo della variabile"},{"location":"02_dispense/04_programmazione/03_variabili/#importanza-del-tipo","text":"Tenere in conto il tipo di dato durante lo sviluppo di un programma \u00e8 estremamente importante principalmente per due ragioni.","title":"Importanza del tipo"},{"location":"02_dispense/04_programmazione/03_variabili/#1-flusso-logico-del-programma","text":"La prima \u00e8 legata alla gestione del flusso logico del programma . Immaginiamo, infatti, di dover sommare due numeri reali x ed y , e di voler associare il valore risultante da questa operazione alla variabile z , che per\u00f2 \u00e8 di tipo intero: float x = 1.1 ; float y = 1.2 ; int z ; z = x + y ; E' facile comprendere come, nonostante il valore atteso di z sia pari a 2.3 , avremo in realt\u00e0 2 a causa del fatto che z \u00e8 un valore intero, con un errore di troncamento pari a 0.3 . Questo, ovviamente, nel caso in cui il programma venga comunque compilato: infatti, se il linguaggio impone un controllo stringente sul tipo di dato, \u00e8 probabile che la procedura di compilazione non vada a buon fine.","title":"1. Flusso logico del programma"},{"location":"02_dispense/04_programmazione/03_variabili/#strani-errori-e-come-trovarli","text":"E' importante stare attenti a situazioni nelle quali si sommano degli interi a dei caratteri. Ricordiamo infatti che ogni carattere ha una rappresentazione numerica associata in un determinato formato; quindi, in un linguaggio \"particolarmente\" permissivo, potrebbe essere concesso sommare un intero ad un char , ottenendo per\u00f2 risultati inaspettati. Ad esempio, provando ad eseguire questa addizione: int x = 1 ; char y = '1' ; int z = x + y ; il valore di z ottenuto non sar\u00e0 pari a 2, ma a 50!","title":"Strani errori e come trovarli"},{"location":"02_dispense/04_programmazione/03_variabili/#2-quantita-di-memoria-allocata-per-la-variabile","text":"Il tipo di dato ha forti implicazioni sulla quantit\u00e0 di memoria utilizzata da ogni variabile, e quindi sul numero di valori che \u00e8 possibile rappresentare. La seguente tabella riporta queste associazioni per alcuni tipi di dato comunemente utilizzati. Denominazione Spazio occupato Descrizione short 16 bit Rappresenta un tipo di dato intero con precisione a 16 bit. int 32 bit Rappresenta un dato di tipo intero con segno. uint 32 bit Rappresenta un tipo di dato intero senza segno ( unsigned ) long 64 bit Rappresenta un tipo di dato intero con precisione a 64 bit. float 32 bit Rappresenta un tipo di dato reale con precisione a 32 bit. double 64 bit Rappresenta un tipo di dato reale con precisione a 64 bit. bool 1 bit Rappresenta un valore nell'algebra booleana (ovvero uno 0 o un 1 ). char 1 byte Rappresenta un singolo carattere. E' quindi importante scegliere il tipo di dato adatto alla specifica situazione. Se siamo sicuri, ad esempio, che tratteremo solo interi inferiori al 100, potremmo scegliere un formato di tipo short per risparmiare quanta pi\u00f9 memoria possibile. Cosa accadrebbe per\u00f2 se \"infrangessimo\" il limite massimo di valori degli short, ovvero \\(2^{16}\\) ? In questo caso, ovviamente, il tipo di dato (e quindi il quantitativo di memoria riservato per la variabile) non cambierebbe; ci\u00f2 significa che avremmo un errore di troncamento legato al fatto che ogni valore superiore a \\(2^{16}\\) (per la cronaca, 65.536) sarebbe approssimato (o meglio, troncato ) proprio a quest'ultimo. Tipizzazione forte e debole E' importante porre particolare attenzione alla tipizzazione offerta dal linguaggio in uso. In un linguaggio a tipizzazione forte, come il C, \u00e8 sempre necessario specificare il tipo della variabile, ed \u00e8 opportuno tenerne strettamente conto durante l'intero arco di esecuzione del programma. I linguaggi a tipizzazione debole, invece, come il Python, sono pi\u00f9 permissivi da questo punto di vista. Tuttavia, laddove scrivere un programma in un linguaggio a tipizzazione debole pu\u00f2 essere pi\u00f9 semplice, \u00e8 comunque facile ritrovarsi in situazioni inattese, in quanto al programmatore non verranno date indicazioni a priori sulla correttezza del flusso di esecuzione del programma.","title":"2. Quantit\u00e0 di memoria allocata per la variabile"},{"location":"02_dispense/04_programmazione/04_funzioni/","text":"La funzione , o metodo , \u00e8 un costrutto che permette di raggruppare una serie di istruzioni che sono eseguite pi\u00f9 volte all'interno del nostro programma. Una funzione \u00e8 articolata in due parti: una firma ed un corpo . La firma della funzione \u00e8 dove sono definiti: nome della funzione (ovvero un identificativo utile a richiamarla in altre parti del programma); tipo di ritorno , ovvero il tipo del valore in output alla funzione; parametri di ingresso , ovvero il tipo ed i nomi dei valori che saranno mandati in input alla funzione. Nel corpo sono invece definite le istruzioni vere e proprie, oltre che il valore restituito dalla funzione (che, ovviamente, deve essere del tipo specificato in firma.) Ad esempio: // Questa \u00e8 la firma! tipo_ritorno nome_funzione ( tipo_par_1 par_1 , tipo_par_2 par_2 ) { // Questo \u00e8 il corpo istr_1 ; istr_2 ; tipo_ritorno valore_ritorno = istr_3 ; return valore_ritorno ; } E' importante sottolineare come il tipo di ritorno ed i tipi dei parametri in ingresso possono essere omessi in caso di linguaggio non fortemente tipizzato. Molti linguaggi specificano inoltre dei modificatori di accesso alla funzione; ne parleremo in seguito, quando introdurremo la programmazione orientata agli oggetti. Riutilizzo del codice \u00b6 Il principio alla base dello sviluppo delle funzioni \u00e8 quello secondo il quale vogliamo minimizzare il quantitativo di codice scritto. Meno codice, infatti, significa meno possibilit\u00e0 di refusi, che in linguaggi dalla grammatica \"rigida\" come quello per i computer possono anche significare l'impossibilit\u00e0 di eseguire il programma. Inoltre, una funzione pu\u00f2 essere intesa, molto alla lontana, come un teorema matematico: ad esempio, le relazioni definite dal teorema di Pitagora valgono indipendentemente dai valori dei cateti e dell'ipotenusa. Ci\u00f2 ci permette quindi di avere un insieme di istruzioni fisse e controllabili , che possiamo manipolare e verificare a piacimento, conservando la coerenza del nostro programma: saremo infatti sicuri che il comportamento di una funzione sar\u00e0 replicato alla stessa maniera ogni volta che la chiameremo , indipendentemente dal programma considerato. Facciamo un esempio. def ipotenusa ( c_1 , c_2 ): c_1_quad = c_1 ** 2 c_2_quad = c_2 ** 2 i = ( c_1_quad + c_2_quad ) ** 1 / 2 return i # Questo \u00e8 il nostro programma if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d ) Se non avessimo utilizzato la funzione ipotenusa, avremmo dovuto scrivere due volte la formula per il calcolo dell'ipotenusa, con il rischio di sbagliare una volta, o comunque scrivere due metodi di calcolo differenti. La stessa funzione in C L'esempio precedente \u00e8 scritto in Python, linguaggio non fortemente tipizzato. In C la funzione sarebbe int ipotenusa ( int c_1 , int c_2 ) { int c_1_quad = c_1 * c_1 ; int c_2_quad = c_2 * c_2 ; int c_quad_sum = c_1_quad + c_2_quad ; int i = sqrt ( c_quad_sum ); return i ; } Modularit\u00e0 \u00b6 Le funzioni permettono anche di scrivere del codice modulare . Ci\u00f2 significa che ogni funzione asserve ad un determinato scopo, ed il nostro programma pu\u00f2 \"comporsi\" a partire da diversi metodi, cambiando i quali se ne cambiano anche scopi e finalit\u00e0. Ad esempio, se si dovesse in futuro scoprire una nuova formulazione per il teorema di Pitagora, non dovremmo cambiare tutto il nostro programma, ma basterebbe modificare esclusivamente la funzione che implementa il teorema di Pitagora: def ipotenusa ( c_1 , c_2 ): i = ( c_1 + c_2 ) return i # Il programma non cambia! if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d )","title":"12 - Funzioni"},{"location":"02_dispense/04_programmazione/04_funzioni/#riutilizzo-del-codice","text":"Il principio alla base dello sviluppo delle funzioni \u00e8 quello secondo il quale vogliamo minimizzare il quantitativo di codice scritto. Meno codice, infatti, significa meno possibilit\u00e0 di refusi, che in linguaggi dalla grammatica \"rigida\" come quello per i computer possono anche significare l'impossibilit\u00e0 di eseguire il programma. Inoltre, una funzione pu\u00f2 essere intesa, molto alla lontana, come un teorema matematico: ad esempio, le relazioni definite dal teorema di Pitagora valgono indipendentemente dai valori dei cateti e dell'ipotenusa. Ci\u00f2 ci permette quindi di avere un insieme di istruzioni fisse e controllabili , che possiamo manipolare e verificare a piacimento, conservando la coerenza del nostro programma: saremo infatti sicuri che il comportamento di una funzione sar\u00e0 replicato alla stessa maniera ogni volta che la chiameremo , indipendentemente dal programma considerato. Facciamo un esempio. def ipotenusa ( c_1 , c_2 ): c_1_quad = c_1 ** 2 c_2_quad = c_2 ** 2 i = ( c_1_quad + c_2_quad ) ** 1 / 2 return i # Questo \u00e8 il nostro programma if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d ) Se non avessimo utilizzato la funzione ipotenusa, avremmo dovuto scrivere due volte la formula per il calcolo dell'ipotenusa, con il rischio di sbagliare una volta, o comunque scrivere due metodi di calcolo differenti. La stessa funzione in C L'esempio precedente \u00e8 scritto in Python, linguaggio non fortemente tipizzato. In C la funzione sarebbe int ipotenusa ( int c_1 , int c_2 ) { int c_1_quad = c_1 * c_1 ; int c_2_quad = c_2 * c_2 ; int c_quad_sum = c_1_quad + c_2_quad ; int i = sqrt ( c_quad_sum ); return i ; }","title":"Riutilizzo del codice"},{"location":"02_dispense/04_programmazione/04_funzioni/#modularita","text":"Le funzioni permettono anche di scrivere del codice modulare . Ci\u00f2 significa che ogni funzione asserve ad un determinato scopo, ed il nostro programma pu\u00f2 \"comporsi\" a partire da diversi metodi, cambiando i quali se ne cambiano anche scopi e finalit\u00e0. Ad esempio, se si dovesse in futuro scoprire una nuova formulazione per il teorema di Pitagora, non dovremmo cambiare tutto il nostro programma, ma basterebbe modificare esclusivamente la funzione che implementa il teorema di Pitagora: def ipotenusa ( c_1 , c_2 ): i = ( c_1 + c_2 ) return i # Il programma non cambia! if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d )","title":"Modularit\u00e0"},{"location":"02_dispense/04_programmazione/05_complessita/","text":"Analisi degli algoritmi \u00b6 L'analisi delle performance di un algoritmo pu\u00f2 essere effettuata in due diverse fasi, ovvero prima ( analisi a priori ) e dopo ( analisi a posteriori ) l'implementazione. Analisi a priori \u00b6 L' analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato, o la quantit\u00e0 di memoria disponibile (RAM, cache e registri), siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso. Nota Ovviamente, sta al lettore comprendere il contesto legato alle premesse dell'analisi a priori. Ci\u00f2 significa che \u00e8 fortemente sconsigliato provare ad eseguire un algoritmo che ha difficolt\u00e0 a girare su una GeForce 3090 su un Raspberry Pi 2, indipendentemente dalle considerazioni derivanti dall'analisi a priori. Analisi a posteriori \u00b6 L' analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata. Importanza del contesto Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore, che rappresentano spesso il vero e proprio collo di bottiglia. Statistica ed analisi E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti. Ad ogni modo, che si parli di analisi a priori od a posteriori, questa procedura \u00e8 necessaria per valutare la complessit\u00e0 dell'algoritmo. Complessit\u00e0 degli algoritmi \u00b6 Supponiamo che un algoritmo \\(X\\) abbia un insieme di dati in ingresso di cardinalit\u00e0 \\(N\\) . La complessit\u00e0 dell'algoritmo \u00e8 strettamente correlata a due fattori, ovvero il tempo richiesto per l'esecuzione dell'algoritmo e lo spazio occupato da questo in memoria. In particolare, la complessit\u00e0 temporale \u00e8 determinata contando il numero di operazioni effettuate. Per esempio, negli algoritmi di ordinamento, il fattore temporale \u00e8 direttamente proporzionale al numero di confronti tra gli elementi che saranno ordinati. La complessit\u00e0 spaziale \u00e8 invece determinata valutando lo spazio massimo richiesto dall'algoritmo in termini di memoria occupata. Iniziamo parlando proprio di quest'ultima. Complessit\u00e0 spaziale \u00b6 La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria dall'inizio alla fine della sua esecuzione. Questo \u00e8 pari alla somma di due componenti: una parte fissa, pari allo spazio richiesto per la memorizzazione di dati \"fissi\", come funzioni e costanti, che non variano a seconda del problema; una parte variabile, data dallo spazio richiesto per la memorizzazione (appunto) delle variabili, la cui dimensione \u00e8 dipendente dal problema stesso. Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(S(X)\\) di un algoritmo \\(X\\) come: \\[ S(X) = S_F + S_V(C) \\] con \\(S_F\\) parte fissa ed \\(S_V\\) parte variabile e dipendente dalle caratteristiche \\(C\\) dell'algoritmo \\(X\\) . Nota Le caratteristiche \\(C\\) non coincidono con il numero di variabili in input per l'algoritmo \\(N\\) . Un esempio \u00b6 Consideriamo il seguente algoritmo (in pseudocodice): SUM_ONE(P, Q) Step 1 -> START Step 2 -> R = P + Q + 1 Step 3 -> STOP Analisi a priori \u00b6 Il numero di variabili in questo algoritmo \u00e8 pari a 3, ovvero P e Q (input) ed R (output). Abbiamo inoltre una costante (il valore 1 ). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a: \\[ S(X) = S_F + S_V(C) = 1 + 3 \\] Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria. Analisi a posteriori \u00b6 Supponiamo che l'effettiva implementazione dell'algoritmo sia in linguaggio C, e che il tipo di dato associato a ciascuna variabile sia un intero. La complessit\u00e0 spaziale (analizzata a posteriori) sar\u00e0 pari a: \\[ m_{int} = 32 bit \\Rightarrow S(X) = S_F + S_V(C) = 4 m_{int} = 128 bit \\] Complessit\u00e0 temporale \u00b6 Abbiamo visto come la complessit\u00e0 temporale di un algoritmo sia associata alla quantit\u00e0 di tempo richiesto dallo stesso per una sua completa esecuzione. Anche questa complessit\u00e0 pu\u00f2 essere espressa come una funzione numerica del tipo \\(T(I)\\) , con \\(I\\) numero di step necessari al completamento dell'istruzione. Un esempio \u00b6 Analisi a priori \u00b6 Torniamo al precedente algoritmo. In questo caso, abbiamo elencato tre step, anche se, nei fatti, ci sono solo due operazioni di cui tenere conto, ovvero due addizione. Quindi, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(T(I) = 2\\) . Analisi a posteriori \u00b6 Anche in questo caso, per effettuare l'analisi a posteriori avremo bisogno di fissare alcune condizioni. Supponiamo, ad esempio, che il nostro processore impieghi un microsecondo per eseguire una somma. Di conseguenza, la complessit\u00e0 temporale analizzata a posteriori sar\u00e0 pari a 2 microsecondi. Complessit\u00e0 di caso peggiore \u00b6 L'esempio che abbiamo visto \u00e8, al solito, estremamente semplice. In realt\u00e0, \u00e8 difficile che nella realt\u00e0 sia necessario calcolare la complessit\u00e0 computazionale di situazioni cos\u00ec poco articolate; \u00e8 pi\u00f9 facile avere un'idea abbastanza sommaria della complessit\u00e0 spaziale e temporale di un algoritmo, che va quindi stimata assumendo il caso peggiore , ovvero calcolando il numero massimo di operazioni e/o spazio che, nel peggiore dei casi, il nostro algoritmo dovrebbe dover effettuare e/o occupare. Per far questo, si utilizza la notazione O-grande , utilizzata spesso per descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. Detto in maniera meno formale: un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(T(n) = O(n^2)\\) avr\u00e0 un costo, in termini di tempo, pari al pi\u00f9 ad \\(n^2\\) ; un algoritmo con una complessit\u00e0 \\(T(n) = O(n * log(n))\\) \"coster\u00e0\" al massimo \\(n*log(n)\\) operazioni, e cos\u00ec via. Alcuni esempi \u00b6 Semplice ciclo for \u00b6 Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo for : int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \"%d\" , i ); i ++ ; } Notiamo innanzitutto che il valore del contatore i viene incrementato di due ad ogni iterazione. Ci\u00f2 significa che, al pi\u00f9 , saranno eseguite \\(n/2\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale sia nell'ordine di \\(O(n/2)\\) . Cicli for annidati \u00b6 Vediamo cosa accade nel caso si considerino due cicli for l'uno annidato all'interno dell'altro. int n = 10 ; for ( int i = 0 ; i < n 0 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { printf ( \"%d\" , i ); } } Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile i ) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile j ). La complessit\u00e0 di caso peggiore sar\u00e0 quindi \\(O(n^2)\\) .","title":"13 - Complessit\u00e0 computazionale"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-degli-algoritmi","text":"L'analisi delle performance di un algoritmo pu\u00f2 essere effettuata in due diverse fasi, ovvero prima ( analisi a priori ) e dopo ( analisi a posteriori ) l'implementazione.","title":"Analisi degli algoritmi"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-priori","text":"L' analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato, o la quantit\u00e0 di memoria disponibile (RAM, cache e registri), siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso. Nota Ovviamente, sta al lettore comprendere il contesto legato alle premesse dell'analisi a priori. Ci\u00f2 significa che \u00e8 fortemente sconsigliato provare ad eseguire un algoritmo che ha difficolt\u00e0 a girare su una GeForce 3090 su un Raspberry Pi 2, indipendentemente dalle considerazioni derivanti dall'analisi a priori.","title":"Analisi a priori"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-posteriori","text":"L' analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata. Importanza del contesto Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore, che rappresentano spesso il vero e proprio collo di bottiglia. Statistica ed analisi E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti. Ad ogni modo, che si parli di analisi a priori od a posteriori, questa procedura \u00e8 necessaria per valutare la complessit\u00e0 dell'algoritmo.","title":"Analisi a posteriori"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-degli-algoritmi","text":"Supponiamo che un algoritmo \\(X\\) abbia un insieme di dati in ingresso di cardinalit\u00e0 \\(N\\) . La complessit\u00e0 dell'algoritmo \u00e8 strettamente correlata a due fattori, ovvero il tempo richiesto per l'esecuzione dell'algoritmo e lo spazio occupato da questo in memoria. In particolare, la complessit\u00e0 temporale \u00e8 determinata contando il numero di operazioni effettuate. Per esempio, negli algoritmi di ordinamento, il fattore temporale \u00e8 direttamente proporzionale al numero di confronti tra gli elementi che saranno ordinati. La complessit\u00e0 spaziale \u00e8 invece determinata valutando lo spazio massimo richiesto dall'algoritmo in termini di memoria occupata. Iniziamo parlando proprio di quest'ultima.","title":"Complessit\u00e0 degli algoritmi"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-spaziale","text":"La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria dall'inizio alla fine della sua esecuzione. Questo \u00e8 pari alla somma di due componenti: una parte fissa, pari allo spazio richiesto per la memorizzazione di dati \"fissi\", come funzioni e costanti, che non variano a seconda del problema; una parte variabile, data dallo spazio richiesto per la memorizzazione (appunto) delle variabili, la cui dimensione \u00e8 dipendente dal problema stesso. Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(S(X)\\) di un algoritmo \\(X\\) come: \\[ S(X) = S_F + S_V(C) \\] con \\(S_F\\) parte fissa ed \\(S_V\\) parte variabile e dipendente dalle caratteristiche \\(C\\) dell'algoritmo \\(X\\) . Nota Le caratteristiche \\(C\\) non coincidono con il numero di variabili in input per l'algoritmo \\(N\\) .","title":"Complessit\u00e0 spaziale"},{"location":"02_dispense/04_programmazione/05_complessita/#un-esempio","text":"Consideriamo il seguente algoritmo (in pseudocodice): SUM_ONE(P, Q) Step 1 -> START Step 2 -> R = P + Q + 1 Step 3 -> STOP","title":"Un esempio"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-priori_1","text":"Il numero di variabili in questo algoritmo \u00e8 pari a 3, ovvero P e Q (input) ed R (output). Abbiamo inoltre una costante (il valore 1 ). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a: \\[ S(X) = S_F + S_V(C) = 1 + 3 \\] Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria.","title":"Analisi a priori"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-posteriori_1","text":"Supponiamo che l'effettiva implementazione dell'algoritmo sia in linguaggio C, e che il tipo di dato associato a ciascuna variabile sia un intero. La complessit\u00e0 spaziale (analizzata a posteriori) sar\u00e0 pari a: \\[ m_{int} = 32 bit \\Rightarrow S(X) = S_F + S_V(C) = 4 m_{int} = 128 bit \\]","title":"Analisi a posteriori"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-temporale","text":"Abbiamo visto come la complessit\u00e0 temporale di un algoritmo sia associata alla quantit\u00e0 di tempo richiesto dallo stesso per una sua completa esecuzione. Anche questa complessit\u00e0 pu\u00f2 essere espressa come una funzione numerica del tipo \\(T(I)\\) , con \\(I\\) numero di step necessari al completamento dell'istruzione.","title":"Complessit\u00e0 temporale"},{"location":"02_dispense/04_programmazione/05_complessita/#un-esempio_1","text":"","title":"Un esempio"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-priori_2","text":"Torniamo al precedente algoritmo. In questo caso, abbiamo elencato tre step, anche se, nei fatti, ci sono solo due operazioni di cui tenere conto, ovvero due addizione. Quindi, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(T(I) = 2\\) .","title":"Analisi a priori"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-posteriori_2","text":"Anche in questo caso, per effettuare l'analisi a posteriori avremo bisogno di fissare alcune condizioni. Supponiamo, ad esempio, che il nostro processore impieghi un microsecondo per eseguire una somma. Di conseguenza, la complessit\u00e0 temporale analizzata a posteriori sar\u00e0 pari a 2 microsecondi.","title":"Analisi a posteriori"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-di-caso-peggiore","text":"L'esempio che abbiamo visto \u00e8, al solito, estremamente semplice. In realt\u00e0, \u00e8 difficile che nella realt\u00e0 sia necessario calcolare la complessit\u00e0 computazionale di situazioni cos\u00ec poco articolate; \u00e8 pi\u00f9 facile avere un'idea abbastanza sommaria della complessit\u00e0 spaziale e temporale di un algoritmo, che va quindi stimata assumendo il caso peggiore , ovvero calcolando il numero massimo di operazioni e/o spazio che, nel peggiore dei casi, il nostro algoritmo dovrebbe dover effettuare e/o occupare. Per far questo, si utilizza la notazione O-grande , utilizzata spesso per descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. Detto in maniera meno formale: un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(T(n) = O(n^2)\\) avr\u00e0 un costo, in termini di tempo, pari al pi\u00f9 ad \\(n^2\\) ; un algoritmo con una complessit\u00e0 \\(T(n) = O(n * log(n))\\) \"coster\u00e0\" al massimo \\(n*log(n)\\) operazioni, e cos\u00ec via.","title":"Complessit\u00e0 di caso peggiore"},{"location":"02_dispense/04_programmazione/05_complessita/#alcuni-esempi","text":"","title":"Alcuni esempi"},{"location":"02_dispense/04_programmazione/05_complessita/#semplice-ciclo-for","text":"Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo for : int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \"%d\" , i ); i ++ ; } Notiamo innanzitutto che il valore del contatore i viene incrementato di due ad ogni iterazione. Ci\u00f2 significa che, al pi\u00f9 , saranno eseguite \\(n/2\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale sia nell'ordine di \\(O(n/2)\\) .","title":"Semplice ciclo for"},{"location":"02_dispense/04_programmazione/05_complessita/#cicli-for-annidati","text":"Vediamo cosa accade nel caso si considerino due cicli for l'uno annidato all'interno dell'altro. int n = 10 ; for ( int i = 0 ; i < n 0 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { printf ( \"%d\" , i ); } } Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile i ) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile j ). La complessit\u00e0 di caso peggiore sar\u00e0 quindi \\(O(n^2)\\) .","title":"Cicli for annidati"},{"location":"02_dispense/04_programmazione/06_strutture_dati/","text":"I linguaggi di programmazione sfruttano il cocnetto struttura dati per organizzare , gestire e memorizzare una serie di valori nella maniera pi\u00f9 efficiente psosibile. Le strutture dati non sono quindi altro che degli insiemi , o collezioni , di valori, che caratterizzano anche le relazioni intercorrenti tra essi, oltre che le operazioni che vi possono essere applicate. Esistono diverse tipologie di strutture dati, ognuna delle quali particolarmente adatta a determinati scopi. Vediamone alcune di seguito. Array \u00b6 Un array \u00e8 concettualmente riconducibile ad un vettore, inteso nel senso pi\u00f9 \"algebrico\" del termine. Un array contiene quindi un vettore (o, per estensione, una matrice) di elementi, tipicamente (ma, a seconda del linguaggio, non necessariamente ) dello stesso tipo, i quali sono organizzati seguendo un ordine specifico, esplorabile mediante il concetto di indice . Questo definisce la modalit\u00e0 di accesso ai dati di un array, che \u00e8 chiamata accesso diretto o casuale : in pratica, l'elemento viene estratto in maniera diretta, utilizzando l'indice, e di conseguenza l'operazione \u00e8 immediata (in termini di complessit\u00e0 computazionale, abbiamo un \\(O(1)\\) , ovvero un'unica operazione necessaria). Questo vantaggio ha per\u00f2 come contraltare la necessit\u00e0 di implementare una serie laboriosa di operazioni di accesso alla memoria nel caso si voglia inserire o rimuovere un elemento nell'array. Una tipica rappresentazione di un array \u00e8 la seguente: [8, 5, 12, 7, 4] In particolare, il precedente array \u00e8 composto esclusivamente da elementi di tipo intero, ed ha lunghezza pari a 5 ; da notare che l'indice del primo elemento (in questo caso, il valore 3 ) non \u00e8 quasi mai pari ad 1 : nella maggior parte dei linguaggi di programmazione, infatti, l'indicizzazione parte da 0 e termina ad un valore n - 1 , con n lunghezza dell'array. Nel caso precedente: Liste \u00b6 Una lista (conosciuta anche come linked list ) \u00e8 una struttura dati simile agli array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento a quello successivo. Vediamo un esempio nella seguente figura: Dall'immagine precedente, vediamo che: il primo elemento nella lista ha valore 5 , e conserva un riferimento all'elemento successivo R3 ; il secondo elemento nella lista ha valore 3 , e conserva un riferimento all'elemento successivo R2 ; ci\u00f2 prosegue sino all'elemento 7 , che conserva un riferimento all'ultimo elemento R12 . Questa particolarit\u00e0 della lista rispetto all'array ha due effetti. Il primo consiste nel fatto che la lista \u00e8 una struttura ad accesso sequenziale ; in parole povere, occorrer\u00e0 \"scorrere\" tutti gli elementi della lista fino ad arrivare a quello desiderato. In molti linguaggi di programmazione, esistono appositi costrutti per compiere questa operazione chiamati iteratori . La seconda conseguenza sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o riumuovere un elemento alla lista, specie se comparato con l'array: baster\u00e0 infatti manipolare opportunamente i riferimenti agli elementi successivi della lista. Struct \u00b6 Una struct (conosciuta anche come tupla ) \u00e8 una struttura dati che contiene a sua volta un insieme di valori chiamati membri o campi . In una struct, il numero, la sequenza ed il tipo dei campi sono solitamente fissi. Ecco un esempio di struct che ci permette di rappresentare una persona: struct persona { char nome [ 16 ]; char cognome [ 32 ]; int eta ; } ettore ; La struct precedente ci permetter\u00e0 quindi di definire la variabile ettore con nome, cognome ed et\u00e0. Union \u00b6 Una union \u00e8 una struttura dati che specifica il tipo del valore che pu\u00f2 essere memorizzato tra un certo numero di tipi primitivi. Nonostante sia sintatticamente simile alla struct, ne differisce semanticamente e funzionalmente , in quanto ammette la presenza di un unico valore per volta (che per\u00f2 pu\u00f2 essere di tipo di volta in volta differente). Ad esempio: union lettura_sensore { int lettura_intera ; float lettura_reale ; } lettura ; Analogamente alla struct, potremo definire la variabile lettura come valore intero o reale. Pile e code \u00b6 Abbiamo visto che gli array sono strutture ad accesso casuale, mentre le liste sono ad accesso sequenziale. Esiste un altro tipo di accesso ai dati presenti in una struttura, detto accesso limitato , che viene usato da alcune strutture dati come pile e code . Scopriamolo insieme. Pile \u00b6 Una pila (o stack ) \u00e8 un contenitore di oggetti che possono essere inseriti o rimossi seguendo il principio LIFO ( Last-In, First-Out ). In parole povere, questo significa che l'ultimo elemento che accede alla pila \u00e8 anche il primo ad uscirne . Lo stack prevede due diverse operazioni: la prima \u00e8 quella di push , ovvero di inserimento di un oggetto all'interno dello stack, mentre la seconda \u00e8 quella di pop , ovvero di estrazione di un elemento dallo stack. Il fatto che l'accesso sia limitato \u00e8 dovuto proprio ad una limitazione a queste due operazioni: in particolare, sia il push, sia il pop, possono essere effettuati soltanto sugli elementi in cima alla pila. Quindi: Operazione di push L'operazione di push permette di inserire un oggetto in cima ad uno stack. Operazione di pop L'operazione di pop permette di estrarre l'oggetto attualmente in cima allo stack. Notiamo anche che lo stack \u00e8 una struttura dati di tipo ricorsivo: infatti, \u00e8 facile dimostrare che uno stack non vuoto \u00e8 in realt\u00e0 composto da un elemento in cima ( top ) ad un altro stack. Pila come array \u00b6 Per implementare una pila sotto forma di array, abbiamo bisogno dei seguenti elementi: un array di lunghezza superiore ad uno ( stack ); una variabile che caratterizza l'elemento in cima all'array ( top ); una variabile che si riferisce alla lunghezza dell'array ( capacity ). Lo stack \u00e8 pieno quando top \u00e8 pari a capacity - 1 ; invece, \u00e8 vuoto quando top \u00e8 pari a -1 . Questi principi sono riassunti nella figura successiva: E' importante notare che possiamo avere due tipi di implementazione: una in cui la dimensione dell'array \u00e8 fissa, ed una in cui la dimensione dell'array varia in maniera dinamica. Nella prima, ovviamente, quando il top \u00e8 pari a capacity si genera un errore; ci\u00f2 non avviene nel secondo caso. L'operazione di push prevede quindi che sia inserito un nuovo elemento all'indice top dell'array; di converso, l'operazione di pop prevede che tale elemento sia rimosso. In etrambi i casi, \u00e8 importante aggiornare il valore di top . push(array, top, capacity, element) STEP 1 -> top = top + 1; STEP 2 -> if (top >= capacity) return ERROR; STEP 3 -> array[top] = element; pop(array, top) STEP 1 -> element = array[top]; STEP 2 -> top = top - 1; STEP 3 -> return element; Code \u00b6 Una coda ( queue ) \u00e8 un contenitore di oggetti che sono inseriti o rimossi secondo il principio FIFO ( first-in, first-out ). Concettualmente, \u00e8 quella che siamo abituati a vedere negli Uffici Postali, ad esempio: il primo arrivato sar\u00e0 il primo ad essere servito (e, di conseguenza, rimosso dalla coda ). Definiremo quindi una funzione enqueue per mettere in coda un nuovo elemento, e dequeue per togliere dalla coda l'elemento presente da pi\u00f9 tempo. La differenza fondamentale rispetto agli stack sta nella rimozione degli oggetti: in uno stack, rimuoviamo l'oggetti che abbiamo aggiunto pi\u00f9 di recente, mentre in una coda rimuoviamo quello che abbiamo aggiunto meno di recente. Esempio di implementazione come array \u00b6 Nel caso volessimo implementare una coda come array, dovremmo definire almeno i metodi enqueue e dequeue . In particolare, la procedura di enqueue prevede che sia posto come primo membro dell'array proprio l'elemento che si vuole aggiungere. Per farlo, potremmo ad esempio salvare l'array in una variabile temporanea, e concatenarlo all'elemento che entra in coda. enqueue(array, element) STEP 1 -> temp_array = array; STEP 2 -> new_array = concatenate(element, temp_array); STEP 3 -> return new_array; La procedura di dequeue di converso comporta la semplice rimozione dell'ultimo elemento nell'array. dequeue(array) STEP 1 -> element = array[length(array) - 1] STEP 2 -> new_array = remove_last(array) STEP 3 -> return new_array, element Grafi \u00b6 Ecco un modo per rappresentare una rete sociale: Le linee presenti tra i nomi di due persone indicano che queste si conoscono tra loro. Ovviamente, la conoscenza \u00e8 bidirezionale : dato che Alice conosce Bob, anche Bob conosce Alice. Questo modo di schematizzare una rete sociale \u00e8 conosciuto come grafo . Vertici ed archi \u00b6 Ciascun nodo \u00e8 noto come vertice , mentre ogni linea \u00e8 un arco che connette due vertici. L'insieme dei vertici \u00e8 dato da \\(V\\) , mentre quello degli archi \u00e8 dato da \\(E\\) . Il grafo \u00e8 quindi rappresentabile come una coppia \\(G=(V,E)\\) . Anche i nodi possono essere rappresentati a coppie: in particolare, due nodi \\(u\\) e \\(v\\) connessi da un arco sono una coppia \\((u, v)\\) . Grafo non diretto \u00b6 Abbiamo detto che le relazioni rappresentate nella nostra rete sociale sono bidirezionali: ci\u00f2 significa che non \u00e8 possibile individuare una \"direzione\" specifica nella relazione. Siamo quindi in presenza di un grafo non diretto . In un grafo non diretto, un arco \\((u, v)\\) equivale all'arco \\((v, u)\\) . Ciascun arco incide su entrambi i vertici, ed i vertici connessi da un arco sono adiacenti o vicini . Definiamo inoltre il numero di archi che incide su un vertice come grado dello stesso. Cammini e cicli \u00b6 Immaginiamo che Bob voglia conoscere Eric. non vi \u00e8 un arco che li collega; per\u00f2, Bob potrebbe chiedere ad Alice di presentargli David, che a sua volta potrebbe presentargli Eric. Esiste quindi un percorso , o cammino , composto da tre archi tra Bob ed Eric, e rappresenta il modo pi\u00f9 diretto per i due per incontrarsi. Chiamiamo un percorso del genere (ovvero il percorso con un numero minimo di archi) cammino minimo , o shortest path . Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo . Ad esempio, quello che va da Alice, passa per David, Eric e Charlie, e torna ad Alice, \u00e8 appunto un ciclo. Grafo pesato \u00b6 Alle volte, gli archi sono pesati , ovvero correlati da valori numerici. Ad esempio, potremmo rappresentare la distanza tra diverse citt\u00e0 come segue: Il termine generale per ognuno dei numeri che mettiamo su un lato \u00e8 peso , ed un grafo i cui archi hanno dei pesi \u00e8 un grafo pesato . In questo caso, volendo trovare il percorso minimo tra due posizioni, dovremo tenere contro del valore dei pesi. Ad esempio, per Andare da Bari a Napoli, occorrer\u00e0, nel nostro caso, passare da Roma e Milano (piuttosto che da Torino). Nota Il Docente si scusa per questa interpretazione poco realistica. Non seguite questa mappa, e risparmierete molte ore. Grafo diretto \u00b6 Cosa accade se inseriamo informazioni inerenti i sensi di marcia all'interno del grafo precedente? Otteniamo un grafo diretto . Le direzioni degli archi mostrano quali percorsi possono essere affrontati, e quali no. In questo caso, ad esempio, non potremo uscire da Bari, in quanto non ci saranno archi uscenti. Roma invece perde il suo status, in quanto si dimostra che non tutte le strade portano a Roma . Possiamo fare altre due osservazioni su questo grafo: il grafo non ha alcun ciclo, per cui siamo in presenza di un grafo aciclico diretto ; il grafo conserva i pesi, per cui siamo comunque in presenza di un grafo pesato. Per quello che riguarda infine il grado di ogni arco, abbiamo due termini da tenere in considerazione: il grado esterno , o out-degree , \u00e8 il numero di archi in uscita da un vertice; il grado interno , o in-degree , \u00e8 il numero di archi in ingresso in un vertice. Alberi \u00b6 Un albero \u00e8 una struttura dati, particolarmente usata in ambito informatico, che simula una struttura gerarchica, con un valore radice ed una serie di figli, rappresentata sotto forma di grafo non orientato , connesso ed aciclico . In particolare, il fatto che l'albero sia connesso indica che esiste almeno un cammino che connette tutti gli archi . Un particolare tipo di albero \u00e8 poi l' albero binario , nel quale ciascun nodo ha (al pi\u00f9) due figli. Un nodo terminale (ovvero uno in basso nella gerarchia) \u00e8 chiamato foglia .","title":"14 - Strutture dati"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#array","text":"Un array \u00e8 concettualmente riconducibile ad un vettore, inteso nel senso pi\u00f9 \"algebrico\" del termine. Un array contiene quindi un vettore (o, per estensione, una matrice) di elementi, tipicamente (ma, a seconda del linguaggio, non necessariamente ) dello stesso tipo, i quali sono organizzati seguendo un ordine specifico, esplorabile mediante il concetto di indice . Questo definisce la modalit\u00e0 di accesso ai dati di un array, che \u00e8 chiamata accesso diretto o casuale : in pratica, l'elemento viene estratto in maniera diretta, utilizzando l'indice, e di conseguenza l'operazione \u00e8 immediata (in termini di complessit\u00e0 computazionale, abbiamo un \\(O(1)\\) , ovvero un'unica operazione necessaria). Questo vantaggio ha per\u00f2 come contraltare la necessit\u00e0 di implementare una serie laboriosa di operazioni di accesso alla memoria nel caso si voglia inserire o rimuovere un elemento nell'array. Una tipica rappresentazione di un array \u00e8 la seguente: [8, 5, 12, 7, 4] In particolare, il precedente array \u00e8 composto esclusivamente da elementi di tipo intero, ed ha lunghezza pari a 5 ; da notare che l'indice del primo elemento (in questo caso, il valore 3 ) non \u00e8 quasi mai pari ad 1 : nella maggior parte dei linguaggi di programmazione, infatti, l'indicizzazione parte da 0 e termina ad un valore n - 1 , con n lunghezza dell'array. Nel caso precedente:","title":"Array"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#liste","text":"Una lista (conosciuta anche come linked list ) \u00e8 una struttura dati simile agli array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento a quello successivo. Vediamo un esempio nella seguente figura: Dall'immagine precedente, vediamo che: il primo elemento nella lista ha valore 5 , e conserva un riferimento all'elemento successivo R3 ; il secondo elemento nella lista ha valore 3 , e conserva un riferimento all'elemento successivo R2 ; ci\u00f2 prosegue sino all'elemento 7 , che conserva un riferimento all'ultimo elemento R12 . Questa particolarit\u00e0 della lista rispetto all'array ha due effetti. Il primo consiste nel fatto che la lista \u00e8 una struttura ad accesso sequenziale ; in parole povere, occorrer\u00e0 \"scorrere\" tutti gli elementi della lista fino ad arrivare a quello desiderato. In molti linguaggi di programmazione, esistono appositi costrutti per compiere questa operazione chiamati iteratori . La seconda conseguenza sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o riumuovere un elemento alla lista, specie se comparato con l'array: baster\u00e0 infatti manipolare opportunamente i riferimenti agli elementi successivi della lista.","title":"Liste"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#struct","text":"Una struct (conosciuta anche come tupla ) \u00e8 una struttura dati che contiene a sua volta un insieme di valori chiamati membri o campi . In una struct, il numero, la sequenza ed il tipo dei campi sono solitamente fissi. Ecco un esempio di struct che ci permette di rappresentare una persona: struct persona { char nome [ 16 ]; char cognome [ 32 ]; int eta ; } ettore ; La struct precedente ci permetter\u00e0 quindi di definire la variabile ettore con nome, cognome ed et\u00e0.","title":"Struct"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#union","text":"Una union \u00e8 una struttura dati che specifica il tipo del valore che pu\u00f2 essere memorizzato tra un certo numero di tipi primitivi. Nonostante sia sintatticamente simile alla struct, ne differisce semanticamente e funzionalmente , in quanto ammette la presenza di un unico valore per volta (che per\u00f2 pu\u00f2 essere di tipo di volta in volta differente). Ad esempio: union lettura_sensore { int lettura_intera ; float lettura_reale ; } lettura ; Analogamente alla struct, potremo definire la variabile lettura come valore intero o reale.","title":"Union"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#pile-e-code","text":"Abbiamo visto che gli array sono strutture ad accesso casuale, mentre le liste sono ad accesso sequenziale. Esiste un altro tipo di accesso ai dati presenti in una struttura, detto accesso limitato , che viene usato da alcune strutture dati come pile e code . Scopriamolo insieme.","title":"Pile e code"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#pile","text":"Una pila (o stack ) \u00e8 un contenitore di oggetti che possono essere inseriti o rimossi seguendo il principio LIFO ( Last-In, First-Out ). In parole povere, questo significa che l'ultimo elemento che accede alla pila \u00e8 anche il primo ad uscirne . Lo stack prevede due diverse operazioni: la prima \u00e8 quella di push , ovvero di inserimento di un oggetto all'interno dello stack, mentre la seconda \u00e8 quella di pop , ovvero di estrazione di un elemento dallo stack. Il fatto che l'accesso sia limitato \u00e8 dovuto proprio ad una limitazione a queste due operazioni: in particolare, sia il push, sia il pop, possono essere effettuati soltanto sugli elementi in cima alla pila. Quindi: Operazione di push L'operazione di push permette di inserire un oggetto in cima ad uno stack. Operazione di pop L'operazione di pop permette di estrarre l'oggetto attualmente in cima allo stack. Notiamo anche che lo stack \u00e8 una struttura dati di tipo ricorsivo: infatti, \u00e8 facile dimostrare che uno stack non vuoto \u00e8 in realt\u00e0 composto da un elemento in cima ( top ) ad un altro stack.","title":"Pile"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#pila-come-array","text":"Per implementare una pila sotto forma di array, abbiamo bisogno dei seguenti elementi: un array di lunghezza superiore ad uno ( stack ); una variabile che caratterizza l'elemento in cima all'array ( top ); una variabile che si riferisce alla lunghezza dell'array ( capacity ). Lo stack \u00e8 pieno quando top \u00e8 pari a capacity - 1 ; invece, \u00e8 vuoto quando top \u00e8 pari a -1 . Questi principi sono riassunti nella figura successiva: E' importante notare che possiamo avere due tipi di implementazione: una in cui la dimensione dell'array \u00e8 fissa, ed una in cui la dimensione dell'array varia in maniera dinamica. Nella prima, ovviamente, quando il top \u00e8 pari a capacity si genera un errore; ci\u00f2 non avviene nel secondo caso. L'operazione di push prevede quindi che sia inserito un nuovo elemento all'indice top dell'array; di converso, l'operazione di pop prevede che tale elemento sia rimosso. In etrambi i casi, \u00e8 importante aggiornare il valore di top . push(array, top, capacity, element) STEP 1 -> top = top + 1; STEP 2 -> if (top >= capacity) return ERROR; STEP 3 -> array[top] = element; pop(array, top) STEP 1 -> element = array[top]; STEP 2 -> top = top - 1; STEP 3 -> return element;","title":"Pila come array"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#code","text":"Una coda ( queue ) \u00e8 un contenitore di oggetti che sono inseriti o rimossi secondo il principio FIFO ( first-in, first-out ). Concettualmente, \u00e8 quella che siamo abituati a vedere negli Uffici Postali, ad esempio: il primo arrivato sar\u00e0 il primo ad essere servito (e, di conseguenza, rimosso dalla coda ). Definiremo quindi una funzione enqueue per mettere in coda un nuovo elemento, e dequeue per togliere dalla coda l'elemento presente da pi\u00f9 tempo. La differenza fondamentale rispetto agli stack sta nella rimozione degli oggetti: in uno stack, rimuoviamo l'oggetti che abbiamo aggiunto pi\u00f9 di recente, mentre in una coda rimuoviamo quello che abbiamo aggiunto meno di recente.","title":"Code"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#esempio-di-implementazione-come-array","text":"Nel caso volessimo implementare una coda come array, dovremmo definire almeno i metodi enqueue e dequeue . In particolare, la procedura di enqueue prevede che sia posto come primo membro dell'array proprio l'elemento che si vuole aggiungere. Per farlo, potremmo ad esempio salvare l'array in una variabile temporanea, e concatenarlo all'elemento che entra in coda. enqueue(array, element) STEP 1 -> temp_array = array; STEP 2 -> new_array = concatenate(element, temp_array); STEP 3 -> return new_array; La procedura di dequeue di converso comporta la semplice rimozione dell'ultimo elemento nell'array. dequeue(array) STEP 1 -> element = array[length(array) - 1] STEP 2 -> new_array = remove_last(array) STEP 3 -> return new_array, element","title":"Esempio di implementazione come array"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafi","text":"Ecco un modo per rappresentare una rete sociale: Le linee presenti tra i nomi di due persone indicano che queste si conoscono tra loro. Ovviamente, la conoscenza \u00e8 bidirezionale : dato che Alice conosce Bob, anche Bob conosce Alice. Questo modo di schematizzare una rete sociale \u00e8 conosciuto come grafo .","title":"Grafi"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#vertici-ed-archi","text":"Ciascun nodo \u00e8 noto come vertice , mentre ogni linea \u00e8 un arco che connette due vertici. L'insieme dei vertici \u00e8 dato da \\(V\\) , mentre quello degli archi \u00e8 dato da \\(E\\) . Il grafo \u00e8 quindi rappresentabile come una coppia \\(G=(V,E)\\) . Anche i nodi possono essere rappresentati a coppie: in particolare, due nodi \\(u\\) e \\(v\\) connessi da un arco sono una coppia \\((u, v)\\) .","title":"Vertici ed archi"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafo-non-diretto","text":"Abbiamo detto che le relazioni rappresentate nella nostra rete sociale sono bidirezionali: ci\u00f2 significa che non \u00e8 possibile individuare una \"direzione\" specifica nella relazione. Siamo quindi in presenza di un grafo non diretto . In un grafo non diretto, un arco \\((u, v)\\) equivale all'arco \\((v, u)\\) . Ciascun arco incide su entrambi i vertici, ed i vertici connessi da un arco sono adiacenti o vicini . Definiamo inoltre il numero di archi che incide su un vertice come grado dello stesso.","title":"Grafo non diretto"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#cammini-e-cicli","text":"Immaginiamo che Bob voglia conoscere Eric. non vi \u00e8 un arco che li collega; per\u00f2, Bob potrebbe chiedere ad Alice di presentargli David, che a sua volta potrebbe presentargli Eric. Esiste quindi un percorso , o cammino , composto da tre archi tra Bob ed Eric, e rappresenta il modo pi\u00f9 diretto per i due per incontrarsi. Chiamiamo un percorso del genere (ovvero il percorso con un numero minimo di archi) cammino minimo , o shortest path . Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo . Ad esempio, quello che va da Alice, passa per David, Eric e Charlie, e torna ad Alice, \u00e8 appunto un ciclo.","title":"Cammini e cicli"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafo-pesato","text":"Alle volte, gli archi sono pesati , ovvero correlati da valori numerici. Ad esempio, potremmo rappresentare la distanza tra diverse citt\u00e0 come segue: Il termine generale per ognuno dei numeri che mettiamo su un lato \u00e8 peso , ed un grafo i cui archi hanno dei pesi \u00e8 un grafo pesato . In questo caso, volendo trovare il percorso minimo tra due posizioni, dovremo tenere contro del valore dei pesi. Ad esempio, per Andare da Bari a Napoli, occorrer\u00e0, nel nostro caso, passare da Roma e Milano (piuttosto che da Torino). Nota Il Docente si scusa per questa interpretazione poco realistica. Non seguite questa mappa, e risparmierete molte ore.","title":"Grafo pesato"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafo-diretto","text":"Cosa accade se inseriamo informazioni inerenti i sensi di marcia all'interno del grafo precedente? Otteniamo un grafo diretto . Le direzioni degli archi mostrano quali percorsi possono essere affrontati, e quali no. In questo caso, ad esempio, non potremo uscire da Bari, in quanto non ci saranno archi uscenti. Roma invece perde il suo status, in quanto si dimostra che non tutte le strade portano a Roma . Possiamo fare altre due osservazioni su questo grafo: il grafo non ha alcun ciclo, per cui siamo in presenza di un grafo aciclico diretto ; il grafo conserva i pesi, per cui siamo comunque in presenza di un grafo pesato. Per quello che riguarda infine il grado di ogni arco, abbiamo due termini da tenere in considerazione: il grado esterno , o out-degree , \u00e8 il numero di archi in uscita da un vertice; il grado interno , o in-degree , \u00e8 il numero di archi in ingresso in un vertice.","title":"Grafo diretto"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#alberi","text":"Un albero \u00e8 una struttura dati, particolarmente usata in ambito informatico, che simula una struttura gerarchica, con un valore radice ed una serie di figli, rappresentata sotto forma di grafo non orientato , connesso ed aciclico . In particolare, il fatto che l'albero sia connesso indica che esiste almeno un cammino che connette tutti gli archi . Un particolare tipo di albero \u00e8 poi l' albero binario , nel quale ciascun nodo ha (al pi\u00f9) due figli. Un nodo terminale (ovvero uno in basso nella gerarchia) \u00e8 chiamato foglia .","title":"Alberi"},{"location":"02_dispense/05_algoritmi/01_binary_search/","text":"Introduzione al problema \u00b6 Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica. Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare ( linear search ). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto? Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2 , che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice. Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search . Definizione del problema Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata . Descrizione dell'algoritmo \u00b6 L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli . Facciamo un rapido esempio per capire al meglio di cosa si tratta. Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento . Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore . Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra. La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false , ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore . Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta. La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore . Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0. Il gioco prosegue come segue. ROUND 3 -------------------------------- ALICE -> 62 --- BOB -> INFERIORE -------------------------------- ROUND 4 -------------------------------- ALICE -> 56 --- BOB -> SUPERIORE -------------------------------- ROUND 5 -------------------------------- ALICE -> 59 --- BOB -> SUPERIORE -------------------------------- ROUND 6 (BOB IMPALLIDISCE) -------------------------------- ALICE -> 61 --- BOB -> INFERIORE -------------------------------- ROUND 7 (BOB TREMANTE...) -------------------------------- ALICE -> 60 --- BOB -> PAGARE In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato. Fase di progettazione. \u00b6 Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc. Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice , e poi definirne il flow chart. TODO: da qui Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole. Ecco un'implementazione step-by-step: sia min = 1 e max = n troviamo il valore medio tra min e max, arrotondato ad un intero se abbiamo trovato il numero, fermiamoci. altrimenti se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1 se l'ipotesi era troppo altra, impostiamo max a n/2 - 1 torniamo al passo 2 TODO: flow chart \u00b6 Complessit\u00e0 computazionale \u00b6 Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi. Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica. L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta. Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni. Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni. Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\) . Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\) . Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\) , fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22. Nota I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22. Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente.","title":"01 binary search"},{"location":"02_dispense/05_algoritmi/01_binary_search/#introduzione-al-problema","text":"Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica. Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare ( linear search ). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto? Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2 , che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice. Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search . Definizione del problema Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata .","title":"Introduzione al problema"},{"location":"02_dispense/05_algoritmi/01_binary_search/#descrizione-dellalgoritmo","text":"L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli . Facciamo un rapido esempio per capire al meglio di cosa si tratta. Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento . Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore . Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra. La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false , ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore . Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta. La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore . Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0. Il gioco prosegue come segue. ROUND 3 -------------------------------- ALICE -> 62 --- BOB -> INFERIORE -------------------------------- ROUND 4 -------------------------------- ALICE -> 56 --- BOB -> SUPERIORE -------------------------------- ROUND 5 -------------------------------- ALICE -> 59 --- BOB -> SUPERIORE -------------------------------- ROUND 6 (BOB IMPALLIDISCE) -------------------------------- ALICE -> 61 --- BOB -> INFERIORE -------------------------------- ROUND 7 (BOB TREMANTE...) -------------------------------- ALICE -> 60 --- BOB -> PAGARE In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/01_binary_search/#fase-di-progettazione","text":"Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc. Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice , e poi definirne il flow chart. TODO: da qui Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole. Ecco un'implementazione step-by-step: sia min = 1 e max = n troviamo il valore medio tra min e max, arrotondato ad un intero se abbiamo trovato il numero, fermiamoci. altrimenti se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1 se l'ipotesi era troppo altra, impostiamo max a n/2 - 1 torniamo al passo 2","title":"Fase di progettazione."},{"location":"02_dispense/05_algoritmi/01_binary_search/#todo-flow-chart","text":"","title":"TODO: flow chart"},{"location":"02_dispense/05_algoritmi/01_binary_search/#complessita-computazionale","text":"Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi. Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica. L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta. Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni. Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni. Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\) . Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\) . Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\) , fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22. Nota I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22. Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente.","title":"Complessit\u00e0 computazionale"},{"location":"02_dispense/05_algoritmi/02_selection_sort/","text":"Introduzione al problema \u00b6 Ordinare una lista di elementi (ovviamente dello stesso tipo) pu\u00f2 aiutare ad individuare rapidamente un certo elemento della stessa. In tal senso, esistono diversi algoritmi, chiamati algoritmi di ordinamento (o, in inglese, sorting algorithms ). Il primo, e pi\u00f9 semplice, algoritmo di ordinamento \u00e8 chiamato selection sort . Per comprenderne il funzionamento, ricorriamo (al solito) ai nostri cari Alice e Bob. Descrizione dell'algoritmo \u00b6 Il selection sort \u00e8 un algoritmo iterativo : ad ogni iterazione, viene analizzato un elemento della lista L'idea alla base del selection sort \u00e8 quella di *scambia Invece di sviluppare il tema d\u2019anno di Informatica, Alice e Bob decidono di prendersi il pomeriggio libero, e si imbattono nel vecchio mazzo di carte del cugino di Bob. \u201cAlice, ricordi il caff\u00e8 che ho perso l\u2019altra volta? Beh, ho in mente un modo per riaverlo indietro.\u201d \u201cDimmi pure. Cosa hai in mente?\u201d \u201cScommetto che non riesci a trovare una maniera algoritmica per ordinare questo vecchio mazzo.\u201d \u201cScommessa accettata.\u201d Alice, che ricordiamo essere una assidua frequentatrice del corso di Informatica, inizia facendo queste mosse. Per prima cosa, dispone tutte le carte presenti nel mazzo lungo un\u2019unica fila. A quel punto, inizia a cercare la carta pi\u00f9 piccola, e la posiziona al primo posto. Successivamente, suddivide la fila in due: a sinistra mette le carte gi\u00e0 ordinate (ovvero, la prima carta), ed a destra quelle ancora da ordinare. A quel punto, prende dalla fila di destra la carta pi\u00f9 piccola, e la posiziona immediatamente a destra dell\u2019ultimo elemento della fila di sinistra. Fatto questo, reitera questa procedura fino a che la fila di destra non \u00e8 completamente vuota, mentre quella di sinistra ha al suo interno tutte le carte ordinate. \u201cOk, Alice, hai ordinato le carte, ma non vedo alcun algoritmo.\u201d \u201cE\u2019 qui che ti sbagli, mio caro.\u201d Ed Alice, pregustando la vittoria, elenca a Bob le istruzioni che ha eseguito, dimostrando che la procedura che ha eseguito \u00e8 modellabile secondo l\u2019algoritmo di selection sort. Sia x un array di n elementi interi. Associare ad i il primo indice dell\u2019array (0), ed a j l\u2019ultimo (n-1). Associare ad una variabile il valore di x(0), e supporre che sia il valore minore. Confrontare tutti gli elementi di x(k), con k che va da 1 ad n - 1, con x(0). Aggiornare il valore di x(0) nel caso x(k) minore di x (0). Incrementare di 1 il valore di i. Ritornare all\u2019istruzione 4 fino a che i == j. Un esempio pratico Immaginiamo di avere un array con valori [12, 4, 8, 7, 2]. Per prima cosa, vediamo che il valore di i sar\u00e0 pari a 0, mentre j sar\u00e0 pari a 4. A questo punto, poniamo min = x(0) = 12. Vediamo che x(1) = 4 \u00e8 minore di 12, per cui il valore min viene aggiornato, e risulta essere pari a 4. Andiamo avanti, e compiamo soltanto un altro aggiornamento, ovvero quando vediamo che x(4) minore di min. A questo punto, inseriamo x(0) all\u2019estrema sinistra (posizione i). Aggiorniamo il valore di i ad 1, e reiteriamo la procedura, fino ad ottenere l\u2019array finale: [12, 4, 8, 7, 2] i = 0; j = 4; min = x(0) = 12; min = x(4) = 2; new = [2, 12, 4, 8, 7] i = 1; min = x(1) = 12; min = x(2) = 4; new = [2, 4, 12, 8, 7] i = 2; min = x(2) = 12; min = x(4) = 7; new = [2, 4, 7, 12, 8] i = 3; min = x(3) = 12; min = x(4) = 8; new = [2, 4, 7, 8, 12] return TODO FLOW CHART Analisi dell\u2019algoritmo Il selection sort itera su tutti gli indici di un array. Supponiamo di avere un array di n elementi; avremo (ovviamente) n indici. Per capire quante operazioni sono necessarie per completare l\u2019operazione di ordinamento, dobbiamo contare il numero di confronti necessari ad individuare l\u2019elemento minore attualmente presente nell\u2019array. In particolare, alla prima iterazione, quando i = 0, avremo la necessit\u00e0 di effettuare n operazioni, una per ogni elemento dell\u2019array. Alla seconda iterazione, quando i = 1, dovremo fare n - 1 confronti; alla terza, basteranno n - 2 confronti, e cos\u00ec via. Ci\u00f2 significa che avremo bisogno di n + (n-1) + \u2026 + 2 + 1 confronti; ci\u00f2 equivale ad una serie aritmetica pari a (n^2/2) + n/2. La complessit\u00e0 di caso peggiore tiene per\u00f2 conto di un limite asintoticamente superiore di questa serie, che \u00e8 pari ad n^2; ci\u00f2 significa che saremo in una situazione per cui la complessit\u00e0 computazionale \u00e8 pari ad O(n^2). Nota Una complessit\u00e0 di questo tipo ci permette di notare che il tempo richiesto all\u2019esecuzione dell\u2019algoritmo cresce molto velocemente al crescere del numero di elementi dell\u2019array. Con n = 10, infatti, avremo bisogno di 100 unit\u00e0 di tempo. Supponendo che un\u2019unit\u00e0 di tempo sia pari ad un microsecondo, avremo bisogno di 0.1 secondi. Se n = 100, allora avremo bisogno di 10 secondi. Se n = 1.000, invece, avremo bisogno di 1.000 secondi (ovvero quasi 17 minuti!).","title":"02 selection sort"},{"location":"02_dispense/05_algoritmi/02_selection_sort/#introduzione-al-problema","text":"Ordinare una lista di elementi (ovviamente dello stesso tipo) pu\u00f2 aiutare ad individuare rapidamente un certo elemento della stessa. In tal senso, esistono diversi algoritmi, chiamati algoritmi di ordinamento (o, in inglese, sorting algorithms ). Il primo, e pi\u00f9 semplice, algoritmo di ordinamento \u00e8 chiamato selection sort . Per comprenderne il funzionamento, ricorriamo (al solito) ai nostri cari Alice e Bob.","title":"Introduzione al problema"},{"location":"02_dispense/05_algoritmi/02_selection_sort/#descrizione-dellalgoritmo","text":"Il selection sort \u00e8 un algoritmo iterativo : ad ogni iterazione, viene analizzato un elemento della lista L'idea alla base del selection sort \u00e8 quella di *scambia Invece di sviluppare il tema d\u2019anno di Informatica, Alice e Bob decidono di prendersi il pomeriggio libero, e si imbattono nel vecchio mazzo di carte del cugino di Bob. \u201cAlice, ricordi il caff\u00e8 che ho perso l\u2019altra volta? Beh, ho in mente un modo per riaverlo indietro.\u201d \u201cDimmi pure. Cosa hai in mente?\u201d \u201cScommetto che non riesci a trovare una maniera algoritmica per ordinare questo vecchio mazzo.\u201d \u201cScommessa accettata.\u201d Alice, che ricordiamo essere una assidua frequentatrice del corso di Informatica, inizia facendo queste mosse. Per prima cosa, dispone tutte le carte presenti nel mazzo lungo un\u2019unica fila. A quel punto, inizia a cercare la carta pi\u00f9 piccola, e la posiziona al primo posto. Successivamente, suddivide la fila in due: a sinistra mette le carte gi\u00e0 ordinate (ovvero, la prima carta), ed a destra quelle ancora da ordinare. A quel punto, prende dalla fila di destra la carta pi\u00f9 piccola, e la posiziona immediatamente a destra dell\u2019ultimo elemento della fila di sinistra. Fatto questo, reitera questa procedura fino a che la fila di destra non \u00e8 completamente vuota, mentre quella di sinistra ha al suo interno tutte le carte ordinate. \u201cOk, Alice, hai ordinato le carte, ma non vedo alcun algoritmo.\u201d \u201cE\u2019 qui che ti sbagli, mio caro.\u201d Ed Alice, pregustando la vittoria, elenca a Bob le istruzioni che ha eseguito, dimostrando che la procedura che ha eseguito \u00e8 modellabile secondo l\u2019algoritmo di selection sort. Sia x un array di n elementi interi. Associare ad i il primo indice dell\u2019array (0), ed a j l\u2019ultimo (n-1). Associare ad una variabile il valore di x(0), e supporre che sia il valore minore. Confrontare tutti gli elementi di x(k), con k che va da 1 ad n - 1, con x(0). Aggiornare il valore di x(0) nel caso x(k) minore di x (0). Incrementare di 1 il valore di i. Ritornare all\u2019istruzione 4 fino a che i == j. Un esempio pratico Immaginiamo di avere un array con valori [12, 4, 8, 7, 2]. Per prima cosa, vediamo che il valore di i sar\u00e0 pari a 0, mentre j sar\u00e0 pari a 4. A questo punto, poniamo min = x(0) = 12. Vediamo che x(1) = 4 \u00e8 minore di 12, per cui il valore min viene aggiornato, e risulta essere pari a 4. Andiamo avanti, e compiamo soltanto un altro aggiornamento, ovvero quando vediamo che x(4) minore di min. A questo punto, inseriamo x(0) all\u2019estrema sinistra (posizione i). Aggiorniamo il valore di i ad 1, e reiteriamo la procedura, fino ad ottenere l\u2019array finale: [12, 4, 8, 7, 2] i = 0; j = 4; min = x(0) = 12; min = x(4) = 2; new = [2, 12, 4, 8, 7] i = 1; min = x(1) = 12; min = x(2) = 4; new = [2, 4, 12, 8, 7] i = 2; min = x(2) = 12; min = x(4) = 7; new = [2, 4, 7, 12, 8] i = 3; min = x(3) = 12; min = x(4) = 8; new = [2, 4, 7, 8, 12] return TODO FLOW CHART Analisi dell\u2019algoritmo Il selection sort itera su tutti gli indici di un array. Supponiamo di avere un array di n elementi; avremo (ovviamente) n indici. Per capire quante operazioni sono necessarie per completare l\u2019operazione di ordinamento, dobbiamo contare il numero di confronti necessari ad individuare l\u2019elemento minore attualmente presente nell\u2019array. In particolare, alla prima iterazione, quando i = 0, avremo la necessit\u00e0 di effettuare n operazioni, una per ogni elemento dell\u2019array. Alla seconda iterazione, quando i = 1, dovremo fare n - 1 confronti; alla terza, basteranno n - 2 confronti, e cos\u00ec via. Ci\u00f2 significa che avremo bisogno di n + (n-1) + \u2026 + 2 + 1 confronti; ci\u00f2 equivale ad una serie aritmetica pari a (n^2/2) + n/2. La complessit\u00e0 di caso peggiore tiene per\u00f2 conto di un limite asintoticamente superiore di questa serie, che \u00e8 pari ad n^2; ci\u00f2 significa che saremo in una situazione per cui la complessit\u00e0 computazionale \u00e8 pari ad O(n^2). Nota Una complessit\u00e0 di questo tipo ci permette di notare che il tempo richiesto all\u2019esecuzione dell\u2019algoritmo cresce molto velocemente al crescere del numero di elementi dell\u2019array. Con n = 10, infatti, avremo bisogno di 100 unit\u00e0 di tempo. Supponendo che un\u2019unit\u00e0 di tempo sia pari ad un microsecondo, avremo bisogno di 0.1 secondi. Se n = 100, allora avremo bisogno di 10 secondi. Se n = 1.000, invece, avremo bisogno di 1.000 secondi (ovvero quasi 17 minuti!).","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/03_insertion_sort/","text":"Introduzione al problema \u00b6 Abbiamo visto INSERTION SORT Ci sono molti modi diversi di effettuare il sort. un altro modo \u00e8 l\u2019insertion sort. Immaginiamo che stimao giocando un gioco di carte. Stiamo tenendo delle carte in mano, e tutte queste carte sono ordinate. Il dealer ci d\u00e0 esattamente una nuova carta. Si deve metterla nel posto corretto in modo che la carta cheabbiamo in mano siano ancora ordinate. Nel selection sort, ogni elemento che aggiungiamo all\u2019array ordinato non pu\u00f2 essere pi\u00f9 piccolo degli elementi gi\u00e0 presenti nell\u2019arry ordinato. Ma nel nostro esempio, la nuova carta pu\u00f2 essere pi\u00f9 piccola delle carte che abbiamo gi\u00e0 in mano, per cui dobbiamo andare gi\u00f9 nella linea, comparando le nuove card con ognuna delle carte in mano, fino a che non troviamo un posto epr inserirla. Inseriamo la nuova carta nel punto giusto, e nuovamente la nostra mano ha delle card completamente ordinate. Quindi il dealer ci da un\u2019altra carta, e si ripete la stesa procedura. Quindi un\u2019altra carta, e via dicendo, fino a che il dealer non ci d\u00e0 pi\u00f9 alcuna carta. Questa \u00e8 l\u2019idea dietro linsertion sort. Iterare nelle posizsioni dell\u2019array, a partire dall\u2019indice 1. COn ogni nuova posizione \u00e8 come la nuova carta che civieen data dal dealer, e dobbiamo inserirla nel psto corretto nel subarray ordinato a sinistra di quella posizione. Immaginiamo che il subarray dall\u2019indice 0 all\u2019indice 5 sia gi\u00e0 ordinato, e vogliamo inserire l\u2019ekemeto attuamlmente all\u2019indice 6 in questo subarray gi\u00e0 ordinato, in modo che il subarray dall\u2019indice 0 all\u2019indice 6 sia ordinato. 2 3 7 8 10 13 5 PER ARRIVARE A 2 3 5 7 9 10 13 Per inserire l\u2019eeento in posizione 6 nel subarray alla sua sinsitra, compariamo ripetutatmente questo con gli elementi alla sua sinistra, andando da destra verso sinistra. Chiamaiamo quindi l\u00ecelemento in posizione 6 chiave. ogni volta che capiamo che la chiave \u00e8 inferiroe di un elemento alla sua sinistra, lo spostiamo verso destra, dal momento che sappiamo che la chiave dovr\u00e0 andare alla sinistra di quell\u2019elemento. Dovremo fare altre due cose per far funzionare questa idea: dovremo avere un\u2019operazione slide (che sposta un elemento di una posizione a destra), e dovremo salvare il valore della chiave in un puno separato. Nel nostro esempio, : 1.- inseriamo l\u2019elemento all\u2019indice 6 in ua variabile chiamata key compariamo key con l\u2019elemento alla posizione 5. sappiamo che key \u00e8 inferiore all\u2019elemento in posizione 5, quindi faccioamo lo slide di questo alla posizione 6. Notiamo che l\u2019operazione di slide si limita a copiare l\u2019eemento una posizione a destra. Quindi, compariamo key con l\u2019elemento in posizione 4. troviamo che key \u00e8 inferiore, e reiteriamo la procedura. Quando l\u2019elemento\u00e8 inferiore di key, non effettuiamo l\u2019operazione di slide. Invece, lasciamo la variabile key in quella posizione, immediatamente all\u2019elemento a destra. Il risultato \u00e8 \u2018ordinamento di tutto l\u2019array. Il nome dell\u2019insertion sort deriva dal fatto che questo inserisce ripetutamente un elemento nel subarray a sinistra dell\u2019elemento che sta valutando. Di conseguenza, nel caso generale, si parte considerando sempre il primo elemento del subarray (o meglio un subarray di un elemento), che non pu\u00f2 non essere ordinato (\u00e8 ordinato rispetto a se stesso). La prima chiave sar\u00e0 quindi l\u2019elemento con indice 1. 10 7 3 13 7 10 3 13 A questo punto, il subarray ordinato va da 0 ad 1, quindi il nuovo key \u00e8 indice 2. compariamo questo con quelli a sinistra ed abbiamo: 7 10 3 13 7 3 10 13 3 7 10 13 Ci sono un paio di situazioni limite. Il primo \u00e8 quando l\u2019elemento chiave \u00e8 inferiore a tutti gli elementi nel subarray ordinato; il secondo \u00e8 qunado invece \u00e8 superiore. Nel primo, ogni elemento del subarray deve effettuare uno slide, nel secondo non ci sono slide da effettuare. pseudocdice chiamo insert per inserire l\u2019elemento cheinizia all\u2019indice 1 nell\u2019array ordinato all\u2019indice 0. chiamo insert per insierire l\u2019elemento che inizia all\u2019indice 2 nell\u2019array ordinato in un indice che va da 0 ad 1. \u2026 Chiamo insert per insserire l\u2019elemento che inizia all\u2019indice n-1 nell\u2019array ordinato nell\u2019indice che va da 0 ad n - 2. analisi come nel caso del selection sort, l\u2019insertion sort fa un loop sugli indici dell\u2019array. chiama semplicemente insert sugli elementi di indice che vanno da 1 ad n-1. Ogni chiamata ad insert richiede un certo periodo di tempo. Prendiamo una situazione nella quale chiamoiamo insrt ed il valore che viene inserito nel subarray \u00e8 inferiore ad ogni elemento nel sybarray. Quindi, ogni elemento nel subarray dovr\u00e0 effettuare lo slide di una posizione a sinistra. Per cui, in generale, se stiamo inserendo un nuovo elemento in un subarray con k elementi, tutti i k elementi dovranno effettuare uno slide di una posizione. Pitutosto che contare esattamente quante linee di codice dobbiamo usare, diciamo che questo numero \u00e8 c. Quindi, potremmo aver bisogno di c * k linee per inserire un valore in un subarray di k elementi. Supponiamo che ad ogni chiamata ad insert, il valore che venga inserito sia inferirore ad ogni elmento nel subarray alla sua sinsitra. Quando chiamiamo insert la prima vlta, con k = 1. La seconda volta, k = 2. La terza volta, k = 3. E via, fino all\u2019ultima volta, quando k = n -1. Quinid, il tempo totale speso ad inserire qualcosa nel sub array \u00e8 c * (1 + 2 + .. + n-1). Anche in questo caso abbiamo una serie aritmetica. Tornando alla notazione, O(n^2). Molto probabilmente, per\u00f2, l\u2019insertion sort potrebbe avere meno tempo necessario (ad esempio, questo accadrebbe nel caso avessimo un array gi\u00e0 ordinato). Per\u00f2 non \u00e8 detto, quindi \u00e8 necessario sempre e comunque considerare un tempo pari a O(n^2). Potremmo per\u00f2 considerare il caso migliroe, che avrebbe un O(n) (in questo caso l\u2019array \u00e8 gi\u00e0 quasi ordinato).","title":"03 insertion sort"},{"location":"02_dispense/05_algoritmi/03_insertion_sort/#introduzione-al-problema","text":"Abbiamo visto INSERTION SORT Ci sono molti modi diversi di effettuare il sort. un altro modo \u00e8 l\u2019insertion sort. Immaginiamo che stimao giocando un gioco di carte. Stiamo tenendo delle carte in mano, e tutte queste carte sono ordinate. Il dealer ci d\u00e0 esattamente una nuova carta. Si deve metterla nel posto corretto in modo che la carta cheabbiamo in mano siano ancora ordinate. Nel selection sort, ogni elemento che aggiungiamo all\u2019array ordinato non pu\u00f2 essere pi\u00f9 piccolo degli elementi gi\u00e0 presenti nell\u2019arry ordinato. Ma nel nostro esempio, la nuova carta pu\u00f2 essere pi\u00f9 piccola delle carte che abbiamo gi\u00e0 in mano, per cui dobbiamo andare gi\u00f9 nella linea, comparando le nuove card con ognuna delle carte in mano, fino a che non troviamo un posto epr inserirla. Inseriamo la nuova carta nel punto giusto, e nuovamente la nostra mano ha delle card completamente ordinate. Quindi il dealer ci da un\u2019altra carta, e si ripete la stesa procedura. Quindi un\u2019altra carta, e via dicendo, fino a che il dealer non ci d\u00e0 pi\u00f9 alcuna carta. Questa \u00e8 l\u2019idea dietro linsertion sort. Iterare nelle posizsioni dell\u2019array, a partire dall\u2019indice 1. COn ogni nuova posizione \u00e8 come la nuova carta che civieen data dal dealer, e dobbiamo inserirla nel psto corretto nel subarray ordinato a sinistra di quella posizione. Immaginiamo che il subarray dall\u2019indice 0 all\u2019indice 5 sia gi\u00e0 ordinato, e vogliamo inserire l\u2019ekemeto attuamlmente all\u2019indice 6 in questo subarray gi\u00e0 ordinato, in modo che il subarray dall\u2019indice 0 all\u2019indice 6 sia ordinato. 2 3 7 8 10 13 5 PER ARRIVARE A 2 3 5 7 9 10 13 Per inserire l\u2019eeento in posizione 6 nel subarray alla sua sinsitra, compariamo ripetutatmente questo con gli elementi alla sua sinistra, andando da destra verso sinistra. Chiamaiamo quindi l\u00ecelemento in posizione 6 chiave. ogni volta che capiamo che la chiave \u00e8 inferiroe di un elemento alla sua sinistra, lo spostiamo verso destra, dal momento che sappiamo che la chiave dovr\u00e0 andare alla sinistra di quell\u2019elemento. Dovremo fare altre due cose per far funzionare questa idea: dovremo avere un\u2019operazione slide (che sposta un elemento di una posizione a destra), e dovremo salvare il valore della chiave in un puno separato. Nel nostro esempio, : 1.- inseriamo l\u2019elemento all\u2019indice 6 in ua variabile chiamata key compariamo key con l\u2019elemento alla posizione 5. sappiamo che key \u00e8 inferiore all\u2019elemento in posizione 5, quindi faccioamo lo slide di questo alla posizione 6. Notiamo che l\u2019operazione di slide si limita a copiare l\u2019eemento una posizione a destra. Quindi, compariamo key con l\u2019elemento in posizione 4. troviamo che key \u00e8 inferiore, e reiteriamo la procedura. Quando l\u2019elemento\u00e8 inferiore di key, non effettuiamo l\u2019operazione di slide. Invece, lasciamo la variabile key in quella posizione, immediatamente all\u2019elemento a destra. Il risultato \u00e8 \u2018ordinamento di tutto l\u2019array. Il nome dell\u2019insertion sort deriva dal fatto che questo inserisce ripetutamente un elemento nel subarray a sinistra dell\u2019elemento che sta valutando. Di conseguenza, nel caso generale, si parte considerando sempre il primo elemento del subarray (o meglio un subarray di un elemento), che non pu\u00f2 non essere ordinato (\u00e8 ordinato rispetto a se stesso). La prima chiave sar\u00e0 quindi l\u2019elemento con indice 1. 10 7 3 13 7 10 3 13 A questo punto, il subarray ordinato va da 0 ad 1, quindi il nuovo key \u00e8 indice 2. compariamo questo con quelli a sinistra ed abbiamo: 7 10 3 13 7 3 10 13 3 7 10 13 Ci sono un paio di situazioni limite. Il primo \u00e8 quando l\u2019elemento chiave \u00e8 inferiore a tutti gli elementi nel subarray ordinato; il secondo \u00e8 qunado invece \u00e8 superiore. Nel primo, ogni elemento del subarray deve effettuare uno slide, nel secondo non ci sono slide da effettuare. pseudocdice chiamo insert per inserire l\u2019elemento cheinizia all\u2019indice 1 nell\u2019array ordinato all\u2019indice 0. chiamo insert per insierire l\u2019elemento che inizia all\u2019indice 2 nell\u2019array ordinato in un indice che va da 0 ad 1. \u2026 Chiamo insert per insserire l\u2019elemento che inizia all\u2019indice n-1 nell\u2019array ordinato nell\u2019indice che va da 0 ad n - 2. analisi come nel caso del selection sort, l\u2019insertion sort fa un loop sugli indici dell\u2019array. chiama semplicemente insert sugli elementi di indice che vanno da 1 ad n-1. Ogni chiamata ad insert richiede un certo periodo di tempo. Prendiamo una situazione nella quale chiamoiamo insrt ed il valore che viene inserito nel subarray \u00e8 inferiore ad ogni elemento nel sybarray. Quindi, ogni elemento nel subarray dovr\u00e0 effettuare lo slide di una posizione a sinistra. Per cui, in generale, se stiamo inserendo un nuovo elemento in un subarray con k elementi, tutti i k elementi dovranno effettuare uno slide di una posizione. Pitutosto che contare esattamente quante linee di codice dobbiamo usare, diciamo che questo numero \u00e8 c. Quindi, potremmo aver bisogno di c * k linee per inserire un valore in un subarray di k elementi. Supponiamo che ad ogni chiamata ad insert, il valore che venga inserito sia inferirore ad ogni elmento nel subarray alla sua sinsitra. Quando chiamiamo insert la prima vlta, con k = 1. La seconda volta, k = 2. La terza volta, k = 3. E via, fino all\u2019ultima volta, quando k = n -1. Quinid, il tempo totale speso ad inserire qualcosa nel sub array \u00e8 c * (1 + 2 + .. + n-1). Anche in questo caso abbiamo una serie aritmetica. Tornando alla notazione, O(n^2). Molto probabilmente, per\u00f2, l\u2019insertion sort potrebbe avere meno tempo necessario (ad esempio, questo accadrebbe nel caso avessimo un array gi\u00e0 ordinato). Per\u00f2 non \u00e8 detto, quindi \u00e8 necessario sempre e comunque considerare un tempo pari a O(n^2). Potremmo per\u00f2 considerare il caso migliroe, che avrebbe un O(n) (in questo caso l\u2019array \u00e8 gi\u00e0 quasi ordinato).","title":"Introduzione al problema"},{"location":"02_dispense/05_algoritmi/04_merge_sort/","text":"Il paradigma Divide-et-Impera (Divide-and-Conquer) \u00b6 Prima di introdurre questo algoritmo ed il successivo, \u00e8 opportuno parlare dell'approccio su cui sono basati, chiamato divide-et-impera o, in inglese, divide-and-conquer . Useremo la notazione inglese perch\u00e9 fa pi\u00f9 \"stile\", ovviamente. Il paradigma divide-and-conquer \u00e8 puramente ricorsivo: infatti, divide un problema in diversi sotto-problemi, che risultano essere riconducibili al caso originario, pur rimanendo meno complessi. Una volta ricondottisi ai singoli casi base, l'approccio risolve ciascuno dei singoli problemi, combinando le soluzioni per risolvere il problema originario. E' quindi possibile schematizzare il paradigma in tre parti: divide : suddividiamo il problema in diversi sotto problemi, che rappresentano delle istanze pi\u00f9 piccole del problema originario. conquer : risolviamo ogni sotto-problema, se riconducibile ad un caso base. combine : combiniamo le soluzioni ai sottoproblemi, arrivando a quella del problema originario. Schematizzando: Descrizione dell'algoritmo \u00b6 Abbiamo gi\u00e0 detto come il merge sort si basi su un approccio di tipo divide-and-conquer. Di conseguenza, partendo dal nostro solito problema (ovvero, l'ordinamento di un array), dobbiamo definire il sotto-problema da risolvere . Banalmente, questo potr\u00e0 essere proprio quello di ordinare ciascun sotto-array in cui viene scomposto il nostro array originario. Utilizziamo in tal senso una notazione specifica per indicare il sotto-array che va dall'elemento di indice \\(l\\) all'elemento di indice \\(r\\) , denotandolo con array[l, r] . Per fare un esempio, se il nostro array iniziale fosse: array = [8, 5, 12, 7, 4]; allora: l = 0; r = 2; array[l,r] = [8, 5, 12]; Il merge sort utilizza l'approccio divide-and-conquer come segue: divide : trova il valore \\(q\\) intermedio tra \\(l\\) ed \\(r\\) . Se \\(q\\) \u00e8 dispari, lo approssimiamo all'intero inferiore; conquer : ordina i due sotto-array creati dal passo divide . Ci\u00f2 significa che si agir\u00e0 su array[l,q] ed array[q+1,r] ; combine : unisci i due sotto-array in uno singolo array[l, r] . Ovviamente, come tutti i problemi ricorsivi, avremo bisogno di un caso base. Ci\u00f2 avviene quando gli array risultanti dal passo conquer hanno meno di due elementi, ovvero quando \\(l \\geq r\\) : questo \u00e8 ovviamente legato al fatto che un array vuoto o con un solo elemento \u00e8 gi\u00e0 ordinato di suo. Un esempio \u00b6 Vediamo un esempio di utilizzo del merge sort. In tal senso, usiamo il nostro solito array con valori [8, 5, 12, 7, 4] . Al primo livello, l'array da considerare \u00e8 quello completo, e quindi: l = 0; r = 4; array[l,r] = [8, 5, 12, 7, 4] divide : in questo passo, calcoliamo \\(q=2\\) ; conquer : in questo passo, notiamo che i due array non sono riconducibili ad un caso base, per cui ripetiamo il divide ; Avremo quindi il secondo livello. In questo passo, l'array array[0,1] avr\u00e0 ancora due elementi, per cui sar\u00e0 necessario suddividerlo ulteriormente; stesso vale per array[2,4] . Arrivando in fondo, avremo la scomposizione di ogni array a livello di singolo elemento. Ci\u00f2 comporta che si arriver\u00e0 ad un certo punto ad una situazione in cui tutti gli array sotto esame saranno composti da un unico elemento, come mostrato in figura. A questo punto, ci si \u00e8 ricondotti in ogni situazione al caso base. Potr\u00e0 quindi avvenire lo step conquer , dove saranno ordinati i diversi sotto-array, ed infine lo step combine , che combiner\u00e0 i risultati in uscita dal conquer . Questo processo \u00e8 mostrato in figura. Notiamo come, dal punto di vista logico, i passaggi divide e conquer del merge sort siano in realt\u00e0 abbastanza semplici. Il punto \"complesso\", quello dove avviene l'ordinamento vero \u00e8 proprio, \u00e8 il combine . Merging \u00b6 Il passo combine \u00e8 quello che ci permette di \"unire\" due sotto-array adiacenti, ovvero array[l, q] ed array[q+1, r] , in un singolo array ordinato. Supponiamo che l'array iniziale array[l, r] abbia \\(n\\) elementi. E' necessario esaminare ciascuno di essi, per cui, nel caso migliore, potremo sperare in un tempo per l'unione in un \\(O(n)\\) . Detto questo chiamiamo, per comodit\u00e0, array[l,q] con il nome di left , ed array[q+1, r] con il nome di right . Vogliamo fare in modo che nell'elemento pi\u00f9 a sinistra di array , ovvero array[l] , venga inserito l'elemento pi\u00f9 minore presente sia in left sia in right . Ovviamente, dato che left e right si suppongono ordinati, il valore pi\u00f9 piccolo pu\u00f2 essere, all'inizio, o in left[0] o in right[0] . Possiamo usare quindi tre variabili per indicizzare gli array: i indicizza il primo elemento di left non ancora copiato in array . Inizialmente, i = 0 ; j indicizza il primo elemento di right non ancora copiato in array . Inizialmente, j = 0 ; k indicizza la posizione successiva di array in cui copiare. Inizialmente, k = l . In pratica, avremo un ciclo all'interno del quale verranno reiterate le seguenti istruzioni: if ( left [ i ] > right [ j ]) { array [ k ] = right [ j ]; j ++ ; } else { array [ k ] = left [ i ]; i ++ ; } k ++ ; Potr\u00e0 ovviamente accadere che uno tra left e right si \"svuoti\" per primo; di conseguenza, dato che l'altro \u00e8 comunque ordinato, potremo semplicemente limitarci a copiarlo integralmente negli elementi restanti di array , senza la necessit\u00e0 di effettuare alcuna ulteriore comparazione. Analisi computazionale \u00b6 Passo combine \u00b6 Verifichiamo che il costo legato allo step combine sia in \\(O(n)\\) . L'operazione di unione avviene in tre parti: nella prima, creiamo i due array left e right ; fino a che ci sono degli elementi non copiati da left o right in array , compariamo il primo elemento non ancora copiato di left a quello non ancora copiato di right , e copiamo il minore in array ; una volta che abbiamo copiato tutti gli elementi da left (o right ) in array , copiamo ogni elemento rimanente da right (o left ) in array . E' chiaro che, al massimo, dovremo effettuare n comparazioni ed n operazioni di copia. Ci\u00f2 significa che, al pi\u00f9, avremo \\(2 \\cdot n\\) operazioni, per cui la complessit\u00e0 sar\u00e0 in un \\(O(n)\\) . Analisi di caso peggiore \u00b6 Per effettuare l'analisi della complessit\u00e0 globale dell'algoritmo, consideriamo i tempi di esecuzione di ciascuno degli step coinvolti. Assumiamo, al solito, di stare ordinando un array ad \\(n\\) elementi. Nel passo divide , abbiamo bisogno di un tempo costante, ed indipendente dalla dimensione degli array coinvolti. Infatti, stiamo semplicemente calcolando il valore medio tra l ed r , per cui abbiamo bisogno di un'unica operazione. Nel passo conquer , ordiniamo ricorsivamente due sotto-array di approsimativamente \\(n/2\\) elementi. Nel passo combine , uniamo \\(n\\) elementi, ed abbiamo gi\u00e0 verificato avere bisogno di un \\(O(n)\\) . Considerando i passi divide e combine assieme, notiamo che il tempo necessario al divide \u00e8 trascurabile, per cui possiamo considerare solo quello per il combine . Resta da calcolare il tempo necessario al conquer . Per mantenere le cose semplici, consideriamo \\(n\\) pari e potenza di due (nel caso \\(n\\) sia dispari, il calcolo della complessit\u00e0 non cambia molto). Notiamo poi che l'esecuzione del merge sort su un array ad \\(n\\) elementi richieder\u00e0 (approssimativamente) lo stesso tempo dell'esecuzione di due merge sort su array ad \\(n/2\\) elementi, ciascuno dei quali richiede il doppio dell'esecuzione del merge sort su un array ad \\(n/4\\) elementi, e cos\u00ec via. Ricordando che il merge sort pu\u00f2 essere visto come un albero binario, \u00e8 evidente come ad ogni livello successivo dell'albero il numero di problemi raddoppi , mentre il tempo necessario alla risoluzione di un singolo problema si dimezzi . Questi due effetti si annullano reciprocamente, per cui potremo dire che, ad ogni livello, avremo bisogno al pi\u00f9 di \\(n\\) operazioni. Il tempo totale necessario \u00e8 quindi considerando un \\(O(n)\\) per ogni livello dell'albero prodotto dal merge sort. Con \\(c\\) livelli, avremo che il tempo totale necessario sar\u00e0 al pi\u00f9 \\(c \\cdot n\\) . Qual \u00e8 quindi il valore di \\(c\\) ? Dato che stiamo parlando di un albero binario, e che stiamo considerando un valore di \\(n\\) pari e potenza di due, sappiamo che \\(c = log_2n\\) . Di conseguenza, il tempo necessario per il merge sort sar\u00e0 dato da \\(n\\) (ovvero il numero di operazioni da effettuare a ciascun livello) moltiplicato per \\(c\\) (il numero di livelli), ovvero un \\(O(n \\cdot log_n2)\\) .","title":"17 - Merge sort"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#il-paradigma-divide-et-impera-divide-and-conquer","text":"Prima di introdurre questo algoritmo ed il successivo, \u00e8 opportuno parlare dell'approccio su cui sono basati, chiamato divide-et-impera o, in inglese, divide-and-conquer . Useremo la notazione inglese perch\u00e9 fa pi\u00f9 \"stile\", ovviamente. Il paradigma divide-and-conquer \u00e8 puramente ricorsivo: infatti, divide un problema in diversi sotto-problemi, che risultano essere riconducibili al caso originario, pur rimanendo meno complessi. Una volta ricondottisi ai singoli casi base, l'approccio risolve ciascuno dei singoli problemi, combinando le soluzioni per risolvere il problema originario. E' quindi possibile schematizzare il paradigma in tre parti: divide : suddividiamo il problema in diversi sotto problemi, che rappresentano delle istanze pi\u00f9 piccole del problema originario. conquer : risolviamo ogni sotto-problema, se riconducibile ad un caso base. combine : combiniamo le soluzioni ai sottoproblemi, arrivando a quella del problema originario. Schematizzando:","title":"Il paradigma Divide-et-Impera (Divide-and-Conquer)"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#descrizione-dellalgoritmo","text":"Abbiamo gi\u00e0 detto come il merge sort si basi su un approccio di tipo divide-and-conquer. Di conseguenza, partendo dal nostro solito problema (ovvero, l'ordinamento di un array), dobbiamo definire il sotto-problema da risolvere . Banalmente, questo potr\u00e0 essere proprio quello di ordinare ciascun sotto-array in cui viene scomposto il nostro array originario. Utilizziamo in tal senso una notazione specifica per indicare il sotto-array che va dall'elemento di indice \\(l\\) all'elemento di indice \\(r\\) , denotandolo con array[l, r] . Per fare un esempio, se il nostro array iniziale fosse: array = [8, 5, 12, 7, 4]; allora: l = 0; r = 2; array[l,r] = [8, 5, 12]; Il merge sort utilizza l'approccio divide-and-conquer come segue: divide : trova il valore \\(q\\) intermedio tra \\(l\\) ed \\(r\\) . Se \\(q\\) \u00e8 dispari, lo approssimiamo all'intero inferiore; conquer : ordina i due sotto-array creati dal passo divide . Ci\u00f2 significa che si agir\u00e0 su array[l,q] ed array[q+1,r] ; combine : unisci i due sotto-array in uno singolo array[l, r] . Ovviamente, come tutti i problemi ricorsivi, avremo bisogno di un caso base. Ci\u00f2 avviene quando gli array risultanti dal passo conquer hanno meno di due elementi, ovvero quando \\(l \\geq r\\) : questo \u00e8 ovviamente legato al fatto che un array vuoto o con un solo elemento \u00e8 gi\u00e0 ordinato di suo.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#un-esempio","text":"Vediamo un esempio di utilizzo del merge sort. In tal senso, usiamo il nostro solito array con valori [8, 5, 12, 7, 4] . Al primo livello, l'array da considerare \u00e8 quello completo, e quindi: l = 0; r = 4; array[l,r] = [8, 5, 12, 7, 4] divide : in questo passo, calcoliamo \\(q=2\\) ; conquer : in questo passo, notiamo che i due array non sono riconducibili ad un caso base, per cui ripetiamo il divide ; Avremo quindi il secondo livello. In questo passo, l'array array[0,1] avr\u00e0 ancora due elementi, per cui sar\u00e0 necessario suddividerlo ulteriormente; stesso vale per array[2,4] . Arrivando in fondo, avremo la scomposizione di ogni array a livello di singolo elemento. Ci\u00f2 comporta che si arriver\u00e0 ad un certo punto ad una situazione in cui tutti gli array sotto esame saranno composti da un unico elemento, come mostrato in figura. A questo punto, ci si \u00e8 ricondotti in ogni situazione al caso base. Potr\u00e0 quindi avvenire lo step conquer , dove saranno ordinati i diversi sotto-array, ed infine lo step combine , che combiner\u00e0 i risultati in uscita dal conquer . Questo processo \u00e8 mostrato in figura. Notiamo come, dal punto di vista logico, i passaggi divide e conquer del merge sort siano in realt\u00e0 abbastanza semplici. Il punto \"complesso\", quello dove avviene l'ordinamento vero \u00e8 proprio, \u00e8 il combine .","title":"Un esempio"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#merging","text":"Il passo combine \u00e8 quello che ci permette di \"unire\" due sotto-array adiacenti, ovvero array[l, q] ed array[q+1, r] , in un singolo array ordinato. Supponiamo che l'array iniziale array[l, r] abbia \\(n\\) elementi. E' necessario esaminare ciascuno di essi, per cui, nel caso migliore, potremo sperare in un tempo per l'unione in un \\(O(n)\\) . Detto questo chiamiamo, per comodit\u00e0, array[l,q] con il nome di left , ed array[q+1, r] con il nome di right . Vogliamo fare in modo che nell'elemento pi\u00f9 a sinistra di array , ovvero array[l] , venga inserito l'elemento pi\u00f9 minore presente sia in left sia in right . Ovviamente, dato che left e right si suppongono ordinati, il valore pi\u00f9 piccolo pu\u00f2 essere, all'inizio, o in left[0] o in right[0] . Possiamo usare quindi tre variabili per indicizzare gli array: i indicizza il primo elemento di left non ancora copiato in array . Inizialmente, i = 0 ; j indicizza il primo elemento di right non ancora copiato in array . Inizialmente, j = 0 ; k indicizza la posizione successiva di array in cui copiare. Inizialmente, k = l . In pratica, avremo un ciclo all'interno del quale verranno reiterate le seguenti istruzioni: if ( left [ i ] > right [ j ]) { array [ k ] = right [ j ]; j ++ ; } else { array [ k ] = left [ i ]; i ++ ; } k ++ ; Potr\u00e0 ovviamente accadere che uno tra left e right si \"svuoti\" per primo; di conseguenza, dato che l'altro \u00e8 comunque ordinato, potremo semplicemente limitarci a copiarlo integralmente negli elementi restanti di array , senza la necessit\u00e0 di effettuare alcuna ulteriore comparazione.","title":"Merging"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#analisi-computazionale","text":"","title":"Analisi computazionale"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#passo-combine","text":"Verifichiamo che il costo legato allo step combine sia in \\(O(n)\\) . L'operazione di unione avviene in tre parti: nella prima, creiamo i due array left e right ; fino a che ci sono degli elementi non copiati da left o right in array , compariamo il primo elemento non ancora copiato di left a quello non ancora copiato di right , e copiamo il minore in array ; una volta che abbiamo copiato tutti gli elementi da left (o right ) in array , copiamo ogni elemento rimanente da right (o left ) in array . E' chiaro che, al massimo, dovremo effettuare n comparazioni ed n operazioni di copia. Ci\u00f2 significa che, al pi\u00f9, avremo \\(2 \\cdot n\\) operazioni, per cui la complessit\u00e0 sar\u00e0 in un \\(O(n)\\) .","title":"Passo combine"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#analisi-di-caso-peggiore","text":"Per effettuare l'analisi della complessit\u00e0 globale dell'algoritmo, consideriamo i tempi di esecuzione di ciascuno degli step coinvolti. Assumiamo, al solito, di stare ordinando un array ad \\(n\\) elementi. Nel passo divide , abbiamo bisogno di un tempo costante, ed indipendente dalla dimensione degli array coinvolti. Infatti, stiamo semplicemente calcolando il valore medio tra l ed r , per cui abbiamo bisogno di un'unica operazione. Nel passo conquer , ordiniamo ricorsivamente due sotto-array di approsimativamente \\(n/2\\) elementi. Nel passo combine , uniamo \\(n\\) elementi, ed abbiamo gi\u00e0 verificato avere bisogno di un \\(O(n)\\) . Considerando i passi divide e combine assieme, notiamo che il tempo necessario al divide \u00e8 trascurabile, per cui possiamo considerare solo quello per il combine . Resta da calcolare il tempo necessario al conquer . Per mantenere le cose semplici, consideriamo \\(n\\) pari e potenza di due (nel caso \\(n\\) sia dispari, il calcolo della complessit\u00e0 non cambia molto). Notiamo poi che l'esecuzione del merge sort su un array ad \\(n\\) elementi richieder\u00e0 (approssimativamente) lo stesso tempo dell'esecuzione di due merge sort su array ad \\(n/2\\) elementi, ciascuno dei quali richiede il doppio dell'esecuzione del merge sort su un array ad \\(n/4\\) elementi, e cos\u00ec via. Ricordando che il merge sort pu\u00f2 essere visto come un albero binario, \u00e8 evidente come ad ogni livello successivo dell'albero il numero di problemi raddoppi , mentre il tempo necessario alla risoluzione di un singolo problema si dimezzi . Questi due effetti si annullano reciprocamente, per cui potremo dire che, ad ogni livello, avremo bisogno al pi\u00f9 di \\(n\\) operazioni. Il tempo totale necessario \u00e8 quindi considerando un \\(O(n)\\) per ogni livello dell'albero prodotto dal merge sort. Con \\(c\\) livelli, avremo che il tempo totale necessario sar\u00e0 al pi\u00f9 \\(c \\cdot n\\) . Qual \u00e8 quindi il valore di \\(c\\) ? Dato che stiamo parlando di un albero binario, e che stiamo considerando un valore di \\(n\\) pari e potenza di due, sappiamo che \\(c = log_2n\\) . Di conseguenza, il tempo necessario per il merge sort sar\u00e0 dato da \\(n\\) (ovvero il numero di operazioni da effettuare a ciascun livello) moltiplicato per \\(c\\) (il numero di livelli), ovvero un \\(O(n \\cdot log_n2)\\) .","title":"Analisi di caso peggiore"},{"location":"02_dispense/05_algoritmi/05_quick_sort/","text":"Descrizione dell'algoritmo \u00b6 Cos\u00ec come il merge sort, il quick sort utilizza l'approccio divide-and-conquer , ed \u00e8 ovviamente un algoritmo di tipo ricorsivo. Tuttavia, laddove nel merge sort lo step divide \u00e8 praticamente ininfluente, ed \u00e8 il combine ad essere quello pi\u00f9 rilevante per il riordinamento, nel quick sort i ruoli si invertono. Ecco quindi come si articolano i tre diversi step del divide-and-conquer nel quick sort. Divide e procedura di partitioning \u00b6 Nel passo divide , scegliamo un elemento dell'array array[l,r] chiamato elemento pivot . A questo punto, gli elementi presenti nell'array saranno disposti in modo che: tutti gli elementi minori o uguali del pivot siano alla sua sinistra ; tutti gli elementi strettamente maggiori del pivot siano alla sua destra . Questa procedura \u00e8 chiamata partitioning (partizionamento). Nota Non ci interessa l'ordine relativo degli elementi a sinistra o a destra del pivot. Nella pratica, vedremo come conviene scegliere come pivot sempre l'elemento pi\u00f9 a destra nell'array, ovvero array[r] . Ad esempio, con il nostro array [8, 4, 5, 12, 7] , il pivot ad essere scelto alla prima iterazione sar\u00e0 proprio il 7 . Dopo il partizionamento, l'array sar\u00e0 riscritto come [4, 5, 7, 8, 12] , ed indicheremo con q il nuovo indice del pivot (in questo caso, q = 2 ). Nota Il fatto che siamo riusciti a riordinare l'array in una sola mossa \u00e8 puramente fortuito. Conquer \u00b6 Nel passo conquer ordiniamo in maniera ricorsiva gli array array[l, q-1] (ovvero tutti gli elementi minori o uguali al pivot) ed array[q+1, r] (ovvero tutti gli elementi maggiori del pivot). Combine \u00b6 Come accennato in precedenza, il passo combine non fa effettivamente niente, dato che tutti gli elementi a sinistra del pivot saranno ordinati, e lo stesso varr\u00e0 per gli elementi a destra dello stesso. Partitioning \u00b6 Abbiamo visto che il \"lavoro\" vero e proprio dell'algoritmo di quick sort avviene durante lo step divide ; ricordiamo inoltre che \u00e8 opportuno scegliere come pivot l'elemento pi\u00f9 a destra nell'array sotto analisi. Dopo aver scelto il pivot, dividiamo il nostro array come segue. Per prima cosa, usiamo due indici, chiamati \\(q\\) e \\(j\\) , per dividere l'array in quattro gruppi. La variabile q sar\u00e0 quella che contiene il riferimento all'indice nel quale inseriremo il pivot; la variabile j invece sar\u00e0 usata come contatore. In particolare, avremo: un gruppo \\(L\\) , in cui saranno inseriti tutti gli elementi di array[l, q-1] (ovvero quelli minori o uguali al pivot); un gruppo \\(G\\) , in cui saranno inseriti tutti gli elementi di array[q+1, j-1] (ovvero quelli maggiori del pivot); un gruppo \\(U\\) , in cui saranno inseriti tutti gli elementi di array[j, r-1] (ovvero quelli la cui relazione con il pivot non \u00e8 conosciuta perch\u00e9 non ancora comparati). Il pivot \u00e8 contraddistinto con array[r] . All'inizio, sia q sia j sono uguali ad l . Ad ogni step, si compara array[j] , ovvero l'elemento pi\u00f9 a sinistra del gruppo \\(U\\) , con il pivot. Se array[j] \u00e8 maggiore del pivot, ci limitiamo ad incrementare il valore di j ; se invece array[j] \u00e8 inferiore al pivot, allora lo sostituiamo con array[q] , aumentando contestualmente j e q . Una volta arrivati al pivot, il gruppo \\(U\\) risulta essere vuoto. A quel punto, sostituiamo il pivot con l'elemento pi\u00f9 a sinistra del gruppo \\(G\\) , ovvero sostituendo array[r] con array[q] . Questo cambio mette il pivot sempre tra i gruppi \\(L\\) e \\(G\\) . Analisi computazionale \u00b6 Analisi del partitioning \u00b6 Il partitioning di un array ad n elementi si effettua in \\(O(n)\\) . Questo \u00e8 legato al fatto che ogni elemento array[j] viene comparato una volta sola con il pivot; a seguito della comparazione, pu\u00f2 avvenire uno swap, q pu\u00f2 essere incrementato o meno, e j \u00e8 sempre incrementato. Analisi di caso peggiore \u00b6 Partiamo dall'analisi di caso peggiore. Supponiamo infatti che le dimensioni delle partizioni non siano bilanciate, e che il pivot scelto sia l'elemento pi\u00f9 piccolo o grande dell'array. Di conseguenza, una delle partizioni non avr\u00e0 alcun elemento, mentre l'altra ne avr\u00e0 \\(n-1\\) (ovvero tutti tranne il pivot). Di conseguenza, dovremo valutare ricorsivamente un array ad \\(n-i\\) elementi, con \\(1 \\leq i \\leq n\\) . Notiamo quindi che, in questo caso, avremo una serie del tipo \\(n + (n - 1) + \\ldots + 2 + 1\\) , che abbiamo visto essere in un \\(O(n^2)\\) . Analisi di caso migliore \u00b6 Nel caso migliore, le partizioni sono ben bilanciate. Ad esempio, potremmo trovarci nel caso in cui l'array analizzato ha un numero dispari di elementi, ed il pivot si trova esattamente al centro dopo il primo partitioning, per cui ogni partizione ha \\((n-1)/2\\) elementi. Oppure ancora, avendo un numero pari di elementi, avremo che la partizione di sinistra avr\u00e0 \\(n/2\\) elementi, mentre quella di destra \\((n - 2)/2\\) . In questi casi, l'albero \u00e8 facilmente riconducibile a quello del merge sort, per cui la complessit\u00e0 \u00e8 in \\(O(n \\cdot log_2n)\\) .","title":"18 - Quick sort"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#descrizione-dellalgoritmo","text":"Cos\u00ec come il merge sort, il quick sort utilizza l'approccio divide-and-conquer , ed \u00e8 ovviamente un algoritmo di tipo ricorsivo. Tuttavia, laddove nel merge sort lo step divide \u00e8 praticamente ininfluente, ed \u00e8 il combine ad essere quello pi\u00f9 rilevante per il riordinamento, nel quick sort i ruoli si invertono. Ecco quindi come si articolano i tre diversi step del divide-and-conquer nel quick sort.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#divide-e-procedura-di-partitioning","text":"Nel passo divide , scegliamo un elemento dell'array array[l,r] chiamato elemento pivot . A questo punto, gli elementi presenti nell'array saranno disposti in modo che: tutti gli elementi minori o uguali del pivot siano alla sua sinistra ; tutti gli elementi strettamente maggiori del pivot siano alla sua destra . Questa procedura \u00e8 chiamata partitioning (partizionamento). Nota Non ci interessa l'ordine relativo degli elementi a sinistra o a destra del pivot. Nella pratica, vedremo come conviene scegliere come pivot sempre l'elemento pi\u00f9 a destra nell'array, ovvero array[r] . Ad esempio, con il nostro array [8, 4, 5, 12, 7] , il pivot ad essere scelto alla prima iterazione sar\u00e0 proprio il 7 . Dopo il partizionamento, l'array sar\u00e0 riscritto come [4, 5, 7, 8, 12] , ed indicheremo con q il nuovo indice del pivot (in questo caso, q = 2 ). Nota Il fatto che siamo riusciti a riordinare l'array in una sola mossa \u00e8 puramente fortuito.","title":"Divide e procedura di partitioning"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#conquer","text":"Nel passo conquer ordiniamo in maniera ricorsiva gli array array[l, q-1] (ovvero tutti gli elementi minori o uguali al pivot) ed array[q+1, r] (ovvero tutti gli elementi maggiori del pivot).","title":"Conquer"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#combine","text":"Come accennato in precedenza, il passo combine non fa effettivamente niente, dato che tutti gli elementi a sinistra del pivot saranno ordinati, e lo stesso varr\u00e0 per gli elementi a destra dello stesso.","title":"Combine"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#partitioning","text":"Abbiamo visto che il \"lavoro\" vero e proprio dell'algoritmo di quick sort avviene durante lo step divide ; ricordiamo inoltre che \u00e8 opportuno scegliere come pivot l'elemento pi\u00f9 a destra nell'array sotto analisi. Dopo aver scelto il pivot, dividiamo il nostro array come segue. Per prima cosa, usiamo due indici, chiamati \\(q\\) e \\(j\\) , per dividere l'array in quattro gruppi. La variabile q sar\u00e0 quella che contiene il riferimento all'indice nel quale inseriremo il pivot; la variabile j invece sar\u00e0 usata come contatore. In particolare, avremo: un gruppo \\(L\\) , in cui saranno inseriti tutti gli elementi di array[l, q-1] (ovvero quelli minori o uguali al pivot); un gruppo \\(G\\) , in cui saranno inseriti tutti gli elementi di array[q+1, j-1] (ovvero quelli maggiori del pivot); un gruppo \\(U\\) , in cui saranno inseriti tutti gli elementi di array[j, r-1] (ovvero quelli la cui relazione con il pivot non \u00e8 conosciuta perch\u00e9 non ancora comparati). Il pivot \u00e8 contraddistinto con array[r] . All'inizio, sia q sia j sono uguali ad l . Ad ogni step, si compara array[j] , ovvero l'elemento pi\u00f9 a sinistra del gruppo \\(U\\) , con il pivot. Se array[j] \u00e8 maggiore del pivot, ci limitiamo ad incrementare il valore di j ; se invece array[j] \u00e8 inferiore al pivot, allora lo sostituiamo con array[q] , aumentando contestualmente j e q . Una volta arrivati al pivot, il gruppo \\(U\\) risulta essere vuoto. A quel punto, sostituiamo il pivot con l'elemento pi\u00f9 a sinistra del gruppo \\(G\\) , ovvero sostituendo array[r] con array[q] . Questo cambio mette il pivot sempre tra i gruppi \\(L\\) e \\(G\\) .","title":"Partitioning"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-computazionale","text":"","title":"Analisi computazionale"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-del-partitioning","text":"Il partitioning di un array ad n elementi si effettua in \\(O(n)\\) . Questo \u00e8 legato al fatto che ogni elemento array[j] viene comparato una volta sola con il pivot; a seguito della comparazione, pu\u00f2 avvenire uno swap, q pu\u00f2 essere incrementato o meno, e j \u00e8 sempre incrementato.","title":"Analisi del partitioning"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-di-caso-peggiore","text":"Partiamo dall'analisi di caso peggiore. Supponiamo infatti che le dimensioni delle partizioni non siano bilanciate, e che il pivot scelto sia l'elemento pi\u00f9 piccolo o grande dell'array. Di conseguenza, una delle partizioni non avr\u00e0 alcun elemento, mentre l'altra ne avr\u00e0 \\(n-1\\) (ovvero tutti tranne il pivot). Di conseguenza, dovremo valutare ricorsivamente un array ad \\(n-i\\) elementi, con \\(1 \\leq i \\leq n\\) . Notiamo quindi che, in questo caso, avremo una serie del tipo \\(n + (n - 1) + \\ldots + 2 + 1\\) , che abbiamo visto essere in un \\(O(n^2)\\) .","title":"Analisi di caso peggiore"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-di-caso-migliore","text":"Nel caso migliore, le partizioni sono ben bilanciate. Ad esempio, potremmo trovarci nel caso in cui l'array analizzato ha un numero dispari di elementi, ed il pivot si trova esattamente al centro dopo il primo partitioning, per cui ogni partizione ha \\((n-1)/2\\) elementi. Oppure ancora, avendo un numero pari di elementi, avremo che la partizione di sinistra avr\u00e0 \\(n/2\\) elementi, mentre quella di destra \\((n - 2)/2\\) . In questi casi, l'albero \u00e8 facilmente riconducibile a quello del merge sort, per cui la complessit\u00e0 \u00e8 in \\(O(n \\cdot log_2n)\\) .","title":"Analisi di caso migliore"},{"location":"02_dispense/05_algoritmi/06_bfs/","text":"Descrizione dell'algoritmo \u00b6 La ricerca in ampiezza , o, in inglese, breath-first search ( BFS ), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi. Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\) , oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi. Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda . Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi. BFS sugli alberi \u00b6 Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero. La BFS opera considerando due parametri: il nodo attualmente ispezionato; i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato. In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i il nodo radice , ovvero quello da cui parte la ricerca; la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice; il predecessore del nodo Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore \u00e8 la distanza , che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\) . Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8. Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\) , la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste. TODO: esempio vertice isolato Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\) . TODO: ESEMPIO SU ALBERO Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null. L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda. In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue(). TODO: esempio su albero Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\) . In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\) . Analisi della BFS \u00b6 Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\) ? La risposta \u00e8 un tempo pari a \\(O(V + E)\\) . Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\) , che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi: \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\) , allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\) . Se, per\u00f2, abbiamo \\(|E| < |V|\\) , allora: \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\) . Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\) . In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\) , \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\) . Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\) ? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a null , per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.","title":"06 bfs"},{"location":"02_dispense/05_algoritmi/06_bfs/#descrizione-dellalgoritmo","text":"La ricerca in ampiezza , o, in inglese, breath-first search ( BFS ), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi. Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\) , oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi. Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda . Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/06_bfs/#bfs-sugli-alberi","text":"Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero. La BFS opera considerando due parametri: il nodo attualmente ispezionato; i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato. In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i il nodo radice , ovvero quello da cui parte la ricerca; la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice; il predecessore del nodo Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore \u00e8 la distanza , che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\) . Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8. Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\) , la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste. TODO: esempio vertice isolato Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\) . TODO: ESEMPIO SU ALBERO Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null. L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda. In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue(). TODO: esempio su albero Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\) . In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\) .","title":"BFS sugli alberi"},{"location":"02_dispense/05_algoritmi/06_bfs/#analisi-della-bfs","text":"Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\) ? La risposta \u00e8 un tempo pari a \\(O(V + E)\\) . Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\) , che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi: \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\) , allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\) . Se, per\u00f2, abbiamo \\(|E| < |V|\\) , allora: \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\) . Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\) . In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\) , \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\) . Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\) ? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a null , per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.","title":"Analisi della BFS"},{"location":"02_dispense/06_modelli/01_turing/","text":"Modelli di calcolo \u00b6 Con il termine modello di calcolo rappresentiamo tutte quelle macchine, astratte o reali, in grado di risolvere degli algoritmi. E' quindi bene premettere che non esiste un modello di calcolo univoco : ogni modello adotta un esecutore con caratteristiche e capacit\u00e0 variabili, il che porta ad un approccio differente alla risoluzione di un problema. Dall'altro lato, basarsi su un modello di calcolo comune \u00e8 necessario per confrontare l'efficienza di diversi algoritmi, ed \u00e8 quindi un ottimo modo di integrare le nostre capacit\u00e0 di analisi computazionale a priori . Nonostante esistano quindi diversi modelli, alcuni dei quali recenti o in fase di sviluppo, come ad esempio il quantum computing o il DNA computing , il modello di riferimento in informatica \u00e8 sempre stato, e probabilmente rimarr\u00e0, la macchina di Turing . Macchina di Turing \u00b6 Ideata nel 1936 da uno dei \"padri\" dell'informatica, il famoso matematico inglese Alan Turing, la macchina di Turing \u00e8 un modello di calcolo astratto composto essenzialmente da due componenti: in primis, un nastro infinito , che opera da dispositivo di memorizzazione (in pratica, tramite il nastro, la macchina pu\u00f2 accedere alle informazioni); in secundis, una testina di lettura e scrittura che, scorrendo sul nastro, pu\u00f2 leggerne e modificarne il contenuto. Nota La macchina di Turing \u00e8 un modello astratto, ma non c'\u00e8 alcun modello astratto che i Lego non possano rappresentare, come dimostra la seguente figura. La macchina di Turing funziona modificando il suo stato sulla base del contenuto (o simbolo ) presente sul nastro in corrispondenza della testina. Infatti, la macchina valuta il contenuto della posizione corrente del nastro ed il suo stato interno attuale; a partire da questi, \u00e8 in grado di passare in un altro stato, eventualmente accedendo in scrittura al nastro, e scorrendo sullo stesso a destra o sinistra. Questo ci permette di definire la macchina di Turing come un Automa a Stati Finiti Deterministico . Automa a Stati Finiti Deterministico La definizione formale di Automa a Stati Finiti Deterministico esula dagli obiettivi del corso. Tuttavia, possiamo darne una rapida definizione informale , come \"macchina\" che pu\u00f2 avere un numero finito di possibili stati interni, ognuno dei quali \u00e8 determinato a partire dallo stato precedente e dalla lettura del nastro in posizione attuale. Nastro inifinto ed ASFD Da notare che il fatto che il nastro abbia lunghezza infinita non modifica il fatto che gli stati raggiungibili siano in quantit\u00e0 finita. Risoluzione di problemi mediante la macchina di Turing \u00b6 La risoluzione di un problema (e, quindi, la definizione di un algoritmo atto a risolverlo) richiede la progettazione di un'adeguata macchina di Turing. In tal senso, \u00e8 necessario definire almeno cinque parametri: un alfabeto \\(\\Sigma\\) dei simboli che \u00e8 possibile scrivere (leggere) sul (dal) nastro; un insieme di stati \\(S\\) in cui si pu\u00f2 trovare la macchina; uno stato iniziale \\(s_0\\) nel quale la macchina si trova inizialmente, con \\(s_o \\in S\\) ; un insieme di stati finali \\(S_f\\) nel quale la macchina si arresta, con \\(S_f \\in S\\) ; una funzione di transizione \\(\\delta\\) che determina il passaggio da uno stato ad un altro. La funzione di transizione pu\u00f2 essere definita come segue: \\[ \\delta: \\langle \\sigma_I, s_I \\rangle \\rightarrow \\langle t, \\sigma_F, s_F \\rangle \\] dove: \\(\\sigma_I\\) \u00e8 il simbolo letto dalla testina sul nastro; \\(\\s_I\\) \u00e8 lo stato della macchina di Turing antecedente la transizione; \\(t\\) \u00e8 la transizione che verr\u00e0 applicata al nastro (es. scorrimento verso destra o sinistra); \\(\\sigma_f\\) \u00e8 il simbolo scritto dalla testina sul nastro dopo la transizione; \\(\\s_F\\) \u00e8 lo stato della macchina di Turing successivo alla transizione. Formalmente, \u00e8 possibile definire una macchina di Turing \\(T\\) come: \\[ T = \\langle \\Sigma, S, s_0, S_f, \\delta \\rangle \\] Un esempio \u00b6 Vediamo come \u00e8 possibile risolvere un problema mediante una macchina di Turing. Per farlo, utilizzeremo un grafo degli stati per rappresentare l'automa. Il nostro problema \u00e8 quello di valutare se una stringa contiene il carattere \\(a\\) . Per questo, definiamo una macchina di Turing nel seguente modo: l'alfabeto \\(\\Sigma\\) sar\u00e0 dato da tutte le lettere dell'alfabeto inglese, pi\u00f9 il simbolo #, che indica la fine della stringa; l'insieme degli stati \\(S\\) sar\u00e0 dato da \\({s_0, s_1, s_T, s_F}\\) ; lo stato iniziale \u00e8 \\(s_0\\) (stringa non contenente \\(a\\) ); gli stati finali sono \\(s_T\\) (vero) ed \\(s_F\\) (falso). La strategia risolutiva ci permette di individuare la funzione \\(\\delta\\) . Infatti: partiamo dal primo carattere della stringa, e scorriamo il nastro verso destra; se incontriamo il carattere \\(a\\) , la macchina entra nello stato \\(s_1\\) , e ivi permane. Il nastro continua a scorrere verso destra fino a che non trova il carattere #, al quale si sposta in \\(s_T\\) ; se non incontriamo il carattere \\(a\\) , scorriamo il nastro fino al carattere #, al quale si sposta in \\(s_F\\) . Ci\u00f2 definisce la seguente funzione di transizione (in formato matriciale): \\(s_0\\) \\(s_1\\) \\(s_T\\) \\(s_F\\) \\(a\\) \\(\\langle D, s_1, - \\rangle\\) $ \\(\\langle D, s_1, - \\rangle\\) / / \\(b-z\\) \\(\\langle D, s_0, - \\rangle\\) \\(\\langle D, s_1, - \\rangle\\) / / # \\(\\langle -, s_F, - \\rangle\\) \\(\\langle -, s_T, - \\rangle\\) / / L'automa a stati finiti corrispondente sar\u00e0: Tesi di Church-Turing \u00b6 Abbiamo detto che la macchina di Turing \u00e8 un modello di riferimento . Ci\u00f2 significa che \u00e8 possibile dimostrare che tutti i diversi tipi di modello sono equiva\u00f2enti , e quindi un problema risolvibile usando la macchina di Turing \u00e8 risolvibile mediante qualsiasi modello di calcolo, astratto o reale. La tesi di Church - Turing afferma che: Tesi di Church - Turing Se un problema \u00e8 umanamente calcolabile, allora esister\u00e0 una macchina di Turing in grado di risolverlo (cio\u00e8 di calcolarlo) E' importante sottolineare come questa sia solo una tesi , e non un teorema .","title":"20 - Macchina di Turing"},{"location":"02_dispense/06_modelli/01_turing/#modelli-di-calcolo","text":"Con il termine modello di calcolo rappresentiamo tutte quelle macchine, astratte o reali, in grado di risolvere degli algoritmi. E' quindi bene premettere che non esiste un modello di calcolo univoco : ogni modello adotta un esecutore con caratteristiche e capacit\u00e0 variabili, il che porta ad un approccio differente alla risoluzione di un problema. Dall'altro lato, basarsi su un modello di calcolo comune \u00e8 necessario per confrontare l'efficienza di diversi algoritmi, ed \u00e8 quindi un ottimo modo di integrare le nostre capacit\u00e0 di analisi computazionale a priori . Nonostante esistano quindi diversi modelli, alcuni dei quali recenti o in fase di sviluppo, come ad esempio il quantum computing o il DNA computing , il modello di riferimento in informatica \u00e8 sempre stato, e probabilmente rimarr\u00e0, la macchina di Turing .","title":"Modelli di calcolo"},{"location":"02_dispense/06_modelli/01_turing/#macchina-di-turing","text":"Ideata nel 1936 da uno dei \"padri\" dell'informatica, il famoso matematico inglese Alan Turing, la macchina di Turing \u00e8 un modello di calcolo astratto composto essenzialmente da due componenti: in primis, un nastro infinito , che opera da dispositivo di memorizzazione (in pratica, tramite il nastro, la macchina pu\u00f2 accedere alle informazioni); in secundis, una testina di lettura e scrittura che, scorrendo sul nastro, pu\u00f2 leggerne e modificarne il contenuto. Nota La macchina di Turing \u00e8 un modello astratto, ma non c'\u00e8 alcun modello astratto che i Lego non possano rappresentare, come dimostra la seguente figura. La macchina di Turing funziona modificando il suo stato sulla base del contenuto (o simbolo ) presente sul nastro in corrispondenza della testina. Infatti, la macchina valuta il contenuto della posizione corrente del nastro ed il suo stato interno attuale; a partire da questi, \u00e8 in grado di passare in un altro stato, eventualmente accedendo in scrittura al nastro, e scorrendo sullo stesso a destra o sinistra. Questo ci permette di definire la macchina di Turing come un Automa a Stati Finiti Deterministico . Automa a Stati Finiti Deterministico La definizione formale di Automa a Stati Finiti Deterministico esula dagli obiettivi del corso. Tuttavia, possiamo darne una rapida definizione informale , come \"macchina\" che pu\u00f2 avere un numero finito di possibili stati interni, ognuno dei quali \u00e8 determinato a partire dallo stato precedente e dalla lettura del nastro in posizione attuale. Nastro inifinto ed ASFD Da notare che il fatto che il nastro abbia lunghezza infinita non modifica il fatto che gli stati raggiungibili siano in quantit\u00e0 finita.","title":"Macchina di Turing"},{"location":"02_dispense/06_modelli/01_turing/#risoluzione-di-problemi-mediante-la-macchina-di-turing","text":"La risoluzione di un problema (e, quindi, la definizione di un algoritmo atto a risolverlo) richiede la progettazione di un'adeguata macchina di Turing. In tal senso, \u00e8 necessario definire almeno cinque parametri: un alfabeto \\(\\Sigma\\) dei simboli che \u00e8 possibile scrivere (leggere) sul (dal) nastro; un insieme di stati \\(S\\) in cui si pu\u00f2 trovare la macchina; uno stato iniziale \\(s_0\\) nel quale la macchina si trova inizialmente, con \\(s_o \\in S\\) ; un insieme di stati finali \\(S_f\\) nel quale la macchina si arresta, con \\(S_f \\in S\\) ; una funzione di transizione \\(\\delta\\) che determina il passaggio da uno stato ad un altro. La funzione di transizione pu\u00f2 essere definita come segue: \\[ \\delta: \\langle \\sigma_I, s_I \\rangle \\rightarrow \\langle t, \\sigma_F, s_F \\rangle \\] dove: \\(\\sigma_I\\) \u00e8 il simbolo letto dalla testina sul nastro; \\(\\s_I\\) \u00e8 lo stato della macchina di Turing antecedente la transizione; \\(t\\) \u00e8 la transizione che verr\u00e0 applicata al nastro (es. scorrimento verso destra o sinistra); \\(\\sigma_f\\) \u00e8 il simbolo scritto dalla testina sul nastro dopo la transizione; \\(\\s_F\\) \u00e8 lo stato della macchina di Turing successivo alla transizione. Formalmente, \u00e8 possibile definire una macchina di Turing \\(T\\) come: \\[ T = \\langle \\Sigma, S, s_0, S_f, \\delta \\rangle \\]","title":"Risoluzione di problemi mediante la macchina di Turing"},{"location":"02_dispense/06_modelli/01_turing/#un-esempio","text":"Vediamo come \u00e8 possibile risolvere un problema mediante una macchina di Turing. Per farlo, utilizzeremo un grafo degli stati per rappresentare l'automa. Il nostro problema \u00e8 quello di valutare se una stringa contiene il carattere \\(a\\) . Per questo, definiamo una macchina di Turing nel seguente modo: l'alfabeto \\(\\Sigma\\) sar\u00e0 dato da tutte le lettere dell'alfabeto inglese, pi\u00f9 il simbolo #, che indica la fine della stringa; l'insieme degli stati \\(S\\) sar\u00e0 dato da \\({s_0, s_1, s_T, s_F}\\) ; lo stato iniziale \u00e8 \\(s_0\\) (stringa non contenente \\(a\\) ); gli stati finali sono \\(s_T\\) (vero) ed \\(s_F\\) (falso). La strategia risolutiva ci permette di individuare la funzione \\(\\delta\\) . Infatti: partiamo dal primo carattere della stringa, e scorriamo il nastro verso destra; se incontriamo il carattere \\(a\\) , la macchina entra nello stato \\(s_1\\) , e ivi permane. Il nastro continua a scorrere verso destra fino a che non trova il carattere #, al quale si sposta in \\(s_T\\) ; se non incontriamo il carattere \\(a\\) , scorriamo il nastro fino al carattere #, al quale si sposta in \\(s_F\\) . Ci\u00f2 definisce la seguente funzione di transizione (in formato matriciale): \\(s_0\\) \\(s_1\\) \\(s_T\\) \\(s_F\\) \\(a\\) \\(\\langle D, s_1, - \\rangle\\) $ \\(\\langle D, s_1, - \\rangle\\) / / \\(b-z\\) \\(\\langle D, s_0, - \\rangle\\) \\(\\langle D, s_1, - \\rangle\\) / / # \\(\\langle -, s_F, - \\rangle\\) \\(\\langle -, s_T, - \\rangle\\) / / L'automa a stati finiti corrispondente sar\u00e0:","title":"Un esempio"},{"location":"02_dispense/06_modelli/01_turing/#tesi-di-church-turing","text":"Abbiamo detto che la macchina di Turing \u00e8 un modello di riferimento . Ci\u00f2 significa che \u00e8 possibile dimostrare che tutti i diversi tipi di modello sono equiva\u00f2enti , e quindi un problema risolvibile usando la macchina di Turing \u00e8 risolvibile mediante qualsiasi modello di calcolo, astratto o reale. La tesi di Church - Turing afferma che: Tesi di Church - Turing Se un problema \u00e8 umanamente calcolabile, allora esister\u00e0 una macchina di Turing in grado di risolverlo (cio\u00e8 di calcolarlo) E' importante sottolineare come questa sia solo una tesi , e non un teorema .","title":"Tesi di Church-Turing"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/","text":"Cosa \u00e8 C? \u00b6 Il linguaggio C \u00e8 un linguaggio ad alto livello inizialmente sviluppato da Dennis M. Ritchie nell'ambito dello sviluppo del sistema operativo UNIX ai Bell Labs. La sua prima implementazione risale al 1972 su un computer DEC PDP-11. Il primo draft disponibile venne reso disponibile al grande pubblico nel 1978, in quello che \u00e8 conosciuto al giorno d'oggi come K&R standard ; venne poi formalizzato dall' American National Standard Institute ( ANSI ) nel 1988. Al giorno d'oggi, C \u00e8 uno dei linguaggi di programmazioni maggiormente utilizzati. Le sue applicazioni sono estese, e vanno dai sistemi operativi, ai compilatori, ai text editor, passando per database e programmi ottimizzati per smartphone. Vediamo insieme la struttura di un primo programma in C. Hello, C! \u00b6 La Via dell'Informatico ci impone di partire in maniera abbastanza classica, andando a definire un primo, rudimentale, ma famigerato programma: l' Hello, World . #include <stdio.h> int main () { // Ora sono un programmatore! printf ( \"Hello, World! \\n \" ); return 0 ; } Ecco fatto, semplice, vero? Beh, certo, per\u00f2, nonostante la loro semplicit\u00e0, in queste poche righe di codice sono racchiusi tutti i concetti fondamentali a scrivere programmi ben pi\u00f9 complessi. Vediamole una ad una. #include \u00b6 La prima istruzione \u00e8 una direttiva . Se ricordate, \u00e8 proprio una di quelle parti di codice che vengono pre-elaborate dal compilatore. In particolare, questa \u00e8 una direttiva include , che prevede un parametro che pu\u00f2 essere incluso tra i simboli < e > , oppure tra doppi apici, e rappresenta il nome di un file. Quando il compilatore incontra una include , cerca il file specificato (in questo caso, stdio.h , che fa parte dello \"standard\" dettato dal C), e ne copia integralmente il contenuto nel file che andr\u00e0 poi al front end del compilatore. L'uso dei simboli < e > non \u00e8 intercambiabile con quello dei doppi apici: infatti, nel primo caso, la ricerca avviene all'interno della directory in cui si trovano i file di intestazione della libreria standard di C (torneremo in avanti sul concetto di libreria), mentre nel secondo la ricerca avviene all'interno della directory corrente. int main() \u00b6 Questa istruzione \u00e8 la firma di una particolare funzione, ovvero il main() . La funzione main sarebbe una normalissima funzione, se non fosse per un piccolo dettaglio: rappresenta infatti il punto di accesso di un programma, ovvero la parte di codice che verr\u00e0 effettivamente eseguita a runtime, richiamando e componendo alla bisogna le altre istruzioni e funzioni invocate dal programma. // Questo \u00e8 un commento \u00b6 Le istruzioni che hanno preposti due caratteri di slash ( // ) sono chiamate commenti . Queste righe permettono al programmatore di inserire dei \"suggerimenti\" per spiegare meglio il codice ad altri sviluppatori (o per ricordare in futuro cosa si era fatto). Questo tipo di commento \u00e8 a singola linea; esistono anche i commenti multilinea: /* * Questo \u00e8 un commento multilinea! */ // E questo \u00e8 un commento a linea singola! printf(\"Hello, World! \\n\") \u00b6 Questa istruzione richiama una funzione integrata nel file stdio.h che abbiamo invocato in precedenza nella direttiva include , ovvero la funzione printf . Questa accetta in ingresso una stringa (logicamente equivalente ad un array di char), ovvero \"Hello, World! \\n\" , e la stampa a schermo (spesso in una shell). Interessante notare la presenza di un escape character , ovvero \\n , che indica al compilatore di andare a capo dopo il termine della stringa. return 0 \u00b6 La funzione main() prevede in uscita un valore intero; di conseguenza, il return 0 indica il termine del main() stesso. Per convenzione, il return 0 indica il successo del programma, mentre altri valori di ritorno possono indicare degli errori intercorsi durante l'esecuzione.","title":"01 - Introduzione al C"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/#cosa-e-c","text":"Il linguaggio C \u00e8 un linguaggio ad alto livello inizialmente sviluppato da Dennis M. Ritchie nell'ambito dello sviluppo del sistema operativo UNIX ai Bell Labs. La sua prima implementazione risale al 1972 su un computer DEC PDP-11. Il primo draft disponibile venne reso disponibile al grande pubblico nel 1978, in quello che \u00e8 conosciuto al giorno d'oggi come K&R standard ; venne poi formalizzato dall' American National Standard Institute ( ANSI ) nel 1988. Al giorno d'oggi, C \u00e8 uno dei linguaggi di programmazioni maggiormente utilizzati. Le sue applicazioni sono estese, e vanno dai sistemi operativi, ai compilatori, ai text editor, passando per database e programmi ottimizzati per smartphone. Vediamo insieme la struttura di un primo programma in C.","title":"Cosa \u00e8 C?"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/#hello-c","text":"La Via dell'Informatico ci impone di partire in maniera abbastanza classica, andando a definire un primo, rudimentale, ma famigerato programma: l' Hello, World . #include <stdio.h> int main () { // Ora sono un programmatore! printf ( \"Hello, World! \\n \" ); return 0 ; } Ecco fatto, semplice, vero? Beh, certo, per\u00f2, nonostante la loro semplicit\u00e0, in queste poche righe di codice sono racchiusi tutti i concetti fondamentali a scrivere programmi ben pi\u00f9 complessi. Vediamole una ad una.","title":"Hello, C!"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/#include","text":"La prima istruzione \u00e8 una direttiva . Se ricordate, \u00e8 proprio una di quelle parti di codice che vengono pre-elaborate dal compilatore. In particolare, questa \u00e8 una direttiva include , che prevede un parametro che pu\u00f2 essere incluso tra i simboli < e > , oppure tra doppi apici, e rappresenta il nome di un file. Quando il compilatore incontra una include , cerca il file specificato (in questo caso, stdio.h , che fa parte dello \"standard\" dettato dal C), e ne copia integralmente il contenuto nel file che andr\u00e0 poi al front end del compilatore. L'uso dei simboli < e > non \u00e8 intercambiabile con quello dei doppi apici: infatti, nel primo caso, la ricerca avviene all'interno della directory in cui si trovano i file di intestazione della libreria standard di C (torneremo in avanti sul concetto di libreria), mentre nel secondo la ricerca avviene all'interno della directory corrente.","title":"#include"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/#int-main","text":"Questa istruzione \u00e8 la firma di una particolare funzione, ovvero il main() . La funzione main sarebbe una normalissima funzione, se non fosse per un piccolo dettaglio: rappresenta infatti il punto di accesso di un programma, ovvero la parte di codice che verr\u00e0 effettivamente eseguita a runtime, richiamando e componendo alla bisogna le altre istruzioni e funzioni invocate dal programma.","title":"int main()"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/#questo-e-un-commento","text":"Le istruzioni che hanno preposti due caratteri di slash ( // ) sono chiamate commenti . Queste righe permettono al programmatore di inserire dei \"suggerimenti\" per spiegare meglio il codice ad altri sviluppatori (o per ricordare in futuro cosa si era fatto). Questo tipo di commento \u00e8 a singola linea; esistono anche i commenti multilinea: /* * Questo \u00e8 un commento multilinea! */ // E questo \u00e8 un commento a linea singola!","title":"// Questo \u00e8 un commento"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/#printfhello-world-n","text":"Questa istruzione richiama una funzione integrata nel file stdio.h che abbiamo invocato in precedenza nella direttiva include , ovvero la funzione printf . Questa accetta in ingresso una stringa (logicamente equivalente ad un array di char), ovvero \"Hello, World! \\n\" , e la stampa a schermo (spesso in una shell). Interessante notare la presenza di un escape character , ovvero \\n , che indica al compilatore di andare a capo dopo il termine della stringa.","title":"printf(\"Hello, World! \\n\")"},{"location":"02_dispense/07_linguaggio_c/01_introduzione/#return-0","text":"La funzione main() prevede in uscita un valore intero; di conseguenza, il return 0 indica il termine del main() stesso. Per convenzione, il return 0 indica il successo del programma, mentre altri valori di ritorno possono indicare degli errori intercorsi durante l'esecuzione.","title":"return 0"},{"location":"02_dispense/07_linguaggio_c/02_nozioni/","text":"Parole riservate \u00b6 In ogni linguaggio di programmazione esiste una serie di parole riservate , o keyword , che indicano delle specifiche funzionalit\u00e0 dello stesso, e che pertanto non possono essere in alcun modo utilizzate dall'utente. Normalmente, queste parole chiave sono quelle relative a fattori come il tipo di una variabile, oppure ancora dei particolari attributi assegnabili ad una struttura dati o ad una funzione. Ad esempio, proviamo ad esempio a creare la seguente variabile in C: int int = 10 ; Provando a compilare, Visual Studio ci dar\u00e0 i seguenti messaggi di errore: error C2632: 'int' non pu\u00f2 essere seguito da 'int' error C2513: 'int' : nessuna variabile dichiarata prima di '=' Per una lista di keyword usate nei vari linguaggi, controllare l'appendice D. Modularit\u00e0, prototipi e file header \u00b6","title":"02 nozioni"},{"location":"02_dispense/07_linguaggio_c/02_nozioni/#parole-riservate","text":"In ogni linguaggio di programmazione esiste una serie di parole riservate , o keyword , che indicano delle specifiche funzionalit\u00e0 dello stesso, e che pertanto non possono essere in alcun modo utilizzate dall'utente. Normalmente, queste parole chiave sono quelle relative a fattori come il tipo di una variabile, oppure ancora dei particolari attributi assegnabili ad una struttura dati o ad una funzione. Ad esempio, proviamo ad esempio a creare la seguente variabile in C: int int = 10 ; Provando a compilare, Visual Studio ci dar\u00e0 i seguenti messaggi di errore: error C2632: 'int' non pu\u00f2 essere seguito da 'int' error C2513: 'int' : nessuna variabile dichiarata prima di '=' Per una lista di keyword usate nei vari linguaggi, controllare l'appendice D.","title":"Parole riservate"},{"location":"02_dispense/07_linguaggio_c/02_nozioni/#modularita-prototipi-e-file-header","text":"","title":"Modularit\u00e0, prototipi e file header"},{"location":"02_dispense/07_linguaggio_c/07_file/","text":"Il concetto di stream \u00b6 Il linguaggio C (e, di conseguenza, anche il C++) adotta il concetto di stream come base per favorire i meccanismi di input ed output rispettivamente da e verso l'utente. Cosa \u00e8 un file? \u00b6 Possiamo definire un file come un insieme di dati, i quali vengono organizzati e memorizzati sulla maniera ordinata. Il C riconosce due categorie di file: i file di testo ed i file binari . I file di testo sono formati da una sequenza di caratteri organizzati in linee , ciascuna delle quali termina con il carattere \\n ; i file binari, invece, sono costituiti da una sequenza di byte. Accedere ad un file C \u00b6 Per accedere ad un file in C, possiamo usare due diverse modalit\u00e0. La prima \u00e8 l'accesso sequenziale : in questo modo, possiamo accedere ad un elemento scorrendo tutti quelli precedenti. La seconda \u00e8 invece l'accesso casuale , o diretto , che permette di raggiungere un elemento direttamente. Il linguaggio C crea un livello intermedio tra il programma e il file che prende il nome di stream , nel quale si memorizzano le informazioni da gestire. Dunque, il nostro programma non gestisce direttamente il file, quanto piuttosto lo stream , che ha il compito di filtrare le istruzioni. puntatore a FILE \u00b6 per accedere ad un file occorre usare un puntatore a FILE, ovvero un indirizzo di memoria o locazione iniziale del file cui si vuole accedere. FILE \u00e8 un tipo definito nell'header stdio.h. La sintassi \u00e8: #include <stdio.h> // ... FILE * fp ; fopen in C \u00b6 la funzione fopen in C serve ad aprire un file in diverse modalit\u00e0. La sintassi \u00e8 la seguente: FILE fopen(char nomefile, char *modo) I modi sono diversi, ed in particolare: | Modo | Funzione | Creazione file | | -- | -- | |-- | | r | Apre un file in lettura | No (file deve esistere) | | r+ | Apre un file esistente in lettura/scrittura | No (file deve esistere) | | w | Crea un nuovo file in scrittura; se il file esiste, viene cancellato il contenuto | S\u00ec. Se il file esiste, viene cancellato il contenuto. | | w+ | Crea un nuovo file in lettura/scrittura; se il file esiste, wiene cancellato il contentuo | S\u00ec, se il file esiste viene cancellato il contenuto | | a | Aggiunge alla fine del file. Se non esiste, crealo. | S\u00ec | | a+ | Aggiunge e legge a partire dalla fine del file. | S\u00ec (se non esiste viene creato) | E' inoltre possibile specificare il tipo di file usando, rispettivament,e le lettere b o t (binario o di testo). Di default, si usa il valore t. Un esempio di uso \u00e8 il seguente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } Notiamo come controlliamo che il file esiste. Una possibile causa di fallimento potrebbe essere usare la modalit\u00e0 r su un file che non esiste. fclose \u00b6 La funzione fclose serve a chiudere un file dopo averlo utilizzato, di modo da rendere lo stream disponibile per altri utilizzo. La sintassi \u00e8 la seguente: int fclose ( FILE * fp ) La funzione restituisce un valore intero. se tutto \u00e8 andato a buon fine, viene restituito 0; in alternativa, viene restituito EOF, che \u00e8 un valore costante. Volendo estendere il programma precedente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } // uso fclose ( fp ); Nota Tutti i file vengono chiusi in maniera automatica se il programma termina regolarmente; in questi casi, non \u00e8 necessaria la funzione fclose. fprintf \u00b6 La funzione fprintf permette di scrivere sul file in modo formattato dopo l'apertura dello stesso con fopen. Questa funzione \u00e8 molto simile quindi alla printf, ed opera sullo stream del file aperto con la funzione fopen. La sintassi della funzione \u00e8 la seguente: int fprintf ( FILE * fp , char * format , [ args ]) In pratica, \u00e8 analoga alla printf, se non per due differenze: la prima \u00e8 che accetta come primo argomento un puntatore a file; la seconda \u00e8 che restituisce un valore di ritorno, ovvero un intero. Il valore di ritorno della fprintf \u00e8 il numero di caratteri scritti nello stream in caso di successo o un EOF in caso di errore. #include <stdio.h> #include <stdlib.h> int main () { FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } fprintf ( fp , \"Il file esiste!\" ); fclose ( fp ); } scanf \u00b6 La funzione scanf ci permette di acquisire una sequenza di caratteri (lettere o cifre) dalla tastiera e memorizzarla in una variabile opportuna. E' la funzione duale della printf. La sua sintassi \u00e8 la seguente: scanf ( char * format , [ args ]) dove: format rappresenta uno o pi\u00f9 specificatori di formato args rappresenta uno o pi\u00f9 riferimenti alle variabili da popolare. Ad esempio: scanf ( \"%d%, &x) far\u00e0 s\u00ec che il valore passato da tastiera sia salvato nella variabile di tipo intero x, mentre: scanf ( \"%d %f\" , & x , & y ) legger\u00e0 un intero ed un decimale andandoli a mettere nelle variabili x ed y rispettivamente. fscanf \u00b6 La funzione fscanf serve a leggere un file in modo formattato, chiaramente dopo l'apertura con fopen. E', come la fprintf, l'equivalente sugli stream della scanf. La differenza in questo caso \u00e8 anche qui valutabile andando ad esaminare il prootipo della funzione: int fscanf ( FILE * fp , char * format , [ args ]) Notiamo infatti che viene restituito un intero, che rappresenta il numero di caratteri letti, e che come primo argomento viene passato il puntatore al file di riferimento. feof \u00b6 La funzione feof infine serve a sapere se ci troviamo alla fine di un file. Questa \u00e8 definita come segue: int feof ( FILE * fp ) e restituisce 0 se non \u00e8 stata raggiunta laf ine del file, o true altrimenti. Possiamo farlo per leggere nel file fino a che non abbiamo raggiunto la fine dello stesso. Un esempio \u00e8 il seguente: #include <stdio.h> #include <stdlib.h> #define N 5 int main () { FILE * fp ; char cognome [ 20 ]; char nome [ 20 ]; int i , voto ; if (( fp = fopen ( \"alunni.txt\" , \"rt\" )) == NULL ) { printf ( \"Errore nell'apertura del file'\" ); exit ( 1 ); } while ( ! feof ( fp )){ fscanf ( fp , \"%s %s %d \\n \" , & cognome , & nome , & voto ); printf ( \"cognome: %s, nome: %s, voto: %d \\n \" , cognome , nome , voto ); } fclose ( fp ); return 0 ; }","title":"07 file"},{"location":"02_dispense/07_linguaggio_c/07_file/#il-concetto-di-stream","text":"Il linguaggio C (e, di conseguenza, anche il C++) adotta il concetto di stream come base per favorire i meccanismi di input ed output rispettivamente da e verso l'utente.","title":"Il concetto di stream"},{"location":"02_dispense/07_linguaggio_c/07_file/#cosa-e-un-file","text":"Possiamo definire un file come un insieme di dati, i quali vengono organizzati e memorizzati sulla maniera ordinata. Il C riconosce due categorie di file: i file di testo ed i file binari . I file di testo sono formati da una sequenza di caratteri organizzati in linee , ciascuna delle quali termina con il carattere \\n ; i file binari, invece, sono costituiti da una sequenza di byte.","title":"Cosa \u00e8 un file?"},{"location":"02_dispense/07_linguaggio_c/07_file/#accedere-ad-un-file-c","text":"Per accedere ad un file in C, possiamo usare due diverse modalit\u00e0. La prima \u00e8 l'accesso sequenziale : in questo modo, possiamo accedere ad un elemento scorrendo tutti quelli precedenti. La seconda \u00e8 invece l'accesso casuale , o diretto , che permette di raggiungere un elemento direttamente. Il linguaggio C crea un livello intermedio tra il programma e il file che prende il nome di stream , nel quale si memorizzano le informazioni da gestire. Dunque, il nostro programma non gestisce direttamente il file, quanto piuttosto lo stream , che ha il compito di filtrare le istruzioni.","title":"Accedere ad un file C"},{"location":"02_dispense/07_linguaggio_c/07_file/#puntatore-a-file","text":"per accedere ad un file occorre usare un puntatore a FILE, ovvero un indirizzo di memoria o locazione iniziale del file cui si vuole accedere. FILE \u00e8 un tipo definito nell'header stdio.h. La sintassi \u00e8: #include <stdio.h> // ... FILE * fp ;","title":"puntatore a FILE"},{"location":"02_dispense/07_linguaggio_c/07_file/#fopen-in-c","text":"la funzione fopen in C serve ad aprire un file in diverse modalit\u00e0. La sintassi \u00e8 la seguente: FILE fopen(char nomefile, char *modo) I modi sono diversi, ed in particolare: | Modo | Funzione | Creazione file | | -- | -- | |-- | | r | Apre un file in lettura | No (file deve esistere) | | r+ | Apre un file esistente in lettura/scrittura | No (file deve esistere) | | w | Crea un nuovo file in scrittura; se il file esiste, viene cancellato il contenuto | S\u00ec. Se il file esiste, viene cancellato il contenuto. | | w+ | Crea un nuovo file in lettura/scrittura; se il file esiste, wiene cancellato il contentuo | S\u00ec, se il file esiste viene cancellato il contenuto | | a | Aggiunge alla fine del file. Se non esiste, crealo. | S\u00ec | | a+ | Aggiunge e legge a partire dalla fine del file. | S\u00ec (se non esiste viene creato) | E' inoltre possibile specificare il tipo di file usando, rispettivament,e le lettere b o t (binario o di testo). Di default, si usa il valore t. Un esempio di uso \u00e8 il seguente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } Notiamo come controlliamo che il file esiste. Una possibile causa di fallimento potrebbe essere usare la modalit\u00e0 r su un file che non esiste.","title":"fopen in C"},{"location":"02_dispense/07_linguaggio_c/07_file/#fclose","text":"La funzione fclose serve a chiudere un file dopo averlo utilizzato, di modo da rendere lo stream disponibile per altri utilizzo. La sintassi \u00e8 la seguente: int fclose ( FILE * fp ) La funzione restituisce un valore intero. se tutto \u00e8 andato a buon fine, viene restituito 0; in alternativa, viene restituito EOF, che \u00e8 un valore costante. Volendo estendere il programma precedente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } // uso fclose ( fp ); Nota Tutti i file vengono chiusi in maniera automatica se il programma termina regolarmente; in questi casi, non \u00e8 necessaria la funzione fclose.","title":"fclose"},{"location":"02_dispense/07_linguaggio_c/07_file/#fprintf","text":"La funzione fprintf permette di scrivere sul file in modo formattato dopo l'apertura dello stesso con fopen. Questa funzione \u00e8 molto simile quindi alla printf, ed opera sullo stream del file aperto con la funzione fopen. La sintassi della funzione \u00e8 la seguente: int fprintf ( FILE * fp , char * format , [ args ]) In pratica, \u00e8 analoga alla printf, se non per due differenze: la prima \u00e8 che accetta come primo argomento un puntatore a file; la seconda \u00e8 che restituisce un valore di ritorno, ovvero un intero. Il valore di ritorno della fprintf \u00e8 il numero di caratteri scritti nello stream in caso di successo o un EOF in caso di errore. #include <stdio.h> #include <stdlib.h> int main () { FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } fprintf ( fp , \"Il file esiste!\" ); fclose ( fp ); }","title":"fprintf"},{"location":"02_dispense/07_linguaggio_c/07_file/#scanf","text":"La funzione scanf ci permette di acquisire una sequenza di caratteri (lettere o cifre) dalla tastiera e memorizzarla in una variabile opportuna. E' la funzione duale della printf. La sua sintassi \u00e8 la seguente: scanf ( char * format , [ args ]) dove: format rappresenta uno o pi\u00f9 specificatori di formato args rappresenta uno o pi\u00f9 riferimenti alle variabili da popolare. Ad esempio: scanf ( \"%d%, &x) far\u00e0 s\u00ec che il valore passato da tastiera sia salvato nella variabile di tipo intero x, mentre: scanf ( \"%d %f\" , & x , & y ) legger\u00e0 un intero ed un decimale andandoli a mettere nelle variabili x ed y rispettivamente.","title":"scanf"},{"location":"02_dispense/07_linguaggio_c/07_file/#fscanf","text":"La funzione fscanf serve a leggere un file in modo formattato, chiaramente dopo l'apertura con fopen. E', come la fprintf, l'equivalente sugli stream della scanf. La differenza in questo caso \u00e8 anche qui valutabile andando ad esaminare il prootipo della funzione: int fscanf ( FILE * fp , char * format , [ args ]) Notiamo infatti che viene restituito un intero, che rappresenta il numero di caratteri letti, e che come primo argomento viene passato il puntatore al file di riferimento.","title":"fscanf"},{"location":"02_dispense/07_linguaggio_c/07_file/#feof","text":"La funzione feof infine serve a sapere se ci troviamo alla fine di un file. Questa \u00e8 definita come segue: int feof ( FILE * fp ) e restituisce 0 se non \u00e8 stata raggiunta laf ine del file, o true altrimenti. Possiamo farlo per leggere nel file fino a che non abbiamo raggiunto la fine dello stesso. Un esempio \u00e8 il seguente: #include <stdio.h> #include <stdlib.h> #define N 5 int main () { FILE * fp ; char cognome [ 20 ]; char nome [ 20 ]; int i , voto ; if (( fp = fopen ( \"alunni.txt\" , \"rt\" )) == NULL ) { printf ( \"Errore nell'apertura del file'\" ); exit ( 1 ); } while ( ! feof ( fp )){ fscanf ( fp , \"%s %s %d \\n \" , & cognome , & nome , & voto ); printf ( \"cognome: %s, nome: %s, voto: %d \\n \" , cognome , nome , voto ); } fclose ( fp ); return 0 ; }","title":"feof"},{"location":"02_dispense/07_linguaggio_c/08_typedef/","text":"Nel linguaggio C, le struct sono usate per raggrupapre diversi tipi di varaibili sotto lo stesso nome. Ad esempio, potremmo creare una struttura \"persona\", fatta da due stringhe ed un intero. struct persona { char * nome ; char * cognome ; int eta ; }; Con la dichiarazione della struttura abbiamno creato un nuovo tipo chiamato persona. Prima di poter usare il tipo telefono, occorre creare una variabile del tipo telefono. Ad esempio: #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona pippo ; return 0 ; } Per accedere ai membri della struttura persona, dobbiamo inserire un punto tra il nome della struttura e quello della variabile. #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona studente ; studente . nome = \"Piero\" ; studente . cognome = \"Scamarcio\" ; studente . eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente . name , studente . cognome , studente . eta ); return 0 ; } typedef \u00b6 Le definizioni di tipo rendono anche possibile creare i nostri tipi di variabile. Ad esempio, possiamo creare un tipo che rappresenta un puntatore a double. #include <stdio.h> typedef double * double_pointer ; int main () { double val = 0.0 ; double_pointer pointer = & val ; printf ( \"Il valore del puntatore e': %p\" , pointer ); return 0 ; } Questa tecnica pu\u00f2 anche essere estesa alle struct. Ci\u00f2 significa che: #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA pippo ; return 0 ; } otiamo che il nome del tipo associaot alla sturttura \u00e8 quello indicato in maiuscolo immediatamente dopo alla stessa. Puntatori a strutture \u00b6 Possiamo usare anche dei puntatori a strutture. In questo caso, per accedere alla singola propriet\u00e0 della struct, dovremo usare l'operatore infix (->) #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA studente ; PERSONA * puntatore_studente ; studente -> nome = \"Piero\" ; // Prima era studente.nome! studente -> cognome = \"Scamarcio\" ; studente -> eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente -> name , studente -> cognome , studente -> eta ); return 0 ; } Union \u00b6 Le union sono analoghe alle struct dal punto di vista della sintassi, semplicemente per\u00f2 implementano delle strutture dati differenti. Un esempio \u00e8 il seguente. #include <stdio.h> typedef union lettura_sensore { double d ; int i ; } LETTURA_SENSORE ; int main () { LETTURA_SENSORE lettura ; lettura . d = 12.0 ; lettura . i = 5 ; }","title":"08 typedef"},{"location":"02_dispense/07_linguaggio_c/08_typedef/#typedef","text":"Le definizioni di tipo rendono anche possibile creare i nostri tipi di variabile. Ad esempio, possiamo creare un tipo che rappresenta un puntatore a double. #include <stdio.h> typedef double * double_pointer ; int main () { double val = 0.0 ; double_pointer pointer = & val ; printf ( \"Il valore del puntatore e': %p\" , pointer ); return 0 ; } Questa tecnica pu\u00f2 anche essere estesa alle struct. Ci\u00f2 significa che: #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA pippo ; return 0 ; } otiamo che il nome del tipo associaot alla sturttura \u00e8 quello indicato in maiuscolo immediatamente dopo alla stessa.","title":"typedef"},{"location":"02_dispense/07_linguaggio_c/08_typedef/#puntatori-a-strutture","text":"Possiamo usare anche dei puntatori a strutture. In questo caso, per accedere alla singola propriet\u00e0 della struct, dovremo usare l'operatore infix (->) #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA studente ; PERSONA * puntatore_studente ; studente -> nome = \"Piero\" ; // Prima era studente.nome! studente -> cognome = \"Scamarcio\" ; studente -> eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente -> name , studente -> cognome , studente -> eta ); return 0 ; }","title":"Puntatori a strutture"},{"location":"02_dispense/07_linguaggio_c/08_typedef/#union","text":"Le union sono analoghe alle struct dal punto di vista della sintassi, semplicemente per\u00f2 implementano delle strutture dati differenti. Un esempio \u00e8 il seguente. #include <stdio.h> typedef union lettura_sensore { double d ; int i ; } LETTURA_SENSORE ; int main () { LETTURA_SENSORE lettura ; lettura . d = 12.0 ; lettura . i = 5 ; }","title":"Union"},{"location":"02_dispense/08_linguaggio_cpp/01_c_vs_cpp/","text":"Partiamo con quello che, probabilmente, rappresenta il concetto pi\u00f9 importante da sottolineare, ovvero: Affermazione importantissima Il C++ \u00e8 un superset del C. Ci\u00f2 significa, banalmente, che le istruzioni che abbiamo visto ed usato finora in C definiscono un sottoinsieme del C++. Di conseguenza, i due linguaggi condividono una sintassi ed una semantica comune; ci\u00f2 tuttavia non deve trarre in inganno, perch\u00e9 il C++ utilizza diversi concetti avanzati che il C non ha a sua disposizione. Vediamoli insieme. Concetti generali \u00b6 In primis, vediamo riassunte nella seguente tabella alcune differenze fondamentali che intercorrono tra i due linguaggi. Argomento C C++ Keyword 32 52 Paradigma di programmazione Imperativo Imperativo/OOP Focus principale Metodi e processi Dati Tipi definiti dall'utente Supporto limitato con typedef Pieno supporto mediante le classi Gestione delle eccezioni Non presente Presente Nella precedente tabella, vediamo un semplice dato \"numerico\", dato dal maggior numero di keyword a disposizione per il C++; ci\u00f2 indica la presenza di una sintassi comunque pi\u00f9 ricca ed articolata, necessaria a supportare alcuni concetti avanzati non a disposizione del C. La prima differenza di peso sta nel paradigma di programmazione utilizzato: laddove il C infatti utilizza esclusivamente il concetto di programmazione imperativa, il C++ permette di sfruttare la potenza della programmazione orientata agli oggetti (in inglese, object oriented programming , OOP ). Conseguenza naturale \u00e8 il focus del programma: laddove in C l'obiettivo \u00e8 modellare il processo alla base del nostro algoritmo, nel C++ \u00e8 necessario focalizzarsi sui dati che viaggiano da un'istruzione all'altra. Altra cosa importante da considerare \u00e8 il supporto ai tipi definiti dall'utente. Anche C lo offriva: abbiamo infatti visto che, grazie alla parola chiave typedef , \u00e8 possibile definire tipi personalizzati anche abbastanza complessi usando adeguatamente struct ed union. Tuttavia, C++ riesce a potenziare gli strumenti in mano al programmatore grazie al concetto di classe . In ultimo, a differenza del C, il C++ \u00e8 in grado di gestire situazioni inattese grazie al meccanismo delle eccezioni , che ci permettono di \"verificare\" il risultato di una serie di istruzioni, gestendo direttamente nel codice sorgente eventuali errori insorti. Concetti legati alla OOP \u00b6 Ed \u00e8 qui che arriviamo al \"succo\" delle differenze tra C e C++, ovvero quelle che nascono dall'adesione di quest'ultimo al paradigma OOP. Vediamole brevemente riassunte nella seguente tabella. Argomento C C++ Namespace Non definito Definito Allocazione dinamica della memoria malloc() e calloc() new() e delete() Rapporto tra variabili e funzioni Separate Incapsulate negli oggetti Modificatori di accesso No S\u00ec La prima importante differenza \u00e8 quella legata all'adozione, da parte del C++, del concetto di namespace , utile ad evitare delle \"collisioni\" di dominio. In parole povere, usare i namespace permette di diminuire drasticamente le ambiguit\u00e0 presenti nel codice. La seconda importante differenza \u00e8 quella legata ai meccanismi di allocazione dinamica della memoria: in C, questi vengono gestiti mediante l'utilizzo di funzioni come malloc() , calloc() e free() , mentre nel C++ ci si concentra sugli operatori di creazione e distruzione degli oggetti. Altre importanti differenze stanno nel rapporto tra variabili e funzioni, che in C++ fanno largo uso del concetto di incapsulamento per evitare l'accesso da parte di codice esterno e, potenzialmente, dannoso, e nell'utilizzo dei modificatori di accesso per regolare la visibilit\u00e0 di un attributo o di una funzione di una classe. In generale, per\u00f2, i concetti maggiormente importanti sono tre, ovvero incapsulamento , polimorfismo ed ereditariet\u00e0 ; li vedremo pi\u00f9 avanti, quando parleremo pi\u00f9 estesamente della programmazione orientata agli oggetti.","title":"01 - C vs. C++"},{"location":"02_dispense/08_linguaggio_cpp/01_c_vs_cpp/#concetti-generali","text":"In primis, vediamo riassunte nella seguente tabella alcune differenze fondamentali che intercorrono tra i due linguaggi. Argomento C C++ Keyword 32 52 Paradigma di programmazione Imperativo Imperativo/OOP Focus principale Metodi e processi Dati Tipi definiti dall'utente Supporto limitato con typedef Pieno supporto mediante le classi Gestione delle eccezioni Non presente Presente Nella precedente tabella, vediamo un semplice dato \"numerico\", dato dal maggior numero di keyword a disposizione per il C++; ci\u00f2 indica la presenza di una sintassi comunque pi\u00f9 ricca ed articolata, necessaria a supportare alcuni concetti avanzati non a disposizione del C. La prima differenza di peso sta nel paradigma di programmazione utilizzato: laddove il C infatti utilizza esclusivamente il concetto di programmazione imperativa, il C++ permette di sfruttare la potenza della programmazione orientata agli oggetti (in inglese, object oriented programming , OOP ). Conseguenza naturale \u00e8 il focus del programma: laddove in C l'obiettivo \u00e8 modellare il processo alla base del nostro algoritmo, nel C++ \u00e8 necessario focalizzarsi sui dati che viaggiano da un'istruzione all'altra. Altra cosa importante da considerare \u00e8 il supporto ai tipi definiti dall'utente. Anche C lo offriva: abbiamo infatti visto che, grazie alla parola chiave typedef , \u00e8 possibile definire tipi personalizzati anche abbastanza complessi usando adeguatamente struct ed union. Tuttavia, C++ riesce a potenziare gli strumenti in mano al programmatore grazie al concetto di classe . In ultimo, a differenza del C, il C++ \u00e8 in grado di gestire situazioni inattese grazie al meccanismo delle eccezioni , che ci permettono di \"verificare\" il risultato di una serie di istruzioni, gestendo direttamente nel codice sorgente eventuali errori insorti.","title":"Concetti generali"},{"location":"02_dispense/08_linguaggio_cpp/01_c_vs_cpp/#concetti-legati-alla-oop","text":"Ed \u00e8 qui che arriviamo al \"succo\" delle differenze tra C e C++, ovvero quelle che nascono dall'adesione di quest'ultimo al paradigma OOP. Vediamole brevemente riassunte nella seguente tabella. Argomento C C++ Namespace Non definito Definito Allocazione dinamica della memoria malloc() e calloc() new() e delete() Rapporto tra variabili e funzioni Separate Incapsulate negli oggetti Modificatori di accesso No S\u00ec La prima importante differenza \u00e8 quella legata all'adozione, da parte del C++, del concetto di namespace , utile ad evitare delle \"collisioni\" di dominio. In parole povere, usare i namespace permette di diminuire drasticamente le ambiguit\u00e0 presenti nel codice. La seconda importante differenza \u00e8 quella legata ai meccanismi di allocazione dinamica della memoria: in C, questi vengono gestiti mediante l'utilizzo di funzioni come malloc() , calloc() e free() , mentre nel C++ ci si concentra sugli operatori di creazione e distruzione degli oggetti. Altre importanti differenze stanno nel rapporto tra variabili e funzioni, che in C++ fanno largo uso del concetto di incapsulamento per evitare l'accesso da parte di codice esterno e, potenzialmente, dannoso, e nell'utilizzo dei modificatori di accesso per regolare la visibilit\u00e0 di un attributo o di una funzione di una classe. In generale, per\u00f2, i concetti maggiormente importanti sono tre, ovvero incapsulamento , polimorfismo ed ereditariet\u00e0 ; li vedremo pi\u00f9 avanti, quando parleremo pi\u00f9 estesamente della programmazione orientata agli oggetti.","title":"Concetti legati alla OOP"},{"location":"02_dispense/08_linguaggio_cpp/02_stl/","text":"","title":"02 stl"},{"location":"03_appendici/d_keyword/","text":"Lista di keyword per il linguaggio C \u00b6 Nota La lista \u00e8 in aggiornamento. Keyword Uso auto break case Usata in un costrutto switch - case. char Indica un tipo primitivo. const continue default do else Usata in una struttura condizionale. float for goto if Usata in una struttura condizionale. int long register return short signed sizeof static struct switch typedef union unsigned void volatile while Usata in una struttura iterativa.","title":"D keyword"},{"location":"03_appendici/d_keyword/#lista-di-keyword-per-il-linguaggio-c","text":"Nota La lista \u00e8 in aggiornamento. Keyword Uso auto break case Usata in un costrutto switch - case. char Indica un tipo primitivo. const continue default do else Usata in una struttura condizionale. float for goto if Usata in una struttura condizionale. int long register return short signed sizeof static struct switch typedef union unsigned void volatile while Usata in una struttura iterativa.","title":"Lista di keyword per il linguaggio C"},{"location":"03_appendici/configurazioni/a_vs_code_guide/","text":"Installazione e configurazione di C/C++ \u00b6 Una volta installato il software Visual Studio Code (VS Code), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni. Installazione del supporto \u00b6 Per prima cosa, installiamo l'estensione C/C++. Per farlo, selezioniamo da VS Code il menu \"Estensioni\", oppure premiamo la combinazione Ctrl + Maiusc + X , e quindi scriviamo c/c++ nella barra di ricerca. Selezioniamo quella ufficiale di Microsoft ed installiamola seguendo la procedura guidata. Useremo il compilatore ufficiale fornito da Microsoft per Visual Studio. Per scaricarlo, usiamo questo link . In alternativa, qualora questo link non fosse funzionante, dobbiamo andare dalla pagina di download per Visual Studio, e cercare nella pagina Strumenti per Visual Studio > Build Tools for Visual Studio . Installiamo il programma scaricato al passo precedente. Una volta terminata l'installazione, eseguiamo il programma Visual Studio Installer . Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica . Verifica dell'installazione \u00b6 Apriamo la Developer Command Prompt for VS , cercandola dal menu Start, come mostrato in figura. Verifichiamo che il compilatore sia installato digitando cl da riga di comando e premendo Invio . Creazione di un progetto di esempio \u00b6 Creiamo ora un progetto di esempio. Navighiamo in una cartella a nostra scelta (ad esempio C:\\progetti\\informatica ) digitando, da shell, il seguente comando: cd C:/progetti/informatica A questo punto, creiamo una cartella helloworld , spostiamoci all'interno di essa, e lanciamo Visual Studio Code: mkdir helloworld cd helloworld code . Si aprir\u00e0 una nuova schermata di Visual Studio Code. Creiamo un file chiamato helloworld.c e scriviamo il seguente codice. #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; } Compilazione del progetto \u00b6 Per compilare il progetto, scegliamo dal menu principale l'opzione Terminal > Configure Default Build Task (l'ultima opzione). Apparir\u00e0 un men\u00f9 a scorrimento; scegliamo l'opzione cl.exe build active file , come mostrato in figura. A questo punto, sar\u00e0 creato un file tasks.json all'interno di una cartella .vscode . Possiamo configurarlo come meglio ci aggrada; per i nostri scopi, per\u00f2, potremo lasciare la configurazione di default. Torniamo al nostro file helloworld.c , e compiliamo premendo la combinaziont Ctrl + Maiusc + B . Se escono a schermo i messaggi mostrati nella seguente figura, avremo completato correttamente la configurazione. Attenzione! Potremmo ricevere un errore che ci comunica che non \u00e8 stato possibile trovare cl.exe . In questo caso, basta riavviare Visual Studio Code dal prompt degli sviluppatori che abbiamo aperto in precedenza, recandoci all'interno della cartella di progetto e scrivendo l'istruzione code .","title":"Visual Studio Code"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#installazione-e-configurazione-di-cc","text":"Una volta installato il software Visual Studio Code (VS Code), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni.","title":"Installazione e configurazione di C/C++"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#installazione-del-supporto","text":"Per prima cosa, installiamo l'estensione C/C++. Per farlo, selezioniamo da VS Code il menu \"Estensioni\", oppure premiamo la combinazione Ctrl + Maiusc + X , e quindi scriviamo c/c++ nella barra di ricerca. Selezioniamo quella ufficiale di Microsoft ed installiamola seguendo la procedura guidata. Useremo il compilatore ufficiale fornito da Microsoft per Visual Studio. Per scaricarlo, usiamo questo link . In alternativa, qualora questo link non fosse funzionante, dobbiamo andare dalla pagina di download per Visual Studio, e cercare nella pagina Strumenti per Visual Studio > Build Tools for Visual Studio . Installiamo il programma scaricato al passo precedente. Una volta terminata l'installazione, eseguiamo il programma Visual Studio Installer . Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica .","title":"Installazione del supporto"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#verifica-dellinstallazione","text":"Apriamo la Developer Command Prompt for VS , cercandola dal menu Start, come mostrato in figura. Verifichiamo che il compilatore sia installato digitando cl da riga di comando e premendo Invio .","title":"Verifica dell'installazione"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#creazione-di-un-progetto-di-esempio","text":"Creiamo ora un progetto di esempio. Navighiamo in una cartella a nostra scelta (ad esempio C:\\progetti\\informatica ) digitando, da shell, il seguente comando: cd C:/progetti/informatica A questo punto, creiamo una cartella helloworld , spostiamoci all'interno di essa, e lanciamo Visual Studio Code: mkdir helloworld cd helloworld code . Si aprir\u00e0 una nuova schermata di Visual Studio Code. Creiamo un file chiamato helloworld.c e scriviamo il seguente codice. #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; }","title":"Creazione di un progetto di esempio"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#compilazione-del-progetto","text":"Per compilare il progetto, scegliamo dal menu principale l'opzione Terminal > Configure Default Build Task (l'ultima opzione). Apparir\u00e0 un men\u00f9 a scorrimento; scegliamo l'opzione cl.exe build active file , come mostrato in figura. A questo punto, sar\u00e0 creato un file tasks.json all'interno di una cartella .vscode . Possiamo configurarlo come meglio ci aggrada; per i nostri scopi, per\u00f2, potremo lasciare la configurazione di default. Torniamo al nostro file helloworld.c , e compiliamo premendo la combinaziont Ctrl + Maiusc + B . Se escono a schermo i messaggi mostrati nella seguente figura, avremo completato correttamente la configurazione. Attenzione! Potremmo ricevere un errore che ci comunica che non \u00e8 stato possibile trovare cl.exe . In questo caso, basta riavviare Visual Studio Code dal prompt degli sviluppatori che abbiamo aperto in precedenza, recandoci all'interno della cartella di progetto e scrivendo l'istruzione code .","title":"Compilazione del progetto"},{"location":"03_appendici/configurazioni/b_vs_community_guide/","text":"Installazione e configurazione di C/C++ \u00b6 Una volta installato il software Visual Studio Community (VS), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni. Installazione del supporto \u00b6 Per prima cosa, installiamo gli strumenti per lo sviluppo di applicazioni in C e C++. Eseguiamo il programma Visual Studio Installer dal menu Start. Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica . Creazione di un progetto \u00b6 Una volta installati i tool per lo sviluppo, eseguiamo il programma Visual Studio 2019 dal menu Start. Si aprir\u00e0 la seguente schermata: Selezioniamo l'opzione Crea un nuovo progetto . Apparir\u00e0 la seguente schermata: Selezioniamo prima App console C++ a sinistra, e poi Progetto vuoto o App Console a destra. Scegliamo quindi l'opzione Avanti . Diamo un nome al progetto (ad esempio, Primo progetto ) ed alla soluzione (ad esempio, Prima soluzione ), scegliamo la cartella in cui salvare il tutto, e scegliamo l'opzione Crea . Se abbiamo scelto App Console , apparir\u00e0 gi\u00e0 un progetto di esempio. Qualora scegliessimo Progetto vuoto , apparir\u00e0 la seguente schermata. In quest'ultimo caso, selezioniamo clicchiamo con il destro sulla cartella (mostrata nel menu a destra) chiamata File di origine e selezioniamo dal menu che appare Aggiungi > Nuovo Elemento . Da qui possiamo creare direttamente un file C++, oppure un file C modificandone manualmente l'estensione. Creiamo un file chiamato HelloWorld.c ed aggiungiamolo al nostro progetto. Aggiungiamo il seguente codice: #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; } Eseguiamo il nostro programma premendo Ctrl + F5, oppure scegliendo l'opzione Avvia senza eseguire Debug dal menu Debug . Se tutto \u00e8 andato a buon fine, apparir\u00e0 la seguente finestra:","title":"Visual Studio Community"},{"location":"03_appendici/configurazioni/b_vs_community_guide/#installazione-e-configurazione-di-cc","text":"Una volta installato il software Visual Studio Community (VS), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni.","title":"Installazione e configurazione di C/C++"},{"location":"03_appendici/configurazioni/b_vs_community_guide/#installazione-del-supporto","text":"Per prima cosa, installiamo gli strumenti per lo sviluppo di applicazioni in C e C++. Eseguiamo il programma Visual Studio Installer dal menu Start. Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica .","title":"Installazione del supporto"},{"location":"03_appendici/configurazioni/b_vs_community_guide/#creazione-di-un-progetto","text":"Una volta installati i tool per lo sviluppo, eseguiamo il programma Visual Studio 2019 dal menu Start. Si aprir\u00e0 la seguente schermata: Selezioniamo l'opzione Crea un nuovo progetto . Apparir\u00e0 la seguente schermata: Selezioniamo prima App console C++ a sinistra, e poi Progetto vuoto o App Console a destra. Scegliamo quindi l'opzione Avanti . Diamo un nome al progetto (ad esempio, Primo progetto ) ed alla soluzione (ad esempio, Prima soluzione ), scegliamo la cartella in cui salvare il tutto, e scegliamo l'opzione Crea . Se abbiamo scelto App Console , apparir\u00e0 gi\u00e0 un progetto di esempio. Qualora scegliessimo Progetto vuoto , apparir\u00e0 la seguente schermata. In quest'ultimo caso, selezioniamo clicchiamo con il destro sulla cartella (mostrata nel menu a destra) chiamata File di origine e selezioniamo dal menu che appare Aggiungi > Nuovo Elemento . Da qui possiamo creare direttamente un file C++, oppure un file C modificandone manualmente l'estensione. Creiamo un file chiamato HelloWorld.c ed aggiungiamolo al nostro progetto. Aggiungiamo il seguente codice: #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; } Eseguiamo il nostro programma premendo Ctrl + F5, oppure scegliendo l'opzione Avvia senza eseguire Debug dal menu Debug . Se tutto \u00e8 andato a buon fine, apparir\u00e0 la seguente finestra:","title":"Creazione di un progetto"},{"location":"04_esercizi/linguaggio_c/","text":"Esercizi svolti \u00b6 Questi esercizi sono svolti e disponibili a questo link . Nota! Il fatto che gli esercizi siano svolti non vuol essere un incoraggiamento a copiarne la soluzione. L'idea \u00e8 invece quella di usarla come riferimento , per confrontare il proprio approccio ad una tra le tante possibili risoluzioni. Modularit\u00e0 \u00b6 1. Matematicamente \u00b6 Creare il programma Matematicamente che contiene al suo interno due moduli: il modulo aritmetica , contenente le funzioni aggiungi e moltiplica ; il modulo trigonometria , contenente le funzioni seno e coseno . La descrizione delle funzioni \u00e8 la seguente: aggiungi restituisce la somma di due interi a e b ; moltiplica restituisce il prodotto di due interi a e b ; seno restituisce il seno di un angolo a partire dal suo coseno usando l'identit\u00e0 trigonometrica; coseno restituisce il coseno di un angolo a partire dal suo seno usando l'identit\u00e0 trigonometrica. Provare l'utilizzo dei due moduli. Visibilit\u00e0 delle variabili \u00b6 2. AreaPerimetro \u00b6 Creare il programma AreaPerimetro , che include due funzioni: la funzione calcola_area_quadrato restituisce l'area di un quadrato dato il lato; la funzione calcola_perimetro_quadrato restituisce il perimetro di un quadrato dato il lato. Si verifichi cosa accade se si prova ad accedere al valore del perimetro all'interno della funzione calcola_area_quadrato , e viceversa. Si utilizzi una variabile globale per impostare il valore del lato. Si utilizzi una variabile locale, il cui nome \u00e8 lo stesso di quello associato alla variabile globale, per impostare il valore del lato. Suggerimento Per verificare il valore di area e perimetro, si utilizzi la funzione printf . 3. ContatoreStatico \u00b6 Creare il programma ContatoreStatico che include una funzione conta() che, ogni volta che viene chiamata, incrementa il valore numerico intero associato ad un contatore. Fare in modo che: la funzione conta() non accetti in ingresso alcun parametro; il contatore sia una variabile locale alla funzione conta() . Suggerimento Si utilizzi in maniera appropriata la parola chiave static . 4. Operatori \u00b6 Parte 1: Quadratico \u00b6 Scriviamo il programma Quadratico , che include una funzione che, dato un valore intero in ingresso, ne calcola il quadrato e lo restituisce. Il valore restituito dovr\u00e0 essere stampato a schermo all'interno della funzione main . Parte 2: Pari e Dispari \u00b6 Scriviamo il programma PariDispari che, dato un valore intero in ingresso, valuta se questo \u00e8 pari mediante un'apposita funzione. Detta funzione restituir\u00e0 un valore booleano in uscita; se questo \u00e8 vero ( true ), avviser\u00e0 l'utente che il numero \u00e8 pari, altrimenti avviser\u00e0 l'utente che il numero \u00e8 dispari. Suggerimento Utilizzare l'header stdbool.h per gestire i valori booleani. In alternativa, ricordare che ogni intero diverso da 0 \u00e8 considerato come un true . Parte 3: Confrontiamoci \u00b6 Scriviamo il programma Confrontiamoci , che confronta due intervalli di valori di tipo \\([a,b]\\) e \\([c,d]\\) con \\((a,b,c,d)\\) numeri interi. Scriviamo in primis una funzione confronto_relazionale che dovr\u00e0: stampare a schermo il maggiore tra gli estremi inferiori \\(a\\) e \\(c\\) ; stampare a schermo il minore tra gli estremi superiori \\(b\\) e \\(d\\) ; stabilire se il numero di elementi all'interno dei due insiemi \u00e8 lo stesso. Successivamente, scriviamo una funzione confronto_logico che dovr\u00e0 verificare, usando solo operatori di logica booleana, se gli intervalli sopraccitati hanno lo stesso numero di elementi e gli estremi degli stessi coincidono, oppure se una sola di queste condizioni \u00e8 verificata. 5. Array \u00b6 Un tensore \u00e8 un array ad \\(n\\) dimensioni contenente valori arbitrari. Creare due tensori di dimensioni \\(3 \\times 3 \\times 3\\) , uno contenente valori interi, e l'altro contenente valori in formato double . Usare l'operatore sizeof per confrontare lo spazio occupato in memoria, visualizzando a schermo tutti i valori dell'array pi\u00f9 \"pesante\". Esercizi da svolgere \u00b6 Lo svolgimento di questi esercizi \u00e8 delegato allo studente. Modularit\u00e0 \u00b6 1. SimulAuto \u00b6 Creare il programma SimulAuto che contiene al suo interno due moduli: il modulo gestisci_velocita , contenente le funzioni accelera e decelera ; il modulo gestisci direzione , contenente la funzione sterza . Le funzioni sono descritte come segue: accelera restituisce la velocit\u00e0 raggiunta dopo t secondi a partire dalla velocit\u00e0 v_i applicando l'accelerazione a ; decelera restituisce la velocit\u00e0 raggiunta dopo t secondi a partire dalla velocit\u00e0 v_i applicando la decelerazione d ; sterza restituisce il nuovo angolo di sterzata a partire da quello attuale a e da quello applicato s . Nota Tutti i valori sono da considerarsi interi. Suggerimento Si consideri l'accelerazione pari ad: \\(a = \\frac{v_f - v_i}{t_f - t_i}\\) .","title":"Linguaggio C"},{"location":"04_esercizi/linguaggio_c/#esercizi-svolti","text":"Questi esercizi sono svolti e disponibili a questo link . Nota! Il fatto che gli esercizi siano svolti non vuol essere un incoraggiamento a copiarne la soluzione. L'idea \u00e8 invece quella di usarla come riferimento , per confrontare il proprio approccio ad una tra le tante possibili risoluzioni.","title":"Esercizi svolti"},{"location":"04_esercizi/linguaggio_c/#modularita","text":"","title":"Modularit\u00e0"},{"location":"04_esercizi/linguaggio_c/#1-matematicamente","text":"Creare il programma Matematicamente che contiene al suo interno due moduli: il modulo aritmetica , contenente le funzioni aggiungi e moltiplica ; il modulo trigonometria , contenente le funzioni seno e coseno . La descrizione delle funzioni \u00e8 la seguente: aggiungi restituisce la somma di due interi a e b ; moltiplica restituisce il prodotto di due interi a e b ; seno restituisce il seno di un angolo a partire dal suo coseno usando l'identit\u00e0 trigonometrica; coseno restituisce il coseno di un angolo a partire dal suo seno usando l'identit\u00e0 trigonometrica. Provare l'utilizzo dei due moduli.","title":"1. Matematicamente"},{"location":"04_esercizi/linguaggio_c/#visibilita-delle-variabili","text":"","title":"Visibilit\u00e0 delle variabili"},{"location":"04_esercizi/linguaggio_c/#2-areaperimetro","text":"Creare il programma AreaPerimetro , che include due funzioni: la funzione calcola_area_quadrato restituisce l'area di un quadrato dato il lato; la funzione calcola_perimetro_quadrato restituisce il perimetro di un quadrato dato il lato. Si verifichi cosa accade se si prova ad accedere al valore del perimetro all'interno della funzione calcola_area_quadrato , e viceversa. Si utilizzi una variabile globale per impostare il valore del lato. Si utilizzi una variabile locale, il cui nome \u00e8 lo stesso di quello associato alla variabile globale, per impostare il valore del lato. Suggerimento Per verificare il valore di area e perimetro, si utilizzi la funzione printf .","title":"2. AreaPerimetro"},{"location":"04_esercizi/linguaggio_c/#3-contatorestatico","text":"Creare il programma ContatoreStatico che include una funzione conta() che, ogni volta che viene chiamata, incrementa il valore numerico intero associato ad un contatore. Fare in modo che: la funzione conta() non accetti in ingresso alcun parametro; il contatore sia una variabile locale alla funzione conta() . Suggerimento Si utilizzi in maniera appropriata la parola chiave static .","title":"3. ContatoreStatico"},{"location":"04_esercizi/linguaggio_c/#4-operatori","text":"","title":"4. Operatori"},{"location":"04_esercizi/linguaggio_c/#parte-1-quadratico","text":"Scriviamo il programma Quadratico , che include una funzione che, dato un valore intero in ingresso, ne calcola il quadrato e lo restituisce. Il valore restituito dovr\u00e0 essere stampato a schermo all'interno della funzione main .","title":"Parte 1: Quadratico"},{"location":"04_esercizi/linguaggio_c/#parte-2-pari-e-dispari","text":"Scriviamo il programma PariDispari che, dato un valore intero in ingresso, valuta se questo \u00e8 pari mediante un'apposita funzione. Detta funzione restituir\u00e0 un valore booleano in uscita; se questo \u00e8 vero ( true ), avviser\u00e0 l'utente che il numero \u00e8 pari, altrimenti avviser\u00e0 l'utente che il numero \u00e8 dispari. Suggerimento Utilizzare l'header stdbool.h per gestire i valori booleani. In alternativa, ricordare che ogni intero diverso da 0 \u00e8 considerato come un true .","title":"Parte 2: Pari e Dispari"},{"location":"04_esercizi/linguaggio_c/#parte-3-confrontiamoci","text":"Scriviamo il programma Confrontiamoci , che confronta due intervalli di valori di tipo \\([a,b]\\) e \\([c,d]\\) con \\((a,b,c,d)\\) numeri interi. Scriviamo in primis una funzione confronto_relazionale che dovr\u00e0: stampare a schermo il maggiore tra gli estremi inferiori \\(a\\) e \\(c\\) ; stampare a schermo il minore tra gli estremi superiori \\(b\\) e \\(d\\) ; stabilire se il numero di elementi all'interno dei due insiemi \u00e8 lo stesso. Successivamente, scriviamo una funzione confronto_logico che dovr\u00e0 verificare, usando solo operatori di logica booleana, se gli intervalli sopraccitati hanno lo stesso numero di elementi e gli estremi degli stessi coincidono, oppure se una sola di queste condizioni \u00e8 verificata.","title":"Parte 3: Confrontiamoci"},{"location":"04_esercizi/linguaggio_c/#5-array","text":"Un tensore \u00e8 un array ad \\(n\\) dimensioni contenente valori arbitrari. Creare due tensori di dimensioni \\(3 \\times 3 \\times 3\\) , uno contenente valori interi, e l'altro contenente valori in formato double . Usare l'operatore sizeof per confrontare lo spazio occupato in memoria, visualizzando a schermo tutti i valori dell'array pi\u00f9 \"pesante\".","title":"5. Array"},{"location":"04_esercizi/linguaggio_c/#esercizi-da-svolgere","text":"Lo svolgimento di questi esercizi \u00e8 delegato allo studente.","title":"Esercizi da svolgere"},{"location":"04_esercizi/linguaggio_c/#modularita_1","text":"","title":"Modularit\u00e0"},{"location":"04_esercizi/linguaggio_c/#1-simulauto","text":"Creare il programma SimulAuto che contiene al suo interno due moduli: il modulo gestisci_velocita , contenente le funzioni accelera e decelera ; il modulo gestisci direzione , contenente la funzione sterza . Le funzioni sono descritte come segue: accelera restituisce la velocit\u00e0 raggiunta dopo t secondi a partire dalla velocit\u00e0 v_i applicando l'accelerazione a ; decelera restituisce la velocit\u00e0 raggiunta dopo t secondi a partire dalla velocit\u00e0 v_i applicando la decelerazione d ; sterza restituisce il nuovo angolo di sterzata a partire da quello attuale a e da quello applicato s . Nota Tutti i valori sono da considerarsi interi. Suggerimento Si consideri l'accelerazione pari ad: \\(a = \\frac{v_f - v_i}{t_f - t_i}\\) .","title":"1. SimulAuto"}]}