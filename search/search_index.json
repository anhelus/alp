{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Informatica - CdL in Matematica (UniBa 20/21) \u00b6 Benvenuti! Indirizzi utili \u00b6 E-mail del docente: angelo.cardellicchio@uniba.it Contatto Skype: angelo_cardellicchio Orari del corso \u00b6 Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 . Ricevimento \u00b6 Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Nota A causa dell'emergenza COVID-19, il ricevimento deve essere necessariamente concordato a mezzo e-mail; \u00e8 inoltre preferibile evitare il ricevimento in presenza, optando per comunicazioni telematiche a mezzo e-mail, Skype o Microsoft Teams. Modalit\u00e0 di svolgimento delle lezioni \u00b6 Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica. Prerequisiti \u00b6 Non sono necessari particolari prerequisiti per l'accesso al Corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il Corso. Modalit\u00e0 di valutazione \u00b6 Modalit\u00e0 Standard \u00b6 Prevede una prova scritta ed una prova orale . La prova scritta prevede tre \u2013 cinque domande sui diversi argomenti del corso. All\u2019interno della prova scritta possono esserci esercizi di programmazione da svolgersi direttamente sull\u2019elaborato . La prova scritta \u00e8 valutata in trentesimi. La prova orale \u00e8 obbligatoria se il risultato della prova scritta \u00e8 compreso tra 15 e 17 . Se il risultato della prova scritta \u00e8 maggiore o uguale a 18 , la prova orale \u00e8 a discrezione dello studente. Se il risultato della prova scritta \u00e8 minore o uguale a 14 , lo studente dovr\u00e0 ripetere la prova scritta a partire dall\u2019appello successivo Modalit\u00e0 Alternativa con Tema d'anno (precedentemente esoneri) \u00b6 Nota Questa particolare modalit\u00e0 \u00e8 scelta esclusivamente per l\u2019A.A. 2020/2021 a causa della situazione imposta dal Covid-19. Durante il corso, gli studenti potranno decidere, in maniera autonoma o in gruppo composto al massimo da due componenti, di svolgere un tema d\u2019anno, articolato in quattro parti, valido per l\u2019esonero dalle prove scritta ed orale. Per accedere a questa modalit\u00e0, i gruppi/studenti dovranno essere comunicati al docente entro il termine massimo (improrogabile) del 09/11/2020 via email all\u2019indirizzo angelo.cardellicchio@uniba.it . I temi d\u2019anno, in base al numero di gruppi/studenti, verranno proposti dal docente a partire dal 16/11/2020 . Ciascun gruppo/studente dovr\u00e0 comunicare all\u2019email del docente due preferenze tra i temi proposti. Il primo tema indicato sar\u00e0 la prima scelta, il secondo tema indicato sar\u00e0 la seconda scelta . Si cercher\u00e0 in ogni caso di assegnare ad ogni gruppo la prima scelta, ripiegando eventualmente sulla seconda. In caso di pi\u00f9 preferenze da diversi gruppi/studenti sullo stesso tema, quest\u2019ultimo sar\u00e0 assegnato secondo un criterio strettamente cronologico di arrivo della richiesta. Esempio Tizio esprime preferenza il 17/11/2020 alle 08:35 per i Temi A (prima scelta) e B (seconda scelta). Caio esprime preferenza il 17/11/2020 alle 08:40 per i temi A (prima scelta) e C (seconda scelta). Sempronio esprime preferenza il 17/11/2020 alle ore 08:30 per i temi B (prima scelta) e A (seconda scelta). A Tizio sar\u00e0 assegnato il Tema A, a Caio il tema C, a Sempronio il tema B. La scelta dei temi dovr\u00e0 essere comunicata improrogabilmente entro il 22/11/2020 . L\u2019esito delle scelte sar\u00e0 comunicato entro il 25/11/2020 . La prima parte del tema d\u2019anno dovr\u00e0 essere consegnata entro il 02/12/2020 . Le date successive saranno comunicate quanto prima. Post Scriptum Il mancato rispetto delle date indicate prevede l\u2019esclusione automatica dalla modalit\u00e0 a tema d\u2019anno. Post Post Scriptum Ci\u00f2 non vale per il Docente, apparentemente, per\u00f2 questi giura che prover\u00e0 comunque a rispettare il Patto Inderogabile di Fiducia con gli Studenti . Date rilevanti per la Modalit\u00e0 Alternativa con Esoneri \u00b6 Data Evento Note 06 novembre 2020 Termine adesioni esoneri Entro questa data, i gruppi che vorranno sostenere gli esoneri dovranno segnalarlo al docente. 09 novembre 2020 Proposta temi d'anno In questa data, il docente effettuer\u00e0 la proposta dei temi di esonero. 16 novembre 2020 Assegnazione temi d'anno In questa data, saranno assegnati i temi d'anno. Ogni gruppo potr\u00e0 richiedere, mediante il proprio referente, fino a due temi d'anno. Il docente assegner\u00e0 il tema d'anno in base all'ordine cronologico delle richieste pervenute via mail . Non \u00e8 assicurato che il tema d'anno assegnato combaci con una delle preferenze espresse. 23 novembre 2020 Consegna primo esonero In questa data, dovr\u00e0 essere consegnato dal referente di ciascun gruppo, esclusivamente a mezzo di posta elettronica ed in fomrato PDF/A , il primo elaborato di esonero. Nota 1 La data del 06 novembre 2020 \u00e8 la data ultima con la quale gli interessati potranno iscriversi al team del Corso per essere considerati come potenziali partecipanti e, conseguentemente, essere considerati come potenzialmente sottoponibili ad esonero. Si noti che **l'iscrizione al team pu\u00f2 avvenire Programma del Corso \u00b6 Il programma del Corso si articola come segue: Argomento Dispense Slide Introduzione al corso Introduzione all'Informatica Introduzione agli Algoritmi Rappresentazione dei Dati Testi di riferimento \u00b6 Nota Questi testi sono consigliati . Ci\u00f2 non implica che sia necessario seguirli in maniera pedissequa , ma che occorre intenderli come materiale da usare per motivi di approfondimento personale. Ci\u00f2 comporta due conseguenze: la prima \u00e8 che il corso non segue un testo di riferimento, quanto piuttosto le dispense e le slide proiettate a lezione; la seconda, pi\u00f9 rilevante per lo Studente, \u00e8 che per superare l'esame basta seguire queste ultime. Testi integrativi (per l'approfondimento della materia) \u00b6 Questi testi possono essere considerati come una buona integrazione, da usare per approfondire gli argomenti trattati a lezione. Tanenbaum, Architettura dei calcolatori. Un approccio strutturale Tanenbaum, Reti di calcolatori Deitel, Deitel, C++. Fondamenti di programmazione Testi online \u00b6 Questi testi sono da considerarsi al pari dei testi integrativi per l'approfondimento della materia, con la differenza che sono disponibili (liberamente) online. The Python Tutorial Python Data Science Handbook Testi consigliati (per la data science) \u00b6 Questi testi sono da considerarsi come dei buoni approfondimenti qualora si decida di approfondire, magari in futuro, degli aspetti legati ai principi matematici ed informatici della data science. Goodfellow, Deep Learning G\u00e9ron, Hands-On Machine Learning with Scikit-Learn and Tensorflow: Concepts, Tools, and Techniques to Build Intelligent Systems","title":"Informatica - CdL in Matematica (UniBa 20/21)"},{"location":"#informatica-cdl-in-matematica-uniba-2021","text":"Benvenuti!","title":"Informatica - CdL in Matematica (UniBa 20/21)"},{"location":"#indirizzi-utili","text":"E-mail del docente: angelo.cardellicchio@uniba.it Contatto Skype: angelo_cardellicchio","title":"Indirizzi utili"},{"location":"#orari-del-corso","text":"Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 .","title":"Orari del corso"},{"location":"#ricevimento","text":"Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Nota A causa dell'emergenza COVID-19, il ricevimento deve essere necessariamente concordato a mezzo e-mail; \u00e8 inoltre preferibile evitare il ricevimento in presenza, optando per comunicazioni telematiche a mezzo e-mail, Skype o Microsoft Teams.","title":"Ricevimento"},{"location":"#modalita-di-svolgimento-delle-lezioni","text":"Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica.","title":"Modalit\u00e0 di svolgimento delle lezioni"},{"location":"#prerequisiti","text":"Non sono necessari particolari prerequisiti per l'accesso al Corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il Corso.","title":"Prerequisiti"},{"location":"#modalita-di-valutazione","text":"","title":"Modalit\u00e0 di valutazione"},{"location":"#modalita-standard","text":"Prevede una prova scritta ed una prova orale . La prova scritta prevede tre \u2013 cinque domande sui diversi argomenti del corso. All\u2019interno della prova scritta possono esserci esercizi di programmazione da svolgersi direttamente sull\u2019elaborato . La prova scritta \u00e8 valutata in trentesimi. La prova orale \u00e8 obbligatoria se il risultato della prova scritta \u00e8 compreso tra 15 e 17 . Se il risultato della prova scritta \u00e8 maggiore o uguale a 18 , la prova orale \u00e8 a discrezione dello studente. Se il risultato della prova scritta \u00e8 minore o uguale a 14 , lo studente dovr\u00e0 ripetere la prova scritta a partire dall\u2019appello successivo","title":"Modalit\u00e0 Standard"},{"location":"#modalita-alternativa-con-tema-danno-precedentemente-esoneri","text":"Nota Questa particolare modalit\u00e0 \u00e8 scelta esclusivamente per l\u2019A.A. 2020/2021 a causa della situazione imposta dal Covid-19. Durante il corso, gli studenti potranno decidere, in maniera autonoma o in gruppo composto al massimo da due componenti, di svolgere un tema d\u2019anno, articolato in quattro parti, valido per l\u2019esonero dalle prove scritta ed orale. Per accedere a questa modalit\u00e0, i gruppi/studenti dovranno essere comunicati al docente entro il termine massimo (improrogabile) del 09/11/2020 via email all\u2019indirizzo angelo.cardellicchio@uniba.it . I temi d\u2019anno, in base al numero di gruppi/studenti, verranno proposti dal docente a partire dal 16/11/2020 . Ciascun gruppo/studente dovr\u00e0 comunicare all\u2019email del docente due preferenze tra i temi proposti. Il primo tema indicato sar\u00e0 la prima scelta, il secondo tema indicato sar\u00e0 la seconda scelta . Si cercher\u00e0 in ogni caso di assegnare ad ogni gruppo la prima scelta, ripiegando eventualmente sulla seconda. In caso di pi\u00f9 preferenze da diversi gruppi/studenti sullo stesso tema, quest\u2019ultimo sar\u00e0 assegnato secondo un criterio strettamente cronologico di arrivo della richiesta. Esempio Tizio esprime preferenza il 17/11/2020 alle 08:35 per i Temi A (prima scelta) e B (seconda scelta). Caio esprime preferenza il 17/11/2020 alle 08:40 per i temi A (prima scelta) e C (seconda scelta). Sempronio esprime preferenza il 17/11/2020 alle ore 08:30 per i temi B (prima scelta) e A (seconda scelta). A Tizio sar\u00e0 assegnato il Tema A, a Caio il tema C, a Sempronio il tema B. La scelta dei temi dovr\u00e0 essere comunicata improrogabilmente entro il 22/11/2020 . L\u2019esito delle scelte sar\u00e0 comunicato entro il 25/11/2020 . La prima parte del tema d\u2019anno dovr\u00e0 essere consegnata entro il 02/12/2020 . Le date successive saranno comunicate quanto prima. Post Scriptum Il mancato rispetto delle date indicate prevede l\u2019esclusione automatica dalla modalit\u00e0 a tema d\u2019anno. Post Post Scriptum Ci\u00f2 non vale per il Docente, apparentemente, per\u00f2 questi giura che prover\u00e0 comunque a rispettare il Patto Inderogabile di Fiducia con gli Studenti .","title":"Modalit\u00e0 Alternativa con Tema d'anno (precedentemente esoneri)"},{"location":"#date-rilevanti-per-la-modalita-alternativa-con-esoneri","text":"Data Evento Note 06 novembre 2020 Termine adesioni esoneri Entro questa data, i gruppi che vorranno sostenere gli esoneri dovranno segnalarlo al docente. 09 novembre 2020 Proposta temi d'anno In questa data, il docente effettuer\u00e0 la proposta dei temi di esonero. 16 novembre 2020 Assegnazione temi d'anno In questa data, saranno assegnati i temi d'anno. Ogni gruppo potr\u00e0 richiedere, mediante il proprio referente, fino a due temi d'anno. Il docente assegner\u00e0 il tema d'anno in base all'ordine cronologico delle richieste pervenute via mail . Non \u00e8 assicurato che il tema d'anno assegnato combaci con una delle preferenze espresse. 23 novembre 2020 Consegna primo esonero In questa data, dovr\u00e0 essere consegnato dal referente di ciascun gruppo, esclusivamente a mezzo di posta elettronica ed in fomrato PDF/A , il primo elaborato di esonero. Nota 1 La data del 06 novembre 2020 \u00e8 la data ultima con la quale gli interessati potranno iscriversi al team del Corso per essere considerati come potenziali partecipanti e, conseguentemente, essere considerati come potenzialmente sottoponibili ad esonero. Si noti che **l'iscrizione al team pu\u00f2 avvenire","title":"Date rilevanti per la Modalit\u00e0 Alternativa con Esoneri"},{"location":"#programma-del-corso","text":"Il programma del Corso si articola come segue: Argomento Dispense Slide Introduzione al corso Introduzione all'Informatica Introduzione agli Algoritmi Rappresentazione dei Dati","title":"Programma del Corso"},{"location":"#testi-di-riferimento","text":"Nota Questi testi sono consigliati . Ci\u00f2 non implica che sia necessario seguirli in maniera pedissequa , ma che occorre intenderli come materiale da usare per motivi di approfondimento personale. Ci\u00f2 comporta due conseguenze: la prima \u00e8 che il corso non segue un testo di riferimento, quanto piuttosto le dispense e le slide proiettate a lezione; la seconda, pi\u00f9 rilevante per lo Studente, \u00e8 che per superare l'esame basta seguire queste ultime.","title":"Testi di riferimento"},{"location":"#testi-integrativi-per-lapprofondimento-della-materia","text":"Questi testi possono essere considerati come una buona integrazione, da usare per approfondire gli argomenti trattati a lezione. Tanenbaum, Architettura dei calcolatori. Un approccio strutturale Tanenbaum, Reti di calcolatori Deitel, Deitel, C++. Fondamenti di programmazione","title":"Testi integrativi (per l'approfondimento della materia)"},{"location":"#testi-online","text":"Questi testi sono da considerarsi al pari dei testi integrativi per l'approfondimento della materia, con la differenza che sono disponibili (liberamente) online. The Python Tutorial Python Data Science Handbook","title":"Testi online"},{"location":"#testi-consigliati-per-la-data-science","text":"Questi testi sono da considerarsi come dei buoni approfondimenti qualora si decida di approfondire, magari in futuro, degli aspetti legati ai principi matematici ed informatici della data science. Goodfellow, Deep Learning G\u00e9ron, Hands-On Machine Learning with Scikit-Learn and Tensorflow: Concepts, Tools, and Techniques to Build Intelligent Systems","title":"Testi consigliati (per la data science)"},{"location":"03_architettura/","text":"Un po' di storia \u00b6 Le origini del concetto di calcolatore (o, nell'accezione comune del termine, computer ) possono essere fatte risalire alla storia antica, con invenzioni come l' abaco , ovvero dei veri e propri strumenti di supporto che permettevano all'operatore umano di svolgere in maniera pi\u00f9 rapida calcoli anche complessi. Il calcolatore si \u00e8 poi evoluto in et\u00e0 moderna: si \u00e8 passati dalle prime sperimentazioni, come le macchine di Pascal e di Leibniz, alle prime calcolatrici , per arrivare al primo modello (teorico) di dispositivo programmabile , ovvero in grado di adattarsi a compiti anche molto diversi tra loro, che si deve al matematico britannico Charles Babbage con la sua Macchina Analitica, progettata nel 1833, e considerata il primo progetto di computer nella storia. Nei decenni successivi, vennero introdotti diversi tipi di calcolatori analogici. Successivamente, si pass\u00f2 alla concettualizzazione della macchina di Turing , per poi arrivare ai computer meccanici ed elettromeccanici, ed infine alle architetture digitali ed elettroniche, basate su transistor e circuiti integrati ad altissima densit\u00e0. Le prossime frontiere sono probabilmente quelle dettate dal quantum computing , che potrebbero rivoluzionare completamente l'idea attuale di elaborazione, rendedo vetusta qualsiasi applicazione dell'informatica odierna. Tuttavia, nessuno degli scenari verificatisi negli ultimi 80 anni si sarebbe potuto realizzare se John von Neumann (un altro matematico) non avesse proposto la sua architettura . L'architettura di von Neumann \u00b6 Il modello proposto da John von Neumann \u00e8 unanimamente riconosciuto come la base sulla quale sono basate le moderne architetture dei calcolatori. Elaborato negli anni '40 del secolo scorso, prevede la presenza di quattro entit\u00e0 principali: la Central Processing Unit ( CPU ); la memoria ; i dispositivi di input/output ; il bus di comunicazione . SCHEMA MACCHINA DI VON NEUMANN Le informazioni viaggiano tra i diversi componenti mediante un \"canale\" chiamato bus . Vediamo nel dettaglio le singole parti. Central Processing Unit \u00b6 Componenti fondamentali \u00b6 La CPU \u00e8 il \"cuore\" della macchina di von Neumann, ed \u00e8 a sua volta divisa in due parti: una control unit , responsabile per il prelievo (fetch) e decodifica (decode) delle istruzioni; una processing unit , responsabile dell'esecuzione delle operazioni aritmetiche e logiche. La control unit contiene al suo interno due registri (ovvero piccole sezioni di memoria rapidamente accessibili) fondamentali, ovvero: il Current Instruction Register ( CIR ), che contiene l'istruzione attualmente in esecuzione; il Program Counter , che contiene l'indirizzo dell'istruzione successiva del programma in esecuzione. La processing unit \u00e8 invece composta da: una Arithmetic Logic Unit ( ALU ), ovvero l'unit\u00e0 delegata alla gestione delle operazioni aritmetiche e logiche; una serie di registri che memorizzano le operazioni fondamentali e pi\u00f9 utilizzate dalla macchina. Alcune varianti della CPU prevedono anche la presenza di un segnale di clock. Memoria \u00b6 Rappresenta la memoria \"centrale\" del sistema, di lavoro. Il suo ruolo \u00e8 assimilabile a quello delle RAM , in quanto contiene tutti i dati e le istruzioni necessarie alla corretta esecuzione del programma attuale. E' importante non confondere questa memoria con la memoria di massa (ovvero gli hard disk o gli SSD), nella quale sono immagazzinati i dati ed i programmi quando questi non sono in uso. La memoria dialoga principalmente con la CPU, ed il suo compito consiste nell'agire da \"magazzino\", accessibile in maniera rapida (anche se non tanto rapida quanto i registri) dalla CPU, allo scopo di recuperare i dati necessari all'esecuzione del programma attuale. Dispositivi di Input/Output \u00b6 Sono i dispositivi con cui, rispettivamente, sono forniti dati e programmi alla CPU (Input) e vengono restituiti dalla CPU i risultati dell'elaborazione . E' interessante notare come una memoria di massa possa fungere sia da dispositivo di input, sia da dispositivo di output. Bus \u00b6 Il bus \u00e8 il mezzo con cui i vari componenti della macchina di von Neumann comunicano tra loro. TODO: Funzionamento \u00b6 Esecuzione di programmi \u00b6 La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina - per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite Ciclo Fetch-Decode-Execute \u00b6 L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati FINE TODO: L'importanza della macchina di von Neumann \u00b6 I primi computer \u00b6 I primi computer non avevano una memoria propriamente intesa: i programmi infatti erano spesso \"cablati\" nella logica della macchina. Di conseguenza, un computer progettato per eseguire (ad esempio) determinati calcoli matematici, non poteva essere usato per scrivere, a meno di riprogrammarlo . Questo significava ovviamente imbarcarsi in una procedura lunga, tediosa e complessa, spesso con implicazioni anche di tipo meccanico (ovvero, necessit\u00e0 di ricablare i collegamenti tra le diverse parti della macchina). Per fare un esempio, modificare il programma in esecuzione su una macchina ENIAC (il primo computer general-purpose ) richiedeva circa tre settimane. La macchina di von Neumann permise di superare questo limite introducendo il concetto di stored-program computer , inteso come calcolatore in grado di memorizzare le istruzioni da eseguire in forma elettronica, ottica, o comunque facilmente accessibile . Questo, ovviamente, derivava dalla struttura stessa della macchina, che non implicava una completa integrazione di CPU e memoria, le quali erano bens\u00ec separate ed indipendenti. Va da s\u00e9 che riscrivere la memoria non comportava la riprogrammazione completa della CPU, con un notevole vantaggio in termini di accessibilit\u00e0 e riprogrammabilit\u00e0 del calcolatore. Il collo di bottiglia di von Neumann \u00b6 La macchina di von Neumann soffre di un notevole limite, legato principalmente al rapporto tra la velocit\u00e0 della CPU ed il transfer rate della memoria. Il problema principale \u00e8 legato al fatto che, nel corso del tempo, la velocit\u00e0 delle CPU \u00e8 aumentata seguendo per molti anni la cosiddetta legge di Moore , mentre le evoluzioni delle memorie si sono concentrate sulla loro densit\u00e0 (ovvero sul quantitativo di memoria disponibile) piuttosto che sul throughput (ovvero sul quantitativo di dati che \u00e8 possibile trasferire dalla memoria verso la CPU). Questo fenomeno \u00e8 detto collo di bottiglia di von Neumann , o von Neumann bottleneck . La conseguenza di questo fenomeno sta nel fatto che le CPU elaborano troppe informazioni rispetto a quelle che la memoria pu\u00f2 inviare , e quindi i processori si ritrovano a \"dover attendere\" le istruzioni fornite dalla memoria, lasciando che preziosi cicli di clock passino inutilizzati. Per mitigare questo fenomeno, nel tempo sono stati elaborati diversi approcci, come: creare delle memorie cache , di dimensioni limitate rispetto alle RAM, ma comunque molto pi\u00f9 veloci; fare in modo che dati ed istruzioni viaggino su percorsi differenti, riducendo la congestione sul bus; usare degli algoritmi di branch prediction , che tentano di prevedere quali istruzioni saranno usate successivamente, precaricandole dalla memoria. Nonostante questi \"escamotage\", per\u00f2, la soluzione al von Neumann bottleneck arriv\u00f2 introducendo un'altra architettura. L'architettura Harvard \u00b6 Inizialmente implementata sulla macchina Harvard Mark I , l' architettura Harvard venne introdotta per superare i limiti imposti dal modello di von Neumann, separando la memoria dedicata ai programmi ( instruction memory ) da quella dedicata ai dati ( data memory ). Differenze con l'architettura di von Neumann \u00b6 L'architettura Harvard permette di superare il collo di bottiglia intrinseco nell'architettura di von Neumann permettendo alla CPU di leggere un'istruzione contemporaneamente all'accesso ai dati, anche senza utilizzare una cache; ci\u00f2 significa che, al costo di una complessit\u00e0 circuitale superiore, un computer basato su architettura Harvard \u00e8 pi\u00f9 veloce di uno basato sull'architettura di von Neumann. L'architettura Harvard modificata \u00b6 Una architettura Harvard modificata \u00e8 definita in modo molto vago, ma vi sono tre diverse possibilit\u00e0. Queste architetture sono la Split Cache , access Instruction Memory as Data , e Read Instructions from Data Memory . Access Instruction Memory as Data \u00b6 Questa architettura ricorda l'architettura Harvard standard, ma con uno speciale insieme di istruzioni che permettono di leggere le costanti dalla memoria legata A modified Harvard architecture machine is very much like a Harvard architecture machine, but it relaxes the strict separation between instruction and data while still letting the CPU concurrently access two (or more) memory buses. The most common modification includes separate instruction and data caches backed by a common address space. While the CPU executes from cache, it acts as a pure Harvard machine. When accessing backing memory, it acts like a von Neumann machine (where code can be moved around like data, which is a powerful technique). This modification is widespread in modern processors, such as the ARM architecture, Power ISA and x86 processors. It is sometimes loosely called a Harvard architecture, overlooking the fact that it is actually \"modified\".","title":"03 architettura"},{"location":"03_architettura/#un-po-di-storia","text":"Le origini del concetto di calcolatore (o, nell'accezione comune del termine, computer ) possono essere fatte risalire alla storia antica, con invenzioni come l' abaco , ovvero dei veri e propri strumenti di supporto che permettevano all'operatore umano di svolgere in maniera pi\u00f9 rapida calcoli anche complessi. Il calcolatore si \u00e8 poi evoluto in et\u00e0 moderna: si \u00e8 passati dalle prime sperimentazioni, come le macchine di Pascal e di Leibniz, alle prime calcolatrici , per arrivare al primo modello (teorico) di dispositivo programmabile , ovvero in grado di adattarsi a compiti anche molto diversi tra loro, che si deve al matematico britannico Charles Babbage con la sua Macchina Analitica, progettata nel 1833, e considerata il primo progetto di computer nella storia. Nei decenni successivi, vennero introdotti diversi tipi di calcolatori analogici. Successivamente, si pass\u00f2 alla concettualizzazione della macchina di Turing , per poi arrivare ai computer meccanici ed elettromeccanici, ed infine alle architetture digitali ed elettroniche, basate su transistor e circuiti integrati ad altissima densit\u00e0. Le prossime frontiere sono probabilmente quelle dettate dal quantum computing , che potrebbero rivoluzionare completamente l'idea attuale di elaborazione, rendedo vetusta qualsiasi applicazione dell'informatica odierna. Tuttavia, nessuno degli scenari verificatisi negli ultimi 80 anni si sarebbe potuto realizzare se John von Neumann (un altro matematico) non avesse proposto la sua architettura .","title":"Un po' di storia"},{"location":"03_architettura/#larchitettura-di-von-neumann","text":"Il modello proposto da John von Neumann \u00e8 unanimamente riconosciuto come la base sulla quale sono basate le moderne architetture dei calcolatori. Elaborato negli anni '40 del secolo scorso, prevede la presenza di quattro entit\u00e0 principali: la Central Processing Unit ( CPU ); la memoria ; i dispositivi di input/output ; il bus di comunicazione . SCHEMA MACCHINA DI VON NEUMANN Le informazioni viaggiano tra i diversi componenti mediante un \"canale\" chiamato bus . Vediamo nel dettaglio le singole parti.","title":"L'architettura di von Neumann"},{"location":"03_architettura/#central-processing-unit","text":"","title":"Central Processing Unit"},{"location":"03_architettura/#componenti-fondamentali","text":"La CPU \u00e8 il \"cuore\" della macchina di von Neumann, ed \u00e8 a sua volta divisa in due parti: una control unit , responsabile per il prelievo (fetch) e decodifica (decode) delle istruzioni; una processing unit , responsabile dell'esecuzione delle operazioni aritmetiche e logiche. La control unit contiene al suo interno due registri (ovvero piccole sezioni di memoria rapidamente accessibili) fondamentali, ovvero: il Current Instruction Register ( CIR ), che contiene l'istruzione attualmente in esecuzione; il Program Counter , che contiene l'indirizzo dell'istruzione successiva del programma in esecuzione. La processing unit \u00e8 invece composta da: una Arithmetic Logic Unit ( ALU ), ovvero l'unit\u00e0 delegata alla gestione delle operazioni aritmetiche e logiche; una serie di registri che memorizzano le operazioni fondamentali e pi\u00f9 utilizzate dalla macchina. Alcune varianti della CPU prevedono anche la presenza di un segnale di clock.","title":"Componenti fondamentali"},{"location":"03_architettura/#memoria","text":"Rappresenta la memoria \"centrale\" del sistema, di lavoro. Il suo ruolo \u00e8 assimilabile a quello delle RAM , in quanto contiene tutti i dati e le istruzioni necessarie alla corretta esecuzione del programma attuale. E' importante non confondere questa memoria con la memoria di massa (ovvero gli hard disk o gli SSD), nella quale sono immagazzinati i dati ed i programmi quando questi non sono in uso. La memoria dialoga principalmente con la CPU, ed il suo compito consiste nell'agire da \"magazzino\", accessibile in maniera rapida (anche se non tanto rapida quanto i registri) dalla CPU, allo scopo di recuperare i dati necessari all'esecuzione del programma attuale.","title":"Memoria"},{"location":"03_architettura/#dispositivi-di-inputoutput","text":"Sono i dispositivi con cui, rispettivamente, sono forniti dati e programmi alla CPU (Input) e vengono restituiti dalla CPU i risultati dell'elaborazione . E' interessante notare come una memoria di massa possa fungere sia da dispositivo di input, sia da dispositivo di output.","title":"Dispositivi di Input/Output"},{"location":"03_architettura/#bus","text":"Il bus \u00e8 il mezzo con cui i vari componenti della macchina di von Neumann comunicano tra loro. TODO:","title":"Bus"},{"location":"03_architettura/#funzionamento","text":"","title":"Funzionamento"},{"location":"03_architettura/#esecuzione-di-programmi","text":"La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina - per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite","title":"Esecuzione di programmi"},{"location":"03_architettura/#ciclo-fetch-decode-execute","text":"L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati FINE TODO:","title":"Ciclo Fetch-Decode-Execute"},{"location":"03_architettura/#limportanza-della-macchina-di-von-neumann","text":"","title":"L'importanza della macchina di von Neumann"},{"location":"03_architettura/#i-primi-computer","text":"I primi computer non avevano una memoria propriamente intesa: i programmi infatti erano spesso \"cablati\" nella logica della macchina. Di conseguenza, un computer progettato per eseguire (ad esempio) determinati calcoli matematici, non poteva essere usato per scrivere, a meno di riprogrammarlo . Questo significava ovviamente imbarcarsi in una procedura lunga, tediosa e complessa, spesso con implicazioni anche di tipo meccanico (ovvero, necessit\u00e0 di ricablare i collegamenti tra le diverse parti della macchina). Per fare un esempio, modificare il programma in esecuzione su una macchina ENIAC (il primo computer general-purpose ) richiedeva circa tre settimane. La macchina di von Neumann permise di superare questo limite introducendo il concetto di stored-program computer , inteso come calcolatore in grado di memorizzare le istruzioni da eseguire in forma elettronica, ottica, o comunque facilmente accessibile . Questo, ovviamente, derivava dalla struttura stessa della macchina, che non implicava una completa integrazione di CPU e memoria, le quali erano bens\u00ec separate ed indipendenti. Va da s\u00e9 che riscrivere la memoria non comportava la riprogrammazione completa della CPU, con un notevole vantaggio in termini di accessibilit\u00e0 e riprogrammabilit\u00e0 del calcolatore.","title":"I primi computer"},{"location":"03_architettura/#il-collo-di-bottiglia-di-von-neumann","text":"La macchina di von Neumann soffre di un notevole limite, legato principalmente al rapporto tra la velocit\u00e0 della CPU ed il transfer rate della memoria. Il problema principale \u00e8 legato al fatto che, nel corso del tempo, la velocit\u00e0 delle CPU \u00e8 aumentata seguendo per molti anni la cosiddetta legge di Moore , mentre le evoluzioni delle memorie si sono concentrate sulla loro densit\u00e0 (ovvero sul quantitativo di memoria disponibile) piuttosto che sul throughput (ovvero sul quantitativo di dati che \u00e8 possibile trasferire dalla memoria verso la CPU). Questo fenomeno \u00e8 detto collo di bottiglia di von Neumann , o von Neumann bottleneck . La conseguenza di questo fenomeno sta nel fatto che le CPU elaborano troppe informazioni rispetto a quelle che la memoria pu\u00f2 inviare , e quindi i processori si ritrovano a \"dover attendere\" le istruzioni fornite dalla memoria, lasciando che preziosi cicli di clock passino inutilizzati. Per mitigare questo fenomeno, nel tempo sono stati elaborati diversi approcci, come: creare delle memorie cache , di dimensioni limitate rispetto alle RAM, ma comunque molto pi\u00f9 veloci; fare in modo che dati ed istruzioni viaggino su percorsi differenti, riducendo la congestione sul bus; usare degli algoritmi di branch prediction , che tentano di prevedere quali istruzioni saranno usate successivamente, precaricandole dalla memoria. Nonostante questi \"escamotage\", per\u00f2, la soluzione al von Neumann bottleneck arriv\u00f2 introducendo un'altra architettura.","title":"Il collo di bottiglia di von Neumann"},{"location":"03_architettura/#larchitettura-harvard","text":"Inizialmente implementata sulla macchina Harvard Mark I , l' architettura Harvard venne introdotta per superare i limiti imposti dal modello di von Neumann, separando la memoria dedicata ai programmi ( instruction memory ) da quella dedicata ai dati ( data memory ).","title":"L'architettura Harvard"},{"location":"03_architettura/#differenze-con-larchitettura-di-von-neumann","text":"L'architettura Harvard permette di superare il collo di bottiglia intrinseco nell'architettura di von Neumann permettendo alla CPU di leggere un'istruzione contemporaneamente all'accesso ai dati, anche senza utilizzare una cache; ci\u00f2 significa che, al costo di una complessit\u00e0 circuitale superiore, un computer basato su architettura Harvard \u00e8 pi\u00f9 veloce di uno basato sull'architettura di von Neumann.","title":"Differenze con l'architettura di von Neumann"},{"location":"03_architettura/#larchitettura-harvard-modificata","text":"Una architettura Harvard modificata \u00e8 definita in modo molto vago, ma vi sono tre diverse possibilit\u00e0. Queste architetture sono la Split Cache , access Instruction Memory as Data , e Read Instructions from Data Memory .","title":"L'architettura Harvard modificata"},{"location":"03_architettura/#access-instruction-memory-as-data","text":"Questa architettura ricorda l'architettura Harvard standard, ma con uno speciale insieme di istruzioni che permettono di leggere le costanti dalla memoria legata A modified Harvard architecture machine is very much like a Harvard architecture machine, but it relaxes the strict separation between instruction and data while still letting the CPU concurrently access two (or more) memory buses. The most common modification includes separate instruction and data caches backed by a common address space. While the CPU executes from cache, it acts as a pure Harvard machine. When accessing backing memory, it acts like a von Neumann machine (where code can be moved around like data, which is a powerful technique). This modification is widespread in modern processors, such as the ARM architecture, Power ISA and x86 processors. It is sometimes loosely called a Harvard architecture, overlooking the fact that it is actually \"modified\".","title":"Access Instruction Memory as Data"},{"location":"05_reti/","text":"Reti di telecomunicazione: cosa sono ed a che servono? \u00b6 Nell'ultima lezione, abbiamo introdotto le principali caratteristiche dell'architettura interna di un calcolatore. Il naturale step successivo \u00e8 quindi chiedersi come possano comunicare tra loro due (o pi\u00f9) calcolatori . Ed \u00e8 a questo scopo che sono state introdotte le reti di telecomunicazione . Alcune definizioni \u00b6 Commutazione di circuito vs. commutazione di pacchetto \u00b6 Le reti a commutazione di circuito stabiliscono una connessione fisica tra il mittente ed il destinatario. Un esempio di rete a commutazione di circuito sono le vecchie reti telefoniche, nelle quali veniva creato appunto un circuito fisico tra i due capi della comunicazione. Le reti a commutazione di pacchetto invece non stabiliscono una connessione fisica tra il mittente ed il destinatario, ma fanno s\u00ec che siano i dispositivi di rete ad instradare i dati, opportunamente suddivisi in pacchetti , tra il mittente ed il destinatario. Topologia di rete \u00b6 Standardizzazione \u00b6 Affinch\u00e9 due calcolatori scambino dati (il che, nel gergo comune, significa \" affinch\u00e8 due computer parlino tra loro \") \u00e8 necessario che entrambi si adeguino ad uno standard di comunicazione. Pensiamoci un attimo: saremmo forse in grado di capire ci\u00f2 che dice il nostro docente di Informatica se non avessimo un protocollo di comunicazione comune? Nota Se alla domanda precedente avete risposto di no , la colpa \u00e8 sicuramente vostra e non del docente di Informatica, che risulta essere chiaro, comprensibile, affabile e disponibile. Lo scambio di dati tra due computer \u00e8 inoltre molto pi\u00f9 complesso rispetto alla comunicazione verbale: infatti, prevede che ciascuno dei due computer sia in grado di: presentare i dati scambiati all'utente finale; identificare sia il mittente sia il destinatario dei dati stessi; codificare i dati sotto forma di segnale fisico da inviare su degli opportuni canali di comunicazione fisici. E' inoltre necessario che la comunicazione sia indipendente dal tipo di dispositivo utilizzato: se ci pensate, alcuni di voi seguono le lezioni da un iPad, altri dal proprio smartphone, altri ancora dal proprio laptop o PC desktop. Abbiamo quindi una serie di vincoli da rispettare affinch\u00e9 due o pi\u00f9 dispositivi comunichino. Ed \u00e8 stato proprio questo il punto di partenza dal quale \u00e8 stato definito un modello concettuale volto a caratterizzare e standardizzare la comunicazione tra dispositivi, indipendentemente dalle tecnologie adottate, ovvero il modello ISO/OSI . Il modello ISO/OSI \u00b6 OSI \u00e8 un acronimo che sta per Open Systems Interconnection , ed indica un modello sviluppato tenendo come obiettivo finale l'interoperabilit\u00e0 di diversi sistemi di comunicazione grazie a protocolli di comunicazione standardizzati . La storia del modello OSI nasce negli anni '70, in cui venne sviluppato per supportare la standardizzazione dei diversi tipi di rete di calcolatori emergenti. Negli anni '80, il modello venne adottato dall' International Organization for Standardization ( ISO ), ed assunse il nome di modello ISO/OSI . Il modello ISO/OSI suddivide il flusso dei dati in un sistema di comunicazione in sette diversi livelli ad astrazione crescente, partendo dall'implementazione fisica della trasmissione dei bit sul canale comunicativo, per arrivare alla rappresentazione dei dati ad alto livello (ovvero quello che viene \"presentato\" all'utente). E' importante sottolineare alcune caratteristiche del modello ISO/OSI. In primis, per quello che riguarda una singola macchina, ogni layer comunica esclusivamente con: il livello sottostante, di cui sfrutta le funzionalit\u00e0; il livello sovrastante, cui fornisce una serie di funzionalit\u00e0; Nella comunicazione tra due macchine, invece, ogni layer comunica con il suo pari ( peer ): ad esempio, il layer fisico della macchina A parler\u00e0 soltanto con il layer fisico della macchina B; il layer di rete della macchina A solo con quello di rete della macchina B, e via dicendo. I livelli del modello ISO/OSI \u00b6 Diamo ora una panoramica dei diversi livelli descritti dal modello. Livello 1: Livello fisico \u00b6 Il layer fisico \u00e8 responsabile per la trasmissione e ricezione di dati grezzi ( raw ) tra due dispositivi. Per farlo, sfrutta un mezzo di trasmissione fisico (come ad esempio una guida d'onda o delle onde radio). La sua funzione principale \u00e8 quella di convertire i bit digitali in segnali di tipo elettrico, radio od ottico. Le specifiche del layer includono caratteristiche come livelli di tensione da utilizzare, bit rate, distanza massima di trasmissione, schema di modulazione dei dati e via dicendo. Permette inoltre di definire tre modalit\u00e0 di trasmissione su un canale: simplex : in questo caso, la trasmissione \u00e8 monodirezionale, senza che il ricevitore si alterni con il trasmettitore (e viceversa); half-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, ma il ricevitore si alterna con il trasmettitore (ovvero, la comunicazione non pu\u00f2 avvenire contemporaneamente in entrambe le direzioni); full-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, e la comunicazione pu\u00f2 avvenire contemporaneamente in entrambe le direzioni. Questi includono dei pin, tensioni, impedenze di linea, specifiche dei cavi, timing del segmale e frequenza per i dispositivi wireless. Il controllo del bit rate \u00e8 fatto a livello fisico e pu\u00f2 definire delle modalit\u00e0 di trasmissione come simplex , half-duplex o full duplex. Livello 2: Livello data link \u00b6 Il livello data link \u00e8 quello che si occupa di stabilire un \"collegamento\" tra due diversi nodi. In particolare: individua e corregge gli errori che avvengono a livello fisico; definisce come vengono instaurate e terminate le connessioni; controlla il flusso dati. Il progetto IEEE 802 \u00b6 Il progetto IEEE 802 definisce, relativamente soprattutto al livello data link, un insieme di standard per le reti locali, in inglese Local Area Networks ( LAN ). In tal senso, la definizione data dal progetto IEEE 802 di rete locale \u00e8 la seguente: Quote Una LAN \u00e8 un sistema di comunicazione che permette ad apparecchiature indipendenti di comunicare fra loro entro un'area delimitata usando un canale fisico a velocit\u00e0 elevata e con basso tasso di errore. Notiamo che la LAN non \u00e8 quindi limitata nell'ambito (domestico, commerciale, industriale) n\u00e9 nelle tecnologie utilizzate: gli unici limiti sono l'area di interesse (giocoforza limitata), velocit\u00e0 ed affidabilit\u00e0 della comunicazione. Il progetto IEEE 802 ha quindi suddiviso il livello data link in due diversi sottolivelli: il livello Medium Access Control ( MAC ) verifica come i dispositivi di rete accedono al mezzo fisico; il livello Logical Link Control ( LLC ) controlla gli errori e sincronizza i frame. Concretamente, esistono diversi protocolli definiti nell'ambito del progetto IEEE 802, che sono usati nelle comunicazioni di tutti i giorni. Un esempio sono le reti Ethernet, che aderiscono allo standard 802.3, e le reti WiFi, che aderiscono a diverse versioni dello standard 802.11 (arrivato di recente alla revisione p ). Livello 3: livello di rete \u00b6 Il livello di rete definisce come trasferire sequenze di lunghezza arbitraria ( pacchetti ) tra due nodi connessi in reti differenti, laddove per rete si potrebbe intendere sia una singola LAN, sia l'interconnessione di diverse LAN. E' sul concetto di rete che \u00e8 necessario focalizzarsi. Infatti, ogni dispositivo in rete \u00e8 comunemente detto nodo , e pu\u00f2 trasferire messaggi agli altri nodi semplicemente specificando l'indirizzo degli stessi (oltre che ovviamente il messaggio); saranno i dispositivi di rete a trovar eil modo di consegnare il messaggio al destiantario, magari instradandolo attraverso i nodi intermedi. Notiamo anche che la consegna dei messaggi a livello di rete non \u00e8 strettamente affidabile ; questo comporta quindi che i messaggi potrebbero essere persi, ed \u00e8 quindi necessario prevedere altri meccanismi per garantire l'affidabilit\u00e0 della comunicazione. Livello 4: livello di trasporto \u00b6 Il livello di trasporto \u00e8 quello delegato a garantire questa affidabilit\u00e0 mediante opportuni meccanismi di controllo di flusso e di errore. Il modello ISO/OSI definisce cinque classi di protocolli a livello di trasporto, in base ai tipi di meccanismi di controllo dell'affidabilit\u00e0. Si va dalla classe TP0 , progettata per essere implementata su connessioni supposte error-free , ed i cui protocolli non forniscono alcun meccanismo per la gestione degli errori, fino alla classe TP4 , che \u00e8 quella che ricorda pi\u00f9 da vicino i protocolli maggiormente usati a livello di trasporto in Internet. Livello 5: livello di sessione \u00b6 Il livello di sessione si occupa di controllare il \"dialogo\", ovvero le connessioni , tra i diversi computer, gestendone, tra le altre cose, l'inizializzazione e la chiusura. Livello 6: livello di presentazione \u00b6 Nel modello ISO/OSI, il livello di presentazione si occupa di stabilire un contesto tra due diverse entit\u00e0, all'interno del quale le due possono comunicare pur usando semantica e sentassi differenti . Il livello di presentazione funziona quindi un po' come un traduttore : fa in modo che due applicazioni, anche differenti, siano in grado di comunicare tra loro, fornendo una sorta di \"dizionario\" (o, pi\u00f9 correttamente, mappatura ) tra i linguaggi da loro compresi. E' anche per questo motivo che alle volte il livello di presentazione \u00e8 anche chiamato syntax layer . Oltre alla funzione di mapping, il livello di presentazione ne offre anche di altre, tra cui quella pi\u00f9 importante \u00e8 quella delegata alla compressione dei dati. Livello 7: Livello applicativo \u00b6 Il livello applicativo \u00e8 quello pi\u00f9 vicino all'utente, ed interagisce direttamente con gli applicativi software da questo utilizzati. E' importante sottolineare che la specifica di questi programmi ricade al di fuori dell'ambito del modello ISO/OSI ; di conseguenza, le specifiche (ad esempio) del browser o di un'app per smartphone non saranno mai dettate dallo standard. Quest'ultima considerazione ci permette di distinguere tra applicazione ed entit\u00e0 legata all'applicazione: ad esempio, in un sito di prenotazione degli alberghi ci possono essere due entit\u00e0, una che usa un protocollo a livello applicativo per comunicare con gli utenti, ed un'altra che usa un protocollo a livello applicativo per salvare i dati su un database remoto. Nessuna di queste due entit\u00e0 ha per\u00f2 a che fare con l'applicazione stessa, che \u00e8 definita dalla logica di business (in questo caso, la prenotazione degli alberghi). Lo standard del mondo reale: lo stack TCP/IP \u00b6 Il modello ISO/OSI non trova riscontro diretto nelle applicazioni reali: piuttosto, \u00e8 l' Internet Protocol Suite , o stack TCP/IP , lo stack protocollare usato ed implementato su Internet. Come vedremo, la denominazione stack TCP/IP deriva direttamente dal nome dei due principali protocolli su cui \u00e8 basato lo stack, ovvero il Transmission Control Protocol ( TCP ) e l' Internet Protocol ( IP ). I livelli dello stack TCP/IP \u00b6 A differenza del modello ISO/OSI, lo stack TCP/IP \u00e8 organizzato in quattro diversi livelli, pi\u00f9 o meno riconducibili a quelli dell'ISO/OSI. Questi sono, dal pi\u00f9 basso al pi\u00f9 alto, il livello link , il livello internet , il livello trasporto ed il livello applicativo . Vediamoli di seguito. Livello 1: Livello link \u00b6 Il livello link si occupa di gestire la connessione limitatamente all'ambito della rete locale cui un host \u00e8 collegato. Il link , o collegamento , include quindi tutti gli host che \u00e8 possibile raggiungere senza dover coinvolgere un router (che \u00e8 il dispositivo che permette la connessione tra diverse reti locali). Va da s\u00e9 che la dimensione del link \u00e8 determinata dal progetto della rete stessa. Nel confronto con il modello ISO/OSI, il livello link racchiude le funzionalit\u00e0 corrispondenti a quelle del secondo layer (ovvero il data link ). E' importante sottolieare come l'effettiva implementazione del progetto IEEE 802 sia avvenuta proprio a questo livello. Livello 2: Livello internet \u00b6 La comunicazione tra diverse reti richiede che i dati siano correttamente instradati dalla rete iniziale a quella di destinazione, secondo un processo chiamato routing e supportato dall'identificazione degli indirizzi degli host coinvolti mediante il sistema degli indirizzi IP . Il livello internet fornisce una comunicazione non affidabile su reti differenti, garantendo l'inoltro dei pacchetti mediante dei dispositivi chiamati router. Il livello permette quindi l'interoperabilit\u00e0 di reti eterogenee, e definisce Internet nel modo in cui la conosciamo oggi. Il protocollo principale usato a questo livello \u00e8 l' Internet Protocol , che definisce due diversi sistemi di indirizzamento per l'identificazione degli host sulla rete. Il sistema originario di indirizzamento \u00e8 chiamato Internet Protocol version 4 ( IPv4 ), ed usa un indirizzo a 32 bit per identificare un numero massimo di \\(2^32\\) host. Ovviamente, con il progressivo diffondersi delle reti di telecomunicazione, questo valore ha rappresentato un limite, che \u00e8 stato dapprima arginato inserendo diverse classi di indirizzi riservati alle macchine interne ad ogni LAN, per poi essere superato nel 1998 mediante la standardizzazione dell'Internet Protocol version 6 (IPv6), che usa indirizzi a 128 bit. Tuttavia, nonostante le schede di rete in grado di supportare IPv6 esistano dal 2006 circa, l'IPv4 \u00e8 ancora il protocollo di comunicazione maggiormente utilizzato. Livello 3: Livello di trasporto \u00b6 Il livello di trasporto permette di creare dei \"canali dati\", che le applicazioni usano per lo scambio di messaggi specifici per determinati task. La connettivit\u00e0 pu\u00f2 essere implementata sia come connection-oriented , mediante il protocollo TCP, o connectionless , mediante il protocollo UDP. E' possibile fornire canali di trasmissione specifici per diversi processi mediante il concetto di porta di rete , ovvero la creazione di un costrutto logico numerico allocato specificamente per ognuno dei canali di comunicazione necessari. E' importante notare come, per molti servizi, questi numeri di porta siano stati standardizzati, in modo che i computer client possano indirizzare servizi specifici senza necessitare di tecniche di service discovery . Ad esempio, l'utilizzo standard del protocollo HTTP prevede il coinvolgimento della porta 80, mentre il protocollo SSH la porta 22. Il layer di trasporto dello stack TCP/IP corrisponde approssimativamente al quarto livello del modello OSI, chiamato transport layer. Trasmission Control Protocol \u00b6 Il protocollo TCP \u00e8 un protocollo connection-oriented che risolve i problemi di affidabilit\u00e0 che possono riscontrarsi nella fornitura di un flusso di byte affidabile. In particolare, il TCP garantisce che: i dati arrivino in ordine; i dati siano correttamente ricevuti; i dati duplicati siano scartati; i pacchetti persi o scartati siano nuovamente inviati; la congestione del traffico sia adeguatamente controllata. User Datagram Protocol \u00b6 Il protocollo UDP ( User Datagram Protocol ) \u00e8, a differenza del TCP, un protocollo connectionless , e si occupa di fornire una trasmissione dati non affidabile ma, non includendo il controllo degli errori tipico di TCP, pi\u00f9 veloce. L'UDP \u00e8 tipicamente usato per applicazioni legate allo streaming (audio, video e VoIP), dove l'arrivo in tempo dei dati \u00e8 pi\u00f9 importante dell'effettiva consegna degli stessi. Altri tipi di applicazioni sono quelle che prevedono esclusivamente semplici cicli di richiesta/risposta. Livello 4: Livello applicativo \u00b6 Il livello applicativo include i protocolli usati dalla maggior part edelle applicazioni per fornire servizi all'utente. Questi possono includere servizi di supporto di rete, come protocolli per il routing e la configurazione di rete. Un esempio di protocollo a livello applicativo sono l*Hypertext Transfer Protocol* ( HTTP ). I dati codificati secondo i protocolli a livello applicativo vengono quindi incapsulati in unit\u00e0 a livello di trasporto (ad esempio, in formato TCP o UDP), per poi venire ulteriormente incapsulati man mano che si scende verso il layer fisico. E' interessante notare come lo stack TCP/IP non specifichi la formattazione e la presentazione dei dati, e non definisca dei layer aggiuntivi tra quello applicativo e di trasporto. Per quello che riguarda la comunicazione con il livello di trasporto (e quelli sottostanti), il livello applicativo tratta quest'ultimo come una black box : non si occupa quindi dei dettagli implementativi dello stesso, anche se \u00e8 a conoscenza di alcune informazioni fondamentali come indirizzo IP e numero di porta utilizzati. Dal punto di vista del confronto con il modello ISO/OSI, possiamo dire che il layer applicativo del modello TCP/IP \u00e8 spesso comparato ad una combinazione dei livelli di sessione, presentazione ed applicazione del primo.","title":"05 reti"},{"location":"05_reti/#reti-di-telecomunicazione-cosa-sono-ed-a-che-servono","text":"Nell'ultima lezione, abbiamo introdotto le principali caratteristiche dell'architettura interna di un calcolatore. Il naturale step successivo \u00e8 quindi chiedersi come possano comunicare tra loro due (o pi\u00f9) calcolatori . Ed \u00e8 a questo scopo che sono state introdotte le reti di telecomunicazione .","title":"Reti di telecomunicazione: cosa sono ed a che servono?"},{"location":"05_reti/#alcune-definizioni","text":"","title":"Alcune definizioni"},{"location":"05_reti/#commutazione-di-circuito-vs-commutazione-di-pacchetto","text":"Le reti a commutazione di circuito stabiliscono una connessione fisica tra il mittente ed il destinatario. Un esempio di rete a commutazione di circuito sono le vecchie reti telefoniche, nelle quali veniva creato appunto un circuito fisico tra i due capi della comunicazione. Le reti a commutazione di pacchetto invece non stabiliscono una connessione fisica tra il mittente ed il destinatario, ma fanno s\u00ec che siano i dispositivi di rete ad instradare i dati, opportunamente suddivisi in pacchetti , tra il mittente ed il destinatario.","title":"Commutazione di circuito vs. commutazione di pacchetto"},{"location":"05_reti/#topologia-di-rete","text":"","title":"Topologia di rete"},{"location":"05_reti/#standardizzazione","text":"Affinch\u00e9 due calcolatori scambino dati (il che, nel gergo comune, significa \" affinch\u00e8 due computer parlino tra loro \") \u00e8 necessario che entrambi si adeguino ad uno standard di comunicazione. Pensiamoci un attimo: saremmo forse in grado di capire ci\u00f2 che dice il nostro docente di Informatica se non avessimo un protocollo di comunicazione comune? Nota Se alla domanda precedente avete risposto di no , la colpa \u00e8 sicuramente vostra e non del docente di Informatica, che risulta essere chiaro, comprensibile, affabile e disponibile. Lo scambio di dati tra due computer \u00e8 inoltre molto pi\u00f9 complesso rispetto alla comunicazione verbale: infatti, prevede che ciascuno dei due computer sia in grado di: presentare i dati scambiati all'utente finale; identificare sia il mittente sia il destinatario dei dati stessi; codificare i dati sotto forma di segnale fisico da inviare su degli opportuni canali di comunicazione fisici. E' inoltre necessario che la comunicazione sia indipendente dal tipo di dispositivo utilizzato: se ci pensate, alcuni di voi seguono le lezioni da un iPad, altri dal proprio smartphone, altri ancora dal proprio laptop o PC desktop. Abbiamo quindi una serie di vincoli da rispettare affinch\u00e9 due o pi\u00f9 dispositivi comunichino. Ed \u00e8 stato proprio questo il punto di partenza dal quale \u00e8 stato definito un modello concettuale volto a caratterizzare e standardizzare la comunicazione tra dispositivi, indipendentemente dalle tecnologie adottate, ovvero il modello ISO/OSI .","title":"Standardizzazione"},{"location":"05_reti/#il-modello-isoosi","text":"OSI \u00e8 un acronimo che sta per Open Systems Interconnection , ed indica un modello sviluppato tenendo come obiettivo finale l'interoperabilit\u00e0 di diversi sistemi di comunicazione grazie a protocolli di comunicazione standardizzati . La storia del modello OSI nasce negli anni '70, in cui venne sviluppato per supportare la standardizzazione dei diversi tipi di rete di calcolatori emergenti. Negli anni '80, il modello venne adottato dall' International Organization for Standardization ( ISO ), ed assunse il nome di modello ISO/OSI . Il modello ISO/OSI suddivide il flusso dei dati in un sistema di comunicazione in sette diversi livelli ad astrazione crescente, partendo dall'implementazione fisica della trasmissione dei bit sul canale comunicativo, per arrivare alla rappresentazione dei dati ad alto livello (ovvero quello che viene \"presentato\" all'utente). E' importante sottolineare alcune caratteristiche del modello ISO/OSI. In primis, per quello che riguarda una singola macchina, ogni layer comunica esclusivamente con: il livello sottostante, di cui sfrutta le funzionalit\u00e0; il livello sovrastante, cui fornisce una serie di funzionalit\u00e0; Nella comunicazione tra due macchine, invece, ogni layer comunica con il suo pari ( peer ): ad esempio, il layer fisico della macchina A parler\u00e0 soltanto con il layer fisico della macchina B; il layer di rete della macchina A solo con quello di rete della macchina B, e via dicendo.","title":"Il modello ISO/OSI"},{"location":"05_reti/#i-livelli-del-modello-isoosi","text":"Diamo ora una panoramica dei diversi livelli descritti dal modello.","title":"I livelli del modello ISO/OSI"},{"location":"05_reti/#livello-1-livello-fisico","text":"Il layer fisico \u00e8 responsabile per la trasmissione e ricezione di dati grezzi ( raw ) tra due dispositivi. Per farlo, sfrutta un mezzo di trasmissione fisico (come ad esempio una guida d'onda o delle onde radio). La sua funzione principale \u00e8 quella di convertire i bit digitali in segnali di tipo elettrico, radio od ottico. Le specifiche del layer includono caratteristiche come livelli di tensione da utilizzare, bit rate, distanza massima di trasmissione, schema di modulazione dei dati e via dicendo. Permette inoltre di definire tre modalit\u00e0 di trasmissione su un canale: simplex : in questo caso, la trasmissione \u00e8 monodirezionale, senza che il ricevitore si alterni con il trasmettitore (e viceversa); half-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, ma il ricevitore si alterna con il trasmettitore (ovvero, la comunicazione non pu\u00f2 avvenire contemporaneamente in entrambe le direzioni); full-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, e la comunicazione pu\u00f2 avvenire contemporaneamente in entrambe le direzioni. Questi includono dei pin, tensioni, impedenze di linea, specifiche dei cavi, timing del segmale e frequenza per i dispositivi wireless. Il controllo del bit rate \u00e8 fatto a livello fisico e pu\u00f2 definire delle modalit\u00e0 di trasmissione come simplex , half-duplex o full duplex.","title":"Livello 1: Livello fisico"},{"location":"05_reti/#livello-2-livello-data-link","text":"Il livello data link \u00e8 quello che si occupa di stabilire un \"collegamento\" tra due diversi nodi. In particolare: individua e corregge gli errori che avvengono a livello fisico; definisce come vengono instaurate e terminate le connessioni; controlla il flusso dati.","title":"Livello 2: Livello data link"},{"location":"05_reti/#il-progetto-ieee-802","text":"Il progetto IEEE 802 definisce, relativamente soprattutto al livello data link, un insieme di standard per le reti locali, in inglese Local Area Networks ( LAN ). In tal senso, la definizione data dal progetto IEEE 802 di rete locale \u00e8 la seguente: Quote Una LAN \u00e8 un sistema di comunicazione che permette ad apparecchiature indipendenti di comunicare fra loro entro un'area delimitata usando un canale fisico a velocit\u00e0 elevata e con basso tasso di errore. Notiamo che la LAN non \u00e8 quindi limitata nell'ambito (domestico, commerciale, industriale) n\u00e9 nelle tecnologie utilizzate: gli unici limiti sono l'area di interesse (giocoforza limitata), velocit\u00e0 ed affidabilit\u00e0 della comunicazione. Il progetto IEEE 802 ha quindi suddiviso il livello data link in due diversi sottolivelli: il livello Medium Access Control ( MAC ) verifica come i dispositivi di rete accedono al mezzo fisico; il livello Logical Link Control ( LLC ) controlla gli errori e sincronizza i frame. Concretamente, esistono diversi protocolli definiti nell'ambito del progetto IEEE 802, che sono usati nelle comunicazioni di tutti i giorni. Un esempio sono le reti Ethernet, che aderiscono allo standard 802.3, e le reti WiFi, che aderiscono a diverse versioni dello standard 802.11 (arrivato di recente alla revisione p ).","title":"Il progetto IEEE 802"},{"location":"05_reti/#livello-3-livello-di-rete","text":"Il livello di rete definisce come trasferire sequenze di lunghezza arbitraria ( pacchetti ) tra due nodi connessi in reti differenti, laddove per rete si potrebbe intendere sia una singola LAN, sia l'interconnessione di diverse LAN. E' sul concetto di rete che \u00e8 necessario focalizzarsi. Infatti, ogni dispositivo in rete \u00e8 comunemente detto nodo , e pu\u00f2 trasferire messaggi agli altri nodi semplicemente specificando l'indirizzo degli stessi (oltre che ovviamente il messaggio); saranno i dispositivi di rete a trovar eil modo di consegnare il messaggio al destiantario, magari instradandolo attraverso i nodi intermedi. Notiamo anche che la consegna dei messaggi a livello di rete non \u00e8 strettamente affidabile ; questo comporta quindi che i messaggi potrebbero essere persi, ed \u00e8 quindi necessario prevedere altri meccanismi per garantire l'affidabilit\u00e0 della comunicazione.","title":"Livello 3: livello di rete"},{"location":"05_reti/#livello-4-livello-di-trasporto","text":"Il livello di trasporto \u00e8 quello delegato a garantire questa affidabilit\u00e0 mediante opportuni meccanismi di controllo di flusso e di errore. Il modello ISO/OSI definisce cinque classi di protocolli a livello di trasporto, in base ai tipi di meccanismi di controllo dell'affidabilit\u00e0. Si va dalla classe TP0 , progettata per essere implementata su connessioni supposte error-free , ed i cui protocolli non forniscono alcun meccanismo per la gestione degli errori, fino alla classe TP4 , che \u00e8 quella che ricorda pi\u00f9 da vicino i protocolli maggiormente usati a livello di trasporto in Internet.","title":"Livello 4: livello di trasporto"},{"location":"05_reti/#livello-5-livello-di-sessione","text":"Il livello di sessione si occupa di controllare il \"dialogo\", ovvero le connessioni , tra i diversi computer, gestendone, tra le altre cose, l'inizializzazione e la chiusura.","title":"Livello 5: livello di sessione"},{"location":"05_reti/#livello-6-livello-di-presentazione","text":"Nel modello ISO/OSI, il livello di presentazione si occupa di stabilire un contesto tra due diverse entit\u00e0, all'interno del quale le due possono comunicare pur usando semantica e sentassi differenti . Il livello di presentazione funziona quindi un po' come un traduttore : fa in modo che due applicazioni, anche differenti, siano in grado di comunicare tra loro, fornendo una sorta di \"dizionario\" (o, pi\u00f9 correttamente, mappatura ) tra i linguaggi da loro compresi. E' anche per questo motivo che alle volte il livello di presentazione \u00e8 anche chiamato syntax layer . Oltre alla funzione di mapping, il livello di presentazione ne offre anche di altre, tra cui quella pi\u00f9 importante \u00e8 quella delegata alla compressione dei dati.","title":"Livello 6: livello di presentazione"},{"location":"05_reti/#livello-7-livello-applicativo","text":"Il livello applicativo \u00e8 quello pi\u00f9 vicino all'utente, ed interagisce direttamente con gli applicativi software da questo utilizzati. E' importante sottolineare che la specifica di questi programmi ricade al di fuori dell'ambito del modello ISO/OSI ; di conseguenza, le specifiche (ad esempio) del browser o di un'app per smartphone non saranno mai dettate dallo standard. Quest'ultima considerazione ci permette di distinguere tra applicazione ed entit\u00e0 legata all'applicazione: ad esempio, in un sito di prenotazione degli alberghi ci possono essere due entit\u00e0, una che usa un protocollo a livello applicativo per comunicare con gli utenti, ed un'altra che usa un protocollo a livello applicativo per salvare i dati su un database remoto. Nessuna di queste due entit\u00e0 ha per\u00f2 a che fare con l'applicazione stessa, che \u00e8 definita dalla logica di business (in questo caso, la prenotazione degli alberghi).","title":"Livello 7: Livello applicativo"},{"location":"05_reti/#lo-standard-del-mondo-reale-lo-stack-tcpip","text":"Il modello ISO/OSI non trova riscontro diretto nelle applicazioni reali: piuttosto, \u00e8 l' Internet Protocol Suite , o stack TCP/IP , lo stack protocollare usato ed implementato su Internet. Come vedremo, la denominazione stack TCP/IP deriva direttamente dal nome dei due principali protocolli su cui \u00e8 basato lo stack, ovvero il Transmission Control Protocol ( TCP ) e l' Internet Protocol ( IP ).","title":"Lo standard del mondo reale: lo stack TCP/IP"},{"location":"05_reti/#i-livelli-dello-stack-tcpip","text":"A differenza del modello ISO/OSI, lo stack TCP/IP \u00e8 organizzato in quattro diversi livelli, pi\u00f9 o meno riconducibili a quelli dell'ISO/OSI. Questi sono, dal pi\u00f9 basso al pi\u00f9 alto, il livello link , il livello internet , il livello trasporto ed il livello applicativo . Vediamoli di seguito.","title":"I livelli dello stack TCP/IP"},{"location":"05_reti/#livello-1-livello-link","text":"Il livello link si occupa di gestire la connessione limitatamente all'ambito della rete locale cui un host \u00e8 collegato. Il link , o collegamento , include quindi tutti gli host che \u00e8 possibile raggiungere senza dover coinvolgere un router (che \u00e8 il dispositivo che permette la connessione tra diverse reti locali). Va da s\u00e9 che la dimensione del link \u00e8 determinata dal progetto della rete stessa. Nel confronto con il modello ISO/OSI, il livello link racchiude le funzionalit\u00e0 corrispondenti a quelle del secondo layer (ovvero il data link ). E' importante sottolieare come l'effettiva implementazione del progetto IEEE 802 sia avvenuta proprio a questo livello.","title":"Livello 1: Livello link"},{"location":"05_reti/#livello-2-livello-internet","text":"La comunicazione tra diverse reti richiede che i dati siano correttamente instradati dalla rete iniziale a quella di destinazione, secondo un processo chiamato routing e supportato dall'identificazione degli indirizzi degli host coinvolti mediante il sistema degli indirizzi IP . Il livello internet fornisce una comunicazione non affidabile su reti differenti, garantendo l'inoltro dei pacchetti mediante dei dispositivi chiamati router. Il livello permette quindi l'interoperabilit\u00e0 di reti eterogenee, e definisce Internet nel modo in cui la conosciamo oggi. Il protocollo principale usato a questo livello \u00e8 l' Internet Protocol , che definisce due diversi sistemi di indirizzamento per l'identificazione degli host sulla rete. Il sistema originario di indirizzamento \u00e8 chiamato Internet Protocol version 4 ( IPv4 ), ed usa un indirizzo a 32 bit per identificare un numero massimo di \\(2^32\\) host. Ovviamente, con il progressivo diffondersi delle reti di telecomunicazione, questo valore ha rappresentato un limite, che \u00e8 stato dapprima arginato inserendo diverse classi di indirizzi riservati alle macchine interne ad ogni LAN, per poi essere superato nel 1998 mediante la standardizzazione dell'Internet Protocol version 6 (IPv6), che usa indirizzi a 128 bit. Tuttavia, nonostante le schede di rete in grado di supportare IPv6 esistano dal 2006 circa, l'IPv4 \u00e8 ancora il protocollo di comunicazione maggiormente utilizzato.","title":"Livello 2: Livello internet"},{"location":"05_reti/#livello-3-livello-di-trasporto","text":"Il livello di trasporto permette di creare dei \"canali dati\", che le applicazioni usano per lo scambio di messaggi specifici per determinati task. La connettivit\u00e0 pu\u00f2 essere implementata sia come connection-oriented , mediante il protocollo TCP, o connectionless , mediante il protocollo UDP. E' possibile fornire canali di trasmissione specifici per diversi processi mediante il concetto di porta di rete , ovvero la creazione di un costrutto logico numerico allocato specificamente per ognuno dei canali di comunicazione necessari. E' importante notare come, per molti servizi, questi numeri di porta siano stati standardizzati, in modo che i computer client possano indirizzare servizi specifici senza necessitare di tecniche di service discovery . Ad esempio, l'utilizzo standard del protocollo HTTP prevede il coinvolgimento della porta 80, mentre il protocollo SSH la porta 22. Il layer di trasporto dello stack TCP/IP corrisponde approssimativamente al quarto livello del modello OSI, chiamato transport layer.","title":"Livello 3: Livello di trasporto"},{"location":"05_reti/#trasmission-control-protocol","text":"Il protocollo TCP \u00e8 un protocollo connection-oriented che risolve i problemi di affidabilit\u00e0 che possono riscontrarsi nella fornitura di un flusso di byte affidabile. In particolare, il TCP garantisce che: i dati arrivino in ordine; i dati siano correttamente ricevuti; i dati duplicati siano scartati; i pacchetti persi o scartati siano nuovamente inviati; la congestione del traffico sia adeguatamente controllata.","title":"Trasmission Control Protocol"},{"location":"05_reti/#user-datagram-protocol","text":"Il protocollo UDP ( User Datagram Protocol ) \u00e8, a differenza del TCP, un protocollo connectionless , e si occupa di fornire una trasmissione dati non affidabile ma, non includendo il controllo degli errori tipico di TCP, pi\u00f9 veloce. L'UDP \u00e8 tipicamente usato per applicazioni legate allo streaming (audio, video e VoIP), dove l'arrivo in tempo dei dati \u00e8 pi\u00f9 importante dell'effettiva consegna degli stessi. Altri tipi di applicazioni sono quelle che prevedono esclusivamente semplici cicli di richiesta/risposta.","title":"User Datagram Protocol"},{"location":"05_reti/#livello-4-livello-applicativo","text":"Il livello applicativo include i protocolli usati dalla maggior part edelle applicazioni per fornire servizi all'utente. Questi possono includere servizi di supporto di rete, come protocolli per il routing e la configurazione di rete. Un esempio di protocollo a livello applicativo sono l*Hypertext Transfer Protocol* ( HTTP ). I dati codificati secondo i protocolli a livello applicativo vengono quindi incapsulati in unit\u00e0 a livello di trasporto (ad esempio, in formato TCP o UDP), per poi venire ulteriormente incapsulati man mano che si scende verso il layer fisico. E' interessante notare come lo stack TCP/IP non specifichi la formattazione e la presentazione dei dati, e non definisca dei layer aggiuntivi tra quello applicativo e di trasporto. Per quello che riguarda la comunicazione con il livello di trasporto (e quelli sottostanti), il livello applicativo tratta quest'ultimo come una black box : non si occupa quindi dei dettagli implementativi dello stesso, anche se \u00e8 a conoscenza di alcune informazioni fondamentali come indirizzo IP e numero di porta utilizzati. Dal punto di vista del confronto con il modello ISO/OSI, possiamo dire che il layer applicativo del modello TCP/IP \u00e8 spesso comparato ad una combinazione dei livelli di sessione, presentazione ed applicazione del primo.","title":"Livello 4: Livello applicativo"},{"location":"06_linguaggi/","text":"Il Linguaggio Naturale \u00b6 Il Linguaggio Naturale \u00e8 usato per la comunicazione (scritta ed orale) tra gli esseri umani. Ovviamente, il linguaggio naturale presenta diverse fonti di ambiguit\u00e0, tra cui: evoluzione del linguaggio : molto spesso, termini arcaici o neologismi potrebbero non essere ben compresi, come atavico o skippare ; polisemia : esistono termini che hanno un significato diverso a seconda del contesto (ad esempio, i principi non hanno principi ); ambiguit\u00e0 intrinseca : frasi e termini che per essere interpretati hanno necessariamente bisogno del contesto ( una vecchia porta la sbarra ). Questi motivi, oltre all'enorme variabilit\u00e0, fanno s\u00ec che il linguaggio naturale non sia adatto a permettere la comunicazione tra uomo e macchina. E' quindi l'umano a doversi giocoforza adattare. Definizione formale di Linguaggio \u00b6 Iniziamo dando una definizione (pi\u00f9 o meno) formale di linguaggio. Linguaggio Un linguaggio \u00e8 l'insieme di parole ottenute applicando le regole di una data grammatica. La grammatica, a sua volta, \u00e8 definita come segue: Grammatica Una grammatica \u00e8 un formalismo atto a definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle parole. E' chiaro come le due definizioni siano strettamente correlate tra loro, in quanto l'una discende direttamente dall'altra. Sintassi e semantica (nel linguaggio naturale) \u00b6 Le parole di un linguaggio possono essere analizzate da due diversi punti di vista: sintattico : comporta la verifica della correttezza della forma linguistica in cui \u00e8 codificato; semantico : comporta la verifica del significato associato alla forma linguistica. In realt\u00e0, esiste anche l'analisi pragmatica del testo, che ne prevede l'analisi nel contesto dell'utilizzo comune; quest'ultima, tuttavia, esula dai nostri obiettivi, e l'eventuale approfondimento \u00e8 demandato al lettore. Una frase scorretta dal punto di vista sintattico \u00e8 la seguente: Io ho andato a scuola. Una frase corretta dal punto di vista sintattico, ma semanticamente inconsistente \u00e8 la seguente: Tu hai suonato il cellulare al contrario. I Linguaggi di Programmazione \u00b6 I Linguaggi di Programmazione definiscono una notazione specificamente pensata per definire degli algoritmi . La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). Ci\u00f2 \u00e8 possibile usando appositi traduttori (ci ritorneremo pi\u00f9 avanti). Livelli di astrazione \u00b6 In generale, comunque, i linguaggi di programmazione sfruttano appieno il concetto di astrazione delle risorse della macchina su cui viene eseguito un programma. Questo \u00e8 un concetto ricorrente in informatica; ne abbiamo infatti avuto un \"assaggio\" quando abbiamo parlato del modello ISO/OSI, nel quale ogni layer rappresenta una ulteriore \"astrazione\" rispetto a quello sottostante, in modo da rendere il messaggio pi\u00f9 facilmente comprensibile da parte di un utente umano. Nell'ambito dei linguaggi di programmazione, astrarre significa mettere a disposizione i canali fisici di elaborazione dei dati (ovvero, i circuiti) ad un'entit\u00e0 (lo sviluppatore) che parla un linguaggio naturale. Diversi linguaggi di programmazione offrono diversi livelli di astrazione. Linguaggi ad alto livello \u00b6 In generale, i linguaggi ad alto livello , come ad esempio Python, sono molto \"vicini\" al linguaggio parlato da un essere umano, ed astraggono l'accesso alle risorse del calcolatore. Ad esempio, Python non richiede che sia lo sviluppatore a gestire la (tediosa e complessa) operazione di gestione della memoria, ma la gestisce in automatico mediante tecniche di garbage collection . Ci\u00f2 comporta vantaggi e svantaggi: da un lato, \u00e8 pi\u00f9 semplice scrivere programmi in un linguaggio ad alto livello; dall'altro, per\u00f2, vi \u00e8 una certa \"mancanza di controllo\" sulle operazioni compiute dalla macchina che, nonostante non risulti essere un problema nella maggior parte dei casi, pu\u00f2 essere necessaria in caso di applicazioni che richiedono delle procedure di ottimizzazione specifiche. Linguaggi a basso livello \u00b6 A differenza dei linguaggi ad alto livello, quelli a basso livello sono pi\u00f9 vicini al linguaggio parlato dalla macchina. In tal senso, i linguaggi di questo tipo delegano allo sviluppatore operazioni di gestione diretta delle risorse del calcolatore, ed i programmi scritti in questi linguaggi sono contestualmente pi\u00f9 complessi, richiedendo un grado di attenzione ed ottimizzazione pi\u00f9 elevato rispetto a quelli scritti in linguaggi ad alto livello. Ci\u00f2 lascia per\u00f2 spazio al programmatore esperto, che potr\u00e0 ottimizzare in maniera pi\u00f9 granulare le proprie applicazioni, senza dover sottostare ai meccanismi di astrazione delle risorse usati dai linguaggi ad alto livello. Nota sulla gestione delle risorse I meccanismi di gestione delle risorse dei linguaggi ad alto livello non sono \"poco efficienti\". Tutt'altro: essendo scritti da ottimi programmatori, sono molto spesso estremamente pi\u00f9 performanti rispetto a quelli che scriverebbe lo sviluppatore quadratico medio. Tuttavia, questi meccanismi sono, giocoforza, generici , dato che devono adattarsi all'intero ventaglio dei possibili algoritmi implementabili dal linguaggio di programmazione. La genericit\u00e0 determina, in specifiche e limitate circostanze, uno svantaggio, che potrebbe rendere preferibile un maggior controllo sulle risorse della macchina. E' importante sottolineare comunque come la maggior parte dei linguaggi di programmazione ad alto livello offra metodi specifici per gestire questo tipo di situazioni. Strutture dati \u00b6 I linguaggi di programmazione sfruttano il concetto di struttura dati ci permettono di organizzare, gestire e memorizzare dati in maniera efficiente. Entrando nel dettaglio, le strutture dati sono delle collezioni di diversi valori, che caratterizzano anche le relazioni tra di essi e le operazioni che vi possono essere applicate. Esistono diverse tipologie di strutture dati, ognuna delle quali adatta ad un certo utilizzo. Vediamone alcune. Array : questa struttura dati \u00e8 concettualmente assimibilabile ad un vettore di elementi, tipicamente (ma non necessariamente, a seconda del linguaggio) dello stesso tipo, organizzati secondo un ordine specifico, e ridimensionabili a seconda delle esigenze. E' possibile accedere ad ogni elemento dell'array mediate un apposito indice intero. Linked List (o pi\u00f9 semplicemente liste ): sono delle collezioni di elementi, tipicamente dello stesso tipo. Ogni elemento della lista \u00e8 chiamato nodo , e contiene al suo interno le informazioni riguardanti sia il valore associato a quell'elemento, sia un riferimento al nodo successivo nella lista. Concettualmente, lista ed array sono molto simili; tuttavia, la lista offre un vantaggio fondamentale, legato al fatto che \u00e8 possibile inserire o rimuovere un elemento dalla lista in maniera pi\u00f9 efficiente rispetto all'effettuare la stessa operazione su di un array. Struct (o anche tupla ): sono delle strutture dati in cui ogni record \u00e8 un valore che contiene altri valori (chiamati membri o campi ), tipicamente in numero e sequenza fissi, indicizzati usando esclusivamente i nomi. Union : sono delle strutture dati che specificano quale, tra un certo numero di tipi primitivi, pu\u00f2 essere memorizzato in una sua istanza. Si contrappongono alle struct, in quanto ammettono un unico valore per volta. Oggetto : struttura dati che contiene un certo numero di campi (come una struct) e vari metodi che operano direttamente sui contenuti dei dati. Linguaggi imperativi vs. linguaggi dichiarativi \u00b6 In generale, \u00e8 possibile operare un'ulteriore distinzione tra linguaggi di programmazione, in base alle modalit\u00e0 con cui viene definita la serie di operazioni che il programma dovr\u00e0 eseguire. Nella programmazione imperativa (o procedurale ), \u00e8 possibile controllare lo stato del programma, specificando il flusso di esecuzione delle istruzioni. Tipici esempi di linguaggi procedurali sono Python, C e C++. Nella programmazione dichiarativa (o non procedurale ), invece, viene semplicemente indicato al programma il risultato che vogliamo ottenere. Esempi di linguaggi di questo tipo sono SQL e Prolog. Facciamo un esempio. In un linguaggio imperativo, \"imponiamo\" al programma le istruzioni da compiere; specifichiamo quindi come ottenere un risultato. Ad esempio: x = 12 y = x * 2 print ( \"Il valore di x \u00e8: {} \" . format ( x )) Nell'esempio precedente, scritto in Python, indichiamo al programma che deve valutare il valore di x , moltiplicarlo per 2, assegnarlo ad y e mostrarlo a schermo. Un esempio di programmazione dichiarativa \u00e8 invece quello che usiamo quando interroghiamo un database mediante istruzioni SQL. Ad esempio: SELECT * FROM TABLE STUDENTI ; In questo caso, \u00e8 chiaro come non si stia specificando come interrogare il database, ma soltanto quello che ci si aspetta da esso (il cosa ). Espressitiv\u00e0 \u00b6 In generale, un linguaggio \u00e8 una rappresentazione scritta o verbale di una serie di concetti ; la quantit\u00e0 e qualit\u00e0 di questa rappresentazione \u00e8 determinata dalla potenza espressiva di un linguaggio. Per quello che riguarda i linguaggi di programmazione, l'espressivit\u00e0 \u00e8 associata ai problemi che sono in grado di risolvere e, di conseguenza, agli algoritmi che sono in grado di rappresentare . In particolare, i linguaggi di programmazione pi\u00f9 comuni sono spesso definiti come Turing-completi , in quanto possono implementare tutti gli algoritmi risolvibili da una macchina di Turing universale (torneremo pi\u00f9 avanti su questo concetto). I linguaggi di markup, come ad esempio HTML ed XML, non sono normalmente considerati linguaggi di programmazione. Sintassi e semantica (nei linguaggi di programmazione) \u00b6 Come nei linguaggi naturali, anche per i linguaggi di programmazione sono essenziali i concetti di sintassi e semantica . In particolare, la sintassi specifica le regole con le quali un'istruzione viene ritenuta valida. In generale, queste variano da linguaggio a linguaggio (rimanendo pur sempre abbastanza \"affini\"), e sono estremamente rigide : un programma non conforme alle regole sintattiche indicate per il linguaggio non potr\u00e0 in alcun modo essere eseguito. Per fortuna, queste regole sono poche , semplici e ben definite per ogni linguaggio. Neanche lontanamente complesse come l'uso dei congiuntivi, quindi. Anche la semantica ha un rapporto estremamente \"stretto\" con l'analogo concetto usato nei linguaggi naturali, dato che ci permette di valutare il contenuto informativo di un programma. In particolare, ci sono tre metodi per trattare formalmente la semantica di un programma, allo scopo di caratterizzarne il comportamento: nella semantica operazionale si specifica come i costrutti del linguaggio vengano eseguiti su di una macchina astratta; nella semantica denotazionale si specifica come interpretare il significato dei costrutti scritti in un linguaggio; nella semantica assiomatica si specifica come determinare il significato dei costrutti scritti in un linguaggio usando degli assiomi (ovvero regole di \"correttezza\" data una certa logica).","title":"06 linguaggi"},{"location":"06_linguaggi/#il-linguaggio-naturale","text":"Il Linguaggio Naturale \u00e8 usato per la comunicazione (scritta ed orale) tra gli esseri umani. Ovviamente, il linguaggio naturale presenta diverse fonti di ambiguit\u00e0, tra cui: evoluzione del linguaggio : molto spesso, termini arcaici o neologismi potrebbero non essere ben compresi, come atavico o skippare ; polisemia : esistono termini che hanno un significato diverso a seconda del contesto (ad esempio, i principi non hanno principi ); ambiguit\u00e0 intrinseca : frasi e termini che per essere interpretati hanno necessariamente bisogno del contesto ( una vecchia porta la sbarra ). Questi motivi, oltre all'enorme variabilit\u00e0, fanno s\u00ec che il linguaggio naturale non sia adatto a permettere la comunicazione tra uomo e macchina. E' quindi l'umano a doversi giocoforza adattare.","title":"Il Linguaggio Naturale"},{"location":"06_linguaggi/#definizione-formale-di-linguaggio","text":"Iniziamo dando una definizione (pi\u00f9 o meno) formale di linguaggio. Linguaggio Un linguaggio \u00e8 l'insieme di parole ottenute applicando le regole di una data grammatica. La grammatica, a sua volta, \u00e8 definita come segue: Grammatica Una grammatica \u00e8 un formalismo atto a definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle parole. E' chiaro come le due definizioni siano strettamente correlate tra loro, in quanto l'una discende direttamente dall'altra.","title":"Definizione formale di Linguaggio"},{"location":"06_linguaggi/#sintassi-e-semantica-nel-linguaggio-naturale","text":"Le parole di un linguaggio possono essere analizzate da due diversi punti di vista: sintattico : comporta la verifica della correttezza della forma linguistica in cui \u00e8 codificato; semantico : comporta la verifica del significato associato alla forma linguistica. In realt\u00e0, esiste anche l'analisi pragmatica del testo, che ne prevede l'analisi nel contesto dell'utilizzo comune; quest'ultima, tuttavia, esula dai nostri obiettivi, e l'eventuale approfondimento \u00e8 demandato al lettore. Una frase scorretta dal punto di vista sintattico \u00e8 la seguente: Io ho andato a scuola. Una frase corretta dal punto di vista sintattico, ma semanticamente inconsistente \u00e8 la seguente: Tu hai suonato il cellulare al contrario.","title":"Sintassi e semantica (nel linguaggio naturale)"},{"location":"06_linguaggi/#i-linguaggi-di-programmazione","text":"I Linguaggi di Programmazione definiscono una notazione specificamente pensata per definire degli algoritmi . La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). Ci\u00f2 \u00e8 possibile usando appositi traduttori (ci ritorneremo pi\u00f9 avanti).","title":"I Linguaggi di Programmazione"},{"location":"06_linguaggi/#livelli-di-astrazione","text":"In generale, comunque, i linguaggi di programmazione sfruttano appieno il concetto di astrazione delle risorse della macchina su cui viene eseguito un programma. Questo \u00e8 un concetto ricorrente in informatica; ne abbiamo infatti avuto un \"assaggio\" quando abbiamo parlato del modello ISO/OSI, nel quale ogni layer rappresenta una ulteriore \"astrazione\" rispetto a quello sottostante, in modo da rendere il messaggio pi\u00f9 facilmente comprensibile da parte di un utente umano. Nell'ambito dei linguaggi di programmazione, astrarre significa mettere a disposizione i canali fisici di elaborazione dei dati (ovvero, i circuiti) ad un'entit\u00e0 (lo sviluppatore) che parla un linguaggio naturale. Diversi linguaggi di programmazione offrono diversi livelli di astrazione.","title":"Livelli di astrazione"},{"location":"06_linguaggi/#linguaggi-ad-alto-livello","text":"In generale, i linguaggi ad alto livello , come ad esempio Python, sono molto \"vicini\" al linguaggio parlato da un essere umano, ed astraggono l'accesso alle risorse del calcolatore. Ad esempio, Python non richiede che sia lo sviluppatore a gestire la (tediosa e complessa) operazione di gestione della memoria, ma la gestisce in automatico mediante tecniche di garbage collection . Ci\u00f2 comporta vantaggi e svantaggi: da un lato, \u00e8 pi\u00f9 semplice scrivere programmi in un linguaggio ad alto livello; dall'altro, per\u00f2, vi \u00e8 una certa \"mancanza di controllo\" sulle operazioni compiute dalla macchina che, nonostante non risulti essere un problema nella maggior parte dei casi, pu\u00f2 essere necessaria in caso di applicazioni che richiedono delle procedure di ottimizzazione specifiche.","title":"Linguaggi ad alto livello"},{"location":"06_linguaggi/#linguaggi-a-basso-livello","text":"A differenza dei linguaggi ad alto livello, quelli a basso livello sono pi\u00f9 vicini al linguaggio parlato dalla macchina. In tal senso, i linguaggi di questo tipo delegano allo sviluppatore operazioni di gestione diretta delle risorse del calcolatore, ed i programmi scritti in questi linguaggi sono contestualmente pi\u00f9 complessi, richiedendo un grado di attenzione ed ottimizzazione pi\u00f9 elevato rispetto a quelli scritti in linguaggi ad alto livello. Ci\u00f2 lascia per\u00f2 spazio al programmatore esperto, che potr\u00e0 ottimizzare in maniera pi\u00f9 granulare le proprie applicazioni, senza dover sottostare ai meccanismi di astrazione delle risorse usati dai linguaggi ad alto livello. Nota sulla gestione delle risorse I meccanismi di gestione delle risorse dei linguaggi ad alto livello non sono \"poco efficienti\". Tutt'altro: essendo scritti da ottimi programmatori, sono molto spesso estremamente pi\u00f9 performanti rispetto a quelli che scriverebbe lo sviluppatore quadratico medio. Tuttavia, questi meccanismi sono, giocoforza, generici , dato che devono adattarsi all'intero ventaglio dei possibili algoritmi implementabili dal linguaggio di programmazione. La genericit\u00e0 determina, in specifiche e limitate circostanze, uno svantaggio, che potrebbe rendere preferibile un maggior controllo sulle risorse della macchina. E' importante sottolineare comunque come la maggior parte dei linguaggi di programmazione ad alto livello offra metodi specifici per gestire questo tipo di situazioni.","title":"Linguaggi a basso livello"},{"location":"06_linguaggi/#strutture-dati","text":"I linguaggi di programmazione sfruttano il concetto di struttura dati ci permettono di organizzare, gestire e memorizzare dati in maniera efficiente. Entrando nel dettaglio, le strutture dati sono delle collezioni di diversi valori, che caratterizzano anche le relazioni tra di essi e le operazioni che vi possono essere applicate. Esistono diverse tipologie di strutture dati, ognuna delle quali adatta ad un certo utilizzo. Vediamone alcune. Array : questa struttura dati \u00e8 concettualmente assimibilabile ad un vettore di elementi, tipicamente (ma non necessariamente, a seconda del linguaggio) dello stesso tipo, organizzati secondo un ordine specifico, e ridimensionabili a seconda delle esigenze. E' possibile accedere ad ogni elemento dell'array mediate un apposito indice intero. Linked List (o pi\u00f9 semplicemente liste ): sono delle collezioni di elementi, tipicamente dello stesso tipo. Ogni elemento della lista \u00e8 chiamato nodo , e contiene al suo interno le informazioni riguardanti sia il valore associato a quell'elemento, sia un riferimento al nodo successivo nella lista. Concettualmente, lista ed array sono molto simili; tuttavia, la lista offre un vantaggio fondamentale, legato al fatto che \u00e8 possibile inserire o rimuovere un elemento dalla lista in maniera pi\u00f9 efficiente rispetto all'effettuare la stessa operazione su di un array. Struct (o anche tupla ): sono delle strutture dati in cui ogni record \u00e8 un valore che contiene altri valori (chiamati membri o campi ), tipicamente in numero e sequenza fissi, indicizzati usando esclusivamente i nomi. Union : sono delle strutture dati che specificano quale, tra un certo numero di tipi primitivi, pu\u00f2 essere memorizzato in una sua istanza. Si contrappongono alle struct, in quanto ammettono un unico valore per volta. Oggetto : struttura dati che contiene un certo numero di campi (come una struct) e vari metodi che operano direttamente sui contenuti dei dati.","title":"Strutture dati"},{"location":"06_linguaggi/#linguaggi-imperativi-vs-linguaggi-dichiarativi","text":"In generale, \u00e8 possibile operare un'ulteriore distinzione tra linguaggi di programmazione, in base alle modalit\u00e0 con cui viene definita la serie di operazioni che il programma dovr\u00e0 eseguire. Nella programmazione imperativa (o procedurale ), \u00e8 possibile controllare lo stato del programma, specificando il flusso di esecuzione delle istruzioni. Tipici esempi di linguaggi procedurali sono Python, C e C++. Nella programmazione dichiarativa (o non procedurale ), invece, viene semplicemente indicato al programma il risultato che vogliamo ottenere. Esempi di linguaggi di questo tipo sono SQL e Prolog. Facciamo un esempio. In un linguaggio imperativo, \"imponiamo\" al programma le istruzioni da compiere; specifichiamo quindi come ottenere un risultato. Ad esempio: x = 12 y = x * 2 print ( \"Il valore di x \u00e8: {} \" . format ( x )) Nell'esempio precedente, scritto in Python, indichiamo al programma che deve valutare il valore di x , moltiplicarlo per 2, assegnarlo ad y e mostrarlo a schermo. Un esempio di programmazione dichiarativa \u00e8 invece quello che usiamo quando interroghiamo un database mediante istruzioni SQL. Ad esempio: SELECT * FROM TABLE STUDENTI ; In questo caso, \u00e8 chiaro come non si stia specificando come interrogare il database, ma soltanto quello che ci si aspetta da esso (il cosa ).","title":"Linguaggi imperativi vs. linguaggi dichiarativi"},{"location":"06_linguaggi/#espressitiva","text":"In generale, un linguaggio \u00e8 una rappresentazione scritta o verbale di una serie di concetti ; la quantit\u00e0 e qualit\u00e0 di questa rappresentazione \u00e8 determinata dalla potenza espressiva di un linguaggio. Per quello che riguarda i linguaggi di programmazione, l'espressivit\u00e0 \u00e8 associata ai problemi che sono in grado di risolvere e, di conseguenza, agli algoritmi che sono in grado di rappresentare . In particolare, i linguaggi di programmazione pi\u00f9 comuni sono spesso definiti come Turing-completi , in quanto possono implementare tutti gli algoritmi risolvibili da una macchina di Turing universale (torneremo pi\u00f9 avanti su questo concetto). I linguaggi di markup, come ad esempio HTML ed XML, non sono normalmente considerati linguaggi di programmazione.","title":"Espressitiv\u00e0"},{"location":"06_linguaggi/#sintassi-e-semantica-nei-linguaggi-di-programmazione","text":"Come nei linguaggi naturali, anche per i linguaggi di programmazione sono essenziali i concetti di sintassi e semantica . In particolare, la sintassi specifica le regole con le quali un'istruzione viene ritenuta valida. In generale, queste variano da linguaggio a linguaggio (rimanendo pur sempre abbastanza \"affini\"), e sono estremamente rigide : un programma non conforme alle regole sintattiche indicate per il linguaggio non potr\u00e0 in alcun modo essere eseguito. Per fortuna, queste regole sono poche , semplici e ben definite per ogni linguaggio. Neanche lontanamente complesse come l'uso dei congiuntivi, quindi. Anche la semantica ha un rapporto estremamente \"stretto\" con l'analogo concetto usato nei linguaggi naturali, dato che ci permette di valutare il contenuto informativo di un programma. In particolare, ci sono tre metodi per trattare formalmente la semantica di un programma, allo scopo di caratterizzarne il comportamento: nella semantica operazionale si specifica come i costrutti del linguaggio vengano eseguiti su di una macchina astratta; nella semantica denotazionale si specifica come interpretare il significato dei costrutti scritti in un linguaggio; nella semantica assiomatica si specifica come determinare il significato dei costrutti scritti in un linguaggio usando degli assiomi (ovvero regole di \"correttezza\" data una certa logica).","title":"Sintassi e semantica (nei linguaggi di programmazione)"},{"location":"07_traduttori/","text":"Traduttori \u00b6 Parlando dei linguaggi di programmazione, abbiamo detto che: Il Docente, o, alternativamente, Queste Dispense. La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). L'esecuzione di questo task \u00e8 delegato ad un apposito programma chiamato traduttore , che si occupa di tradurre il codice scritto in un linguaggio (chiamato linguaggio sorgente ) in codice scritto in un altro linguaggio (chiamato linguaggio obiettivo ). Normalmente, il linguaggio sorgente \u00e8 ad un livello di astrazione pi\u00f9 alto rispetto al linguaggio obiettivo: ad esempio, il linguaggio sorgente potrebbe essere il C, mentre il linguaggio obiettivo potrebbe essere Assembly. Il traduttore ha diversi compiti: per prima cosa, si occupa di verificare la correttezza sintattica del codice scritto in linguaggio sorgente. Per fare un esempio, il traduttore valider\u00e0 questa istruzione: a = 1 + 2 ma non questa: a = = 2 + 'pippo' Una volta validata la correttezza sintattica delle istruzioni analizzate, attribuir\u00e0 a ciascuna di esse un opportuno significato , associando le corrispondenti istruzioni nel linguaggio obiettivo. E' importante sottolinare come l'interpretazione debba essere univoca , onde garantire la propriet\u00e0 di non ambiguit\u00e0 degli algoritmi. Esistono principalmente due categorie di traduttori: i compilatori e gli interpreti . Compilatori \u00b6 Il termine compilatore viene usato per indicare i traduttori che si occupano di tradurre direttamente il codice da un linguaggio sorgente ad alto livello ad un linguaggio obiettivo a basso livello, come assembly, codice oggetto o codice macchina. Nota Il fatto che un compilatore traduca direttamente il codice da linguaggio ad alto livello a codice oggetto/macchina implica che quest'ultimo sia specifico per un certo tipo di hardware e software. Ci\u00f2 comporta che, in molte situazioni, non saremo in grado di eseguire il codice compilato per i nostri PC su dispositivi come Arduino o i nostri smartphone! Tipologie di compilatore (alcuni esempi) \u00b6 Esistono diversi tipi di compilatore. Ad esempio, se il programma compilato pu\u00f2 essere eseguito su un computer le cui caratteristiche hardware o software sono diverse da quelle del computer sul quale il programma \u00e8 stato compilato, siamo di fronte ad un cross-compilatore . Nota Per \"caratteristiche hardware o software\" si intendono prevalentemente CPU (ed il suo instruction set) e sistema operativo (ed i driver che comandano i diversi dispositivi). Il programma duale di un compilatore \u00e8 chiamato decompilatore , ed \u00e8, prevedibilmente, un programma che traduce il codice da un linguaggio sorgente a basso livello ad un linguaggio obiettivo a pi\u00f9 alto livello. Un altro esempio di compilatore \u00e8 il transcompilatore , che traduce un programma scritto in un sorgente ad alto livello in codice scritto in un obiettivo sempre ad alto livello. Operazioni di un compilatore \u00b6 La maggior parte dei compilatori odierni segue un percorso articolato in tre diverse fasi ( three-stage compilers ), chiamate rispettivamente front end , middle end e back end . Front end \u00b6 Lo scopo del front end \u00e8 quello di analizzare il codice scritto in liguaggio sorgente, creando una rappresentazione intermedia del programma. Il processo supportato dalla fase di front end si articola in quattro diverse fasi. Preprocessing \u00b6 La fase di preprocessing (in italiano pre-elaborazione ) si occupa di sostituire alcune direttive specifiche per il linguaggio (ad esempio, le direttive #define in C) con il corrispondente codice sorgente. Analisi lessicale \u00b6 La fase di analisi lessicale prevede la lettura del sorgente come un'unica stringa, e la successiva suddivisione della stessa in \"parti\" dette token , i quali sono delimitati da caratteri come segni di interpunzione (ad esempio, virgole, punti, etc.), operatori matematici (ad esempio, i segni + , - , etc.), parentesi, o anche nomi di variabile e parole riservate. Un esempio di tokenizzazione \u00e8 il seguente. il codice sorgente: if ( x > 0.0 ) { y = 1.0 ; } diventa: if ( x > 0.0 ) y = 1.0 ; che produce i token if , ( , x , > , 0.0 , ) , y , = , 1.0 . Analisi sintattica \u00b6 La fase di analisi sintattica , comunemente nota anche come parsing , prevede l'analisi dei singoli token allo scopo di valutarne la correttezza sintattica , ovvero l'adesione alle regole grammaticali stabilite per quel linguaggio. L'analisi sintattica crea una struttura ad albero costruita a partire dalle regole formali del linguaggio, chiamata albero di parsing ( parse tree ). Analisi semantica \u00b6 La fase di analisi semantica integra le informazioni immagazzinate nel parse tree con informazioni di tipo semantico, come ad esempio il type checking , che controlla la coerenza tra i diversi tipi assunti dalle variabili. Middle End \u00b6 Lo scopo del middle end \u00e8 quello di ottimizzare la rappresentazione intermedia ottenuta dal front end. Per far questo, sono implementate delle tecniche di analisi del programma (ad esempio, mediante l'analisi del flusso di esecuzione, allo scopo di valutare e la presenza di eventuali ridondanze) ed ottimizzazione (ad esempio, rimuovendo le ridondanze individuate nella fase precedente). Un esempio di ridondanza \u00e8 il seguente: int main ( void ) { int a = 0 ; // Codice ridondante! if ( 1 == 0 ) { a = 1 ; } return a ; } Il codice all'interno dell'istruzione condizionale non \u00e8 raggiungibile , in quanto la condizione di uguaglianza tra uno e zero non \u00e8, per le conoscenze attuali, mai verificata. Back End \u00b6 Lo scopo del back end \u00e8 quello di inserire (opzionalmente) delle ottimizzazioni specifiche per l'architettura corrente (ovvero per il processore per il quale il codice sta venendo compilato), e generare il codice oggetto . Nota Il codice oggetto non \u00e8 il programma eseguibile. Generare l'eseguibile \u00e8 compito di un altro programma, spesso integrato in quelli che generalmente sono indicati come compilatori, chiamato linker . Interpreti \u00b6 L'altro tipo di traduttore comunemente utilizzato al giorno d'oggi \u00e8 chiamato interprete . L'approccio usato dall'interprete si differenzia da quello usato dal compilatore principalmente per un dettaglio: laddove il compilatore fa in modo che l'intero processo di traduzione da codice sorgente a programma eseguibile avvenga prima dell'esecuzione del programma, in un lasso di tempo chiamato compile time , l'interprete esegue un'istruzione immediatamente ; in teoria, ogni istruzione in un linguaggio interpretata potrebbe essere eseguita immediatamente dopo la sua scrittura. Non vi \u00e8 quindi una netta separazione, almeno dal punto di vista dell'utente, tra compile time e run time (con quest'ultimo il lasso di tempo in cui il programma \u00e8 in esecuzione). Gli step di interpetazione sono quindi essenzialmente tre: controllo dell'istruzione sul codice sorgente; traduzione in linguaggio macchina; esecuzione dell'istruzione tradotta. Ne consegue che un programma interpretato potrebbe interrompersi \"al volo\" (ovvero a run time), proprio perch\u00e9 l'interprete non \u00e8 in grado di anticipare eventuali errori sul sorgente. Compilatore vs. Interprete \u00b6 Di seguito una tabella comparativa di vantaggi e svantaggi legati all'adozione di un compilatore o di un interprete. Compilatore Interpete Vantaggi Ottimizzazione del codice Maggiore velocit\u00e0 di esecuzione Controllo sintattico e semantico Compile time nullo o ridotto Maggiore portabilit\u00e0 tra architettura Possibilit\u00e0 di debug con granularit\u00e0 a livello di singola istruzione Svantaggi Minore portabilit\u00e0 tra architetture Debug complesso da effettuare Minore velocit\u00e0 di esecuzione Performance non ottimizzate Possibili errori imprevisti a run time Linguaggi compilati e linguaggi interpretati \u00b6 Per linguaggio compilato si intende un linguaggio di programmazione le cui implementazioni sono tipicamente compilate ; di converso, un linguaggio interpretato prevede l'uso estensivo di interpeti. La distinzione \u00e8 per\u00f2 alquanto vaga. Infatti, almeno in linea di principio, qualunque linguaggio pu\u00f2 essere implementato indifferentemente mediante un compilatore od un itnerprete. E' anche possibile combinare entrambe le soluzioni: un compilatore pu\u00f2 ad esempio occuparsi della traduzione del codice sorgente nella rappresentazione intermedia, chiamata in questi casi bytecode , che viene passata ad un interprete che la esegue. E' questo ad esempio il caso di Java, che utilizza questo tipo di soluzione per passare il bytecode alla Java Virtual Machine , di cui esiste un'implementazione per la maggior parte delle architetture esistenti.","title":"07 traduttori"},{"location":"07_traduttori/#traduttori","text":"Parlando dei linguaggi di programmazione, abbiamo detto che: Il Docente, o, alternativamente, Queste Dispense. La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). L'esecuzione di questo task \u00e8 delegato ad un apposito programma chiamato traduttore , che si occupa di tradurre il codice scritto in un linguaggio (chiamato linguaggio sorgente ) in codice scritto in un altro linguaggio (chiamato linguaggio obiettivo ). Normalmente, il linguaggio sorgente \u00e8 ad un livello di astrazione pi\u00f9 alto rispetto al linguaggio obiettivo: ad esempio, il linguaggio sorgente potrebbe essere il C, mentre il linguaggio obiettivo potrebbe essere Assembly. Il traduttore ha diversi compiti: per prima cosa, si occupa di verificare la correttezza sintattica del codice scritto in linguaggio sorgente. Per fare un esempio, il traduttore valider\u00e0 questa istruzione: a = 1 + 2 ma non questa: a = = 2 + 'pippo' Una volta validata la correttezza sintattica delle istruzioni analizzate, attribuir\u00e0 a ciascuna di esse un opportuno significato , associando le corrispondenti istruzioni nel linguaggio obiettivo. E' importante sottolinare come l'interpretazione debba essere univoca , onde garantire la propriet\u00e0 di non ambiguit\u00e0 degli algoritmi. Esistono principalmente due categorie di traduttori: i compilatori e gli interpreti .","title":"Traduttori"},{"location":"07_traduttori/#compilatori","text":"Il termine compilatore viene usato per indicare i traduttori che si occupano di tradurre direttamente il codice da un linguaggio sorgente ad alto livello ad un linguaggio obiettivo a basso livello, come assembly, codice oggetto o codice macchina. Nota Il fatto che un compilatore traduca direttamente il codice da linguaggio ad alto livello a codice oggetto/macchina implica che quest'ultimo sia specifico per un certo tipo di hardware e software. Ci\u00f2 comporta che, in molte situazioni, non saremo in grado di eseguire il codice compilato per i nostri PC su dispositivi come Arduino o i nostri smartphone!","title":"Compilatori"},{"location":"07_traduttori/#tipologie-di-compilatore-alcuni-esempi","text":"Esistono diversi tipi di compilatore. Ad esempio, se il programma compilato pu\u00f2 essere eseguito su un computer le cui caratteristiche hardware o software sono diverse da quelle del computer sul quale il programma \u00e8 stato compilato, siamo di fronte ad un cross-compilatore . Nota Per \"caratteristiche hardware o software\" si intendono prevalentemente CPU (ed il suo instruction set) e sistema operativo (ed i driver che comandano i diversi dispositivi). Il programma duale di un compilatore \u00e8 chiamato decompilatore , ed \u00e8, prevedibilmente, un programma che traduce il codice da un linguaggio sorgente a basso livello ad un linguaggio obiettivo a pi\u00f9 alto livello. Un altro esempio di compilatore \u00e8 il transcompilatore , che traduce un programma scritto in un sorgente ad alto livello in codice scritto in un obiettivo sempre ad alto livello.","title":"Tipologie di compilatore (alcuni esempi)"},{"location":"07_traduttori/#operazioni-di-un-compilatore","text":"La maggior parte dei compilatori odierni segue un percorso articolato in tre diverse fasi ( three-stage compilers ), chiamate rispettivamente front end , middle end e back end .","title":"Operazioni di un compilatore"},{"location":"07_traduttori/#front-end","text":"Lo scopo del front end \u00e8 quello di analizzare il codice scritto in liguaggio sorgente, creando una rappresentazione intermedia del programma. Il processo supportato dalla fase di front end si articola in quattro diverse fasi.","title":"Front end"},{"location":"07_traduttori/#preprocessing","text":"La fase di preprocessing (in italiano pre-elaborazione ) si occupa di sostituire alcune direttive specifiche per il linguaggio (ad esempio, le direttive #define in C) con il corrispondente codice sorgente.","title":"Preprocessing"},{"location":"07_traduttori/#analisi-lessicale","text":"La fase di analisi lessicale prevede la lettura del sorgente come un'unica stringa, e la successiva suddivisione della stessa in \"parti\" dette token , i quali sono delimitati da caratteri come segni di interpunzione (ad esempio, virgole, punti, etc.), operatori matematici (ad esempio, i segni + , - , etc.), parentesi, o anche nomi di variabile e parole riservate. Un esempio di tokenizzazione \u00e8 il seguente. il codice sorgente: if ( x > 0.0 ) { y = 1.0 ; } diventa: if ( x > 0.0 ) y = 1.0 ; che produce i token if , ( , x , > , 0.0 , ) , y , = , 1.0 .","title":"Analisi lessicale"},{"location":"07_traduttori/#analisi-sintattica","text":"La fase di analisi sintattica , comunemente nota anche come parsing , prevede l'analisi dei singoli token allo scopo di valutarne la correttezza sintattica , ovvero l'adesione alle regole grammaticali stabilite per quel linguaggio. L'analisi sintattica crea una struttura ad albero costruita a partire dalle regole formali del linguaggio, chiamata albero di parsing ( parse tree ).","title":"Analisi sintattica"},{"location":"07_traduttori/#analisi-semantica","text":"La fase di analisi semantica integra le informazioni immagazzinate nel parse tree con informazioni di tipo semantico, come ad esempio il type checking , che controlla la coerenza tra i diversi tipi assunti dalle variabili.","title":"Analisi semantica"},{"location":"07_traduttori/#middle-end","text":"Lo scopo del middle end \u00e8 quello di ottimizzare la rappresentazione intermedia ottenuta dal front end. Per far questo, sono implementate delle tecniche di analisi del programma (ad esempio, mediante l'analisi del flusso di esecuzione, allo scopo di valutare e la presenza di eventuali ridondanze) ed ottimizzazione (ad esempio, rimuovendo le ridondanze individuate nella fase precedente). Un esempio di ridondanza \u00e8 il seguente: int main ( void ) { int a = 0 ; // Codice ridondante! if ( 1 == 0 ) { a = 1 ; } return a ; } Il codice all'interno dell'istruzione condizionale non \u00e8 raggiungibile , in quanto la condizione di uguaglianza tra uno e zero non \u00e8, per le conoscenze attuali, mai verificata.","title":"Middle End"},{"location":"07_traduttori/#back-end","text":"Lo scopo del back end \u00e8 quello di inserire (opzionalmente) delle ottimizzazioni specifiche per l'architettura corrente (ovvero per il processore per il quale il codice sta venendo compilato), e generare il codice oggetto . Nota Il codice oggetto non \u00e8 il programma eseguibile. Generare l'eseguibile \u00e8 compito di un altro programma, spesso integrato in quelli che generalmente sono indicati come compilatori, chiamato linker .","title":"Back End"},{"location":"07_traduttori/#interpreti","text":"L'altro tipo di traduttore comunemente utilizzato al giorno d'oggi \u00e8 chiamato interprete . L'approccio usato dall'interprete si differenzia da quello usato dal compilatore principalmente per un dettaglio: laddove il compilatore fa in modo che l'intero processo di traduzione da codice sorgente a programma eseguibile avvenga prima dell'esecuzione del programma, in un lasso di tempo chiamato compile time , l'interprete esegue un'istruzione immediatamente ; in teoria, ogni istruzione in un linguaggio interpretata potrebbe essere eseguita immediatamente dopo la sua scrittura. Non vi \u00e8 quindi una netta separazione, almeno dal punto di vista dell'utente, tra compile time e run time (con quest'ultimo il lasso di tempo in cui il programma \u00e8 in esecuzione). Gli step di interpetazione sono quindi essenzialmente tre: controllo dell'istruzione sul codice sorgente; traduzione in linguaggio macchina; esecuzione dell'istruzione tradotta. Ne consegue che un programma interpretato potrebbe interrompersi \"al volo\" (ovvero a run time), proprio perch\u00e9 l'interprete non \u00e8 in grado di anticipare eventuali errori sul sorgente.","title":"Interpreti"},{"location":"07_traduttori/#compilatore-vs-interprete","text":"Di seguito una tabella comparativa di vantaggi e svantaggi legati all'adozione di un compilatore o di un interprete. Compilatore Interpete Vantaggi Ottimizzazione del codice Maggiore velocit\u00e0 di esecuzione Controllo sintattico e semantico Compile time nullo o ridotto Maggiore portabilit\u00e0 tra architettura Possibilit\u00e0 di debug con granularit\u00e0 a livello di singola istruzione Svantaggi Minore portabilit\u00e0 tra architetture Debug complesso da effettuare Minore velocit\u00e0 di esecuzione Performance non ottimizzate Possibili errori imprevisti a run time","title":"Compilatore vs. Interprete"},{"location":"07_traduttori/#linguaggi-compilati-e-linguaggi-interpretati","text":"Per linguaggio compilato si intende un linguaggio di programmazione le cui implementazioni sono tipicamente compilate ; di converso, un linguaggio interpretato prevede l'uso estensivo di interpeti. La distinzione \u00e8 per\u00f2 alquanto vaga. Infatti, almeno in linea di principio, qualunque linguaggio pu\u00f2 essere implementato indifferentemente mediante un compilatore od un itnerprete. E' anche possibile combinare entrambe le soluzioni: un compilatore pu\u00f2 ad esempio occuparsi della traduzione del codice sorgente nella rappresentazione intermedia, chiamata in questi casi bytecode , che viene passata ad un interprete che la esegue. E' questo ad esempio il caso di Java, che utilizza questo tipo di soluzione per passare il bytecode alla Java Virtual Machine , di cui esiste un'implementazione per la maggior parte delle architetture esistenti.","title":"Linguaggi compilati e linguaggi interpretati"},{"location":"08_turing/","text":"Introduzione \u00b6 Una macchina di Turing \u00e8 un'astrazione matematica che consiste di un nastro a lunghezza infinita diviso in celle sul quale \u00e8 dato un certo input. Consiste di una testina che legge il nastro di ingresso. Un registro memorizza lo stato della macchina di Turing. Dopo aver letto un simbolo in input, ed averlo rimpiazzato con un altro simbolo, cambia il suo stato interno, e si sposta di una cella a destra o sinistra. Se la macchina di Turing raggiunge lo stato finale, la stringa in input viene accettata; alternativamente, viene rigettata. Una macchina di turing pu\u00f2 essere descritta formalmente come una tupla \\((Q, X, \\Sigma, \\delta, q_0, B, F)\\) dove: \\(Q\\) \u00e8 un insieme finito di stati \\(X\\) \u00e8 l'alfabeto del nastro \\(\\Sigma\\) \u00e8 l'alfabeto in input \\(\\delta\\) \u00e8 una funzione di transizione q_0 \u00e8 lo stato iniziale B \u00e8 il simbolo vuoto F \u00e8 l'insieme finale degli stati In particolare, la funzione \\(\\delta\\) \u00e8 definita come segue: \\[ \\delta: Q \\times X \\leftarrow Q \\times X \\ \\] Esempio \u00b6 Consideriamo una machcina di Turing \\(M\\) del tipo: \\[ M = (Q, X, \\Sigma, \\delta, q_0, B, F) \\] con: \\(Q={q_0, q_1, q_2, q_f}\\) \\(X={a,b}\\) \\(\\Sigma={1}\\) q_0= \\({q_0}\\) F = \\({q_f}\\) \\(\\delta\\) \u00e8 data da: | | | Complesist\u00e0 spazio/temporale \u00b6 Per una macchina di turing la complessit\u00e0 temporale si riferisce alla misura del numero di volte che il nastro si muove quando la macchina \u00e8 inizializzata per alcuni siboli di input, e la complessit\u00e0 spaziale \u00e8 il numero di celle del nastro scritte. La complessit\u00e0 temporale \u00e8: \\[T(n) = O(n log n)\\] mentre quella spaziale: \\[S(n) = O(n)\\] Linguaggi accettati \u00b6 Una TM accetta un linguaggio se entra in uno stato finale per una qualunque stringa di ingresso \\(w\\) . Una TM decide un linguaggio se lo accetta ed entra in uno stato di reject per un qualsiasi input che non \u00e8 nel linugaggio. Un linguaggio \u00e8 ricorsivo se dcidibile da una macchina di Truing. Ci possono essere casi nei quali una TM non si ferma. Questa TM acceetta il linguaggio, ma non lo giudica decidibile. Progettare una macchina di Turing \u00b6 Le linee guida per la progettazione di una macchina di Turing sono le seguenti. Esempio 1 \u00b6 Progettare una TM per riconoscere tutte le stringhe che hanno un numero di a dispari. Soluzione La macchina di Turing pu\u00f2 essere costruita come segue. sia q_1 lo stato iniziale. se M \u00e8 in q 1, sulla scansione di a, entra nello stato di q 2 e scive B (blank) se M \u00e8 in q 2, sulla scansioen di a, entra nello stato q 1 e scrive B dalle mosse precedenti, possiamo vedere che M enra lo stato q 1 se effettua la scansione di un numero pari di a, e entra lo stato q 2 se scandeisc eun numero dispari di a. Quindi q_2 \u00e8 l'unico stato accettato. Di conseguenza: \\[ T = {{q_1, q_2}, {1}, {1, B}, \\delta, q_1, B, {q_2}} \\] con \\(\\delta\\) dato da: Simbolo stato q_1 stato q_2 a BRq_2 BRq_1","title":"08 turing"},{"location":"08_turing/#introduzione","text":"Una macchina di Turing \u00e8 un'astrazione matematica che consiste di un nastro a lunghezza infinita diviso in celle sul quale \u00e8 dato un certo input. Consiste di una testina che legge il nastro di ingresso. Un registro memorizza lo stato della macchina di Turing. Dopo aver letto un simbolo in input, ed averlo rimpiazzato con un altro simbolo, cambia il suo stato interno, e si sposta di una cella a destra o sinistra. Se la macchina di Turing raggiunge lo stato finale, la stringa in input viene accettata; alternativamente, viene rigettata. Una macchina di turing pu\u00f2 essere descritta formalmente come una tupla \\((Q, X, \\Sigma, \\delta, q_0, B, F)\\) dove: \\(Q\\) \u00e8 un insieme finito di stati \\(X\\) \u00e8 l'alfabeto del nastro \\(\\Sigma\\) \u00e8 l'alfabeto in input \\(\\delta\\) \u00e8 una funzione di transizione q_0 \u00e8 lo stato iniziale B \u00e8 il simbolo vuoto F \u00e8 l'insieme finale degli stati In particolare, la funzione \\(\\delta\\) \u00e8 definita come segue: \\[ \\delta: Q \\times X \\leftarrow Q \\times X \\ \\]","title":"Introduzione"},{"location":"08_turing/#esempio","text":"Consideriamo una machcina di Turing \\(M\\) del tipo: \\[ M = (Q, X, \\Sigma, \\delta, q_0, B, F) \\] con: \\(Q={q_0, q_1, q_2, q_f}\\) \\(X={a,b}\\) \\(\\Sigma={1}\\) q_0= \\({q_0}\\) F = \\({q_f}\\) \\(\\delta\\) \u00e8 data da: | | |","title":"Esempio"},{"location":"08_turing/#complesista-spaziotemporale","text":"Per una macchina di turing la complessit\u00e0 temporale si riferisce alla misura del numero di volte che il nastro si muove quando la macchina \u00e8 inizializzata per alcuni siboli di input, e la complessit\u00e0 spaziale \u00e8 il numero di celle del nastro scritte. La complessit\u00e0 temporale \u00e8: \\[T(n) = O(n log n)\\] mentre quella spaziale: \\[S(n) = O(n)\\]","title":"Complesist\u00e0 spazio/temporale"},{"location":"08_turing/#linguaggi-accettati","text":"Una TM accetta un linguaggio se entra in uno stato finale per una qualunque stringa di ingresso \\(w\\) . Una TM decide un linguaggio se lo accetta ed entra in uno stato di reject per un qualsiasi input che non \u00e8 nel linugaggio. Un linguaggio \u00e8 ricorsivo se dcidibile da una macchina di Truing. Ci possono essere casi nei quali una TM non si ferma. Questa TM acceetta il linguaggio, ma non lo giudica decidibile.","title":"Linguaggi accettati"},{"location":"08_turing/#progettare-una-macchina-di-turing","text":"Le linee guida per la progettazione di una macchina di Turing sono le seguenti.","title":"Progettare una macchina di Turing"},{"location":"08_turing/#esempio-1","text":"Progettare una TM per riconoscere tutte le stringhe che hanno un numero di a dispari. Soluzione La macchina di Turing pu\u00f2 essere costruita come segue. sia q_1 lo stato iniziale. se M \u00e8 in q 1, sulla scansione di a, entra nello stato di q 2 e scive B (blank) se M \u00e8 in q 2, sulla scansioen di a, entra nello stato q 1 e scrive B dalle mosse precedenti, possiamo vedere che M enra lo stato q 1 se effettua la scansione di un numero pari di a, e entra lo stato q 2 se scandeisc eun numero dispari di a. Quindi q_2 \u00e8 l'unico stato accettato. Di conseguenza: \\[ T = {{q_1, q_2}, {1}, {1, B}, \\delta, q_1, B, {q_2}} \\] con \\(\\delta\\) dato da: Simbolo stato q_1 stato q_2 a BRq_2 BRq_1","title":"Esempio 1"},{"location":"09_complessita/","text":"Analisi degli algoritmi \u00b6 L'analisi dell'efficienza di un algoritmo pu\u00f2 essere effettuata in due fasi differenti, prima dell'implementazione e dopo dell'implementazione Analisi a priori \u00b6 Questa \u00e8 definita come l'analisi teorica di un algoritmo. L'efficienza di un algoritmo \u00e8 misurata asusmendo che tutti gli altri fattori, come ad esempio la velocit\u00e0 del processore, sono costanti e non hanno alcun effetto sull'implementazione. Analisi a posteriori \u00b6 Questa \u00e8 definita come l'analisi empirica di un algoritmo. L'algoritmo scelto viene implementato usando un linguaggio di programmazione. Successivamente, l'algoritmo scelto \u00e8 eseguito sulla macchina target. In questa analisi, le statistiche come il tempo e lo spazio necessario sono collezionale. L'analisi degli algoritmi tiene conto dell'esecuzione o del tempo delle varie operazioni coinvolt. Il tempo di esecuzione di un'operazione pu\u00f2 essere definito come il numero di istruzioni computerizzate eseguite per ogni operazione. Complessit\u00e0 degli algoritmi \u00b6 Supponiamo che X sia trattato come l'algoritmo e che \\(N\\) sia la dimensione dei dati in ingresso Il tempo e lo spazio richiesto dall'algortimo X sono i due fattori principali che determinano l'efficienza dell'algoritmo. Fattore temporale \u00b6 Il tempo \u00e8 calcolato o misurato contando il numero di oeprazioni (come le comparazioni negli algoritmi di sorting). Fattore spaziale \u00b6 Lo spazio \u00e8 calcolato o misurato contando il massimo spazio richiesto in memoria dall'algoritmo. La complessit\u00e0 di un algoritmo \\(O(n)\\) fornisce il tempo di esecuzione o lo spazio necessario dall'algoritmo considerando \\(N\\) come dimensione dei dati di ingresso. Complessit\u00e0 spaziale \u00b6 La complessit\u00e0 spaziale di un algoritmo rappresenta il quantitativo di spazio di memoria necessario all'algoritmo nel suo life cycle. Lo spazio necesario da un algoritmo \u00e8 uguale alla somma delle seguenti due componenti. Una parte fissa che \u00e8 lo spazio richiesto per memorizzare crti dati e variabili (es. semplici variabili e costanti, dimensioni del programma, etc.) che non sono dipendenti dalla dimensione del problema. Una parte variabile \u00e8 lo spazio richiesto dalle variabili, la cui dimensione \u00e8 totalmente dipendete dalla dimensione del problema. Ad esempio, allocazione dinamica della memoria. La complessit\u00e0 spazilae \\(S(p)\\) di un qualsiasi algoritmo \\(p\\) \u00e8 data da: \\[ S(p) = A + S(I) \\] dove \\(A\\) \u00e8 la parte fissa ed \\(S(I)\\) \u00e8 la parte variabile dell'algoritmo, che dipende dalle caratteristiche \\(I\\) dello stesso. Vediamo un esempio Algoritmo \u00b6 SUM(P, Q) Step 1 -> START Step 2 -> R = P + Q Step 3 -> STOP Qui abbiamo tre variabili, ovvero R , p e q . Di conseguenza, \\(S(p) = 0 + 3\\) . Note Ovviamente, lo spazio effettivo dipende dal data type. Ad esempio, se consideriamo un intero abbiamo che il precedente valore va moltiplicato per 32 bit. T^Complessit\u00e0 nel tempo \u00b6 La complessit\u00e0 nel tempo di un algoritmo \u00e8 la rappresentazione della quantit\u00e0 di tempo richiesto dall'algoritmo per essere completamente eseguito. I requisiti nel tempo possono essere definiti come una funzionenumerica \\(t(N)\\) , dove \\(t(N)\\) pu\u00f2 essere misurata come il numero di step, supponendo che ogni step richieda tempo costante. Ad esempi, nel caso dell'addizione di due interi ad n bit, sono necessari N step. di conseguenza, il tempo totale \u00e8 t(N) = c*n, dove c \u00e8 il tempo necessario all'aggiunta di due bit. Osservamo quinid che t(N) cresce linearmente con l'aumento di N. Esempi \u00b6 for ( i = 0 ; i < n ; i ++ ) { cout << i ; i ++ ; } La complessit\u00e0 computazionale di questo ciclo for \u00e8 pari ad \\(O(n/2)\\) . Questo \u00e8 legato al fatto che ad ogni ciclo il valore di i \u00e8 incrementato due volte. for ( i = n ; i > 0 ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { cout << i ; } } Qui si vede che ad ogni iterazione del ciclo \"esterno\", seguiranno n iterazioni del ciclo interno, per cui la complessit\u00e0 nel tempo \u00e8 pari ad \\(O(n^2)\\) . while ( i ) { cout << i ; i = i / 2 ; } Ad ogni iterazione, il valore di i sar\u00e0 diviso per 2. Di conseguenza, la complessit\u00e0 \u00e8 pari ad \\(O(log(n))\\) .","title":"09 complessita"},{"location":"09_complessita/#analisi-degli-algoritmi","text":"L'analisi dell'efficienza di un algoritmo pu\u00f2 essere effettuata in due fasi differenti, prima dell'implementazione e dopo dell'implementazione","title":"Analisi degli algoritmi"},{"location":"09_complessita/#analisi-a-priori","text":"Questa \u00e8 definita come l'analisi teorica di un algoritmo. L'efficienza di un algoritmo \u00e8 misurata asusmendo che tutti gli altri fattori, come ad esempio la velocit\u00e0 del processore, sono costanti e non hanno alcun effetto sull'implementazione.","title":"Analisi a priori"},{"location":"09_complessita/#analisi-a-posteriori","text":"Questa \u00e8 definita come l'analisi empirica di un algoritmo. L'algoritmo scelto viene implementato usando un linguaggio di programmazione. Successivamente, l'algoritmo scelto \u00e8 eseguito sulla macchina target. In questa analisi, le statistiche come il tempo e lo spazio necessario sono collezionale. L'analisi degli algoritmi tiene conto dell'esecuzione o del tempo delle varie operazioni coinvolt. Il tempo di esecuzione di un'operazione pu\u00f2 essere definito come il numero di istruzioni computerizzate eseguite per ogni operazione.","title":"Analisi a posteriori"},{"location":"09_complessita/#complessita-degli-algoritmi","text":"Supponiamo che X sia trattato come l'algoritmo e che \\(N\\) sia la dimensione dei dati in ingresso Il tempo e lo spazio richiesto dall'algortimo X sono i due fattori principali che determinano l'efficienza dell'algoritmo.","title":"Complessit\u00e0 degli algoritmi"},{"location":"09_complessita/#fattore-temporale","text":"Il tempo \u00e8 calcolato o misurato contando il numero di oeprazioni (come le comparazioni negli algoritmi di sorting).","title":"Fattore temporale"},{"location":"09_complessita/#fattore-spaziale","text":"Lo spazio \u00e8 calcolato o misurato contando il massimo spazio richiesto in memoria dall'algoritmo. La complessit\u00e0 di un algoritmo \\(O(n)\\) fornisce il tempo di esecuzione o lo spazio necessario dall'algoritmo considerando \\(N\\) come dimensione dei dati di ingresso.","title":"Fattore spaziale"},{"location":"09_complessita/#complessita-spaziale","text":"La complessit\u00e0 spaziale di un algoritmo rappresenta il quantitativo di spazio di memoria necessario all'algoritmo nel suo life cycle. Lo spazio necesario da un algoritmo \u00e8 uguale alla somma delle seguenti due componenti. Una parte fissa che \u00e8 lo spazio richiesto per memorizzare crti dati e variabili (es. semplici variabili e costanti, dimensioni del programma, etc.) che non sono dipendenti dalla dimensione del problema. Una parte variabile \u00e8 lo spazio richiesto dalle variabili, la cui dimensione \u00e8 totalmente dipendete dalla dimensione del problema. Ad esempio, allocazione dinamica della memoria. La complessit\u00e0 spazilae \\(S(p)\\) di un qualsiasi algoritmo \\(p\\) \u00e8 data da: \\[ S(p) = A + S(I) \\] dove \\(A\\) \u00e8 la parte fissa ed \\(S(I)\\) \u00e8 la parte variabile dell'algoritmo, che dipende dalle caratteristiche \\(I\\) dello stesso. Vediamo un esempio","title":"Complessit\u00e0 spaziale"},{"location":"09_complessita/#algoritmo","text":"SUM(P, Q) Step 1 -> START Step 2 -> R = P + Q Step 3 -> STOP Qui abbiamo tre variabili, ovvero R , p e q . Di conseguenza, \\(S(p) = 0 + 3\\) . Note Ovviamente, lo spazio effettivo dipende dal data type. Ad esempio, se consideriamo un intero abbiamo che il precedente valore va moltiplicato per 32 bit.","title":"Algoritmo"},{"location":"09_complessita/#tcomplessita-nel-tempo","text":"La complessit\u00e0 nel tempo di un algoritmo \u00e8 la rappresentazione della quantit\u00e0 di tempo richiesto dall'algoritmo per essere completamente eseguito. I requisiti nel tempo possono essere definiti come una funzionenumerica \\(t(N)\\) , dove \\(t(N)\\) pu\u00f2 essere misurata come il numero di step, supponendo che ogni step richieda tempo costante. Ad esempi, nel caso dell'addizione di due interi ad n bit, sono necessari N step. di conseguenza, il tempo totale \u00e8 t(N) = c*n, dove c \u00e8 il tempo necessario all'aggiunta di due bit. Osservamo quinid che t(N) cresce linearmente con l'aumento di N.","title":"T^Complessit\u00e0 nel tempo"},{"location":"09_complessita/#esempi","text":"for ( i = 0 ; i < n ; i ++ ) { cout << i ; i ++ ; } La complessit\u00e0 computazionale di questo ciclo for \u00e8 pari ad \\(O(n/2)\\) . Questo \u00e8 legato al fatto che ad ogni ciclo il valore di i \u00e8 incrementato due volte. for ( i = n ; i > 0 ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { cout << i ; } } Qui si vede che ad ogni iterazione del ciclo \"esterno\", seguiranno n iterazioni del ciclo interno, per cui la complessit\u00e0 nel tempo \u00e8 pari ad \\(O(n^2)\\) . while ( i ) { cout << i ; i = i / 2 ; } Ad ogni iterazione, il valore di i sar\u00e0 diviso per 2. Di conseguenza, la complessit\u00e0 \u00e8 pari ad \\(O(log(n))\\) .","title":"Esempi"},{"location":"10_tipi/","text":"Tipi di dato \u00b6 Per tipo di dato si intende il formato che un dato pu\u00f2 assumere. Il tipo di dato \u00e8 estremamente importante principalemtne per due motivi: il tipo di dato \u00e8 legato al flusso logico del programma il tipo di dato controlla la quantit\u00e0 di memoria allocata ed utilizzata nel corso del programma. Esistono diversi tipi di dati, i pi\u00f9 comuni sono riassunti in tabella. Denominazione Spazio occupato Descrizione byte 8 bit Rappresenta un singolo byte. Pu\u00f2 assumere valori compresi tra \\(0\\) e \\(2^8\\) . short 16 bit Rappresenta un tipo di dato intero con precisione a 16 bit. int 32 bit Rappresenta un dato di tipo intero con segno. uint 32 bit Rappresenta un tipo di dato intero senza segno ( unsigned ) long 64 bit Rappresenta un tipo di dato intero con precisione a 64 bit. float 32 bit Rappresenta un tipo di dato reale con precisione a 32 bit double 64 bit dato reale bool 1 bit rappresenta un valore nell'algebra booleana (ovvero uno 0 o un 1 ) char NON RICORDO rappresenta un singolo carattere string","title":"10 tipi"},{"location":"10_tipi/#tipi-di-dato","text":"Per tipo di dato si intende il formato che un dato pu\u00f2 assumere. Il tipo di dato \u00e8 estremamente importante principalemtne per due motivi: il tipo di dato \u00e8 legato al flusso logico del programma il tipo di dato controlla la quantit\u00e0 di memoria allocata ed utilizzata nel corso del programma. Esistono diversi tipi di dati, i pi\u00f9 comuni sono riassunti in tabella. Denominazione Spazio occupato Descrizione byte 8 bit Rappresenta un singolo byte. Pu\u00f2 assumere valori compresi tra \\(0\\) e \\(2^8\\) . short 16 bit Rappresenta un tipo di dato intero con precisione a 16 bit. int 32 bit Rappresenta un dato di tipo intero con segno. uint 32 bit Rappresenta un tipo di dato intero senza segno ( unsigned ) long 64 bit Rappresenta un tipo di dato intero con precisione a 64 bit. float 32 bit Rappresenta un tipo di dato reale con precisione a 32 bit double 64 bit dato reale bool 1 bit rappresenta un valore nell'algebra booleana (ovvero uno 0 o un 1 ) char NON RICORDO rappresenta un singolo carattere string","title":"Tipi di dato"},{"location":"11_flow_chart/","text":"","title":"11 flow chart"},{"location":"automi/","text":"Il termine automa deriva dal greco e significa \"agente in maniera automaitca\". Questo tipo di macchina \u00e8 un dispositivo astratto che segue una sequenza predeterminata di operazoni in maniera automatica. Un automa con un numero fiinito di stati \u00e8 chiamato Automa a Stati Finiti o macchina a stati finiti . La definizione formale di automa \u00e8 la seguente. Un automa pu\u00f2 essere rappresentato da una tupl del tipo \\((Q, \\Sigma, \\delta, q_0, F)\\) dove: \\(Q\\) \u00e8 un insieme finito di stati; \\(\\Sigma\\) \u00e8 un insieme finito di simboli, chiamato alfabeto dell'automa; \\(\\delta\\) \u00e8 la funzione di transizione \\(q_0\\) \u00e8 lo staot iniziale dal quale ogni input viene elaborato ( \\(q_0 \\in Q\\) ) \\(F\\) \u00e8un insieme di stati finali di \\(Q\\) ( \\(F \\in Q\\) ) Terminologia \u00b6 Alfabeto \u00b6 Definizione: un alfabeto \u00e8 un set finito di simboli Esempi: \\(\\Sigma = {a, b, c, d}\\) \u00e8 un insieme dove i simboli a, b, c e d sono i simboli dell0'alfabeto Stringa \u00b6 Definizione : una stringa \u00e8 una sequenza finita di simboli presi da \\(\\Sigma\\) Esempio: 'cabcad' \u00e8 una stringa valida nell'alfabeto \\(\\Sigma = {a,b,c,d}\\) Lunghezza di una stringa \u00b6 E' il numero di simboli presenti in una stringa, indicato con \\(|S|\\) . Stella di Kleene \u00b6 La stella di Kleene, \\(\\Sigma^*\\) , \u00e8 un operatore unario su un insieme di simboli o stringhe \\(\\Sigma\\) che d\u00e0 l'insieme nonfinito) di tutte le posssibili stringhe di tutte le possibili lunghezze su \\(\\Sigma\\) incluso \\(\\lambda\\) . Chiusura di Kleeene \u00b6 Macchine a stati finiti deterministiche \u00b6 In questo tipo di macchina, si pu\u00f2 determinare a priori lo stato nel quale la macchina si sposter\u00e0. Definizione formale \u00e8 analoga a quella precedente. rappresentazione grafica \u00b6 Un automa a stati finiti deterministico \u00e8 rappresentato mediante un digrafo chiamato diagramma di stato . In questo: i vertici rappresentano gli stati; gli archi etichettati con un alfabeto di ingresso mostrano le transizioni; lo stato iniziale \u00e8 indicato da un arco vuoto in ingresso; lo stato finale \u00e8 contrassegnato da un doppio cerchio. Ad esempio. \\(Q\\) = \\({a, b, c}\\) \\(\\Sigma\\) = \\({0, 1}\\) \\(q_0\\) = \\({a}\\) F = \\({c}\\) La funzione di transizione \\(\\delta\\) \u00e8 definita dalla seguente tabella: Stato attuale Stato successivo per l'input \\(1\\) Stato successivo per l'input \\(0\\) a a b b c a c b c La rappresentazione grafica \u00e8 la seguente.","title":"Automi"},{"location":"automi/#terminologia","text":"","title":"Terminologia"},{"location":"automi/#alfabeto","text":"Definizione: un alfabeto \u00e8 un set finito di simboli Esempi: \\(\\Sigma = {a, b, c, d}\\) \u00e8 un insieme dove i simboli a, b, c e d sono i simboli dell0'alfabeto","title":"Alfabeto"},{"location":"automi/#stringa","text":"Definizione : una stringa \u00e8 una sequenza finita di simboli presi da \\(\\Sigma\\) Esempio: 'cabcad' \u00e8 una stringa valida nell'alfabeto \\(\\Sigma = {a,b,c,d}\\)","title":"Stringa"},{"location":"automi/#lunghezza-di-una-stringa","text":"E' il numero di simboli presenti in una stringa, indicato con \\(|S|\\) .","title":"Lunghezza di una stringa"},{"location":"automi/#stella-di-kleene","text":"La stella di Kleene, \\(\\Sigma^*\\) , \u00e8 un operatore unario su un insieme di simboli o stringhe \\(\\Sigma\\) che d\u00e0 l'insieme nonfinito) di tutte le posssibili stringhe di tutte le possibili lunghezze su \\(\\Sigma\\) incluso \\(\\lambda\\) .","title":"Stella di Kleene"},{"location":"automi/#chiusura-di-kleeene","text":"","title":"Chiusura di Kleeene"},{"location":"automi/#macchine-a-stati-finiti-deterministiche","text":"In questo tipo di macchina, si pu\u00f2 determinare a priori lo stato nel quale la macchina si sposter\u00e0. Definizione formale \u00e8 analoga a quella precedente.","title":"Macchine a stati finiti deterministiche"},{"location":"automi/#rappresentazione-grafica","text":"Un automa a stati finiti deterministico \u00e8 rappresentato mediante un digrafo chiamato diagramma di stato . In questo: i vertici rappresentano gli stati; gli archi etichettati con un alfabeto di ingresso mostrano le transizioni; lo stato iniziale \u00e8 indicato da un arco vuoto in ingresso; lo stato finale \u00e8 contrassegnato da un doppio cerchio. Ad esempio. \\(Q\\) = \\({a, b, c}\\) \\(\\Sigma\\) = \\({0, 1}\\) \\(q_0\\) = \\({a}\\) F = \\({c}\\) La funzione di transizione \\(\\delta\\) \u00e8 definita dalla seguente tabella: Stato attuale Stato successivo per l'input \\(1\\) Stato successivo per l'input \\(0\\) a a b b c a c b c La rappresentazione grafica \u00e8 la seguente.","title":"rappresentazione grafica"},{"location":"01_introduttivi/01_intro/","text":"Una definizione di Informatica \u00b6 Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico. Il concetto di Informazione \u00b6 L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca. I sistemi Informatici \u00b6 Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0. Il ruolo dell'Informatico \u00b6 Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"01 - Introduzione all'Informatica"},{"location":"01_introduttivi/01_intro/#una-definizione-di-informatica","text":"Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico.","title":"Una definizione di Informatica"},{"location":"01_introduttivi/01_intro/#il-concetto-di-informazione","text":"L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca.","title":"Il concetto di Informazione"},{"location":"01_introduttivi/01_intro/#i-sistemi-informatici","text":"Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0.","title":"I sistemi Informatici"},{"location":"01_introduttivi/01_intro/#il-ruolo-dellinformatico","text":"Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"Il ruolo dell'Informatico"},{"location":"01_introduttivi/02_algoritmi/","text":"Formulare un problema \u00b6 Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio. Il problema come compito \u00b6 Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo . L' ente risolutore \u00b6 La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann. Gli elementi noti e le condizioni fissate \u00b6 La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore. Risolvere un problema \u00b6 La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi. Problemi e soluzioni \u00b6 Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione . Costruire la soluzione \u00b6 Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse. Operazioni atomiche \u00b6 Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.). Combinare operazioni atomiche \u00b6 Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori. Determinare l'insieme di operatori \u00b6 Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema. Da soluzione ad algoritmo \u00b6 La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema. Un esempio \u00b6 Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo. Formulazione del problema \u00b6 Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) . Dati \u00b6 Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo. Algoritmo risolutivo (in operazioni atomiche, o quasi) \u00b6 Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 . Esempio numerico \u00b6 Dati \u00b6 \\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\] Passi dell'algoritmo \u00b6 \\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) . Caratteristiche degli algoritmi risolutivi \u00b6 Le cinque caratteristiche principali \u00b6 Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico. Determinismo \u00b6 Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso. Input, Output e Variabili \u00b6 Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"02 - Gli Algoritmi"},{"location":"01_introduttivi/02_algoritmi/#formulare-un-problema","text":"Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio.","title":"Formulare un problema"},{"location":"01_introduttivi/02_algoritmi/#il-problema-come-compito","text":"Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo .","title":"Il problema come compito"},{"location":"01_introduttivi/02_algoritmi/#lente-risolutore","text":"La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann.","title":"L'ente risolutore"},{"location":"01_introduttivi/02_algoritmi/#gli-elementi-noti-e-le-condizioni-fissate","text":"La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore.","title":"Gli elementi noti e le condizioni fissate"},{"location":"01_introduttivi/02_algoritmi/#risolvere-un-problema","text":"La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi.","title":"Risolvere un problema"},{"location":"01_introduttivi/02_algoritmi/#problemi-e-soluzioni","text":"Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione .","title":"Problemi e soluzioni"},{"location":"01_introduttivi/02_algoritmi/#costruire-la-soluzione","text":"Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse.","title":"Costruire la soluzione"},{"location":"01_introduttivi/02_algoritmi/#operazioni-atomiche","text":"Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.).","title":"Operazioni atomiche"},{"location":"01_introduttivi/02_algoritmi/#combinare-operazioni-atomiche","text":"Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori.","title":"Combinare operazioni atomiche"},{"location":"01_introduttivi/02_algoritmi/#determinare-linsieme-di-operatori","text":"Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema.","title":"Determinare l'insieme di operatori"},{"location":"01_introduttivi/02_algoritmi/#da-soluzione-ad-algoritmo","text":"La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema.","title":"Da soluzione ad algoritmo"},{"location":"01_introduttivi/02_algoritmi/#un-esempio","text":"Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo.","title":"Un esempio"},{"location":"01_introduttivi/02_algoritmi/#formulazione-del-problema","text":"Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) .","title":"Formulazione del problema"},{"location":"01_introduttivi/02_algoritmi/#dati","text":"Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo.","title":"Dati"},{"location":"01_introduttivi/02_algoritmi/#algoritmo-risolutivo-in-operazioni-atomiche-o-quasi","text":"Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 .","title":"Algoritmo risolutivo (in operazioni atomiche, o quasi)"},{"location":"01_introduttivi/02_algoritmi/#esempio-numerico","text":"","title":"Esempio numerico"},{"location":"01_introduttivi/02_algoritmi/#dati_1","text":"\\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\]","title":"Dati"},{"location":"01_introduttivi/02_algoritmi/#passi-dellalgoritmo","text":"\\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) .","title":"Passi dell'algoritmo"},{"location":"01_introduttivi/02_algoritmi/#caratteristiche-degli-algoritmi-risolutivi","text":"","title":"Caratteristiche degli algoritmi risolutivi"},{"location":"01_introduttivi/02_algoritmi/#le-cinque-caratteristiche-principali","text":"Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico.","title":"Le cinque caratteristiche principali"},{"location":"01_introduttivi/02_algoritmi/#determinismo","text":"Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso.","title":"Determinismo"},{"location":"01_introduttivi/02_algoritmi/#input-output-e-variabili","text":"Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"Input, Output e Variabili"},{"location":"01_introduttivi/03_rappresentazione/","text":"Rappresentare il mondo in forma binaria \u00b6 Le informazioni contenute all'interno di un calcolatore, siano esse dati o istruzioni, sono rappresentate in forma binaria come sequenze finite di simboli 0 ed 1 . Questa notazione permette di definire una delle nozioni fondamentali su cui \u00e8 basata l'informatica, ovvero quella di bit , contrazione di binary digit (cifra binaria): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero). Conseguentemente, \u00e8 possibile definire un'altra nozione fondamentale, ovvero quella di byte , associata ad una sequenza (arbitraria) di otto bit. E' facile verificare che un byte pu\u00f2 assumere uno tra \\(2^8\\) possibili valori. Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso). I dati numerici \u00b6 Rappresentazione di numeri interi \u00b6 Finitezza \u00b6 I calcolatori sono dispositivi reali , ed in grado quindi di elaborare esclusivamente informazioni finite ; pi\u00f9 nello specifico, laddove il mondo reale \u00e8 analogico , e quindi continuo , il mondo \"comprensibile\" dai calcolatori \u00e8 digitale , e quindi \u00e8 una versione discretizzata del mondo reale. Ci\u00f2 comporta che, parlando di numeri interi rappresentabili in un calcolatore, si sta in realt\u00e0 parlando di un'approssimazione finita dell'insieme dei numeri naturali \\(\\mathbb{N}\\) : l'estensione di questa rappresentazione dipende dall'architettura del calcolatore. Ad esempio, la maggior parte dei calcolatori odierni accetta come limite massimo il valore di \\(2^64\\) , pari \\(18.446.744.073.709.551.616\\) (abbastanza per rappresentare il numero massimo di amici che potete avere su Facebook, plausibilmente). Da decimale a binario \u00b6 Siamo abituati a pensare (ed usare) i numeri interi usando una notazione di tipo decimale e posizionale . Ci\u00f2 significa che: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato. Un esempio \u00b6 In generale, sia \\(N\\) un generico numero intero composto da \\(n\\) simboli. Usando la notazione decimale e posizionale \u00e8 possibile esprimerlo come segue: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n * b^n + a_{n-1} * b^{n-1} + ... + a_1 * b + a_0 \\] Per fare un semplice esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\] Conversione \u00b6 Supponiamo di voler rappresentare \\(N = 485\\) in forma binaria (ovvero in base \\(2\\) ). Dovremo procedere dividendo \\(N\\) per la nostra base \\(b = 2\\) , valutare il resto \\(r\\) , che sar\u00e0 di volta in volta il valore meno significativo del nostro numero in forma binaria, e reiterare l'operazione usando il quoziente \\(q\\) . Otteniamo quindi: \\[ \\begin{eqnarray} 485/2 &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ 242/2 &\\Rightarrow q = 121 & r = 0 \\\\ 121/2 &\\Rightarrow q = 60 & r = 1 \\\\ 60/2 &\\Rightarrow q = 30 & r = 0 \\\\ 30/2 &\\Rightarrow q = 15 & r = 0 \\\\ 15/2 &\\Rightarrow q = 7 & r = 1 \\\\ 7/2 &\\Rightarrow q = 3 & r = 1 \\\\ 3/2 &\\Rightarrow q = 1 & r = 1 \\\\ 1/2 &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo). Segno \u00b6 E' importante ricordare che i numeri interi possono essere dotati di segno; questo \u00e8, ovviamente, un fattore di cui va tenuto conto nella rappresentazione del numero stesso, ed \u00e8 legato al fatto che il calcolatore pu\u00f2 contenere solo un quantitativo finito di infomrazione. Immaginiamo infatti che il computer utilizzi una word di \\(W\\) bit per memorizzare gli interi; ci\u00f2 significa che sar\u00e0 possibile memorizzare al pi\u00f9 \\(2^W\\) valori. Nel caso si considerino tutti i valori positivi (includendo nel conteggio \"per convenzione\" anche lo \\(0\\) ), il calcolatore potr\u00e0 rappresentare tutti i numeri che vanno da \\(0\\) a \\(2^W-1\\) . Questa situazione, per\u00f2, cambia nel caso si voglia considerare il segno del numero. Infatti, supponendo di suddividere l'intervallo considerato in valori negativi e valori positivi, il calcolatore sar\u00e0 in grado di rappresentare sempre \\(2^W\\) valori, ma met\u00e0 di questi saranno negativi, mentre l'altra met\u00e0 sar\u00e0 composta da valori positivi. Ci\u00f2 ha come diretta conseguenza il fatto che il range dei numeri rappresentati varia da \\(-2^{W-1}\\) a \\(2^{W-1}-1\\) . Per fare un esempio pratico, supponendo un valore di \\(W = 8\\) , avremo che: se consideriamo solo gli interi positivi, potremo rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^8-1\\) ; se consideriamo anche i valori negativi, potremo rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{W-1}\\) e \\(127 = -2^{W-1}-1\\) . Rappresentazione di numeri reali \u00b6 Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) pu\u00f2 essere rappresentato all'interno di un calcolatore esclusivamente mediante un'approssimazione finita. Per trovare quest'approssimazione, occorre considerare che ogni numero reale \u00e8 composto da una parte intera \\(r\\) ed una parte frazionaria \\(f\\) . Rappresentazione a virgola fissa \u00b6 Supponiamo di avere a disposizione parole composte da \\(W\\) bit. Nella rappresentazione a virgola fissa (o fixed point ) di un numero \\(N\\) , usiamo un numero fisso di bit (ovvero \\(W_r\\) ) per la parte intera di \\(N\\) , ed i rimanenti bit ( \\(W_f\\) ) per la rappresentazione della parte frazionaria. Ovviamente, questa rappresentazione ha lo svantaggio di essere poco flessibile, e le viene spesso preferita quella a virgola mobile . Rappresentazione a virgola mobile \u00b6 La modalit\u00e0 di rappresentazione di un numero reale maggiormente diffusa \u00e8 quella a virgola mobile ( floating point ), che si basa sui concetti di mantissa , ovvero la parte frazionaria di un numero, e caratteristica , o esponente . In particolare, la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_i\\) : \\[ M = n - n_i \\] Ad esempio, la mantissa di \\(5.2\\) \u00e8 pari a \\(0.2\\) . E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . Ne consegue che un numero \\(a\\) \u00e8 rappresentabile in una data base \\(b\\) mediante la seguente relazione: \\[ a = M * b^e \\] Rappresentazione di caratteri \u00b6 Anche i caratteri (ovvero quelli che troviamo normalmente sulle nostre tastiere) possono essere rappresentati in binario. Pi\u00f9 in generale, il concetto di \"carattere\" \u00e8 assimilabile a quello di simbolo , in quanto i calcolatori sono in grado di comprendere simboli che indicano, tra le altre cose, le cifre decimali, la punteggiatura, ed una vasta serie di caratteri speciali (ad esempio, l'underscore, la \"chiocciola\", e via dicendo). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra ogni carattere ed un numero intero. Tale corrispondenza \u00e8 stabilita da standard ben precisi, tra i quali vale la pena di ricordare lo standard ASCII e quello UNICODE. Quest'ultimo \u00e8 particolarmente potente (ed esteso), in quanto permette di codificare la maggior parte dei caratteri conosciuti, compresi quelli di alcune lingue ormai considerate morte (come ad esempio il greco antico). Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri. Essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"03 - Rappresentazione dei dati"},{"location":"01_introduttivi/03_rappresentazione/#rappresentare-il-mondo-in-forma-binaria","text":"Le informazioni contenute all'interno di un calcolatore, siano esse dati o istruzioni, sono rappresentate in forma binaria come sequenze finite di simboli 0 ed 1 . Questa notazione permette di definire una delle nozioni fondamentali su cui \u00e8 basata l'informatica, ovvero quella di bit , contrazione di binary digit (cifra binaria): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero). Conseguentemente, \u00e8 possibile definire un'altra nozione fondamentale, ovvero quella di byte , associata ad una sequenza (arbitraria) di otto bit. E' facile verificare che un byte pu\u00f2 assumere uno tra \\(2^8\\) possibili valori. Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso).","title":"Rappresentare il mondo in forma binaria"},{"location":"01_introduttivi/03_rappresentazione/#i-dati-numerici","text":"","title":"I dati numerici"},{"location":"01_introduttivi/03_rappresentazione/#rappresentazione-di-numeri-interi","text":"","title":"Rappresentazione di numeri interi"},{"location":"01_introduttivi/03_rappresentazione/#finitezza","text":"I calcolatori sono dispositivi reali , ed in grado quindi di elaborare esclusivamente informazioni finite ; pi\u00f9 nello specifico, laddove il mondo reale \u00e8 analogico , e quindi continuo , il mondo \"comprensibile\" dai calcolatori \u00e8 digitale , e quindi \u00e8 una versione discretizzata del mondo reale. Ci\u00f2 comporta che, parlando di numeri interi rappresentabili in un calcolatore, si sta in realt\u00e0 parlando di un'approssimazione finita dell'insieme dei numeri naturali \\(\\mathbb{N}\\) : l'estensione di questa rappresentazione dipende dall'architettura del calcolatore. Ad esempio, la maggior parte dei calcolatori odierni accetta come limite massimo il valore di \\(2^64\\) , pari \\(18.446.744.073.709.551.616\\) (abbastanza per rappresentare il numero massimo di amici che potete avere su Facebook, plausibilmente).","title":"Finitezza"},{"location":"01_introduttivi/03_rappresentazione/#da-decimale-a-binario","text":"Siamo abituati a pensare (ed usare) i numeri interi usando una notazione di tipo decimale e posizionale . Ci\u00f2 significa che: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato.","title":"Da decimale a binario"},{"location":"01_introduttivi/03_rappresentazione/#un-esempio","text":"In generale, sia \\(N\\) un generico numero intero composto da \\(n\\) simboli. Usando la notazione decimale e posizionale \u00e8 possibile esprimerlo come segue: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n * b^n + a_{n-1} * b^{n-1} + ... + a_1 * b + a_0 \\] Per fare un semplice esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\]","title":"Un esempio"},{"location":"01_introduttivi/03_rappresentazione/#conversione","text":"Supponiamo di voler rappresentare \\(N = 485\\) in forma binaria (ovvero in base \\(2\\) ). Dovremo procedere dividendo \\(N\\) per la nostra base \\(b = 2\\) , valutare il resto \\(r\\) , che sar\u00e0 di volta in volta il valore meno significativo del nostro numero in forma binaria, e reiterare l'operazione usando il quoziente \\(q\\) . Otteniamo quindi: \\[ \\begin{eqnarray} 485/2 &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ 242/2 &\\Rightarrow q = 121 & r = 0 \\\\ 121/2 &\\Rightarrow q = 60 & r = 1 \\\\ 60/2 &\\Rightarrow q = 30 & r = 0 \\\\ 30/2 &\\Rightarrow q = 15 & r = 0 \\\\ 15/2 &\\Rightarrow q = 7 & r = 1 \\\\ 7/2 &\\Rightarrow q = 3 & r = 1 \\\\ 3/2 &\\Rightarrow q = 1 & r = 1 \\\\ 1/2 &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo).","title":"Conversione"},{"location":"01_introduttivi/03_rappresentazione/#segno","text":"E' importante ricordare che i numeri interi possono essere dotati di segno; questo \u00e8, ovviamente, un fattore di cui va tenuto conto nella rappresentazione del numero stesso, ed \u00e8 legato al fatto che il calcolatore pu\u00f2 contenere solo un quantitativo finito di infomrazione. Immaginiamo infatti che il computer utilizzi una word di \\(W\\) bit per memorizzare gli interi; ci\u00f2 significa che sar\u00e0 possibile memorizzare al pi\u00f9 \\(2^W\\) valori. Nel caso si considerino tutti i valori positivi (includendo nel conteggio \"per convenzione\" anche lo \\(0\\) ), il calcolatore potr\u00e0 rappresentare tutti i numeri che vanno da \\(0\\) a \\(2^W-1\\) . Questa situazione, per\u00f2, cambia nel caso si voglia considerare il segno del numero. Infatti, supponendo di suddividere l'intervallo considerato in valori negativi e valori positivi, il calcolatore sar\u00e0 in grado di rappresentare sempre \\(2^W\\) valori, ma met\u00e0 di questi saranno negativi, mentre l'altra met\u00e0 sar\u00e0 composta da valori positivi. Ci\u00f2 ha come diretta conseguenza il fatto che il range dei numeri rappresentati varia da \\(-2^{W-1}\\) a \\(2^{W-1}-1\\) . Per fare un esempio pratico, supponendo un valore di \\(W = 8\\) , avremo che: se consideriamo solo gli interi positivi, potremo rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^8-1\\) ; se consideriamo anche i valori negativi, potremo rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{W-1}\\) e \\(127 = -2^{W-1}-1\\) .","title":"Segno"},{"location":"01_introduttivi/03_rappresentazione/#rappresentazione-di-numeri-reali","text":"Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) pu\u00f2 essere rappresentato all'interno di un calcolatore esclusivamente mediante un'approssimazione finita. Per trovare quest'approssimazione, occorre considerare che ogni numero reale \u00e8 composto da una parte intera \\(r\\) ed una parte frazionaria \\(f\\) .","title":"Rappresentazione di numeri reali"},{"location":"01_introduttivi/03_rappresentazione/#rappresentazione-a-virgola-fissa","text":"Supponiamo di avere a disposizione parole composte da \\(W\\) bit. Nella rappresentazione a virgola fissa (o fixed point ) di un numero \\(N\\) , usiamo un numero fisso di bit (ovvero \\(W_r\\) ) per la parte intera di \\(N\\) , ed i rimanenti bit ( \\(W_f\\) ) per la rappresentazione della parte frazionaria. Ovviamente, questa rappresentazione ha lo svantaggio di essere poco flessibile, e le viene spesso preferita quella a virgola mobile .","title":"Rappresentazione a virgola fissa"},{"location":"01_introduttivi/03_rappresentazione/#rappresentazione-a-virgola-mobile","text":"La modalit\u00e0 di rappresentazione di un numero reale maggiormente diffusa \u00e8 quella a virgola mobile ( floating point ), che si basa sui concetti di mantissa , ovvero la parte frazionaria di un numero, e caratteristica , o esponente . In particolare, la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_i\\) : \\[ M = n - n_i \\] Ad esempio, la mantissa di \\(5.2\\) \u00e8 pari a \\(0.2\\) . E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . Ne consegue che un numero \\(a\\) \u00e8 rappresentabile in una data base \\(b\\) mediante la seguente relazione: \\[ a = M * b^e \\]","title":"Rappresentazione a virgola mobile"},{"location":"01_introduttivi/03_rappresentazione/#rappresentazione-di-caratteri","text":"Anche i caratteri (ovvero quelli che troviamo normalmente sulle nostre tastiere) possono essere rappresentati in binario. Pi\u00f9 in generale, il concetto di \"carattere\" \u00e8 assimilabile a quello di simbolo , in quanto i calcolatori sono in grado di comprendere simboli che indicano, tra le altre cose, le cifre decimali, la punteggiatura, ed una vasta serie di caratteri speciali (ad esempio, l'underscore, la \"chiocciola\", e via dicendo). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra ogni carattere ed un numero intero. Tale corrispondenza \u00e8 stabilita da standard ben precisi, tra i quali vale la pena di ricordare lo standard ASCII e quello UNICODE. Quest'ultimo \u00e8 particolarmente potente (ed esteso), in quanto permette di codificare la maggior parte dei caratteri conosciuti, compresi quelli di alcune lingue ormai considerate morte (come ad esempio il greco antico). Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri. Essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"Rappresentazione di caratteri"}]}