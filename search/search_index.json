{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Corso di Algoritmi e Linguaggi di programmazione Python/C \u00b6 Benvenuti nel corso di Algoritmi e Linguaggi di Programmazione Python/C. Per selezionare l'argomento di interesse, usare i menu laterali. Attenzione Le dispense sono attualmente in fase di aggiornamento. Modalit\u00e0 di esame \u00b6 Le modalit\u00e0 di esame previste sono due: un esame orale , costituito da un colloquio nel quale saranno poste al candidato tre domande, due di natura teorica, ed una di natura pratica, strettamente inerenti i contenuti del corso; un tema d'anno , costituito da un progetto a scelta degli studenti, organizzati in gruppi da massimo quattro (4) componenti . Il tema d'anno dovr\u00e0 essere prettamente pratico, e corredato da una breve presentazione ( massimo dodici (12) slides ) ed una relazione sul lavoro svolto ( massimo quattro (4) pagine ). A queste modalit\u00e0 si integrano una serie di task assegnati durante il corso, ognuno dei quali pu\u00f2 assegnare al massimo due (2) ulteriori punti. Date di appello \u00b6 Le date di appello indicative sono le seguenti: Numero appello Data indicativa Primo 27/05/2022 ore 12:00 Secondo 17/06/2022 ore 08:30 Terzo 01/07/2022 ore 08:30 Quarto 15/07/2022 ore 08:30 Ricevimento \u00b6 E' possibile concordare un ricevimento inviando una e-mail all'indirizzo angelo.cardellicchio@stiima.cnr.it .","title":"Home del corso"},{"location":"#corso-di-algoritmi-e-linguaggi-di-programmazione-pythonc","text":"Benvenuti nel corso di Algoritmi e Linguaggi di Programmazione Python/C. Per selezionare l'argomento di interesse, usare i menu laterali. Attenzione Le dispense sono attualmente in fase di aggiornamento.","title":"Corso di Algoritmi e Linguaggi di programmazione Python/C"},{"location":"#modalita-di-esame","text":"Le modalit\u00e0 di esame previste sono due: un esame orale , costituito da un colloquio nel quale saranno poste al candidato tre domande, due di natura teorica, ed una di natura pratica, strettamente inerenti i contenuti del corso; un tema d'anno , costituito da un progetto a scelta degli studenti, organizzati in gruppi da massimo quattro (4) componenti . Il tema d'anno dovr\u00e0 essere prettamente pratico, e corredato da una breve presentazione ( massimo dodici (12) slides ) ed una relazione sul lavoro svolto ( massimo quattro (4) pagine ). A queste modalit\u00e0 si integrano una serie di task assegnati durante il corso, ognuno dei quali pu\u00f2 assegnare al massimo due (2) ulteriori punti.","title":"Modalit\u00e0 di esame"},{"location":"#date-di-appello","text":"Le date di appello indicative sono le seguenti: Numero appello Data indicativa Primo 27/05/2022 ore 12:00 Secondo 17/06/2022 ore 08:30 Terzo 01/07/2022 ore 08:30 Quarto 15/07/2022 ore 08:30","title":"Date di appello"},{"location":"#ricevimento","text":"E' possibile concordare un ricevimento inviando una e-mail all'indirizzo angelo.cardellicchio@stiima.cnr.it .","title":"Ricevimento"},{"location":"material/01_intro/01_introduction/lecture/","text":"1 - Introduzione: cosa \u00e8 l'Informatica? \u00b6 Come per molti degli argomenti cui ci si approccia nel corso della vita, trovare una definizione per il concetto di informatica pu\u00f2 aiutare a comprenderne al meglio la natura. Partiamo quindi da una (breve) analisi etimologica del termine informatica . Questo, infatti, \u00e8 la traduzione italiana del francese informatique , crasi delle parole informa(tion) ed (automa)tique . Intuitivamente, possiamo dedurre che la disciplina tratti quindi di \"informazioni automatiche\" o, per meglio dire, automatizzazione delle informazioni . E, se ci pensiamo, \u00e8 proprio di quello che si occupa l'informatica, ovvero di gestire in maniera automatica una serie pi\u00f9 o meno rilevante di informazioni, correlate ad un qualsiasi aspetto della nostra vita, siano esse le nostre foto su Facebook, il nostro libretto universitario oppure i dati dei nostri conti corrente bancari: tutte queste informazioni vengono elaborate in maniera (pi\u00f9 o meno) automatica. Proviamo ad arricchire questa prima, un po' generica, definizione. Per farlo, sfruttiamo un'altra denominazione straniera, ovvero quella inglese, lingua nella quale l'informatica \u00e8 chiamata computer science . Quello che notiamo di questa definizione \u00e8 il termine science , che ci suggerisce come l'informatica, in realt\u00e0, sia basata su solide fondamenta scientifiche: per capirci, infatti, i \"padri fondatori\" della materia erano prevalentemente dei matematici, uno fra tutti il celebre Alan Turing. L'ultimo fattore da tenere in conto \u00e8 che l'informatica rappresenta uno vero e proprio pilastro della societ\u00e0 moderna. Tutto ci\u00f2 che utilizziamo al giorno d'oggi, dallo smartphone che stiamo usando per leggere questo documento, al computer mediante il quale \u00e8 stato scritto, fino ad arrivare alle nostre auto, o anche ai termostati nelle nostre caldaie, sono basati su tutte le evoluzioni informatiche (ed elettroniche) succedutesi a partire dal Secondo Dopoguerra. Ecco, quindi, che possiamo dare una definizione \"finale\" di informatica, presa direttamente dall'Oxford Languages: L'informatica L'informatica \u00e8 la scienza che si occupa dell' ordinamento , del trattamento e della trasmissione delle informazioni per mezzo dell' elaborazione elettronica , la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico. Ora, non \u00e8 tanto importante memorizzare questa definizione, quanto piuttosto comprenderne la portata: l'informatica \u00e8 ovunque, e conoscerla ci d\u00e0 l'accesso alle porte di quello che \u00e8 il mondo odierno. 1.1 - Approfondiamo un po' \u00b6 Nel precedente paragrafo, abbiamo introdotto alcuni elementi legati alla disciplina dell'informatica. Approfondiamoli brevemente. 1.1.1 - L'informazione \u00b6 Pi\u00f9 volte in precedenza abbiamo parlato di \"informazione\". Intuitivamente, ognuno di noi sa cosa questo termine intenda, anche se pu\u00f2 essere un po' difficile spiegarlo. L'informazione \u00e8 comunemente associata ai concetti di conoscenza ed esperienza : la conoscenza di un teorema matematico rappresenta un'informazione su come la teoria analitica dimostri delle ipotesi a partire da delle tesi e dei processi logici; allo stesso modo, l'esperienza che accumuliamo provando a cucinare dei manicaretti rappresenta un'informazione su come mescolare al punto giusto dei cibi per ottenere un risultato. Seppur agli antipodi, i due precedenti esempi mostrano come vi sia una base comune alle diverse informazioni: infatti, queste possono essere comunicate , o trasmesse , ed il concetto formale di informazione, definito dall'omonima teoria elaborata da Claude Shannon, \u00e8 quello alla base del processo comunicativo . Teoria dell'Informazione La teoria dell'informazione, cui abbiamo brevemente accennato in precedenza, non deve essere confusa con l'informatica, di cui \u00e8 soltanto una \"cugina\". Brevemente, infatti, la teoria dell'informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione dell'informazione su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca. 1.1.2 - I sistemi Informatici \u00b6 Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0.","title":"1 - Introduzione all'informatica"},{"location":"material/01_intro/01_introduction/lecture/#1-introduzione-cosa-e-linformatica","text":"Come per molti degli argomenti cui ci si approccia nel corso della vita, trovare una definizione per il concetto di informatica pu\u00f2 aiutare a comprenderne al meglio la natura. Partiamo quindi da una (breve) analisi etimologica del termine informatica . Questo, infatti, \u00e8 la traduzione italiana del francese informatique , crasi delle parole informa(tion) ed (automa)tique . Intuitivamente, possiamo dedurre che la disciplina tratti quindi di \"informazioni automatiche\" o, per meglio dire, automatizzazione delle informazioni . E, se ci pensiamo, \u00e8 proprio di quello che si occupa l'informatica, ovvero di gestire in maniera automatica una serie pi\u00f9 o meno rilevante di informazioni, correlate ad un qualsiasi aspetto della nostra vita, siano esse le nostre foto su Facebook, il nostro libretto universitario oppure i dati dei nostri conti corrente bancari: tutte queste informazioni vengono elaborate in maniera (pi\u00f9 o meno) automatica. Proviamo ad arricchire questa prima, un po' generica, definizione. Per farlo, sfruttiamo un'altra denominazione straniera, ovvero quella inglese, lingua nella quale l'informatica \u00e8 chiamata computer science . Quello che notiamo di questa definizione \u00e8 il termine science , che ci suggerisce come l'informatica, in realt\u00e0, sia basata su solide fondamenta scientifiche: per capirci, infatti, i \"padri fondatori\" della materia erano prevalentemente dei matematici, uno fra tutti il celebre Alan Turing. L'ultimo fattore da tenere in conto \u00e8 che l'informatica rappresenta uno vero e proprio pilastro della societ\u00e0 moderna. Tutto ci\u00f2 che utilizziamo al giorno d'oggi, dallo smartphone che stiamo usando per leggere questo documento, al computer mediante il quale \u00e8 stato scritto, fino ad arrivare alle nostre auto, o anche ai termostati nelle nostre caldaie, sono basati su tutte le evoluzioni informatiche (ed elettroniche) succedutesi a partire dal Secondo Dopoguerra. Ecco, quindi, che possiamo dare una definizione \"finale\" di informatica, presa direttamente dall'Oxford Languages: L'informatica L'informatica \u00e8 la scienza che si occupa dell' ordinamento , del trattamento e della trasmissione delle informazioni per mezzo dell' elaborazione elettronica , la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico. Ora, non \u00e8 tanto importante memorizzare questa definizione, quanto piuttosto comprenderne la portata: l'informatica \u00e8 ovunque, e conoscerla ci d\u00e0 l'accesso alle porte di quello che \u00e8 il mondo odierno.","title":"1 - Introduzione: cosa \u00e8 l'Informatica?"},{"location":"material/01_intro/01_introduction/lecture/#11-approfondiamo-un-po","text":"Nel precedente paragrafo, abbiamo introdotto alcuni elementi legati alla disciplina dell'informatica. Approfondiamoli brevemente.","title":"1.1 - Approfondiamo un po'"},{"location":"material/01_intro/01_introduction/lecture/#111-linformazione","text":"Pi\u00f9 volte in precedenza abbiamo parlato di \"informazione\". Intuitivamente, ognuno di noi sa cosa questo termine intenda, anche se pu\u00f2 essere un po' difficile spiegarlo. L'informazione \u00e8 comunemente associata ai concetti di conoscenza ed esperienza : la conoscenza di un teorema matematico rappresenta un'informazione su come la teoria analitica dimostri delle ipotesi a partire da delle tesi e dei processi logici; allo stesso modo, l'esperienza che accumuliamo provando a cucinare dei manicaretti rappresenta un'informazione su come mescolare al punto giusto dei cibi per ottenere un risultato. Seppur agli antipodi, i due precedenti esempi mostrano come vi sia una base comune alle diverse informazioni: infatti, queste possono essere comunicate , o trasmesse , ed il concetto formale di informazione, definito dall'omonima teoria elaborata da Claude Shannon, \u00e8 quello alla base del processo comunicativo . Teoria dell'Informazione La teoria dell'informazione, cui abbiamo brevemente accennato in precedenza, non deve essere confusa con l'informatica, di cui \u00e8 soltanto una \"cugina\". Brevemente, infatti, la teoria dell'informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione dell'informazione su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca.","title":"1.1.1 - L'informazione"},{"location":"material/01_intro/01_introduction/lecture/#112-i-sistemi-informatici","text":"Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0.","title":"1.1.2 - I sistemi Informatici"},{"location":"material/01_intro/02_algorithms/lecture/","text":"2 - Introduzione agli algoritmi \u00b6 2.1 - Formulare un problema \u00b6 Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio. 2.1.1 - Il problema come compito \u00b6 Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo . 2.1.2 - L' ente risolutore \u00b6 La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann. 2.1.3 - Gli elementi noti e le condizioni fissate \u00b6 La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore. 2.2 - Risolvere un problema \u00b6 La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi. 2.2.1 Problemi e soluzioni \u00b6 Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione . 2.2.2 - Costruire la soluzione \u00b6 Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse. 2.2.2.1 Operazioni atomiche \u00b6 Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.). 2.2.2.2 Combinare operazioni atomiche \u00b6 Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori. 2.2.2.3 Determinare l'insieme di operatori \u00b6 Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema. 2.2.2.4 Da soluzione ad algoritmo \u00b6 La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema. 2.3 - Un esempio \u00b6 Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo. 2.3.1 - Formulazione del problema \u00b6 Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) . 2.3.2 - Dati \u00b6 Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo. 2.3.3 - Algoritmo risolutivo (in operazioni atomiche, o quasi) \u00b6 Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 . 2.3.4 Svolgimento numerico \u00b6 Dati \u00b6 \\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\] Passi dell'algoritmo \u00b6 \\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) . 2.4 - Caratteristiche degli algoritmi risolutivi \u00b6 Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. 2.4.1 Determinismo \u00b6 Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso. 2.4.2 Input, Output e Variabili \u00b6 Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"2 - Introduzione agli algoritmi"},{"location":"material/01_intro/02_algorithms/lecture/#2-introduzione-agli-algoritmi","text":"","title":"2 - Introduzione agli algoritmi"},{"location":"material/01_intro/02_algorithms/lecture/#21-formulare-un-problema","text":"Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio.","title":"2.1 - Formulare un problema"},{"location":"material/01_intro/02_algorithms/lecture/#211-il-problema-come-compito","text":"Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo .","title":"2.1.1 - Il problema come compito"},{"location":"material/01_intro/02_algorithms/lecture/#212-lente-risolutore","text":"La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann.","title":"2.1.2 - L'ente risolutore"},{"location":"material/01_intro/02_algorithms/lecture/#213-gli-elementi-noti-e-le-condizioni-fissate","text":"La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore.","title":"2.1.3 - Gli elementi noti e le condizioni fissate"},{"location":"material/01_intro/02_algorithms/lecture/#22-risolvere-un-problema","text":"La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi.","title":"2.2 - Risolvere un problema"},{"location":"material/01_intro/02_algorithms/lecture/#221-problemi-e-soluzioni","text":"Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione .","title":"2.2.1 Problemi e soluzioni"},{"location":"material/01_intro/02_algorithms/lecture/#222-costruire-la-soluzione","text":"Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse.","title":"2.2.2 - Costruire la soluzione"},{"location":"material/01_intro/02_algorithms/lecture/#2221-operazioni-atomiche","text":"Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.).","title":"2.2.2.1 Operazioni atomiche"},{"location":"material/01_intro/02_algorithms/lecture/#2222-combinare-operazioni-atomiche","text":"Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori.","title":"2.2.2.2 Combinare operazioni atomiche"},{"location":"material/01_intro/02_algorithms/lecture/#2223-determinare-linsieme-di-operatori","text":"Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema.","title":"2.2.2.3 Determinare l'insieme di operatori"},{"location":"material/01_intro/02_algorithms/lecture/#2224-da-soluzione-ad-algoritmo","text":"La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema.","title":"2.2.2.4 Da soluzione ad algoritmo"},{"location":"material/01_intro/02_algorithms/lecture/#23-un-esempio","text":"Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo.","title":"2.3 - Un esempio"},{"location":"material/01_intro/02_algorithms/lecture/#231-formulazione-del-problema","text":"Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) .","title":"2.3.1 - Formulazione del problema"},{"location":"material/01_intro/02_algorithms/lecture/#232-dati","text":"Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo.","title":"2.3.2 - Dati"},{"location":"material/01_intro/02_algorithms/lecture/#233-algoritmo-risolutivo-in-operazioni-atomiche-o-quasi","text":"Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 .","title":"2.3.3 - Algoritmo risolutivo (in operazioni atomiche, o quasi)"},{"location":"material/01_intro/02_algorithms/lecture/#234-svolgimento-numerico","text":"","title":"2.3.4 Svolgimento numerico"},{"location":"material/01_intro/02_algorithms/lecture/#dati","text":"\\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\]","title":"Dati"},{"location":"material/01_intro/02_algorithms/lecture/#passi-dellalgoritmo","text":"\\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) .","title":"Passi dell'algoritmo"},{"location":"material/01_intro/02_algorithms/lecture/#24-caratteristiche-degli-algoritmi-risolutivi","text":"Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata.","title":"2.4 - Caratteristiche degli algoritmi risolutivi"},{"location":"material/01_intro/02_algorithms/lecture/#241-determinismo","text":"Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso.","title":"2.4.1 Determinismo"},{"location":"material/01_intro/02_algorithms/lecture/#242-input-output-e-variabili","text":"Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"2.4.2 Input, Output e Variabili"},{"location":"material/01_intro/03_dec_bin/lecture/","text":"3 - Il mondo in forma binaria \u00b6 3.1 - Le informazioni nel mondo reale \u00b6 Nel mondo reale, le informazioni fluiscono dalla sorgente al destinatario sotto forma di onde analogiche . Per capirci, pensiamo ad una conversazione tra due persone: entrambe produrranno, mediante il loro apparato fonatorio, delle onde sonore, continue sia nel tempo che nelle ampiezze, che arriveranno all'orecchio dell'altro interlocutore, il quale le passer\u00e0 al cervello che, a sua volta, le interpreter\u00e0. Di particolare importanza \u00e8 il concetto di continuit\u00e0 della forma d'onda utilizzata. Partiamo dall'analisi matematica: sappiamo che le funzioni continue sono definite nel dominio \\(\\mathbb{R}\\) dei numeri reali, per cui assumono, a meno dei punti di discontinuit\u00e0, un numero infinito di valori. Questo vale anche per le forme d'onda analogiche, che abbiamo detto essere continue: ogni onda sonora emessa nella conversazione di cui sopra potr\u00e0 assumere un numero \"infinito\" di valori all'interno degli intervalli temporali e di ampiezza nei quali \u00e8 emessa. Nota Ovviamente, non teniamo conto di effetti quantistici: stiamo parlando di fenomeni macroscopici . 3.2 - La gestione dell'informazione \u00b6 Chiarito il concetto di grandezza \"analogica\", pensiamo adesso a come uno strumento potrebbe in qualche modo caratterizzarla. In particolare, ragioniamo in termini di capacit\u00e0 dello strumento, ovvero: Quanti stati deve essere in grado di rappresentare contemporaneamente un sistema per caratterizzare completamente una forma d'onda analogica? Beh, la risposta a questa domanda \u00e8 semplice: infiniti . Ovviamente, una realizzazione pratica di questa macchina non esiste, n\u00e9 pu\u00f2 essere realizzata con le tecnologie attuali. Occorre quindi ridurre il numero di stati che devono essere rappresentati contemporaneamente. Per farlo, dobbiamo passare dal dominio analogico a quello digitale . 3.3 - La rappresentazione digitale dell'informazione \u00b6 Il dominio digitale \u00e8 semplice da caratterizzare: infatti, l'informazione pu\u00f2 assumere soltanto due possibili valori, ovvero \\(0\\) ed \\(1\\) (chiamati alle volte anche basso ed alto , o anche spento ed acceso ). 3.3.1 - Il bit \u00b6 Appare chiaro come una rappresentazione digitale, detta anche binaria , sia molto pi\u00f9 facile da gestire per un calcolatore rispetto ad una rappresentazione analogica. Ed \u00e8 per questo che \u00e8 importante definire la nozione fondamentale su cui \u00e8 basata l'intera informatica, ovvero bit , crasi di binary digit (traducibile dall'inglese come cifra binaria ): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero). 3.3.2 - Il byte \u00b6 Dalla definizione di bit segue quella, altrettanto importante, di byte , associata ad una sequenza arbitraria di otto bit. Quanti sono i possibili valori di un byte? Per rispondere a questa domanda, ricordiamoci che ogni bit pu\u00f2 assumere soltanto due valori; di conseguenza, due bit potranno assumere al massimo \\(2 \\times 2\\) valori, ovvero quattro, tre bit \\(2 \\times 2 \\times 2\\) valori, ovvero otto, e cos\u00ec via. E' semplice quindi constatare che una sequenza di \\(n\\) bit assume al pi\u00f9 \\(2^n\\) valori, per cui otto bit potranno assumere al massimo \\(2^8\\) valori. Ne consegue che, riportando il tutto in decimale, un byte potr\u00e0 assumere al massimo 256 valori. 3.3.3 - La parola \u00b6 Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso). Ad esempio, la maggior parte dei processori consumer odierni utilizza parole da otto byte, ovvero 64 bit, capaci quindi di rappresentare fino a \\(2^{64}\\) valori. 3.4 - Da decimale a binario \u00b6 Nel mondo reale, siamo abituati ad utilizzare i numeri seguendo una notazione di tipo decimale e posizionale . Detto in altri termini: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato. 3.4.1 - Espressione formale di un numero in base decimale \u00b6 Formalmente, se \\(N \\in \\mathbb{i}\\) \u00e8 un numero intero composto da \\(k\\) simboli, \u00e8 possibile esprimerlo come: \\[ N = a_k a_{k-1} a_{k-2} \\ldots a_2 a_1 a_0 \\] dove \\(a_i\\) \u00e8 l' \\(i\\) -mo simbolo, con \\(i \\in [1, \\ldots, k]\\) . Possiamo esprimere \\(N\\) anche in base \\(10\\) : \\[ N = a_k * 10^k + a_{k-1} * 10^{k-1} + \\ldots + a_1 * 10^1 + a_0 * 10^0 \\] Per fare un semplice esempio: \\[ N = 485 = 4 * 10^2 + 8 * 10 + 5 \\] 3.4.2 - Da base decimale a base binaria \u00b6 Ovviamente, l'espressione formale di un numero in base decimale \u00e8 facilmente adattabile ad altre basi, per cui, in generale, vale che un numero \\(B\\) a \\(l\\) simboli \u00e8 esprimibile in base \\(b\\) mediante un'espressione del tipo: \\[ B_{b} = a_l * b^l + a_{l-1} * b^{l-1} + \\ldots + a_1 * b^1 + a_0 * b^0 \\] Supponiamo adesso di voler convertire un numero \\(N\\) dalla forma decimale a quella binaria. Per farlo, dovremo procedere dividendo \\(N\\) per la base \\(2\\) , valutando il resto \\(r\\) , e reiterare l'operazione usando il quoziente \\(q\\) . Facciamo un esempio usando \\(N = 485\\) . \\[ \\begin{eqnarray} \\frac{485}{2} &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ \\frac{242}{2} &\\Rightarrow q = 121 & r = 0 \\\\ \\frac{121}{2} &\\Rightarrow q = 60 & r = 1 \\\\ \\frac{60}{2} &\\Rightarrow q = 30 & r = 0 \\\\ \\frac{30}{2} &\\Rightarrow q = 15 & r = 0 \\\\ \\frac{15}{2} &\\Rightarrow q = 7 & r = 1 \\\\ \\frac{7}{2} &\\Rightarrow q = 3 & r = 1 \\\\ \\frac{3}{2} &\\Rightarrow q = 1 & r = 1 \\\\ \\frac{1}{2} &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo).","title":"3 - Rappresentazione binaria e decimale"},{"location":"material/01_intro/03_dec_bin/lecture/#3-il-mondo-in-forma-binaria","text":"","title":"3 - Il mondo in forma binaria"},{"location":"material/01_intro/03_dec_bin/lecture/#31-le-informazioni-nel-mondo-reale","text":"Nel mondo reale, le informazioni fluiscono dalla sorgente al destinatario sotto forma di onde analogiche . Per capirci, pensiamo ad una conversazione tra due persone: entrambe produrranno, mediante il loro apparato fonatorio, delle onde sonore, continue sia nel tempo che nelle ampiezze, che arriveranno all'orecchio dell'altro interlocutore, il quale le passer\u00e0 al cervello che, a sua volta, le interpreter\u00e0. Di particolare importanza \u00e8 il concetto di continuit\u00e0 della forma d'onda utilizzata. Partiamo dall'analisi matematica: sappiamo che le funzioni continue sono definite nel dominio \\(\\mathbb{R}\\) dei numeri reali, per cui assumono, a meno dei punti di discontinuit\u00e0, un numero infinito di valori. Questo vale anche per le forme d'onda analogiche, che abbiamo detto essere continue: ogni onda sonora emessa nella conversazione di cui sopra potr\u00e0 assumere un numero \"infinito\" di valori all'interno degli intervalli temporali e di ampiezza nei quali \u00e8 emessa. Nota Ovviamente, non teniamo conto di effetti quantistici: stiamo parlando di fenomeni macroscopici .","title":"3.1 - Le informazioni nel mondo reale"},{"location":"material/01_intro/03_dec_bin/lecture/#32-la-gestione-dellinformazione","text":"Chiarito il concetto di grandezza \"analogica\", pensiamo adesso a come uno strumento potrebbe in qualche modo caratterizzarla. In particolare, ragioniamo in termini di capacit\u00e0 dello strumento, ovvero: Quanti stati deve essere in grado di rappresentare contemporaneamente un sistema per caratterizzare completamente una forma d'onda analogica? Beh, la risposta a questa domanda \u00e8 semplice: infiniti . Ovviamente, una realizzazione pratica di questa macchina non esiste, n\u00e9 pu\u00f2 essere realizzata con le tecnologie attuali. Occorre quindi ridurre il numero di stati che devono essere rappresentati contemporaneamente. Per farlo, dobbiamo passare dal dominio analogico a quello digitale .","title":"3.2 - La gestione dell'informazione"},{"location":"material/01_intro/03_dec_bin/lecture/#33-la-rappresentazione-digitale-dellinformazione","text":"Il dominio digitale \u00e8 semplice da caratterizzare: infatti, l'informazione pu\u00f2 assumere soltanto due possibili valori, ovvero \\(0\\) ed \\(1\\) (chiamati alle volte anche basso ed alto , o anche spento ed acceso ).","title":"3.3 - La rappresentazione digitale dell'informazione"},{"location":"material/01_intro/03_dec_bin/lecture/#331-il-bit","text":"Appare chiaro come una rappresentazione digitale, detta anche binaria , sia molto pi\u00f9 facile da gestire per un calcolatore rispetto ad una rappresentazione analogica. Ed \u00e8 per questo che \u00e8 importante definire la nozione fondamentale su cui \u00e8 basata l'intera informatica, ovvero bit , crasi di binary digit (traducibile dall'inglese come cifra binaria ): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero).","title":"3.3.1 - Il bit"},{"location":"material/01_intro/03_dec_bin/lecture/#332-il-byte","text":"Dalla definizione di bit segue quella, altrettanto importante, di byte , associata ad una sequenza arbitraria di otto bit. Quanti sono i possibili valori di un byte? Per rispondere a questa domanda, ricordiamoci che ogni bit pu\u00f2 assumere soltanto due valori; di conseguenza, due bit potranno assumere al massimo \\(2 \\times 2\\) valori, ovvero quattro, tre bit \\(2 \\times 2 \\times 2\\) valori, ovvero otto, e cos\u00ec via. E' semplice quindi constatare che una sequenza di \\(n\\) bit assume al pi\u00f9 \\(2^n\\) valori, per cui otto bit potranno assumere al massimo \\(2^8\\) valori. Ne consegue che, riportando il tutto in decimale, un byte potr\u00e0 assumere al massimo 256 valori.","title":"3.3.2 - Il byte"},{"location":"material/01_intro/03_dec_bin/lecture/#333-la-parola","text":"Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso). Ad esempio, la maggior parte dei processori consumer odierni utilizza parole da otto byte, ovvero 64 bit, capaci quindi di rappresentare fino a \\(2^{64}\\) valori.","title":"3.3.3 - La parola"},{"location":"material/01_intro/03_dec_bin/lecture/#34-da-decimale-a-binario","text":"Nel mondo reale, siamo abituati ad utilizzare i numeri seguendo una notazione di tipo decimale e posizionale . Detto in altri termini: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato.","title":"3.4 - Da decimale a binario"},{"location":"material/01_intro/03_dec_bin/lecture/#341-espressione-formale-di-un-numero-in-base-decimale","text":"Formalmente, se \\(N \\in \\mathbb{i}\\) \u00e8 un numero intero composto da \\(k\\) simboli, \u00e8 possibile esprimerlo come: \\[ N = a_k a_{k-1} a_{k-2} \\ldots a_2 a_1 a_0 \\] dove \\(a_i\\) \u00e8 l' \\(i\\) -mo simbolo, con \\(i \\in [1, \\ldots, k]\\) . Possiamo esprimere \\(N\\) anche in base \\(10\\) : \\[ N = a_k * 10^k + a_{k-1} * 10^{k-1} + \\ldots + a_1 * 10^1 + a_0 * 10^0 \\] Per fare un semplice esempio: \\[ N = 485 = 4 * 10^2 + 8 * 10 + 5 \\]","title":"3.4.1 - Espressione formale di un numero in base decimale"},{"location":"material/01_intro/03_dec_bin/lecture/#342-da-base-decimale-a-base-binaria","text":"Ovviamente, l'espressione formale di un numero in base decimale \u00e8 facilmente adattabile ad altre basi, per cui, in generale, vale che un numero \\(B\\) a \\(l\\) simboli \u00e8 esprimibile in base \\(b\\) mediante un'espressione del tipo: \\[ B_{b} = a_l * b^l + a_{l-1} * b^{l-1} + \\ldots + a_1 * b^1 + a_0 * b^0 \\] Supponiamo adesso di voler convertire un numero \\(N\\) dalla forma decimale a quella binaria. Per farlo, dovremo procedere dividendo \\(N\\) per la base \\(2\\) , valutando il resto \\(r\\) , e reiterare l'operazione usando il quoziente \\(q\\) . Facciamo un esempio usando \\(N = 485\\) . \\[ \\begin{eqnarray} \\frac{485}{2} &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ \\frac{242}{2} &\\Rightarrow q = 121 & r = 0 \\\\ \\frac{121}{2} &\\Rightarrow q = 60 & r = 1 \\\\ \\frac{60}{2} &\\Rightarrow q = 30 & r = 0 \\\\ \\frac{30}{2} &\\Rightarrow q = 15 & r = 0 \\\\ \\frac{15}{2} &\\Rightarrow q = 7 & r = 1 \\\\ \\frac{7}{2} &\\Rightarrow q = 3 & r = 1 \\\\ \\frac{3}{2} &\\Rightarrow q = 1 & r = 1 \\\\ \\frac{1}{2} &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo).","title":"3.4.2 - Da base decimale a base binaria"},{"location":"material/01_intro/04_data_type/lecture/","text":"4 - I tipi di dato \u00b6 Nel capitolo precedente abbiamo accennato al fatto che i calcolatori hanno a disposizione una determinata parola , la cui dimensione dipende dall'architettura, che determina il numero massimo di bit che possono essere rappresentati nei dati gestiti in fase di elaborazione. Questo, ovviamente, comporta un limite: vediamone in breve le implicazioni, approfittando per introdurre i diversi tipi di dato. 4.1 - Dati numerici \u00b6 Il primo tipo di dati che vediamo \u00e8 quello numerico , che comprende, in linea generale, i numeri interi e reali. I numeri complessi I pi\u00f9 attenti potrebbero chiedersi perch\u00e9 i numeri complessi non sono stati menzionati in precedenza. Infatti, i numeri complessi non sono contemplati come dati primitivi in numerosi linguaggi di programmazione, anche se, come vedremo, Python prevede un'apposita struttura dedicata allo scopo. 4.1.1 - Numeri interi \u00b6 Il limite imposto alla lunghezza della parola comporta che il valore numerico massimo trattabile da un calcolatore sia finito: ad esempio, nel caso di un'architettura con parola a 64 bit (come la maggior parte dei processori odierni), sar\u00e0 possibile rappresentare \"soltanto\" \\(2^{64}\\) possibili valori. Nota Ricordiamo che \\(2^{64} = 18.446.744.073.709.551.616\\) . Il limite appare quindi abbastanza permissivo. Cosa accade, quindi, se dovessimo raggiungere \\(2^{64}\\) ? Molto semplice: il conteggio ricomincia da zero (o il programma va in errore). Altrettanto importante \u00e8 il notare come i numeri possano essere dotati di segno. Questo, ovviamente, va ad influenzare gli estremi dell'intervallo dei valori rappresentabili, ma non la cardinalit\u00e0 dello stesso. Infatti, se si considera il segno anteposto al numero, potremo trattare valori che vanno nell'intervallo da \\(-2^{63}\\) a \\(2^{63}\\) . Facciamo un breve esempio pratico, con una lunghezza della parola di otto bit. In questo caso: considerando solo lo zero ed i valori strettamente positivi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^{8-1}\\) ; considerando anche i valori negativi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{8-1}\\) e \\(127 = -2^{8-1}-1\\) . Nella seguente tabella, sono riassunti alcuni tra i tipi di valore intero pi\u00f9 comune, differenziati a seconda della loro lunghezza. Tipo di dato Lunghezza Valore minimo assumibile Valore massimo assumibile bit 1 bit 0 1 ubyte 8 bit 0 255 byte 8 bit -128 127 ushort 16 bit 0 \\(2^{16} - 1\\) = 65535 short 16 bit -32768 32767 uint 32 bit 0 \\(2^{32} - 1\\) = 4294967295 int 32 bit \\(-2^{31}\\) = 2147483648 \\(2^{31} - 1\\) = 2147483647 ulong 64 bit 0 \\(2^{64} - 1\\) long 64 bit \\(-2^{63}\\) \\(2^{63} - 1\\) Il bit Il bit \u00e8 il tipo di dato numerico pi\u00f9 \"limitato\" rappresentabile, e viene spesso utilizzato come valore booleano. Il simbolo u I pi\u00f9 attenti avranno notato la presenza del simbolo u nelle notazioni che includono solo i valori positivi. Intuitivamente, la u sta per unsigned , ovvero \"senza segno\". Tipi e lunghezza I tipi riportati nella tabella precedente, assieme alla loro lunghezza, sono quelli \"standard\", cui aderiscono la maggior parte dei linguaggi di programmazione (ma non tutti ). 4.1.2 Rappresentazione di numeri reali \u00b6 Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) deve essere rappresentato mediante un'approssimazione finita. Ricordiamo che ogni numero reale \u00e8 composto da una parte intera ed una razionale ; di conseguenza, considerato che il numero di bit per la rappresentazione \u00e8 sempre lo stesso, occorre trovare un modo per conciliare la presenza di queste due parti. In tal senso, esistono due possibili rappresentazioni che \u00e8 possibile utilizzare. Nella rappresentazione a virgola fissa , o fixed point , si usa un numero fisso di bit per la parte intera del numero da rappresentare, con i rimanenti usati per la parte decimale. Pi\u00f9 interessante \u00e8 invece la rappresentazione a virgola mobile , o floating point , basata sui concetti di mantissa (ovvero, parte decimale) ed esponente . Formalmente, definiamo la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_{int}\\) : \\[ M = n - n_{int} \\] E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . La rappresentazione in virgola mobile di \\(n\\) \u00e8 definita quindi come: \\[ n = M * b^e \\] con \\(b\\) base scelta, ed \\(e\\) esponente. Ad esempio, per rappresentare il numero \\(5.2\\) in virgola mobile, potremo scrivere: \\[ n = 0.52 * 10^1 \\] da cui \\(M = 0.52\\) ed \\(e = 1\\) . Questa notazione, detta normalizzata , prevede che la parte razionale sia sempre minore di uno, mentre quella intera sia pari a zero. Equivalentemente, potremmo scrivere: \\[ n = 0.052 * 10^2 \\] cos\u00ec come: \\[ n = 52 * 10^{-1} \\] Tuttavia, \u00e8 la notazione normalizzata ad essere usata per convenzione. Il vantaggio legato all'utilizzo della rappresentazione in virgola mobile sta nel fatto che \u00e8 possibile rappresentare un range di numeri molto pi\u00f9 ampio rispetto a quello a virgola fissa. Ad esempio, immaginiamo di voler utilizzare quattro simboli ( notate che non stiamo utilizzando la rappresentazione binaria, quindi non parliamo di bit ) per rappresentare il numero \\(63500\\) . Se usassimo una rappresentazione a virgola fissa, cos\u00ec come una intera, non potremmo in alcun modo rappresentarlo ; invece, con la rappresentazione a virgola mobile, avremmo: \\[ M = 635 \\\\ e = 5 \\\\ n = 0.635 * 10^5 \\] e, dovendo memorizzare esclusivamente la mantissa (che richiede tre simboli) e l'esponente (che ne richiede uno), riusciremmo nel nostro intento. 4.2 - Caratteri \u00b6 Anche i caratteri che troviamo normalmente sulle nostre tastiere devono essere rappresentati in binario. In generale, il concetto di carattere deve essere assimilato a quello di simbolo , in quanto i calcolatori devono poter rappresentare simboli \"speciali\" (ad esempio, la chiocciola @ o l'underscore _), cos\u00ec come caratteri in altri tipi di alfabeti (ad esempio, il cirillico o il mandarino). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra simboli e numeri interi. Questa corrispondenza \u00e8 stata codificata in standard ben precisi, tra i quali vale la pena citare l'ASCII e l'UNICODE. Quello che per\u00f2 questo comporta dal punto di vista pratico \u00e8 che, cos\u00ec come i dati di tipo numerico, anche il numero totale di caratteri rappresentabili sar\u00e0 limitato dalla lunghezza della parola utilizzata dall'architettura del calcolatore. Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri; essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"4 - Tipi di dato"},{"location":"material/01_intro/04_data_type/lecture/#4-i-tipi-di-dato","text":"Nel capitolo precedente abbiamo accennato al fatto che i calcolatori hanno a disposizione una determinata parola , la cui dimensione dipende dall'architettura, che determina il numero massimo di bit che possono essere rappresentati nei dati gestiti in fase di elaborazione. Questo, ovviamente, comporta un limite: vediamone in breve le implicazioni, approfittando per introdurre i diversi tipi di dato.","title":"4 - I tipi di dato"},{"location":"material/01_intro/04_data_type/lecture/#41-dati-numerici","text":"Il primo tipo di dati che vediamo \u00e8 quello numerico , che comprende, in linea generale, i numeri interi e reali. I numeri complessi I pi\u00f9 attenti potrebbero chiedersi perch\u00e9 i numeri complessi non sono stati menzionati in precedenza. Infatti, i numeri complessi non sono contemplati come dati primitivi in numerosi linguaggi di programmazione, anche se, come vedremo, Python prevede un'apposita struttura dedicata allo scopo.","title":"4.1 - Dati numerici"},{"location":"material/01_intro/04_data_type/lecture/#411-numeri-interi","text":"Il limite imposto alla lunghezza della parola comporta che il valore numerico massimo trattabile da un calcolatore sia finito: ad esempio, nel caso di un'architettura con parola a 64 bit (come la maggior parte dei processori odierni), sar\u00e0 possibile rappresentare \"soltanto\" \\(2^{64}\\) possibili valori. Nota Ricordiamo che \\(2^{64} = 18.446.744.073.709.551.616\\) . Il limite appare quindi abbastanza permissivo. Cosa accade, quindi, se dovessimo raggiungere \\(2^{64}\\) ? Molto semplice: il conteggio ricomincia da zero (o il programma va in errore). Altrettanto importante \u00e8 il notare come i numeri possano essere dotati di segno. Questo, ovviamente, va ad influenzare gli estremi dell'intervallo dei valori rappresentabili, ma non la cardinalit\u00e0 dello stesso. Infatti, se si considera il segno anteposto al numero, potremo trattare valori che vanno nell'intervallo da \\(-2^{63}\\) a \\(2^{63}\\) . Facciamo un breve esempio pratico, con una lunghezza della parola di otto bit. In questo caso: considerando solo lo zero ed i valori strettamente positivi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^{8-1}\\) ; considerando anche i valori negativi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{8-1}\\) e \\(127 = -2^{8-1}-1\\) . Nella seguente tabella, sono riassunti alcuni tra i tipi di valore intero pi\u00f9 comune, differenziati a seconda della loro lunghezza. Tipo di dato Lunghezza Valore minimo assumibile Valore massimo assumibile bit 1 bit 0 1 ubyte 8 bit 0 255 byte 8 bit -128 127 ushort 16 bit 0 \\(2^{16} - 1\\) = 65535 short 16 bit -32768 32767 uint 32 bit 0 \\(2^{32} - 1\\) = 4294967295 int 32 bit \\(-2^{31}\\) = 2147483648 \\(2^{31} - 1\\) = 2147483647 ulong 64 bit 0 \\(2^{64} - 1\\) long 64 bit \\(-2^{63}\\) \\(2^{63} - 1\\) Il bit Il bit \u00e8 il tipo di dato numerico pi\u00f9 \"limitato\" rappresentabile, e viene spesso utilizzato come valore booleano. Il simbolo u I pi\u00f9 attenti avranno notato la presenza del simbolo u nelle notazioni che includono solo i valori positivi. Intuitivamente, la u sta per unsigned , ovvero \"senza segno\". Tipi e lunghezza I tipi riportati nella tabella precedente, assieme alla loro lunghezza, sono quelli \"standard\", cui aderiscono la maggior parte dei linguaggi di programmazione (ma non tutti ).","title":"4.1.1 - Numeri interi"},{"location":"material/01_intro/04_data_type/lecture/#412-rappresentazione-di-numeri-reali","text":"Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) deve essere rappresentato mediante un'approssimazione finita. Ricordiamo che ogni numero reale \u00e8 composto da una parte intera ed una razionale ; di conseguenza, considerato che il numero di bit per la rappresentazione \u00e8 sempre lo stesso, occorre trovare un modo per conciliare la presenza di queste due parti. In tal senso, esistono due possibili rappresentazioni che \u00e8 possibile utilizzare. Nella rappresentazione a virgola fissa , o fixed point , si usa un numero fisso di bit per la parte intera del numero da rappresentare, con i rimanenti usati per la parte decimale. Pi\u00f9 interessante \u00e8 invece la rappresentazione a virgola mobile , o floating point , basata sui concetti di mantissa (ovvero, parte decimale) ed esponente . Formalmente, definiamo la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_{int}\\) : \\[ M = n - n_{int} \\] E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . La rappresentazione in virgola mobile di \\(n\\) \u00e8 definita quindi come: \\[ n = M * b^e \\] con \\(b\\) base scelta, ed \\(e\\) esponente. Ad esempio, per rappresentare il numero \\(5.2\\) in virgola mobile, potremo scrivere: \\[ n = 0.52 * 10^1 \\] da cui \\(M = 0.52\\) ed \\(e = 1\\) . Questa notazione, detta normalizzata , prevede che la parte razionale sia sempre minore di uno, mentre quella intera sia pari a zero. Equivalentemente, potremmo scrivere: \\[ n = 0.052 * 10^2 \\] cos\u00ec come: \\[ n = 52 * 10^{-1} \\] Tuttavia, \u00e8 la notazione normalizzata ad essere usata per convenzione. Il vantaggio legato all'utilizzo della rappresentazione in virgola mobile sta nel fatto che \u00e8 possibile rappresentare un range di numeri molto pi\u00f9 ampio rispetto a quello a virgola fissa. Ad esempio, immaginiamo di voler utilizzare quattro simboli ( notate che non stiamo utilizzando la rappresentazione binaria, quindi non parliamo di bit ) per rappresentare il numero \\(63500\\) . Se usassimo una rappresentazione a virgola fissa, cos\u00ec come una intera, non potremmo in alcun modo rappresentarlo ; invece, con la rappresentazione a virgola mobile, avremmo: \\[ M = 635 \\\\ e = 5 \\\\ n = 0.635 * 10^5 \\] e, dovendo memorizzare esclusivamente la mantissa (che richiede tre simboli) e l'esponente (che ne richiede uno), riusciremmo nel nostro intento.","title":"4.1.2 Rappresentazione di numeri reali"},{"location":"material/01_intro/04_data_type/lecture/#42-caratteri","text":"Anche i caratteri che troviamo normalmente sulle nostre tastiere devono essere rappresentati in binario. In generale, il concetto di carattere deve essere assimilato a quello di simbolo , in quanto i calcolatori devono poter rappresentare simboli \"speciali\" (ad esempio, la chiocciola @ o l'underscore _), cos\u00ec come caratteri in altri tipi di alfabeti (ad esempio, il cirillico o il mandarino). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra simboli e numeri interi. Questa corrispondenza \u00e8 stata codificata in standard ben precisi, tra i quali vale la pena citare l'ASCII e l'UNICODE. Quello che per\u00f2 questo comporta dal punto di vista pratico \u00e8 che, cos\u00ec come i dati di tipo numerico, anche il numero totale di caratteri rappresentabili sar\u00e0 limitato dalla lunghezza della parola utilizzata dall'architettura del calcolatore. Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri; essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"4.2 - Caratteri"},{"location":"material/02_principles/05_flow_chart/lecture/","text":"5 - I diagrammi di flusso \u00b6 In una delle lezioni precedenti, abbiamo visto come un algoritmo pu\u00f2 essere espresso come una sequenza arbitrariamente complessa di operazioni atomiche. Detta sequenza, ovviamente, deve essere in qualche modo \"fissata\", di modo da indirizzare il funzionamento dell'algoritmo secondo le modalit\u00e0 desiderate. In tal senso, la tentazione potrebbe essere quella di limitarsi a tenere a mente i passi della sequenza di istruzioni, ed implementarle di getto . Tuttavia, questo non \u00e8 il modo migliore per farlo, in quanto risulta essere abbastanza complesso gestire tali informazioni all'aumentare della complessit\u00e0 dell'algoritmo. Un'altra soluzione potrebbe essere quella di scrivere le istruzioni su un qualche tipo di supporto o documento; tuttavia, la soluzione migliore \u00e8 quella di affidarsi a degli strumenti appositamente predisposti in tal senso, ovvero i diagrammi di flusso . 5.1 - Cosa sono i diagrammi di flusso? \u00b6 I diagrammi di flusso (in inglese flow charts ) sono uno strumento utile a gestire il flusso delle istruzioni. Un flow chart \u00e8 uno strumento prettamente visivo , atto a schematizzare il flusso delle singole istruzioni di un algoritmo. In tal modo, diventa estremamente pi\u00f9 semplice scrivere l'algoritmo, e valutare come i dati cambiano all'interno dello stesso. 5.2 - Quali sono le componenti fondamentali? \u00b6 Un diagramma di flusso pu\u00f2 avere al suo interno diverse componenti, le pi\u00f9 importanti delle quali sono visualizzate nella tabella successiva. In particolare: una ellisse indica l'inizio o la fine dell'algoritmo, ed andrebbe sempre apposta; un rettangolo indica una singola istruzione (o anche un gruppo di istruzioni) da eseguire nel programma; un parallelogramma indica un input o un output; un rombo indica una ramificazione nel percorso dell'algoritmo, legata prevalentemente alla verifica di una condizione; infine, le frecce sono usate per collegare tra loro diverse parti dello stesso algoritmo. 5.3 - Un esempio \u00b6 Nella seguente figura mostriamo un esempio di diagramma di flusso. Vediamo come il diagramma inizi con un'ellisse, che sar\u00e0 contrassegnata dalla scritta START (inserita arbitrariamente). Immediatamente dopo, vi sar\u00e0 la lettura di due variabili, ovvero \\(c_1\\) e \\(c_2\\) ; a quel punto, vi sar\u00e0 l'assegnazione di altre tre variabili, con infine la variabile \\(v_3\\) scritta su un dispositivo di output, seguita dal simbolo di fine algoritmo. E' estremamente importante notare come l'assegnazione e la lettura siano, in realt\u00e0, quasi \"ambigue\" dal punto di vista della notazione: occorre quindi in tal senso fare attenzione al fatto che si stia usando un parallelogramma o un rettangolo, seguendo le regole descritte nel paragrafo 5.2.","title":"5 - Diagrammi di flusso"},{"location":"material/02_principles/05_flow_chart/lecture/#5-i-diagrammi-di-flusso","text":"In una delle lezioni precedenti, abbiamo visto come un algoritmo pu\u00f2 essere espresso come una sequenza arbitrariamente complessa di operazioni atomiche. Detta sequenza, ovviamente, deve essere in qualche modo \"fissata\", di modo da indirizzare il funzionamento dell'algoritmo secondo le modalit\u00e0 desiderate. In tal senso, la tentazione potrebbe essere quella di limitarsi a tenere a mente i passi della sequenza di istruzioni, ed implementarle di getto . Tuttavia, questo non \u00e8 il modo migliore per farlo, in quanto risulta essere abbastanza complesso gestire tali informazioni all'aumentare della complessit\u00e0 dell'algoritmo. Un'altra soluzione potrebbe essere quella di scrivere le istruzioni su un qualche tipo di supporto o documento; tuttavia, la soluzione migliore \u00e8 quella di affidarsi a degli strumenti appositamente predisposti in tal senso, ovvero i diagrammi di flusso .","title":"5 - I diagrammi di flusso"},{"location":"material/02_principles/05_flow_chart/lecture/#51-cosa-sono-i-diagrammi-di-flusso","text":"I diagrammi di flusso (in inglese flow charts ) sono uno strumento utile a gestire il flusso delle istruzioni. Un flow chart \u00e8 uno strumento prettamente visivo , atto a schematizzare il flusso delle singole istruzioni di un algoritmo. In tal modo, diventa estremamente pi\u00f9 semplice scrivere l'algoritmo, e valutare come i dati cambiano all'interno dello stesso.","title":"5.1 - Cosa sono i diagrammi di flusso?"},{"location":"material/02_principles/05_flow_chart/lecture/#52-quali-sono-le-componenti-fondamentali","text":"Un diagramma di flusso pu\u00f2 avere al suo interno diverse componenti, le pi\u00f9 importanti delle quali sono visualizzate nella tabella successiva. In particolare: una ellisse indica l'inizio o la fine dell'algoritmo, ed andrebbe sempre apposta; un rettangolo indica una singola istruzione (o anche un gruppo di istruzioni) da eseguire nel programma; un parallelogramma indica un input o un output; un rombo indica una ramificazione nel percorso dell'algoritmo, legata prevalentemente alla verifica di una condizione; infine, le frecce sono usate per collegare tra loro diverse parti dello stesso algoritmo.","title":"5.2 - Quali sono le componenti fondamentali?"},{"location":"material/02_principles/05_flow_chart/lecture/#53-un-esempio","text":"Nella seguente figura mostriamo un esempio di diagramma di flusso. Vediamo come il diagramma inizi con un'ellisse, che sar\u00e0 contrassegnata dalla scritta START (inserita arbitrariamente). Immediatamente dopo, vi sar\u00e0 la lettura di due variabili, ovvero \\(c_1\\) e \\(c_2\\) ; a quel punto, vi sar\u00e0 l'assegnazione di altre tre variabili, con infine la variabile \\(v_3\\) scritta su un dispositivo di output, seguita dal simbolo di fine algoritmo. E' estremamente importante notare come l'assegnazione e la lettura siano, in realt\u00e0, quasi \"ambigue\" dal punto di vista della notazione: occorre quindi in tal senso fare attenzione al fatto che si stia usando un parallelogramma o un rettangolo, seguendo le regole descritte nel paragrafo 5.2.","title":"5.3 - Un esempio"},{"location":"material/02_principles/06_structured/lecture/","text":"6 - La Programmazione Strutturata \u00b6 Ai pi\u00f9 \"esperti\" tra i lettori sar\u00e0 capitato di leggere del codice prodotto negli anni '70 ed '80, in linguaggi come il BASIC, simile a qualcosa di questo tipo: 10 dim i 20 i = 0 30 i = i + 1 40 if i <= 10 then goto 70 50 print \"Programma terminato.\" 60 end 70 print i & \" al quadrato = \" & i * i 80 goto 30 Un codice in questa forma (per la cronaca: il codice \u00e8 tratto direttamente da Wikipedia ) \"intreccia\" le istruzioni tra loro: ad esempio, alla riga 80 notiamo come la presenza della (famigerata) istruzione goto imponga di tornare alla riga 30 , con la 70 richiamata dalla 40 qualora si verifichi una determinata condizione. Il codice appare quindi simile ad un \"piatto di spaghetti\", i quali si intrecciano ed ingarbugliano tra loro, confondendosi alla vista; ed \u00e8 proprio per questo che scrivere un codice com il precedente \u00e8 associato alla pratica, divenuta con tempo un antipattern (ovvero, una pratica da sconsigliare), dello spaghetti coding . Lo spaghetti coding rende il nostro programma difficile da interpretare, non solo da parte di altri, ma anche da noi stessi quando lo andiamo a riaprire dopo un po' di tempo. Per questo motivo, nel tempo, sono andati sempre pi\u00f9 diffondendosi nuovi e pi\u00f9 efficaci paradigmi di programmazione, come quella imperativa, orientata agli oggetti e, pi\u00f9 recentemente, funzionale. Tutti, per\u00f2, partivano da un presupposto: dare una struttura al codice. E, in tal senso, l'assunto da cui si parte \u00e8 sempre e solo uno, ovvero il teorema di Bohm e Jacopini . 6.2 - Il teorema di Bohm-Jacopini \u00b6 Il teorema di Bohm - Jacopini venne enunciato nel 1966, ed afferma che qualsiasi algoritmo pu\u00f2 essere implementato (sia sotto forma di codice, sia sotto forma di flow chart) utilizzando esclusivamente le cosiddette tre strutture di controllo , ovvero sequenza , selezione e ciclo . Le implicazioni sono ovviamente importantissime, e ci permettono di semplificare enormemente il nostro lavoro. In tal senso, per\u00f2, \u00e8 necessario conoscere in maniera appropriata le diverse strutture di controllo, che saranno quindi illustrate di seguito. 6.3.1 - Sequenza \u00b6 La sequenza prevede che una serie di istruzioni siano realizzate sequenzialmente, ovvero l'una in cascata all'altra. Immaginiamo ad esempio di dover calcolare la distanza euclidea tra due punti, ovvero a e b , di cui conosciamo le coordinate \\((x_a, y_a)\\) ed \\((x_b, y_b)\\) . In pseudo-codice (ovvero, in un linguaggio simbolico usato per esprimere l'algoritmo senza per questo richiamare necessariamente un linguaggio di programmazione esistente) potremmo esprimere la sequenza come: distanza_x = (x_a - x_b)^2; distanza_y = (y_a - y_b)^2; distanza = (distanza_x + distanza_y)^(1/2); La sequenza di operazioni sar\u00e0 quella mostrata nella seguente figura: Come si pu\u00f2 notare, il flusso delle istruzioni \u00e8 unico , e queste sono eseguite l'una di seguito all'altra, ovverosia in maniera sequenziale. 6.3.2 - Selezione \u00b6 La selezione prevede invece che il flusso delle istruzioni possa diramarsi tra due diversi rami, mutualmente esclusivi, al verificarsi o meno di una condizione. In particolare, la selezione \u00e8 rappresentata mediante il costrutto IF - THEN - ELSE , il cui funzionamento pu\u00f2 essere riassunto in linguaggio naturale come segue: Cite IF (se) la condizione \u00e8 verificata, THEN (allora) esegui le istruzioni su di un ramo, ELSE (altrimenti) esegui le istruzioni sull'altro ramo. Per comprendere meglio il funzionamento della selezione, immaginiamo di voler comparare due numeri \\(a\\) e \\(b\\) . Di nuovo, esprimiamo la selezione in pseudo-codice: a = 1; b = 2; if (a > b): then scrivi \"a \u00e8 maggiore di b\" else: scrivi \"b \u00e8 maggiore di a\" I due rami del programma sono quindi rappresentati dal THEN e dall'ELSE, mentre la condizione dall'IF. Graficamente: 6.3.2.1 - I costrutti ELSE IF e SWITCH \u00b6 Il costrutto IF - THEN - ELSE limita i rami in cui un programma pu\u00f2 derivare a due. Tuttavia, nella realt\u00e0, potrebbe essere necessario avere pi\u00f9 rami; in questi casi, ci viene in aiuto il costrutto ELSE IF, che permette di specificare ulteriori divergenze del programma. Ad esempio: a = 1; b = 2; if (a > b): then scrivi \"a \u00e8 maggiore di b\" else if (a uguale b): then scrivi \"a \u00e8 uguale a b\" else: scrivi \"b \u00e8 maggiore di a\" Vediamo subito come il costrutto ci permetta di ovviare ad una \"mancanza\" del programma precedente, gestendo anche il caso in cui \\(a\\) sia uguale a \\(b\\) . Dal punto di vista del diagramma di flusso, l'ELSE IF \u00e8 rappresentabile mediante una \"cascata\" di selezioni: Il costrutto SWITCH \u00e8 usato per verificare che una certa variabile assuma un dato valore, chiamato case (da cui il nome SWITCH-CASE con cui il costrutto \u00e8 anche conosciuto), normalmente non relativo ad un intervallo, quanto piuttosto ben specifico. Qualora la variabile di controllo rispetti il valore definito da un case, le istruzioni ivi contenute saranno eseguite fino all'uscita dal costrutto. Lo SWITCH ha inoltre un case di default, indicato con la parola chiave omonima, che sar\u00e0 eseguito qualora la variabile da verificare non rispetti alcuno dei case precedenti. Ad esempio: a = 1; switch (a) case 1: scrivi \"Uguale ad uno!\"; case 2: scrivi \"Uguale a due!\" case 3: scrivi \"Uguale a tre!\"; default: scrivi \"Non saprei!\"; 6.3.3 - Iterazione \u00b6 L'ultimo tipo di struttura di controllo \u00e8 l' iterazione , chiamata anche ciclo ; in questo caso, un'istruzione verr\u00e0 reiterata fino a che una certa condizione \u00e8 verificata. Nota In un certo senso, l'iterazione \u00e8 una \"summa\" di struttura e selezione. Per comprendere il funzionamento dell'iterazione, proviamo ad utilizzarla, sempre in pseudocodice, per scrivere i numeri che vanno da uno a dieci: i = 1; for (i che va da 1 a 10): scrivi 'i'; endfor scrivi 'fine'; Schematizziamo il funzionamento dell'iterazione nella figura successiva: Risulta particolarmente interessante notare come l'iterazione (espressa in questo caso da un'istruzione FOR) non faccia altro che verificare una condizione su una variabile contatore (ovvero che i sia minore od uguale a 10), modificando la stessa ad ogni iterazione. Una volta che la condizione sul contatore non sar\u00e0 pi\u00f9 verificata, il programma continuer\u00e0 la sua esecuzione. Nota Modificare la variabile contatore ad ogni iterazione \u00e8 estremamente importante . Se il contatore non fosse mai modificato, infatti, il programma non potrebbe mai uscire dal ciclo. 6.3.3.1 Costrutti FOR e WHILE-DO \u00b6 Tradizionalmente, sono usati due costrutti per implementare una struttura iterativa, ovvero il costrutto FOR (che abbiamo visto in precedenza) ed il costrutto WHILE-DO. La differenza principale tra i due costrutti sta nel fatto che il FOR viene normalmente usato quando il numero di iterazioni \u00e8 conosciuto a priori, mentre il WHILE-DO quando non si conosce il numero di iterazioni, e si vuole semplicemente verificare una condizione. Ad esempio: condizione = vero; while (condizione diverso da falso): do [...] // istruzioni aggiorna condizione; endwhile In pratica, il costrutto WHILE-DO verifica ad ogni iterazione che la condizione sia vera; se ci\u00f2 avviene, sono eseguite le istruzioni specificate nel DO, ed \u00e8 aggiornata la condizione (che, prima o dopo, non dovr\u00e0 essere pi\u00f9 verificata). L'importanza di aggiornare la condizione Nel WHILE-DO, l'importanza dell'aggiornamento della condizione \u00e8 ancora pi\u00f9 evidente rispetto al FOR, ed \u00e8 molto spesso delegata al programmatore. Ci\u00f2 comporta maggiore libert\u00e0 nell'aggiornamento della condizione, ma anche maggiori responsabilit\u00e0 (semi-cit.). Il costrutto DO-WHILE Esiste una variante del costrutto WHILE-DO chiamata DO-WHILE, nella quale le istruzioni specificate nel DO vengono effettuate prima della verifica della condizione. Non tutti i linguaggi di programmazione supportano tale costrutto; inoltre, con pochi accorgimenti, \u00e8 possibile usare indifferentemente il WHILE-DO ed il DO-WHILE. Tuttavia, occorre tener presente che il DO-WHILE sar\u00e0 eseguito almeno una volta, dato che la condizione \u00e8 verificata dopo l'esecuzione delle istruzioni, mentre il WHILE-DO potrebbe non essere mai eseguito, dato che la condizione \u00e8 verificata prima dell'esecuzione delle istruzioni. 6.4 - Esercizi \u00b6 Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto WHILE-DO. Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto SWITCH.","title":"6 - Programmazione strutturata"},{"location":"material/02_principles/06_structured/lecture/#6-la-programmazione-strutturata","text":"Ai pi\u00f9 \"esperti\" tra i lettori sar\u00e0 capitato di leggere del codice prodotto negli anni '70 ed '80, in linguaggi come il BASIC, simile a qualcosa di questo tipo: 10 dim i 20 i = 0 30 i = i + 1 40 if i <= 10 then goto 70 50 print \"Programma terminato.\" 60 end 70 print i & \" al quadrato = \" & i * i 80 goto 30 Un codice in questa forma (per la cronaca: il codice \u00e8 tratto direttamente da Wikipedia ) \"intreccia\" le istruzioni tra loro: ad esempio, alla riga 80 notiamo come la presenza della (famigerata) istruzione goto imponga di tornare alla riga 30 , con la 70 richiamata dalla 40 qualora si verifichi una determinata condizione. Il codice appare quindi simile ad un \"piatto di spaghetti\", i quali si intrecciano ed ingarbugliano tra loro, confondendosi alla vista; ed \u00e8 proprio per questo che scrivere un codice com il precedente \u00e8 associato alla pratica, divenuta con tempo un antipattern (ovvero, una pratica da sconsigliare), dello spaghetti coding . Lo spaghetti coding rende il nostro programma difficile da interpretare, non solo da parte di altri, ma anche da noi stessi quando lo andiamo a riaprire dopo un po' di tempo. Per questo motivo, nel tempo, sono andati sempre pi\u00f9 diffondendosi nuovi e pi\u00f9 efficaci paradigmi di programmazione, come quella imperativa, orientata agli oggetti e, pi\u00f9 recentemente, funzionale. Tutti, per\u00f2, partivano da un presupposto: dare una struttura al codice. E, in tal senso, l'assunto da cui si parte \u00e8 sempre e solo uno, ovvero il teorema di Bohm e Jacopini .","title":"6 - La Programmazione Strutturata"},{"location":"material/02_principles/06_structured/lecture/#62-il-teorema-di-bohm-jacopini","text":"Il teorema di Bohm - Jacopini venne enunciato nel 1966, ed afferma che qualsiasi algoritmo pu\u00f2 essere implementato (sia sotto forma di codice, sia sotto forma di flow chart) utilizzando esclusivamente le cosiddette tre strutture di controllo , ovvero sequenza , selezione e ciclo . Le implicazioni sono ovviamente importantissime, e ci permettono di semplificare enormemente il nostro lavoro. In tal senso, per\u00f2, \u00e8 necessario conoscere in maniera appropriata le diverse strutture di controllo, che saranno quindi illustrate di seguito.","title":"6.2 - Il teorema di Bohm-Jacopini"},{"location":"material/02_principles/06_structured/lecture/#631-sequenza","text":"La sequenza prevede che una serie di istruzioni siano realizzate sequenzialmente, ovvero l'una in cascata all'altra. Immaginiamo ad esempio di dover calcolare la distanza euclidea tra due punti, ovvero a e b , di cui conosciamo le coordinate \\((x_a, y_a)\\) ed \\((x_b, y_b)\\) . In pseudo-codice (ovvero, in un linguaggio simbolico usato per esprimere l'algoritmo senza per questo richiamare necessariamente un linguaggio di programmazione esistente) potremmo esprimere la sequenza come: distanza_x = (x_a - x_b)^2; distanza_y = (y_a - y_b)^2; distanza = (distanza_x + distanza_y)^(1/2); La sequenza di operazioni sar\u00e0 quella mostrata nella seguente figura: Come si pu\u00f2 notare, il flusso delle istruzioni \u00e8 unico , e queste sono eseguite l'una di seguito all'altra, ovverosia in maniera sequenziale.","title":"6.3.1 - Sequenza"},{"location":"material/02_principles/06_structured/lecture/#632-selezione","text":"La selezione prevede invece che il flusso delle istruzioni possa diramarsi tra due diversi rami, mutualmente esclusivi, al verificarsi o meno di una condizione. In particolare, la selezione \u00e8 rappresentata mediante il costrutto IF - THEN - ELSE , il cui funzionamento pu\u00f2 essere riassunto in linguaggio naturale come segue: Cite IF (se) la condizione \u00e8 verificata, THEN (allora) esegui le istruzioni su di un ramo, ELSE (altrimenti) esegui le istruzioni sull'altro ramo. Per comprendere meglio il funzionamento della selezione, immaginiamo di voler comparare due numeri \\(a\\) e \\(b\\) . Di nuovo, esprimiamo la selezione in pseudo-codice: a = 1; b = 2; if (a > b): then scrivi \"a \u00e8 maggiore di b\" else: scrivi \"b \u00e8 maggiore di a\" I due rami del programma sono quindi rappresentati dal THEN e dall'ELSE, mentre la condizione dall'IF. Graficamente:","title":"6.3.2 - Selezione"},{"location":"material/02_principles/06_structured/lecture/#6321-i-costrutti-else-if-e-switch","text":"Il costrutto IF - THEN - ELSE limita i rami in cui un programma pu\u00f2 derivare a due. Tuttavia, nella realt\u00e0, potrebbe essere necessario avere pi\u00f9 rami; in questi casi, ci viene in aiuto il costrutto ELSE IF, che permette di specificare ulteriori divergenze del programma. Ad esempio: a = 1; b = 2; if (a > b): then scrivi \"a \u00e8 maggiore di b\" else if (a uguale b): then scrivi \"a \u00e8 uguale a b\" else: scrivi \"b \u00e8 maggiore di a\" Vediamo subito come il costrutto ci permetta di ovviare ad una \"mancanza\" del programma precedente, gestendo anche il caso in cui \\(a\\) sia uguale a \\(b\\) . Dal punto di vista del diagramma di flusso, l'ELSE IF \u00e8 rappresentabile mediante una \"cascata\" di selezioni: Il costrutto SWITCH \u00e8 usato per verificare che una certa variabile assuma un dato valore, chiamato case (da cui il nome SWITCH-CASE con cui il costrutto \u00e8 anche conosciuto), normalmente non relativo ad un intervallo, quanto piuttosto ben specifico. Qualora la variabile di controllo rispetti il valore definito da un case, le istruzioni ivi contenute saranno eseguite fino all'uscita dal costrutto. Lo SWITCH ha inoltre un case di default, indicato con la parola chiave omonima, che sar\u00e0 eseguito qualora la variabile da verificare non rispetti alcuno dei case precedenti. Ad esempio: a = 1; switch (a) case 1: scrivi \"Uguale ad uno!\"; case 2: scrivi \"Uguale a due!\" case 3: scrivi \"Uguale a tre!\"; default: scrivi \"Non saprei!\";","title":"6.3.2.1 - I costrutti ELSE IF e SWITCH"},{"location":"material/02_principles/06_structured/lecture/#633-iterazione","text":"L'ultimo tipo di struttura di controllo \u00e8 l' iterazione , chiamata anche ciclo ; in questo caso, un'istruzione verr\u00e0 reiterata fino a che una certa condizione \u00e8 verificata. Nota In un certo senso, l'iterazione \u00e8 una \"summa\" di struttura e selezione. Per comprendere il funzionamento dell'iterazione, proviamo ad utilizzarla, sempre in pseudocodice, per scrivere i numeri che vanno da uno a dieci: i = 1; for (i che va da 1 a 10): scrivi 'i'; endfor scrivi 'fine'; Schematizziamo il funzionamento dell'iterazione nella figura successiva: Risulta particolarmente interessante notare come l'iterazione (espressa in questo caso da un'istruzione FOR) non faccia altro che verificare una condizione su una variabile contatore (ovvero che i sia minore od uguale a 10), modificando la stessa ad ogni iterazione. Una volta che la condizione sul contatore non sar\u00e0 pi\u00f9 verificata, il programma continuer\u00e0 la sua esecuzione. Nota Modificare la variabile contatore ad ogni iterazione \u00e8 estremamente importante . Se il contatore non fosse mai modificato, infatti, il programma non potrebbe mai uscire dal ciclo.","title":"6.3.3 - Iterazione"},{"location":"material/02_principles/06_structured/lecture/#6331-costrutti-for-e-while-do","text":"Tradizionalmente, sono usati due costrutti per implementare una struttura iterativa, ovvero il costrutto FOR (che abbiamo visto in precedenza) ed il costrutto WHILE-DO. La differenza principale tra i due costrutti sta nel fatto che il FOR viene normalmente usato quando il numero di iterazioni \u00e8 conosciuto a priori, mentre il WHILE-DO quando non si conosce il numero di iterazioni, e si vuole semplicemente verificare una condizione. Ad esempio: condizione = vero; while (condizione diverso da falso): do [...] // istruzioni aggiorna condizione; endwhile In pratica, il costrutto WHILE-DO verifica ad ogni iterazione che la condizione sia vera; se ci\u00f2 avviene, sono eseguite le istruzioni specificate nel DO, ed \u00e8 aggiornata la condizione (che, prima o dopo, non dovr\u00e0 essere pi\u00f9 verificata). L'importanza di aggiornare la condizione Nel WHILE-DO, l'importanza dell'aggiornamento della condizione \u00e8 ancora pi\u00f9 evidente rispetto al FOR, ed \u00e8 molto spesso delegata al programmatore. Ci\u00f2 comporta maggiore libert\u00e0 nell'aggiornamento della condizione, ma anche maggiori responsabilit\u00e0 (semi-cit.). Il costrutto DO-WHILE Esiste una variante del costrutto WHILE-DO chiamata DO-WHILE, nella quale le istruzioni specificate nel DO vengono effettuate prima della verifica della condizione. Non tutti i linguaggi di programmazione supportano tale costrutto; inoltre, con pochi accorgimenti, \u00e8 possibile usare indifferentemente il WHILE-DO ed il DO-WHILE. Tuttavia, occorre tener presente che il DO-WHILE sar\u00e0 eseguito almeno una volta, dato che la condizione \u00e8 verificata dopo l'esecuzione delle istruzioni, mentre il WHILE-DO potrebbe non essere mai eseguito, dato che la condizione \u00e8 verificata prima dell'esecuzione delle istruzioni.","title":"6.3.3.1 Costrutti FOR e WHILE-DO"},{"location":"material/02_principles/06_structured/lecture/#64-esercizi","text":"Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto WHILE-DO. Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto SWITCH.","title":"6.4 - Esercizi"},{"location":"material/02_principles/07_complexity/exercises/","text":"E7 - Esercizi sulla complessit\u00e0 computazionale \u00b6 Tracce \u00b6 Esercizio 1 \u00b6 Calcolare la complessit\u00e0 di caso peggiore di una sequenza di \\(m\\) istruzioni; si tenga a mente che se la complessit\u00e0 \u00e8 costante, allora si ha un \\(O{1}\\) . Esercizio 2 \u00b6 Calcolare la complessit\u00e0 di caso peggiore di un ciclo while . Esercizio 3 \u00b6 Calcolare la complessit\u00e0 di caso peggiore del seguente algoritmo: for i che va da 1 a 10: for j che va da 1 a 10: calcola i + j; endfor endfor Esercizio 4 \u00b6 Parte 1 \u00b6 Supponiamo di ricevere due prestiti. Il primo prestito, dell'importo totale di 1000 \u20ac, ci viene garantito dalla Banca di Paperopoli il 01/04/2022. Il secondo prestito, dell'importo di 100 \u20ac, ci viene garantito dalla Banca di Topolinia lo stesso giorno. Successivamente, apriamo un filone di credito presso la banca di Topolinia, e per i 99 giorni successivi al 01/04 riceviamo 100 \u20ac al giorno. Calcolare: il valore totale dei due prestiti al primo giorno e dopo 100 giorni; quanto incide (in percentuale) ciascun prestito sul totale al primo giorno; quanto incide (in percentuale) ciascun prestito sul totale al centesimo giorno. Spiegare questi concetti riconducendoli alle nozioni di complessit\u00e0 computazionale. Parte 2 \u00b6 Cosa accadrebbe se la Banca di Paperopoli ci facesse 100 bonifici al giorno per 100 giorni a partire dal primo aprile? Soluzioni \u00b6 Esercizio 1 \u00b6 Una sequenza di \\(m\\) istruzioni \u00e8 data da un diagramma di flusso simile a questo. Di conseguenza, dato che la complessit\u00e0 legata a ciascuna istruzione \u00e8 unitaria, la complessit\u00e0 di caso peggiore sar\u00e0 approssimabile ad un \\(O(1)\\) . Esercizio 2 \u00b6 Definiamo un ciclo while mediante un diagramma di flusso simile a questo, direttamente dall'esercizio 3 sulle strutture dati. In questo caso, il numero di operazioni non \u00e8 deterministico, ma dipende dalla funzione genera_magia , che abbiamo definito essere randomica. Supponendo che la funzione generi un numero superiore a 10 con probabilit\u00e0 pari a \\(\\frac{1}{n}\\) (ovvero, che la funzione generi un numero superiore a 10 una volta su n), allora avremo che la complessit\u00e0 di caso peggiore sar\u00e0 pari a \\(O(n)\\) : in altre parole, nel caso peggiore , ci attendiamo che ci servano \\(n\\) iterazioni per uscire dal ciclo. Esercizio 3 \u00b6 Partiamo dalla costruzione del diagramma di flusso dell'algoritmo, che \u00e8 quello riportato nella seguente figura. Notiamo subito la presenza di due cicli for annidati l'uno dentro l'altro. Entrambi i cicli prevedono dieci iterazioni ciascuno; tuttavia, il ciclo interno sar\u00e0 eseguito dieci volte per ciascuna iterazione del ciclo esterno. Di conseguenza, il numero totale di iterazioni sar\u00e0 dato dalla moltiplicazione delle iterazioni previste per il ciclo interno (ovvero dieci) per quelle previste per il ciclo esterno (sempre dieci), ovvero 100. Aumentando il numero \\(n\\) di iterazioni, vedremo come il numero totale di operazioni aumenter\u00e0 secondo una legge quadratica: per \\(n=11\\) , il numero di iterazioni sar\u00e0 pari a \\(11 \\cdot 11 = 121\\) ; per \\(n=12\\) , il numero di iterazioni sar\u00e0 pari a \\(12 \\cdot 12 = 144\\) ; per \\(n=13\\) , il numero di iterazioni sar\u00e0 pari a \\(13 \\cdot 13 = 169\\) ; e cos\u00ec via. Di conseguenza, la complessit\u00e0 computazionale dipende dal quadrato di \\(n\\) , per cui quella di caso peggiore \u00e8 un \\(O(n^2)\\) . Esercizio 4 \u00b6 Parte 1 \u00b6 Al primo aprile, la nostra situazione finanziaria sar\u00e0 la seguente: \\[ P_{p_1} = 100 \u20ac \\\\ P_{t_1} = 100 \u20ac \\] con \\(P_{p_1}\\) prestito ricevuto al primo aprile dalla Banca di Paperopoli, e \\(P_{t_1}\\) prestito ricevuto al primo aprile dalla Banca di Topolinia. Le percentuali del prestito relativo alle due banche, rispettivamente \\(P_{p_1}(\\%)\\) e \\(P_{t_1}(\\%)\\) , saranno del \\(50(\\%)\\) ciascuna, dato che i prestiti incidono egualmente sull'intera cifra a debito. Vediamo cosa accade al 10 luglio, ovvero 100 giorni dopo. La cifra che dovremo alla Banca di Paperopoli sar\u00e0 sempre di 100 \u20ac, per cui \\(P_{p_{100}} = P_{p_1} = 100 \u20ac\\) . Per quello che riguarda la Banca di Topolinia, invece: \\[ P_{t_{100}} = P_{t_1} + g * p_g = 100 \u20ac + 99 * 100 \u20ac = 10.000 \u20ac \\] dove \\(g\\) \u00e8 il numero di giorni (escluso il primo) in cui riceviamo un prestito di valore \\(p_g\\) . A questo punto, il totale a debito \u00e8 dato da: \\[ P_{TOT} = P_{p_{100}} + P_{t_{100}} = 100 \u20ac + 10.000 \u20ac = 10.100 \u20ac \\] Calcoliamo le percentuali dovute (rispetto al totale) alle due banche: \\[ P_{p_{100}}(\\%) = \\frac{P_{p_{100}}}{P_{TOT}} \\cdot 100 = \\frac{100}{10.100} \\cdot 100 \\sim 0.0099 \\cdot 100 \\sim 1 (\\%) \\] per cui: \\[ P_{t_{100}}(\\%) = 100 - P_{p_{100}}(\\%) \\sim 99 (\\%) \\] Ovviamente, questo si pu\u00f2 rappresentare con uno pseudocodice del tipo: tot_paperopoli = 100; tot_topolinia = 100; for giorno da 1 a 99: tot_topolinia = tot_topolinia + 100; endfor Di conseguenza, \u00e8 possibile valutare empiricamente come il \"peso\" del for , che comporta una complessit\u00e0 pari ad \\(O(n)\\) , incida maggiormente sull'operazione lineare, che ha una complessit\u00e0 pari ad \\(O(1)\\) . Parte 2 \u00b6 Con la nuova modalit\u00e0 di finanziamento da parte della banca di Paperopoli, i valori mostrati in precedenza per questa cambiano come segue. \\[ P_{p_1} = n_b * p_g = 100 \\cdot 100 \u20ac = 10.000 \u20ac \\] con \\(n_b\\) numero di bonifici al giorno, ed \\(p_g\\) importo del singolo bonifico. Di conseguenza, al primo giorno avremo una situazione di questo tipo: \\[ P_{p_1} = 10.000 \u20ac \\\\ P_{t_1} = 100 \u20ac \\] Le percentuali cambiano come segue: \\[ P_{p_1}(\\%) \\sim 99 (\\%) \\\\ P_{t_1}(\\%) \\sim 1 (\\%) \\] Al centesimo giorno: \\[ P_{p_{100}} = n_b \\cdot p_g \\cdot g = 100 \\cdot 100 \u20ac \\cdot 100 = 1.000.000 \u20ac \\] Tenendo conto che P {t } \u00e8 costante, avremo che le nuove percentuali saranno pari a \\(P_{p_{100}}(\\%) \\sim 99 (\\%)\\) , e di conseguenza \\(P_{t_{100}}(\\%) \\sim 1 (\\%)\\) . Tutto ci\u00f2 \u00e8 correlato al fatto che il contributo della Banca di Paperopoli \u00e8 assimilabile a due cicli for annidati: n = 100; for giorno da 1 a n: for bonifico da 1 a n: tot_paperopoli = tot_paperopoli + 100; endfor endfor Provando ad aumentare il valore \\(n\\) , portandolo magari a 200, \u00e8 facile constatare come le percentuali si spostino sempre pi\u00f9 verso \\(P_{p_{200}}(\\%)\\) : \\[ \\begin{align*} &\\begin{cases} P_{p_{200}} = 200 \\cdot 200 \\cdot 100 = 4.000.000 \u20ac \\\\ P_{t_{200}} = 200 \\cdot 100 = 20.000 \u20ac \\end{cases} \\Rightarrow \\\\ &\\Rightarrow \\begin{cases} P_{p_{200}}(\\%) = \\frac{4.000.000}{4.020.000} \\cdot 100 \\sim 99.5 (\\%) \\\\ P_{t_{200}} \\sim 0.5 (\\%) \\end{cases} \\end{align*} \\]","title":"E7 - Complessit\u00e0 computazionale"},{"location":"material/02_principles/07_complexity/exercises/#e7-esercizi-sulla-complessita-computazionale","text":"","title":"E7 - Esercizi sulla complessit\u00e0 computazionale"},{"location":"material/02_principles/07_complexity/exercises/#tracce","text":"","title":"Tracce"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-1","text":"Calcolare la complessit\u00e0 di caso peggiore di una sequenza di \\(m\\) istruzioni; si tenga a mente che se la complessit\u00e0 \u00e8 costante, allora si ha un \\(O{1}\\) .","title":"Esercizio 1"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-2","text":"Calcolare la complessit\u00e0 di caso peggiore di un ciclo while .","title":"Esercizio 2"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-3","text":"Calcolare la complessit\u00e0 di caso peggiore del seguente algoritmo: for i che va da 1 a 10: for j che va da 1 a 10: calcola i + j; endfor endfor","title":"Esercizio 3"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-4","text":"","title":"Esercizio 4"},{"location":"material/02_principles/07_complexity/exercises/#parte-1","text":"Supponiamo di ricevere due prestiti. Il primo prestito, dell'importo totale di 1000 \u20ac, ci viene garantito dalla Banca di Paperopoli il 01/04/2022. Il secondo prestito, dell'importo di 100 \u20ac, ci viene garantito dalla Banca di Topolinia lo stesso giorno. Successivamente, apriamo un filone di credito presso la banca di Topolinia, e per i 99 giorni successivi al 01/04 riceviamo 100 \u20ac al giorno. Calcolare: il valore totale dei due prestiti al primo giorno e dopo 100 giorni; quanto incide (in percentuale) ciascun prestito sul totale al primo giorno; quanto incide (in percentuale) ciascun prestito sul totale al centesimo giorno. Spiegare questi concetti riconducendoli alle nozioni di complessit\u00e0 computazionale.","title":"Parte 1"},{"location":"material/02_principles/07_complexity/exercises/#parte-2","text":"Cosa accadrebbe se la Banca di Paperopoli ci facesse 100 bonifici al giorno per 100 giorni a partire dal primo aprile?","title":"Parte 2"},{"location":"material/02_principles/07_complexity/exercises/#soluzioni","text":"","title":"Soluzioni"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-1_1","text":"Una sequenza di \\(m\\) istruzioni \u00e8 data da un diagramma di flusso simile a questo. Di conseguenza, dato che la complessit\u00e0 legata a ciascuna istruzione \u00e8 unitaria, la complessit\u00e0 di caso peggiore sar\u00e0 approssimabile ad un \\(O(1)\\) .","title":"Esercizio 1"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-2_1","text":"Definiamo un ciclo while mediante un diagramma di flusso simile a questo, direttamente dall'esercizio 3 sulle strutture dati. In questo caso, il numero di operazioni non \u00e8 deterministico, ma dipende dalla funzione genera_magia , che abbiamo definito essere randomica. Supponendo che la funzione generi un numero superiore a 10 con probabilit\u00e0 pari a \\(\\frac{1}{n}\\) (ovvero, che la funzione generi un numero superiore a 10 una volta su n), allora avremo che la complessit\u00e0 di caso peggiore sar\u00e0 pari a \\(O(n)\\) : in altre parole, nel caso peggiore , ci attendiamo che ci servano \\(n\\) iterazioni per uscire dal ciclo.","title":"Esercizio 2"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-3_1","text":"Partiamo dalla costruzione del diagramma di flusso dell'algoritmo, che \u00e8 quello riportato nella seguente figura. Notiamo subito la presenza di due cicli for annidati l'uno dentro l'altro. Entrambi i cicli prevedono dieci iterazioni ciascuno; tuttavia, il ciclo interno sar\u00e0 eseguito dieci volte per ciascuna iterazione del ciclo esterno. Di conseguenza, il numero totale di iterazioni sar\u00e0 dato dalla moltiplicazione delle iterazioni previste per il ciclo interno (ovvero dieci) per quelle previste per il ciclo esterno (sempre dieci), ovvero 100. Aumentando il numero \\(n\\) di iterazioni, vedremo come il numero totale di operazioni aumenter\u00e0 secondo una legge quadratica: per \\(n=11\\) , il numero di iterazioni sar\u00e0 pari a \\(11 \\cdot 11 = 121\\) ; per \\(n=12\\) , il numero di iterazioni sar\u00e0 pari a \\(12 \\cdot 12 = 144\\) ; per \\(n=13\\) , il numero di iterazioni sar\u00e0 pari a \\(13 \\cdot 13 = 169\\) ; e cos\u00ec via. Di conseguenza, la complessit\u00e0 computazionale dipende dal quadrato di \\(n\\) , per cui quella di caso peggiore \u00e8 un \\(O(n^2)\\) .","title":"Esercizio 3"},{"location":"material/02_principles/07_complexity/exercises/#esercizio-4_1","text":"","title":"Esercizio 4"},{"location":"material/02_principles/07_complexity/exercises/#parte-1_1","text":"Al primo aprile, la nostra situazione finanziaria sar\u00e0 la seguente: \\[ P_{p_1} = 100 \u20ac \\\\ P_{t_1} = 100 \u20ac \\] con \\(P_{p_1}\\) prestito ricevuto al primo aprile dalla Banca di Paperopoli, e \\(P_{t_1}\\) prestito ricevuto al primo aprile dalla Banca di Topolinia. Le percentuali del prestito relativo alle due banche, rispettivamente \\(P_{p_1}(\\%)\\) e \\(P_{t_1}(\\%)\\) , saranno del \\(50(\\%)\\) ciascuna, dato che i prestiti incidono egualmente sull'intera cifra a debito. Vediamo cosa accade al 10 luglio, ovvero 100 giorni dopo. La cifra che dovremo alla Banca di Paperopoli sar\u00e0 sempre di 100 \u20ac, per cui \\(P_{p_{100}} = P_{p_1} = 100 \u20ac\\) . Per quello che riguarda la Banca di Topolinia, invece: \\[ P_{t_{100}} = P_{t_1} + g * p_g = 100 \u20ac + 99 * 100 \u20ac = 10.000 \u20ac \\] dove \\(g\\) \u00e8 il numero di giorni (escluso il primo) in cui riceviamo un prestito di valore \\(p_g\\) . A questo punto, il totale a debito \u00e8 dato da: \\[ P_{TOT} = P_{p_{100}} + P_{t_{100}} = 100 \u20ac + 10.000 \u20ac = 10.100 \u20ac \\] Calcoliamo le percentuali dovute (rispetto al totale) alle due banche: \\[ P_{p_{100}}(\\%) = \\frac{P_{p_{100}}}{P_{TOT}} \\cdot 100 = \\frac{100}{10.100} \\cdot 100 \\sim 0.0099 \\cdot 100 \\sim 1 (\\%) \\] per cui: \\[ P_{t_{100}}(\\%) = 100 - P_{p_{100}}(\\%) \\sim 99 (\\%) \\] Ovviamente, questo si pu\u00f2 rappresentare con uno pseudocodice del tipo: tot_paperopoli = 100; tot_topolinia = 100; for giorno da 1 a 99: tot_topolinia = tot_topolinia + 100; endfor Di conseguenza, \u00e8 possibile valutare empiricamente come il \"peso\" del for , che comporta una complessit\u00e0 pari ad \\(O(n)\\) , incida maggiormente sull'operazione lineare, che ha una complessit\u00e0 pari ad \\(O(1)\\) .","title":"Parte 1"},{"location":"material/02_principles/07_complexity/exercises/#parte-2_1","text":"Con la nuova modalit\u00e0 di finanziamento da parte della banca di Paperopoli, i valori mostrati in precedenza per questa cambiano come segue. \\[ P_{p_1} = n_b * p_g = 100 \\cdot 100 \u20ac = 10.000 \u20ac \\] con \\(n_b\\) numero di bonifici al giorno, ed \\(p_g\\) importo del singolo bonifico. Di conseguenza, al primo giorno avremo una situazione di questo tipo: \\[ P_{p_1} = 10.000 \u20ac \\\\ P_{t_1} = 100 \u20ac \\] Le percentuali cambiano come segue: \\[ P_{p_1}(\\%) \\sim 99 (\\%) \\\\ P_{t_1}(\\%) \\sim 1 (\\%) \\] Al centesimo giorno: \\[ P_{p_{100}} = n_b \\cdot p_g \\cdot g = 100 \\cdot 100 \u20ac \\cdot 100 = 1.000.000 \u20ac \\] Tenendo conto che P {t } \u00e8 costante, avremo che le nuove percentuali saranno pari a \\(P_{p_{100}}(\\%) \\sim 99 (\\%)\\) , e di conseguenza \\(P_{t_{100}}(\\%) \\sim 1 (\\%)\\) . Tutto ci\u00f2 \u00e8 correlato al fatto che il contributo della Banca di Paperopoli \u00e8 assimilabile a due cicli for annidati: n = 100; for giorno da 1 a n: for bonifico da 1 a n: tot_paperopoli = tot_paperopoli + 100; endfor endfor Provando ad aumentare il valore \\(n\\) , portandolo magari a 200, \u00e8 facile constatare come le percentuali si spostino sempre pi\u00f9 verso \\(P_{p_{200}}(\\%)\\) : \\[ \\begin{align*} &\\begin{cases} P_{p_{200}} = 200 \\cdot 200 \\cdot 100 = 4.000.000 \u20ac \\\\ P_{t_{200}} = 200 \\cdot 100 = 20.000 \u20ac \\end{cases} \\Rightarrow \\\\ &\\Rightarrow \\begin{cases} P_{p_{200}}(\\%) = \\frac{4.000.000}{4.020.000} \\cdot 100 \\sim 99.5 (\\%) \\\\ P_{t_{200}} \\sim 0.5 (\\%) \\end{cases} \\end{align*} \\]","title":"Parte 2"},{"location":"material/02_principles/07_complexity/lecture/","text":"7 - La complessit\u00e0 computazionale degli algoritmi \u00b6 Il concetto di complessit\u00e0 computazionale di un algoritmo \u00e8 direttamente correlato al numero di operazioni che occorre svolgere per portarlo a termine, oppure ancora alla quantit\u00e0 di memoria occupata nel sistema durante l'esecuzione dello stesso. In particolare, avremo due tipi di complessit\u00e0: la complessit\u00e0 temporale pu\u00f2 essere determinata a partire dal numero di operazioni effettuate dall'algoritmo; la complessit\u00e0 spaziale \u00e8 legata allo spazio massimo richiesto dall'algoritmo in fase di esecuzione nella memoria del calcolatore. Torneremo pi\u00f9 avanti su questi aspetti; per adesso, limitiamoci a fare un breve esempio a titolo meramente illustrativo. 7.1 - Un primo, rapido, esempio \u00b6 Facciamo un rapido esempio introduttivo (nel prosieguo, formalizzeremo al meglio i concetti espressi). Immaginiamo di dover calcolare la distanza euclidea tra due numeri, cos\u00ec come abbiamo visto nella lezione precedente; per comodit\u00e0, riportiamo di seguito lo stesso pseudo-codice: distanza_x = (x_a - x_b)^2; distanza_y = (y_a - y_b)^2; distanza = (distanza_x + distanza_y)^(1/2); La complessit\u00e0 computazionale va valutata a partire dalle operazioni atomiche . Nel caso precedente, notiamo subito che alcune operazioni sono raggruppate, per cui \u00e8 il caso di \"esplodere\" l'algoritmo per quanto possibile. differenza_x = x_a - x_b distanza_x = (differenza_x)^2; differenza_y = y_a - y_b distanza_y = (differenza_y)^2; distanza_quad = distanza_x + distanza_y distanza = (distanza_quad)^(1/2); Nota Per semplicit\u00e0, non teniamo conto dei singoli passaggi che un calcolatore potrebbe impiegare nell'effettuare un'elevazione a potenza, ma consideriamo la stessa un'operazione unitaria. Avremo quindi un totale di \\(N=6\\) operazioni; supponendo che ognuna di queste richieda esattamente un ciclo del nostro processore, e che questo effettui un ciclo al secondo, la complessit\u00e0 computazionale temporale sar\u00e0 proprio pari a 6. Per quello che riguarda la complessit\u00e0 computazionale spaziale, invece, dovremo contare il numero \\(K\\) di variabili create (e, di conseguenza, memorizzate) durante l'esecuzione dell'algoritmo, oltre che il numero \\(b\\) di bit con cui ciascuna variabile \u00e8 rappresentata (per semplicit\u00e0, riterremo costante questo valore). In particolare, notiamo che vengono create 6 variabili, a cui sono da aggiungere gli input x_a ed x_b ; supponendo che \\(b\\) sia pari ad 8 bit, avremo: \\[ K = 6 + 2 = 8, b = 8 \\Rightarrow \\\\ \\Rightarrow C_s = K \\cdot b = 8 \\cdot 8 = 64 \\] La complessit\u00e0 computazionale spaziale sar\u00e0 quindi pari a 64 bit. Importantissimo comunque sottolineare come questo esempio sia puramente introduttivo . Nel seguito, forniremo una definizione formale di complessit\u00e0 spaziale e temporale; per adesso, concentriamoci brevemente su due tipi di analisi che \u00e8 possibile effettuare, ovvero quelle a priori ed a posteriori . 7.2 - Tipi di analisi computazionale \u00b6 7.2.1 - Analisi a priori \u00b6 L' analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato e la quantit\u00e0 di memoria disponibile siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso. 7.2.2 - Analisi a posteriori \u00b6 L' analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata. Importanza del contesto Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore. E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti. Vediamo adesso come \u00e8 possibile formalizzare i due diversi tipi di analisi computazionale per la complessit\u00e0 spaziale e per quella temporale. 7.3 - Complessit\u00e0 spaziale e temporale \u00b6 7.3.1 - Complessit\u00e0 spaziale \u00b6 La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria durante la sua esecuzione. Formalmente, questo \u00e8 pari alla somma di due componenti: una parte fissa , pari allo spazio richiesto per la memorizzazione di dati che non variano (in pratica, funzioni e costanti, che saranno trattati nel seguito); una parte variabile , data dallo spazio richiesto per la memorizzazione delle variabili. Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(C_s(X)\\) di un algoritmo \\(X\\) come: \\[ C_s(X) = C_{S_F}(C) + C_{S_V}(C) \\] con \\(C_{S_F}\\) parte fissa e \\(C_{S_V}\\) parte variabile; entrambe possono essere influenzate dalle caratteristiche \\(C\\) come linguaggio di programmazione ed hardware sottostante. 7.3.1.1 - Un esempio pi\u00f9 strutturato - Parte 1 \u00b6 Consideriamo il seguente algoritmo (in pseudocodice): leggi p, q r = p + q + 1 scrivi r Partiamo dall'analisi a priori. Vediamo subito come questo algoritmo consti di tre variabili, ovvero p e q (variabili di input) ed r (variabile di output). Abbiamo inoltre una costante (il valore 1 ). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a: \\[ C_S(X) = C_{S_F} + C_{S_V} = 1 + 3 \\] Notiamo che abbiamo omesso le caratteristiche \\(C\\) , in quanto, come gi\u00e0 detto, non ne teniamo conto nell'analisi a priori. Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria. Per quello che riguarda l'analisi a posteriori, immaginiamo che il tipo di dato associato a ciascuna variabile sia un intero ad 8 bit. La complessit\u00e0 analizzata a posteriori sar\u00e0: \\[ b = 8 bit \\Rightarrow \\\\ \\Rightarrow C_S(X) = C_{S_F}(C) + C_{S_V}(C) = (1 + 3) \\cdot 8 = 32 bit \\] 7.3.2 - Complessit\u00e0 temporale \u00b6 Abbiamo gi\u00e0 visto come la complessit\u00e0 temporale di un algoritmo risulti essere associata alla quantit\u00e0 di tempo richiesto ad una completa esecuzione dello stesso. Anche questa complessit\u00e0 pu\u00f2 essere espressa da una funzione numerica del tipo: \\[ C_T = \\sum_{i=1}^n t_i(C) \\] con \\(t_i\\) tempo necessario all'esecuzione di uno step atomico dell'algoritmo, e \\(C\\) dipendendente anche stavolta dalle caratteristiche hardware del nostro dispositivo. 7.3.1.2 Un esempio pi\u00f9 strutturato - Parte 2 \u00b6 Torniamo all'algoritmo precedente, ed effettuiamone una valutazione a priori. Abbiamo elencato tre step, anche se, nei fatti, ci saranno soltanto due addizioni della cui esecuzione dovremo tenere conto. Di conseguenza, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(C_T = 2\\) . Per quello che riguarda l'analisi a posteriori, invece, sar\u00e0 necessario anche stavolta fissare una condizione al contorno, ovvero la velocit\u00e0 con cui il nostro processore riesce ad eseguire una singola istruzione. Supponendo che questa sia pari ad un microsecondo, l'analisi a posteriori ci porter\u00e0 a stabilire che la complessit\u00e0 computazionale sar\u00e0 pari a 2 microsecondi. 7.4 - Complessit\u00e0 di caso peggiore \u00b6 Nelle applicazioni reali, \u00e8 abbastanza difficile che si riesca a calcolare esattamente la complessit\u00e0 computazionale di un programma, in quanto il numero di ramificazioni e le variabili da tenere in considerazione sono tali da rendere un approccio deterministico realisticamente non percorribile. Di conseguenza, si ricorre ad approcci che ci permettano di avere un'idea veritiera della complessit\u00e0 dell'algoritmo, stimata assumendo la casistica peggiore , ovvero calcolando la quantit\u00e0 massima di tempo e memoria che, nel peggiore dei casi, il nostro algoritmo richieder\u00e0 per essere eseguito. Per far questo, si utilizza la cosiddetta O-big notation , che in matematica ci permette di descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. In parole povere, un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(C_T(n) = \\mathbb{O}(n^2)\\) richieder\u00e0 un tempo di esecuzione pari al massimo ad \\(n^2\\) , mentre un algoritmo con una complessit\u00e0 \\(C_S(n) = O(n * log(n))\\) occuper\u00e0 al massimo \\(n*log(n)\\) unit\u00e0 di memoria. Nota Nella notazione precedente, n indica una variabile che pu\u00f2 influenzare il numero di operazioni eseguite dall'algoritmo. Il perch\u00e9 occorra specificarla sar\u00e0 pi\u00f9 chiaro grazie ai prossimi esempi. 7.4.1 Alcuni esempi \u00b6 7.4.1.1 Ciclo for (semplice) \u00b6 Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo for : n = 10; for i da 1 a n: scrivi i; incrementa i; endfor Notiamo innanzitutto che il valore del contatore i varia da 1 ad \\(n=10\\) . Ci\u00f2 significa che, al pi\u00f9 , saranno eseguite \\(n-1\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale (nel tempo) sar\u00e0 nell'ordine di \\(O(n)\\) . Per quello che riguarda quella nello spazio, supponendo che ad ogni iterazione le variabili create all'interno del corpo del ciclo (righe 3-4) siano anche cancellate, l'algoritmo avr\u00e0 una complessit\u00e0 spaziale di caso peggiore pari a 2; in questi casi, ovvero quando la complessit\u00e0 di caso peggiore \u00e8 costante, si dice che \\(C_S = O(1)\\) 7.4.1.2 Cicli for annidati \u00b6 Vediamo cosa accade nel caso si considerino due cicli for l'uno annidato all'interno dell'altro. n = 10; for i da 1 a n: for j da 1 a n: scrivi i; scrivi j; endfor endfor Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile i ) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile j ). La complessit\u00e0 temporale di caso peggiore sar\u00e0 quindi \\(O(n^2)\\) ; per quello che riguarda invece la complessit\u00e0 spaziale, invece, assumendo un meccanismo analogo al precedente, avremo sempre \\(O(1)\\) .V","title":"7 - Complessit\u00e0 computazionale"},{"location":"material/02_principles/07_complexity/lecture/#7-la-complessita-computazionale-degli-algoritmi","text":"Il concetto di complessit\u00e0 computazionale di un algoritmo \u00e8 direttamente correlato al numero di operazioni che occorre svolgere per portarlo a termine, oppure ancora alla quantit\u00e0 di memoria occupata nel sistema durante l'esecuzione dello stesso. In particolare, avremo due tipi di complessit\u00e0: la complessit\u00e0 temporale pu\u00f2 essere determinata a partire dal numero di operazioni effettuate dall'algoritmo; la complessit\u00e0 spaziale \u00e8 legata allo spazio massimo richiesto dall'algoritmo in fase di esecuzione nella memoria del calcolatore. Torneremo pi\u00f9 avanti su questi aspetti; per adesso, limitiamoci a fare un breve esempio a titolo meramente illustrativo.","title":"7 - La complessit\u00e0 computazionale degli algoritmi"},{"location":"material/02_principles/07_complexity/lecture/#71-un-primo-rapido-esempio","text":"Facciamo un rapido esempio introduttivo (nel prosieguo, formalizzeremo al meglio i concetti espressi). Immaginiamo di dover calcolare la distanza euclidea tra due numeri, cos\u00ec come abbiamo visto nella lezione precedente; per comodit\u00e0, riportiamo di seguito lo stesso pseudo-codice: distanza_x = (x_a - x_b)^2; distanza_y = (y_a - y_b)^2; distanza = (distanza_x + distanza_y)^(1/2); La complessit\u00e0 computazionale va valutata a partire dalle operazioni atomiche . Nel caso precedente, notiamo subito che alcune operazioni sono raggruppate, per cui \u00e8 il caso di \"esplodere\" l'algoritmo per quanto possibile. differenza_x = x_a - x_b distanza_x = (differenza_x)^2; differenza_y = y_a - y_b distanza_y = (differenza_y)^2; distanza_quad = distanza_x + distanza_y distanza = (distanza_quad)^(1/2); Nota Per semplicit\u00e0, non teniamo conto dei singoli passaggi che un calcolatore potrebbe impiegare nell'effettuare un'elevazione a potenza, ma consideriamo la stessa un'operazione unitaria. Avremo quindi un totale di \\(N=6\\) operazioni; supponendo che ognuna di queste richieda esattamente un ciclo del nostro processore, e che questo effettui un ciclo al secondo, la complessit\u00e0 computazionale temporale sar\u00e0 proprio pari a 6. Per quello che riguarda la complessit\u00e0 computazionale spaziale, invece, dovremo contare il numero \\(K\\) di variabili create (e, di conseguenza, memorizzate) durante l'esecuzione dell'algoritmo, oltre che il numero \\(b\\) di bit con cui ciascuna variabile \u00e8 rappresentata (per semplicit\u00e0, riterremo costante questo valore). In particolare, notiamo che vengono create 6 variabili, a cui sono da aggiungere gli input x_a ed x_b ; supponendo che \\(b\\) sia pari ad 8 bit, avremo: \\[ K = 6 + 2 = 8, b = 8 \\Rightarrow \\\\ \\Rightarrow C_s = K \\cdot b = 8 \\cdot 8 = 64 \\] La complessit\u00e0 computazionale spaziale sar\u00e0 quindi pari a 64 bit. Importantissimo comunque sottolineare come questo esempio sia puramente introduttivo . Nel seguito, forniremo una definizione formale di complessit\u00e0 spaziale e temporale; per adesso, concentriamoci brevemente su due tipi di analisi che \u00e8 possibile effettuare, ovvero quelle a priori ed a posteriori .","title":"7.1 - Un primo, rapido, esempio"},{"location":"material/02_principles/07_complexity/lecture/#72-tipi-di-analisi-computazionale","text":"","title":"7.2 - Tipi di analisi computazionale"},{"location":"material/02_principles/07_complexity/lecture/#721-analisi-a-priori","text":"L' analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato e la quantit\u00e0 di memoria disponibile siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso.","title":"7.2.1 - Analisi a priori"},{"location":"material/02_principles/07_complexity/lecture/#722-analisi-a-posteriori","text":"L' analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata. Importanza del contesto Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore. E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti. Vediamo adesso come \u00e8 possibile formalizzare i due diversi tipi di analisi computazionale per la complessit\u00e0 spaziale e per quella temporale.","title":"7.2.2 - Analisi a posteriori"},{"location":"material/02_principles/07_complexity/lecture/#73-complessita-spaziale-e-temporale","text":"","title":"7.3 - Complessit\u00e0 spaziale e temporale"},{"location":"material/02_principles/07_complexity/lecture/#731-complessita-spaziale","text":"La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria durante la sua esecuzione. Formalmente, questo \u00e8 pari alla somma di due componenti: una parte fissa , pari allo spazio richiesto per la memorizzazione di dati che non variano (in pratica, funzioni e costanti, che saranno trattati nel seguito); una parte variabile , data dallo spazio richiesto per la memorizzazione delle variabili. Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(C_s(X)\\) di un algoritmo \\(X\\) come: \\[ C_s(X) = C_{S_F}(C) + C_{S_V}(C) \\] con \\(C_{S_F}\\) parte fissa e \\(C_{S_V}\\) parte variabile; entrambe possono essere influenzate dalle caratteristiche \\(C\\) come linguaggio di programmazione ed hardware sottostante.","title":"7.3.1 - Complessit\u00e0 spaziale"},{"location":"material/02_principles/07_complexity/lecture/#7311-un-esempio-piu-strutturato-parte-1","text":"Consideriamo il seguente algoritmo (in pseudocodice): leggi p, q r = p + q + 1 scrivi r Partiamo dall'analisi a priori. Vediamo subito come questo algoritmo consti di tre variabili, ovvero p e q (variabili di input) ed r (variabile di output). Abbiamo inoltre una costante (il valore 1 ). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a: \\[ C_S(X) = C_{S_F} + C_{S_V} = 1 + 3 \\] Notiamo che abbiamo omesso le caratteristiche \\(C\\) , in quanto, come gi\u00e0 detto, non ne teniamo conto nell'analisi a priori. Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria. Per quello che riguarda l'analisi a posteriori, immaginiamo che il tipo di dato associato a ciascuna variabile sia un intero ad 8 bit. La complessit\u00e0 analizzata a posteriori sar\u00e0: \\[ b = 8 bit \\Rightarrow \\\\ \\Rightarrow C_S(X) = C_{S_F}(C) + C_{S_V}(C) = (1 + 3) \\cdot 8 = 32 bit \\]","title":"7.3.1.1 - Un esempio pi\u00f9 strutturato - Parte 1"},{"location":"material/02_principles/07_complexity/lecture/#732-complessita-temporale","text":"Abbiamo gi\u00e0 visto come la complessit\u00e0 temporale di un algoritmo risulti essere associata alla quantit\u00e0 di tempo richiesto ad una completa esecuzione dello stesso. Anche questa complessit\u00e0 pu\u00f2 essere espressa da una funzione numerica del tipo: \\[ C_T = \\sum_{i=1}^n t_i(C) \\] con \\(t_i\\) tempo necessario all'esecuzione di uno step atomico dell'algoritmo, e \\(C\\) dipendendente anche stavolta dalle caratteristiche hardware del nostro dispositivo.","title":"7.3.2 - Complessit\u00e0 temporale"},{"location":"material/02_principles/07_complexity/lecture/#7312-un-esempio-piu-strutturato-parte-2","text":"Torniamo all'algoritmo precedente, ed effettuiamone una valutazione a priori. Abbiamo elencato tre step, anche se, nei fatti, ci saranno soltanto due addizioni della cui esecuzione dovremo tenere conto. Di conseguenza, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(C_T = 2\\) . Per quello che riguarda l'analisi a posteriori, invece, sar\u00e0 necessario anche stavolta fissare una condizione al contorno, ovvero la velocit\u00e0 con cui il nostro processore riesce ad eseguire una singola istruzione. Supponendo che questa sia pari ad un microsecondo, l'analisi a posteriori ci porter\u00e0 a stabilire che la complessit\u00e0 computazionale sar\u00e0 pari a 2 microsecondi.","title":"7.3.1.2 Un esempio pi\u00f9 strutturato - Parte 2"},{"location":"material/02_principles/07_complexity/lecture/#74-complessita-di-caso-peggiore","text":"Nelle applicazioni reali, \u00e8 abbastanza difficile che si riesca a calcolare esattamente la complessit\u00e0 computazionale di un programma, in quanto il numero di ramificazioni e le variabili da tenere in considerazione sono tali da rendere un approccio deterministico realisticamente non percorribile. Di conseguenza, si ricorre ad approcci che ci permettano di avere un'idea veritiera della complessit\u00e0 dell'algoritmo, stimata assumendo la casistica peggiore , ovvero calcolando la quantit\u00e0 massima di tempo e memoria che, nel peggiore dei casi, il nostro algoritmo richieder\u00e0 per essere eseguito. Per far questo, si utilizza la cosiddetta O-big notation , che in matematica ci permette di descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. In parole povere, un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(C_T(n) = \\mathbb{O}(n^2)\\) richieder\u00e0 un tempo di esecuzione pari al massimo ad \\(n^2\\) , mentre un algoritmo con una complessit\u00e0 \\(C_S(n) = O(n * log(n))\\) occuper\u00e0 al massimo \\(n*log(n)\\) unit\u00e0 di memoria. Nota Nella notazione precedente, n indica una variabile che pu\u00f2 influenzare il numero di operazioni eseguite dall'algoritmo. Il perch\u00e9 occorra specificarla sar\u00e0 pi\u00f9 chiaro grazie ai prossimi esempi.","title":"7.4 - Complessit\u00e0 di caso peggiore"},{"location":"material/02_principles/07_complexity/lecture/#741-alcuni-esempi","text":"","title":"7.4.1 Alcuni esempi"},{"location":"material/02_principles/07_complexity/lecture/#7411-ciclo-for-semplice","text":"Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo for : n = 10; for i da 1 a n: scrivi i; incrementa i; endfor Notiamo innanzitutto che il valore del contatore i varia da 1 ad \\(n=10\\) . Ci\u00f2 significa che, al pi\u00f9 , saranno eseguite \\(n-1\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale (nel tempo) sar\u00e0 nell'ordine di \\(O(n)\\) . Per quello che riguarda quella nello spazio, supponendo che ad ogni iterazione le variabili create all'interno del corpo del ciclo (righe 3-4) siano anche cancellate, l'algoritmo avr\u00e0 una complessit\u00e0 spaziale di caso peggiore pari a 2; in questi casi, ovvero quando la complessit\u00e0 di caso peggiore \u00e8 costante, si dice che \\(C_S = O(1)\\)","title":"7.4.1.1 Ciclo for (semplice)"},{"location":"material/02_principles/07_complexity/lecture/#7412-cicli-for-annidati","text":"Vediamo cosa accade nel caso si considerino due cicli for l'uno annidato all'interno dell'altro. n = 10; for i da 1 a n: for j da 1 a n: scrivi i; scrivi j; endfor endfor Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile i ) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile j ). La complessit\u00e0 temporale di caso peggiore sar\u00e0 quindi \\(O(n^2)\\) ; per quello che riguarda invece la complessit\u00e0 spaziale, invece, assumendo un meccanismo analogo al precedente, avremo sempre \\(O(1)\\) .V","title":"7.4.1.2 Cicli for annidati"},{"location":"material/02_principles/08_variables/lecture/","text":"8 - Le variabili \u00b6 Comprendere il concetto di variabile \u00e8 fondamentale (o, per meglio dire, propedeutico ) all'acquisizione dei fondamentali della programmazione. Per capire di cosa si tratta, possiamo analizzare il significato della parola nella lingua italiana: intuitivamente, una variabile rappresenta una quantit\u00e0 (o, in maniera molto pi\u00f9 \"lasca\", un dato) a cui \u00e8 \"concesso\" di variare durante l'esecuzione del programma. Risulta importantissimo sottolineare come una variabile non sia quindi necessariamente un dato di ingresso o un risultato atteso: si tratta piuttosto di una rappresentazione (parziale) dello stato interno del programma ad un dato istante. Una variabile pu\u00f2 essere quindi qualsiasi dato contenuto nel nostro programma: ci sono variabili che contano il numero di operazioni eseguite, ad esempio, oppure ancora variabili di supporto, che ci permettono di memorizzare stati intermedi durante l'esecuzione di iterazioni complesse. Nota Non tutti i dati contenuti in un programma sono delle variabili: esistono anche delle costanti , che si differenziano dalle variabili per la caratteristica di non poter variare durante l'esecuzione del programma. Di solito, le costanti vengono utilizzate per modellare valori ben definiti, come ad esempio il \\(\\pi\\) . 8.1 - Dichiarare ed inizializzare una variabile \u00b6 Per poter utilizzare una variabile all'interno del nostro programma dovremo seguire due step fondamentali, indipendentemente dal linguaggio di programmazione scelto . In particolare: nel primo step, chiamato dichiarazione della variabile, dovremo \"informare\" il programma dell'esistenza della stessa, associandovi un identificatore (ovvero, un nome) ed il tipo di dato rappresentato dalla stessa; nel secondo step, chiamato inizializzazione , dovremo assegnare un valore iniziale alla nostra variabile, in accordo ovviamente al tipo di dato utilizzato. Ad esempio, per dichiarare una variabile di tipo type chiamata identifier , dovremo usare una sintassi di questo tipo: type identifier ; Successivamente, potremo inizializzare la variabile identifier con il valore value : identifier = value ; Le due operazioni non sono necessariamente separate, e possono essere combinate in un'unica istruzione. type identifier = value ; Nota Vedremo un gran numero di esempi pratici di dichiarazione ed inizializzazione. 8.2 - Identificatore della variabile \u00b6 In genere, la scelta dell'identificatore da associare ad una variabile lascia vasta libert\u00e0 di scelta al programmatore. Tuttavia, occorre tenere a mente che, indipendentemente dal linguaggio, non sar\u00e0 possibile usare come identificatore una keyword (ad esempio, non \u00e8 possibile chiamare una variabile if o long ); inoltre, \u00e8 fortemente consigliato attenersi allo styling code del linguaggio. Facciamo un paio di esempi. Il linguaggio Java, che non tratteremo, adotta per convenzione uno styling code chiamato camel case , che prevede che parole consecutive siano unite tra di loro, con l'iniziale di ogni parola successiva alla prima in maiuscolo. Ad esempio: int integerVariable = 1 ; Python, invece, utilizza per convenzione lo stile snake case , che prevede che parole consecutive siano \"unite\" mediante un simbolo di underscore, lasciando tutte le lettere minuscole: integer_variable = 1 Sulla scelta del nome La scelta del nome da assegnare ad una variabile non \u00e8 casuale. Il suggerimento \u00e8 quello di assegnare nomi esplicativi , oltre che univoci : ad esempio, un contatore chiamato cnt sar\u00e0 sicuramente pi\u00f9 riconoscibile di un contatore chiamato pippo_joy . 8.3 - Tipo della variabile \u00b6 Il tipo della variabile definisce il tipo di dato associato alla stessa; come abbiamo visto nella lezione 4 , quindi, ci\u00f2 influenzer\u00e0 il range di valori che questa pu\u00f2 rappresentare. Ponderare adeguatamente il tipo di dato da usare per una variabile \u00e8 quindi estremamente importante , principalmente per due ragioni: flusso logico ; complessit\u00e0 computazionale spaziale . Partiamo dal flusso logico. Immaginiamo di dover sommare tra loro due numeri reali x ed y , e di voler associare il valore risultante da questa operazione alla variabile z . Al momento della scrittura del codice, decidiamo di assegnare (correttamente) il tipo float ad x ed y ma, per una disattenzione, assegnamo il tipo int alla variabile z : float x = 1.1 ; float y = 1.2 ; int z ; z = x + y ; Cosa accadr\u00e0? Consideriamo che il valore che ci attendiamo che z assuma \u00e8 pari 2.3 : tuttavia, avremo come output 2 , principalmente a causa del tipo di z . Ci\u00f2 comporter\u00e0 quindi un errore di troncamento pari a 0.3 . Per quello che riguarda invece la complessit\u00e0 computazionale spaziale, ricordiamo, sempre dalla lezione 4, che ogni tipo di dato richiede una quantit\u00e0 di memoria differente, ma al tempo stesso permette di memorizzare un range di valori pi\u00f9 o meno ampio. Questa caratteristica pu\u00f2 e deve essere usata a nostro vantaggio: infatti, qualora fossimo sicuri che le nostre variabili intere assumono sempre valori compresi tra 0 e 100, potremmo utilizzare dati di tipo byte . Tuttavia, se per qualche motivo una variabile si trovasse ad assumere un valore superiore a 256, avremmo un errore di buffer overflow , che porterebbe la variabile a \"ritornare\" a zero, con conseguenze facilmente intuibili. Curiosit\u00e0 Errori di questo tipo possono portare ad esiti catastrofici. Ad esempio, nel 1995, il razzo spaziale Ariane 5 esplose 39 secondi dopo il lancio perch\u00e9 nel software di controllo dell'altitudine era stato usato un intero a 16 bit piuttosto che a 64 bit.","title":"8 - Variabili"},{"location":"material/02_principles/08_variables/lecture/#8-le-variabili","text":"Comprendere il concetto di variabile \u00e8 fondamentale (o, per meglio dire, propedeutico ) all'acquisizione dei fondamentali della programmazione. Per capire di cosa si tratta, possiamo analizzare il significato della parola nella lingua italiana: intuitivamente, una variabile rappresenta una quantit\u00e0 (o, in maniera molto pi\u00f9 \"lasca\", un dato) a cui \u00e8 \"concesso\" di variare durante l'esecuzione del programma. Risulta importantissimo sottolineare come una variabile non sia quindi necessariamente un dato di ingresso o un risultato atteso: si tratta piuttosto di una rappresentazione (parziale) dello stato interno del programma ad un dato istante. Una variabile pu\u00f2 essere quindi qualsiasi dato contenuto nel nostro programma: ci sono variabili che contano il numero di operazioni eseguite, ad esempio, oppure ancora variabili di supporto, che ci permettono di memorizzare stati intermedi durante l'esecuzione di iterazioni complesse. Nota Non tutti i dati contenuti in un programma sono delle variabili: esistono anche delle costanti , che si differenziano dalle variabili per la caratteristica di non poter variare durante l'esecuzione del programma. Di solito, le costanti vengono utilizzate per modellare valori ben definiti, come ad esempio il \\(\\pi\\) .","title":"8 - Le variabili"},{"location":"material/02_principles/08_variables/lecture/#81-dichiarare-ed-inizializzare-una-variabile","text":"Per poter utilizzare una variabile all'interno del nostro programma dovremo seguire due step fondamentali, indipendentemente dal linguaggio di programmazione scelto . In particolare: nel primo step, chiamato dichiarazione della variabile, dovremo \"informare\" il programma dell'esistenza della stessa, associandovi un identificatore (ovvero, un nome) ed il tipo di dato rappresentato dalla stessa; nel secondo step, chiamato inizializzazione , dovremo assegnare un valore iniziale alla nostra variabile, in accordo ovviamente al tipo di dato utilizzato. Ad esempio, per dichiarare una variabile di tipo type chiamata identifier , dovremo usare una sintassi di questo tipo: type identifier ; Successivamente, potremo inizializzare la variabile identifier con il valore value : identifier = value ; Le due operazioni non sono necessariamente separate, e possono essere combinate in un'unica istruzione. type identifier = value ; Nota Vedremo un gran numero di esempi pratici di dichiarazione ed inizializzazione.","title":"8.1 - Dichiarare ed inizializzare una variabile"},{"location":"material/02_principles/08_variables/lecture/#82-identificatore-della-variabile","text":"In genere, la scelta dell'identificatore da associare ad una variabile lascia vasta libert\u00e0 di scelta al programmatore. Tuttavia, occorre tenere a mente che, indipendentemente dal linguaggio, non sar\u00e0 possibile usare come identificatore una keyword (ad esempio, non \u00e8 possibile chiamare una variabile if o long ); inoltre, \u00e8 fortemente consigliato attenersi allo styling code del linguaggio. Facciamo un paio di esempi. Il linguaggio Java, che non tratteremo, adotta per convenzione uno styling code chiamato camel case , che prevede che parole consecutive siano unite tra di loro, con l'iniziale di ogni parola successiva alla prima in maiuscolo. Ad esempio: int integerVariable = 1 ; Python, invece, utilizza per convenzione lo stile snake case , che prevede che parole consecutive siano \"unite\" mediante un simbolo di underscore, lasciando tutte le lettere minuscole: integer_variable = 1 Sulla scelta del nome La scelta del nome da assegnare ad una variabile non \u00e8 casuale. Il suggerimento \u00e8 quello di assegnare nomi esplicativi , oltre che univoci : ad esempio, un contatore chiamato cnt sar\u00e0 sicuramente pi\u00f9 riconoscibile di un contatore chiamato pippo_joy .","title":"8.2 - Identificatore della variabile"},{"location":"material/02_principles/08_variables/lecture/#83-tipo-della-variabile","text":"Il tipo della variabile definisce il tipo di dato associato alla stessa; come abbiamo visto nella lezione 4 , quindi, ci\u00f2 influenzer\u00e0 il range di valori che questa pu\u00f2 rappresentare. Ponderare adeguatamente il tipo di dato da usare per una variabile \u00e8 quindi estremamente importante , principalmente per due ragioni: flusso logico ; complessit\u00e0 computazionale spaziale . Partiamo dal flusso logico. Immaginiamo di dover sommare tra loro due numeri reali x ed y , e di voler associare il valore risultante da questa operazione alla variabile z . Al momento della scrittura del codice, decidiamo di assegnare (correttamente) il tipo float ad x ed y ma, per una disattenzione, assegnamo il tipo int alla variabile z : float x = 1.1 ; float y = 1.2 ; int z ; z = x + y ; Cosa accadr\u00e0? Consideriamo che il valore che ci attendiamo che z assuma \u00e8 pari 2.3 : tuttavia, avremo come output 2 , principalmente a causa del tipo di z . Ci\u00f2 comporter\u00e0 quindi un errore di troncamento pari a 0.3 . Per quello che riguarda invece la complessit\u00e0 computazionale spaziale, ricordiamo, sempre dalla lezione 4, che ogni tipo di dato richiede una quantit\u00e0 di memoria differente, ma al tempo stesso permette di memorizzare un range di valori pi\u00f9 o meno ampio. Questa caratteristica pu\u00f2 e deve essere usata a nostro vantaggio: infatti, qualora fossimo sicuri che le nostre variabili intere assumono sempre valori compresi tra 0 e 100, potremmo utilizzare dati di tipo byte . Tuttavia, se per qualche motivo una variabile si trovasse ad assumere un valore superiore a 256, avremmo un errore di buffer overflow , che porterebbe la variabile a \"ritornare\" a zero, con conseguenze facilmente intuibili. Curiosit\u00e0 Errori di questo tipo possono portare ad esiti catastrofici. Ad esempio, nel 1995, il razzo spaziale Ariane 5 esplose 39 secondi dopo il lancio perch\u00e9 nel software di controllo dell'altitudine era stato usato un intero a 16 bit piuttosto che a 64 bit.","title":"8.3 - Tipo della variabile"},{"location":"material/02_principles/09_functions/exercises/","text":"9.4 - Esercizi \u00b6 Definire una funzione che calcoli l'ipotenusa di un triangolo rettangolo a partire dai suoi cateti. Definire una funzione che calcoli l'area di un cerchio a partire dal suo raggio.","title":"9.4 - Esercizi"},{"location":"material/02_principles/09_functions/exercises/#94-esercizi","text":"Definire una funzione che calcoli l'ipotenusa di un triangolo rettangolo a partire dai suoi cateti. Definire una funzione che calcoli l'area di un cerchio a partire dal suo raggio.","title":"9.4 - Esercizi"},{"location":"material/02_principles/09_functions/lecture/","text":"9 - Le funzioni \u00b6 Immaginiamo di dover calcolare il nostro voto di accesso all'esame laurea. Supponendo che nel nostro corso di studi ci siano esattamente venti esami, le istruzioni necessarie a calcolarlo sono molto semplici: numero_esami = 20; somma_voti = 0; for i che va da 1 a numero_esami: somma_voti = somma_voti + voto_esame_i; endfor voto_medio = somma_voti/numero_esami; voto_accesso = voto_medio / 3 * 11; Queste istruzioni accettano un solo \"insieme\" di esami, relativo quindi a noi; come potremmo fare quindi per calcolare la media di un nostro collega? La tentazione potrebbe essere quella di \"sdoppiare\" le istruzioni, cambiando leggermente il nome delle variabili e passando un insieme di esami diverso: numero_esami = 20; somma_voti_a = 0; for i che va da 1 a numero_esami: somma_voti_a = somma_voti_a + voto_esame_i_a; endfor voto_medio_a = somma_voti_a / numero_esami; voto_accesso_a = voto_medio_a / 3 * 11; somma_voti_b = 0; for i che va da 1 a numero_esami: somma_voti_b = somma_voti_b + voto_esame_i; endfor voto_medio_b = somma_voti_b / numero_esami; voto_accesso_b = voto_medio / 3 * 11; Cosa accadrebbe se volessimo aggiungere un altro studente? Ovviamente, dovremmo aggiungere altre righe di codice; \u00e8 facile quindi intuire che, in breve tempo, la situazione diventerebbe ingestibile. In nostro aiuto, quindi, giungono le funzioni , ovvero dei costrutti che ci permettono di raggruppare istruzioni eseguite un numero arbitrario di volte all'interno del nostro codice. Le funzioni (chiamate anche metodi ) assumono quindi il ruolo di contenitore logico , utilizzabile per effettuare una serie ben definita di operazioni su un certo input, conseguendo un determinato output. Vediamo quindi come sono strutturate. 9.1 - Struttura di una funzione \u00b6 Una funzione consta di due parti: una firma ed un corpo . Nella firma, sono definiti: il nome della funzione, ovvero un identificativo utile a richiamarla in altre parti del programma (un po' come quello della variabile); il tipo di ritorno , ovvero il tipo del valore restituito (ovvero, mandato in output) dalla funzione; i parametri di ingresso , ovvero il tipo ed i nomi dei valori in ingresso (input) alla funzione. Nel corpo, invece, saranno indicate le istruzioni vere e proprie, oltre che l'eventuale valore restituito dalla funzione. Schematizzando: tipo_ritorno nome_funzione(tipo_par_1 par_1, tipo_par_2 par_2): // Questa \u00e8 la firma... istr_1; // ...questo \u00e8 il corpo... istr_2; tipo_ritorno valore_ritorno = istr_3; return valore_ritorno; // ...e questo \u00e8 il valore restituito! Da notare la presenza della parola chiave return , che serve ad indicare il valore (o, per meglio dire, la variabile) che sar\u00e0 \"restituita\" dalla funzione. Nota Quando la funzione trova la parola chiave return , si \"ferma\" immediatamente, e l'esecuzione del programma continua. Facciamo un esempio creando una pseudo-funzione per il calcolo del voto di accesso all'esame di laurea; chiamiamola, in maniera originale, calcolo_voto_accesso_laurea , e supponiamo restituisca un float (il voto di accesso non approssimato) a partire da un insieme di valori interi (i voti dei singoli esami). Allora: numero_esami = 20; float calcolo_voto_accesso_laurea(int[] voti_esami): somma_voti = 0; for i che va da 1 a numero_esami: somma_voti = somma_voti + voto_esame_i; endfor voto_medio = somma_voti / numero_esami; voto_accesso = voto_medio / 3 * 11; return voto_accesso; Immaginiamo di voler chiamare la funzione per calcolare i nostri voti, oltre a quelli di un collega. Per farlo, useremo istruzioni simili a queste: mio_voto_accesso = calcolo_voto_accesso_laurea(miei_voti); voto_accesso_collega = calcolo_voto_accesso_laurea(voti_collega); Come si pu\u00f2 notare, il numero di righe di codice scritte diminuisce in maniera tanto pi\u00f9 rilevante quanto pi\u00f9 si usa la funzione! Nota sulle parentesi quadre Abbiamo usato in precedenza le parentesi quadre ( [] ) per indicare un \"insieme\" di valori. In realt\u00e0, questa notazione indica spesso un array , o una lista , a seconda del linguaggio; ne parleremo pi\u00f9 diffusamente nel seguito. 9.2 - Il concetto di modularit\u00e0 \u00b6 Abbiamo visto come una funzione serva ad evitare di dover ripetere numerose volte lo stesso insieme di istruzioni. Tuttavia, abbiamo accennato in precedenza anche al fatto che ogni funzione \u00e8 un contenitore logico di una sequena di istruzioni da utilizzare per risolvere un problema: ci\u00f2 ci conduce direttamente al concetto di modularit\u00e0 , per il quale una funzione deve contenere esclusivamente le istruzioni necessarie ad eseguire lo scopo per cui \u00e8 stata concepita. Per fare un esempio, immaginiamo adesso di dover calcolare, oltre al voto medio di accesso all'esame di laurea, anche quello finale, tenendo conto della votazione della commissione e dell'eventuale lode. Sottolineamo comunque come sia sempre importante per noi (e, nello specifico, per la segreteria e la commissione) tenere traccia del voto medio, per cui le due cose andranno, in qualche modo, separate. L'approccio da utilizzare \u00e8 quindi quello di creare un'altra funzione che asserva allo scopo di calcolare il voto finale: ```linenums=1\" int calcolo voto finale laurea(float voto accesso, int voto esame, float soglia lode): voto cumulativo = voto accesso + voto esame; if (voto cumulativo > (110 + soglia lode)): return 110L else: return voto cumulativo Da notare la presenza di due `return`: questo \u00e8 corretto perch\u00e9, essendo specificati nei due rami di un'istruzione condizionale, saranno mutualmente esclusivi, e quindi la funzione potr\u00e0 \"arrivare\" soltanto ad uno di essi. ## 9.3 - Funzioni, variabili ed ambito Introduciamo brevemente il concetto di *ambito* di una variabile. All'interno del nostro programma, infatti, ogni variabile ha una sorta di \"ciclo di vita\", nel quale viene creata, utilizzata, ed infine distrutta. L'intero programma ha un ambito chiamato *globale*: ci\u00f2 significa che tutte le variabili specificate nel corpo principale del programma, che vedremo in avanti essere chiamato spesso *main*, avranno validit\u00e0 in tutto il nostro codice. Le singole funzioni, invece, definiscono un ambito *locale*, che viene creato alla chiamata della funzione, e distrutto al termine della stessa. Ad esempio: ```linenums=\"1\" numero_esami = 20; miei_voti = lista_miei_voti; float calcolo_voto_accesso_laurea(int[] voti_esami): somma_voti = 0; for i che va da 1 a numero_esami: somma_voti = somma_voti + voto_esame_i; endfor voto_medio = somma_voti / numero_esami; voto_accesso = voto_medio / 3 * 11; return voto_accesso; voto_accesso_mio = calcolo_voto_accesso_laurea(miei_voti); Nel codice precedente, dichiariamo le variabili numero_esami e miei_voti nel corpo principale del programma: ci\u00f2 significa che questa variabili hanno validit\u00e0 nell'intero codice, e sono quindi richiamabili (e potenzialmente modificabili ) anche all'interno della funzione calcolo_voto_accesso_laurea . Dal canto suo, quest'ultima crea un ambito locale: ci\u00f2 comporta che le variabili create al suo interno, come somma_voti , voto_medio e voto_accesso , non potranno essere accedute all'esterno della funzione . Da ci\u00f2 seguono alcune considerazioni: parlando in maniera \"logica\", la parola chiave return serve a \"trasferire\" il valore di una variabile da un ambito locale ad uno globale; la variabile restituita cambia identificatore , ma il valore \u00e8 quello calcolato all'interno della funzione; occorre fare estrema attenzione alla modifica delle variabili globali in ambito locale, ovvero all'interno delle singole funzioni. Imparare ad utilizzare l'ambito delle variabili \u00e8 propedeutico al corretto utilizzo delle tecniche di programmazione, e tenere a mente queste tre semplici regole ci aiuter\u00e0 enormemente nella scrittura dle nsotro codice.","title":"9 - Funzioni"},{"location":"material/02_principles/09_functions/lecture/#9-le-funzioni","text":"Immaginiamo di dover calcolare il nostro voto di accesso all'esame laurea. Supponendo che nel nostro corso di studi ci siano esattamente venti esami, le istruzioni necessarie a calcolarlo sono molto semplici: numero_esami = 20; somma_voti = 0; for i che va da 1 a numero_esami: somma_voti = somma_voti + voto_esame_i; endfor voto_medio = somma_voti/numero_esami; voto_accesso = voto_medio / 3 * 11; Queste istruzioni accettano un solo \"insieme\" di esami, relativo quindi a noi; come potremmo fare quindi per calcolare la media di un nostro collega? La tentazione potrebbe essere quella di \"sdoppiare\" le istruzioni, cambiando leggermente il nome delle variabili e passando un insieme di esami diverso: numero_esami = 20; somma_voti_a = 0; for i che va da 1 a numero_esami: somma_voti_a = somma_voti_a + voto_esame_i_a; endfor voto_medio_a = somma_voti_a / numero_esami; voto_accesso_a = voto_medio_a / 3 * 11; somma_voti_b = 0; for i che va da 1 a numero_esami: somma_voti_b = somma_voti_b + voto_esame_i; endfor voto_medio_b = somma_voti_b / numero_esami; voto_accesso_b = voto_medio / 3 * 11; Cosa accadrebbe se volessimo aggiungere un altro studente? Ovviamente, dovremmo aggiungere altre righe di codice; \u00e8 facile quindi intuire che, in breve tempo, la situazione diventerebbe ingestibile. In nostro aiuto, quindi, giungono le funzioni , ovvero dei costrutti che ci permettono di raggruppare istruzioni eseguite un numero arbitrario di volte all'interno del nostro codice. Le funzioni (chiamate anche metodi ) assumono quindi il ruolo di contenitore logico , utilizzabile per effettuare una serie ben definita di operazioni su un certo input, conseguendo un determinato output. Vediamo quindi come sono strutturate.","title":"9 - Le funzioni"},{"location":"material/02_principles/09_functions/lecture/#91-struttura-di-una-funzione","text":"Una funzione consta di due parti: una firma ed un corpo . Nella firma, sono definiti: il nome della funzione, ovvero un identificativo utile a richiamarla in altre parti del programma (un po' come quello della variabile); il tipo di ritorno , ovvero il tipo del valore restituito (ovvero, mandato in output) dalla funzione; i parametri di ingresso , ovvero il tipo ed i nomi dei valori in ingresso (input) alla funzione. Nel corpo, invece, saranno indicate le istruzioni vere e proprie, oltre che l'eventuale valore restituito dalla funzione. Schematizzando: tipo_ritorno nome_funzione(tipo_par_1 par_1, tipo_par_2 par_2): // Questa \u00e8 la firma... istr_1; // ...questo \u00e8 il corpo... istr_2; tipo_ritorno valore_ritorno = istr_3; return valore_ritorno; // ...e questo \u00e8 il valore restituito! Da notare la presenza della parola chiave return , che serve ad indicare il valore (o, per meglio dire, la variabile) che sar\u00e0 \"restituita\" dalla funzione. Nota Quando la funzione trova la parola chiave return , si \"ferma\" immediatamente, e l'esecuzione del programma continua. Facciamo un esempio creando una pseudo-funzione per il calcolo del voto di accesso all'esame di laurea; chiamiamola, in maniera originale, calcolo_voto_accesso_laurea , e supponiamo restituisca un float (il voto di accesso non approssimato) a partire da un insieme di valori interi (i voti dei singoli esami). Allora: numero_esami = 20; float calcolo_voto_accesso_laurea(int[] voti_esami): somma_voti = 0; for i che va da 1 a numero_esami: somma_voti = somma_voti + voto_esame_i; endfor voto_medio = somma_voti / numero_esami; voto_accesso = voto_medio / 3 * 11; return voto_accesso; Immaginiamo di voler chiamare la funzione per calcolare i nostri voti, oltre a quelli di un collega. Per farlo, useremo istruzioni simili a queste: mio_voto_accesso = calcolo_voto_accesso_laurea(miei_voti); voto_accesso_collega = calcolo_voto_accesso_laurea(voti_collega); Come si pu\u00f2 notare, il numero di righe di codice scritte diminuisce in maniera tanto pi\u00f9 rilevante quanto pi\u00f9 si usa la funzione! Nota sulle parentesi quadre Abbiamo usato in precedenza le parentesi quadre ( [] ) per indicare un \"insieme\" di valori. In realt\u00e0, questa notazione indica spesso un array , o una lista , a seconda del linguaggio; ne parleremo pi\u00f9 diffusamente nel seguito.","title":"9.1 - Struttura di una funzione"},{"location":"material/02_principles/09_functions/lecture/#92-il-concetto-di-modularita","text":"Abbiamo visto come una funzione serva ad evitare di dover ripetere numerose volte lo stesso insieme di istruzioni. Tuttavia, abbiamo accennato in precedenza anche al fatto che ogni funzione \u00e8 un contenitore logico di una sequena di istruzioni da utilizzare per risolvere un problema: ci\u00f2 ci conduce direttamente al concetto di modularit\u00e0 , per il quale una funzione deve contenere esclusivamente le istruzioni necessarie ad eseguire lo scopo per cui \u00e8 stata concepita. Per fare un esempio, immaginiamo adesso di dover calcolare, oltre al voto medio di accesso all'esame di laurea, anche quello finale, tenendo conto della votazione della commissione e dell'eventuale lode. Sottolineamo comunque come sia sempre importante per noi (e, nello specifico, per la segreteria e la commissione) tenere traccia del voto medio, per cui le due cose andranno, in qualche modo, separate. L'approccio da utilizzare \u00e8 quindi quello di creare un'altra funzione che asserva allo scopo di calcolare il voto finale: ```linenums=1\" int calcolo voto finale laurea(float voto accesso, int voto esame, float soglia lode): voto cumulativo = voto accesso + voto esame; if (voto cumulativo > (110 + soglia lode)): return 110L else: return voto cumulativo Da notare la presenza di due `return`: questo \u00e8 corretto perch\u00e9, essendo specificati nei due rami di un'istruzione condizionale, saranno mutualmente esclusivi, e quindi la funzione potr\u00e0 \"arrivare\" soltanto ad uno di essi. ## 9.3 - Funzioni, variabili ed ambito Introduciamo brevemente il concetto di *ambito* di una variabile. All'interno del nostro programma, infatti, ogni variabile ha una sorta di \"ciclo di vita\", nel quale viene creata, utilizzata, ed infine distrutta. L'intero programma ha un ambito chiamato *globale*: ci\u00f2 significa che tutte le variabili specificate nel corpo principale del programma, che vedremo in avanti essere chiamato spesso *main*, avranno validit\u00e0 in tutto il nostro codice. Le singole funzioni, invece, definiscono un ambito *locale*, che viene creato alla chiamata della funzione, e distrutto al termine della stessa. Ad esempio: ```linenums=\"1\" numero_esami = 20; miei_voti = lista_miei_voti; float calcolo_voto_accesso_laurea(int[] voti_esami): somma_voti = 0; for i che va da 1 a numero_esami: somma_voti = somma_voti + voto_esame_i; endfor voto_medio = somma_voti / numero_esami; voto_accesso = voto_medio / 3 * 11; return voto_accesso; voto_accesso_mio = calcolo_voto_accesso_laurea(miei_voti); Nel codice precedente, dichiariamo le variabili numero_esami e miei_voti nel corpo principale del programma: ci\u00f2 significa che questa variabili hanno validit\u00e0 nell'intero codice, e sono quindi richiamabili (e potenzialmente modificabili ) anche all'interno della funzione calcolo_voto_accesso_laurea . Dal canto suo, quest'ultima crea un ambito locale: ci\u00f2 comporta che le variabili create al suo interno, come somma_voti , voto_medio e voto_accesso , non potranno essere accedute all'esterno della funzione . Da ci\u00f2 seguono alcune considerazioni: parlando in maniera \"logica\", la parola chiave return serve a \"trasferire\" il valore di una variabile da un ambito locale ad uno globale; la variabile restituita cambia identificatore , ma il valore \u00e8 quello calcolato all'interno della funzione; occorre fare estrema attenzione alla modifica delle variabili globali in ambito locale, ovvero all'interno delle singole funzioni. Imparare ad utilizzare l'ambito delle variabili \u00e8 propedeutico al corretto utilizzo delle tecniche di programmazione, e tenere a mente queste tre semplici regole ci aiuter\u00e0 enormemente nella scrittura dle nsotro codice.","title":"9.2 - Il concetto di modularit\u00e0"},{"location":"material/02_principles/10_data_structures/lecture/","text":"10 - Strutture dati \u00b6 Nella lezione precedente abbiamo ad un certo punto parlato di \"insieme\" dei voti relativi ai nostri esami, senza per\u00f2 ben specificare come rappresentarlo con i concetti a nostra disposizione. Se ci pensiamo, infatti, non abbiamo (apparentemente) strumenti per rappresentare degli insiemi: non possiamo certamente utilizzare un singolo dato numerico, cos\u00ec come neanche un dato booleano o un carattere. Per risolvere questo problema (e, in realt\u00e0, mille altri) dobbiamo utilizzare una serie di concetti che vanno sotto il nome collettivo di strutture dati , ovvero dei costrutti progettati per organizzare e gestire un insieme di valori nella maniera pi\u00f9 efficiente possibile. Esistono diversi tipi di struttura dati, ognuno dei quali adatto ad un determinato scopo. Vediamo quelli pi\u00f9 diffusi. 10.1 - Array \u00b6 La maniera pi\u00f9 rapida di rappresentare i nostri voti \u00e8 quella di immaginarli come un vettore di numeri interi; per far questo esiste una struttura dati apposita chiamata array . Un array contiene quindi una sequenza di elementi, tipicamente dello stesso tipo (anche se, come vedremo, ci\u00f2 dipende dal linguaggio di programmazione), ed organizzati seguendo un ordine specifico, \"esplorabile\" mediante il concetto di indice . La presenza dell'indice permette di definire la modalit\u00e0 di accesso ai dati dell'array, indicata come accesso diretto . Nella pratica, possiamo estrarre qualsiasi elemento nell'array mediante l'indice stesso, in maniera diretta, senza dover \"scorrere\" l'intero vettore; questo fa s\u00ec che l'accesso abbia sempre una complessit\u00e0 \\(O(1)\\) , dato che \u00e8 richiesta un'unica operazione. Nota A far da contraltare all'efficienza in termini di accesso vi \u00e8 una certa laboriosit\u00e0 legata all'inserimento o rimozione di un elemento dall'array. Tipicamente, un array viene rappresentato come una serie di singole variabili racchiuse tra due parentesi quadre. Ad esempio: array = [ 8 , 5 , 12 , 7 , 4 ] In particolare, il precedente array \u00e8 composto da elementi di tipo intero, ed ha una lunghezza pari a cinque elementi. Da notare che nella maggior parte dei linguaggi di programmazione l'indice del primo elemento non \u00e8 pari ad uno, ma a zero. La figura successiva esplicita adeguatamente questo concetto. 10.2 - Liste \u00b6 Una lista , conosciuta anche con il nome di linked list , \u00e8 una struttura dati simile all'array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento esplicito a quello successivo. Questo concetto \u00e8 esplicitato nella seguente figura: In particolare, osserviamo che: il primo elemento nella lista, il cui valore \u00e8 5 , ha un riferimento all'elemento successivo R3 ; il secondo elemento nella lista ha valore 3 , e conserva un riferimento all'elemento successivo R2 ; ci\u00f2 prosegue sino all'elemento 7 , che conserva un riferimento all'ultimo elemento R12 . Il fatto che ogni elemento della lista contenga un riferimento al successivo ha due conseguenze: la prima consiste nel fatto che la lista \u00e8 una struttura dati ad accesso sequenziale , il che significa che occorrer\u00e0 \"scorrere\" tutti gli elementi della stessa fino ad arrivare a quello desiderato; la seconda sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o rimuovere un elemento da una lista che da un array: infatti, baster\u00e0 semplicemente modificare i riferimenti dagli elementi contigui a quello che si sta aggiungendo o rimuovendo. 10.3 - Struct \u00b6 Una struct contiene un insieme di valori tipicamente chiamati membri o campi , il cui numero, sequenza e tipo sono tipicamente prefissati. Le struct trovano ampia applicazione in linguaggi come il C, ed hanno una sintassi di questo tipo: struct nome_struct { tipo_campo_uno id_campo_uno ; tipo_campo_due id_campo_due ; }; Questa sintassi ci permette di definire quindi un tipo di struct chiamato nome_struct ed avente, in questo caso, due campi, ovvero un primo campo di tipo tipo_campo_uno ed identificatore id_campo_uno , ed un secondo campo di tipo tipo_campo_due ed identificatore id_campo_due . 10.4 - Union \u00b6 Una union \u00e8 un tipo di struttura dati che permette di specificare il tipo del valore che pu\u00f2 essere memorizzato al suo interno tra un certo numero di tipi primitivi. Nonostante sia sintatticamente affine alla struct, ne differisce quindi dal punto di vista funzionale: non \u00e8 una \"struttura\", ma piuttosto un \"ventaglio di possibili tipi\" da cui selezionare. La sintassi di una union \u00e8 simile alla seguente: union nome_union { tipo_union_uno id_union_tipo_uno ; tipo_union_due id_union_tipo_due ; }; In questo caso, la union di nome nome_union potr\u00e0 assumere uno tra due possibili valori, ovvero id_union_tipo_uno di tipo tipo_union_uno o id_union_tipo_due di tipo id_union_tipo_due . Nota Per adesso, non facciamo un esempio \"concreto\" di union; lo vedremo pi\u00f9 avanti, quando ritorneremo su queste due strutture dati in C. 10.5 - Pile e code \u00b6 Abbiamo visto in precedenza due tipi di accesso ai dati, ovvero quello casuale , proprio degli array, e quello sequenziale , proprio dell eliste. Esiste un altro tipo di accesso ai dati, chiamato accesso limitato , usato da specifiche strutture dati come pile e code . Vediamo brevemente entrambi questi tipi di struttura dati. 10.5.1 - Pile \u00b6 Una pila (in inglese, stack ) \u00e8 una struttura dati che contiene al suo interno variabili inserite e/o rimosse seguendo il principio Last-In, First-Out ( LIFO ). In altre parole, ci\u00f2 significa che l'ultimo elemento che accede ad una pila \u00e8 anche il primo ad uscirne. Una pila ha a disposizione quindi due diverse operazioni, ovvero quella di push , mediante la quale un oggetto viene inserito in cima allo stack, e quella di pop , che permette di estrarre l'oggetto dalla cima dello stesso. Il funzionamento della pila \u00e8 schematizzato all'interno della seguente figura. Nota Il motivo alla base dell'aggettivo \"limitato\" \u00e8 da ricercarsi proprio nel fatto che sia il push sia il pop possono essere effettuati soltanto sugli elementi in cima alla pila. 10.5.2 - Code \u00b6 Una coda (in inglese, queue ) \u00e8 una struttura dati concettualmente simile alla pila, ma che segue il principio ( First-In, First-Out ) ( FIFO ); in questo caso, il primo ad uscire dalla coda sar\u00e0 il primo ad esservi entrato. Le operazioni definite sulla coda sono concettualmente simili a quelle definite sulla pila, e vengono chiamate enqueue (per mettere in coda un nuovo elemento) e dequeue (per togliere dalla coda l'elemento presente da pi\u00f9 tempo). Il funzionamento della coda \u00e8 schematizzato all'interno della seguente figura.","title":"10 - Strutture dati"},{"location":"material/02_principles/10_data_structures/lecture/#10-strutture-dati","text":"Nella lezione precedente abbiamo ad un certo punto parlato di \"insieme\" dei voti relativi ai nostri esami, senza per\u00f2 ben specificare come rappresentarlo con i concetti a nostra disposizione. Se ci pensiamo, infatti, non abbiamo (apparentemente) strumenti per rappresentare degli insiemi: non possiamo certamente utilizzare un singolo dato numerico, cos\u00ec come neanche un dato booleano o un carattere. Per risolvere questo problema (e, in realt\u00e0, mille altri) dobbiamo utilizzare una serie di concetti che vanno sotto il nome collettivo di strutture dati , ovvero dei costrutti progettati per organizzare e gestire un insieme di valori nella maniera pi\u00f9 efficiente possibile. Esistono diversi tipi di struttura dati, ognuno dei quali adatto ad un determinato scopo. Vediamo quelli pi\u00f9 diffusi.","title":"10 - Strutture dati"},{"location":"material/02_principles/10_data_structures/lecture/#101-array","text":"La maniera pi\u00f9 rapida di rappresentare i nostri voti \u00e8 quella di immaginarli come un vettore di numeri interi; per far questo esiste una struttura dati apposita chiamata array . Un array contiene quindi una sequenza di elementi, tipicamente dello stesso tipo (anche se, come vedremo, ci\u00f2 dipende dal linguaggio di programmazione), ed organizzati seguendo un ordine specifico, \"esplorabile\" mediante il concetto di indice . La presenza dell'indice permette di definire la modalit\u00e0 di accesso ai dati dell'array, indicata come accesso diretto . Nella pratica, possiamo estrarre qualsiasi elemento nell'array mediante l'indice stesso, in maniera diretta, senza dover \"scorrere\" l'intero vettore; questo fa s\u00ec che l'accesso abbia sempre una complessit\u00e0 \\(O(1)\\) , dato che \u00e8 richiesta un'unica operazione. Nota A far da contraltare all'efficienza in termini di accesso vi \u00e8 una certa laboriosit\u00e0 legata all'inserimento o rimozione di un elemento dall'array. Tipicamente, un array viene rappresentato come una serie di singole variabili racchiuse tra due parentesi quadre. Ad esempio: array = [ 8 , 5 , 12 , 7 , 4 ] In particolare, il precedente array \u00e8 composto da elementi di tipo intero, ed ha una lunghezza pari a cinque elementi. Da notare che nella maggior parte dei linguaggi di programmazione l'indice del primo elemento non \u00e8 pari ad uno, ma a zero. La figura successiva esplicita adeguatamente questo concetto.","title":"10.1 - Array"},{"location":"material/02_principles/10_data_structures/lecture/#102-liste","text":"Una lista , conosciuta anche con il nome di linked list , \u00e8 una struttura dati simile all'array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento esplicito a quello successivo. Questo concetto \u00e8 esplicitato nella seguente figura: In particolare, osserviamo che: il primo elemento nella lista, il cui valore \u00e8 5 , ha un riferimento all'elemento successivo R3 ; il secondo elemento nella lista ha valore 3 , e conserva un riferimento all'elemento successivo R2 ; ci\u00f2 prosegue sino all'elemento 7 , che conserva un riferimento all'ultimo elemento R12 . Il fatto che ogni elemento della lista contenga un riferimento al successivo ha due conseguenze: la prima consiste nel fatto che la lista \u00e8 una struttura dati ad accesso sequenziale , il che significa che occorrer\u00e0 \"scorrere\" tutti gli elementi della stessa fino ad arrivare a quello desiderato; la seconda sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o rimuovere un elemento da una lista che da un array: infatti, baster\u00e0 semplicemente modificare i riferimenti dagli elementi contigui a quello che si sta aggiungendo o rimuovendo.","title":"10.2 - Liste"},{"location":"material/02_principles/10_data_structures/lecture/#103-struct","text":"Una struct contiene un insieme di valori tipicamente chiamati membri o campi , il cui numero, sequenza e tipo sono tipicamente prefissati. Le struct trovano ampia applicazione in linguaggi come il C, ed hanno una sintassi di questo tipo: struct nome_struct { tipo_campo_uno id_campo_uno ; tipo_campo_due id_campo_due ; }; Questa sintassi ci permette di definire quindi un tipo di struct chiamato nome_struct ed avente, in questo caso, due campi, ovvero un primo campo di tipo tipo_campo_uno ed identificatore id_campo_uno , ed un secondo campo di tipo tipo_campo_due ed identificatore id_campo_due .","title":"10.3 - Struct"},{"location":"material/02_principles/10_data_structures/lecture/#104-union","text":"Una union \u00e8 un tipo di struttura dati che permette di specificare il tipo del valore che pu\u00f2 essere memorizzato al suo interno tra un certo numero di tipi primitivi. Nonostante sia sintatticamente affine alla struct, ne differisce quindi dal punto di vista funzionale: non \u00e8 una \"struttura\", ma piuttosto un \"ventaglio di possibili tipi\" da cui selezionare. La sintassi di una union \u00e8 simile alla seguente: union nome_union { tipo_union_uno id_union_tipo_uno ; tipo_union_due id_union_tipo_due ; }; In questo caso, la union di nome nome_union potr\u00e0 assumere uno tra due possibili valori, ovvero id_union_tipo_uno di tipo tipo_union_uno o id_union_tipo_due di tipo id_union_tipo_due . Nota Per adesso, non facciamo un esempio \"concreto\" di union; lo vedremo pi\u00f9 avanti, quando ritorneremo su queste due strutture dati in C.","title":"10.4 - Union"},{"location":"material/02_principles/10_data_structures/lecture/#105-pile-e-code","text":"Abbiamo visto in precedenza due tipi di accesso ai dati, ovvero quello casuale , proprio degli array, e quello sequenziale , proprio dell eliste. Esiste un altro tipo di accesso ai dati, chiamato accesso limitato , usato da specifiche strutture dati come pile e code . Vediamo brevemente entrambi questi tipi di struttura dati.","title":"10.5 - Pile e code"},{"location":"material/02_principles/10_data_structures/lecture/#1051-pile","text":"Una pila (in inglese, stack ) \u00e8 una struttura dati che contiene al suo interno variabili inserite e/o rimosse seguendo il principio Last-In, First-Out ( LIFO ). In altre parole, ci\u00f2 significa che l'ultimo elemento che accede ad una pila \u00e8 anche il primo ad uscirne. Una pila ha a disposizione quindi due diverse operazioni, ovvero quella di push , mediante la quale un oggetto viene inserito in cima allo stack, e quella di pop , che permette di estrarre l'oggetto dalla cima dello stesso. Il funzionamento della pila \u00e8 schematizzato all'interno della seguente figura. Nota Il motivo alla base dell'aggettivo \"limitato\" \u00e8 da ricercarsi proprio nel fatto che sia il push sia il pop possono essere effettuati soltanto sugli elementi in cima alla pila.","title":"10.5.1 - Pile"},{"location":"material/02_principles/10_data_structures/lecture/#1052-code","text":"Una coda (in inglese, queue ) \u00e8 una struttura dati concettualmente simile alla pila, ma che segue il principio ( First-In, First-Out ) ( FIFO ); in questo caso, il primo ad uscire dalla coda sar\u00e0 il primo ad esservi entrato. Le operazioni definite sulla coda sono concettualmente simili a quelle definite sulla pila, e vengono chiamate enqueue (per mettere in coda un nuovo elemento) e dequeue (per togliere dalla coda l'elemento presente da pi\u00f9 tempo). Il funzionamento della coda \u00e8 schematizzato all'interno della seguente figura.","title":"10.5.2 - Code"},{"location":"material/02_principles/11_recursion/lecture/","text":"11 - Ricorsione \u00b6 Quella della ricorsione \u00e8 una tecnica di programmazione che permette di \"spezzare\" un problema in diverse piccole parti, da trattare una alla volta fino alla risoluzione completa dello stesso. E' quindi in qualche modo assimilabile al paradigma \"divide-et-impera\", tanto caro agli strateghi dell'antica Roma. Nella pratica, si tratta di riapplicare una serie di istruzioni (e, quindi, una funzione) ad istanze sempre pi\u00f9 piccole del problema originario, fino a che non \u00e8 possibile giungere ad una risoluzione diretta; tuttavia, per comprenderne appieno il funzionamento, \u00e8 opportuno procedere con un esempio pratico. 11.1 - Calcolo del fattoriale \u00b6 Il fattoriale di un numero \\(n\\) \u00e8 indicato con \\(n!\\) ed \u00e8 dato dal prodotto di tutti i numeri che vanno da \\(1\\) ad \\(n\\) . Formalmente: \\[ n! = 1 \\cdot 2 \\cdot \\ldots \\cdot (n-1) \\cdot (n) \\] Ad esempio, \\(3! = 6\\) , mentre \\(4! = 24\\) , \\(5! = 120\\) , e via dicendo. Il fattoriale \u00e8 definito per ogni numero intero strettamente positivo, oltre che per lo \\(0\\) , per il quale vale \\(0!=1\\) . Proviamo per prima cosa a calcolare il fattorale usando un ciclo. 11.1.1 - Calcolo iterativo del fattoriale \u00b6 Calcolare il fattoriale mediante un ciclo \u00e8 molto semplice. Infatti, basta usare la formulazione stessa di fattoriale: fatt = 1; for i che varia da 1 ad n: fatt = fatt * i; endfor return fatt; 11.1.2 - Calcolo ricorsivo del fattoriale \u00b6 \"Complichiamoci\" la vita, e vediamo come \u00e8 possibile calcolare il fattoriale in maniera ricorsiva. Riprendiamo la definizione di fattoriale, applicando la propriet\u00e0 commutativa: \\[ n! = n \\cdot(n-1) \\ldots 2 \\cdot 1 \\] Notiamo che \\((n - 1)! = (n - 1) \\cdot \\ldots \\cdot 2 \\cdot 1\\) , per cui possiamo scrivere che: \\[ n! = n \\cdot (n - 1)! \\] Abbiamo quindi scomposto il problema del calcolo del fattoriale di \\(n\\) nel problema della moltiplicazione di \\(n\\) per il fattoriale di \\((n-1)\\) ; di conseguenza, \\((n-1)!\\) \u00e8 un sottoproblema di \\(n!\\) . Se provassimo ad estendere il concetto, avremmo che: \\[ n! = n \\cdot (n-1)! = n \\cdot (n-1) \\cdot (n-2)! = \\ldots = n \\cdot (n-1) \\cdot \\ldots \\cdot 1 \\cdot 0! \\] da cui deriva che: \\[ 0! * 1 = 1 = 1! \\Rightarrow \\\\ \\Rightarrow 1! * 2 = 2 = 2! \\Rightarrow \\\\ \\Rightarrow \\ldots \\Rightarrow \\\\ \\Rightarrow (n-1)! * n = n! \\Rightarrow \\\\ \\] 11.1.2.1 - Caso base e ricorsione \u00b6 Risulta quindi che: nel caso \\(n=0\\) , allora \\(n! = 1\\) ; nel caso \\(n > 0\\) , allora dobbiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\) . Il caso \\(n =0\\) assume il nome di caso base , ed \u00e8 la situazione che cerchiamo per \"terminare\" la ricorsione; alternativamente, dovremo procedere a richiamare ricorsivamente la funzione desiderata. 11.1.2.2 - Implementazione della ricorsione \u00b6 Proviamo ad implementare la funzione ricorsiva in pseudocodice. Scriviamo: int factorial(int n): if n = 0: return 1; else: return n * factorial(n - 1); endif Analizziamo il comportamento della funzione. Se n \u00e8 maggiore di zero, la funzione restituir\u00e0 il prodotto tra n ed il risultato della funzione factorial applicata ad n - 1 . La funzione quindi \"chiama s\u00e8 stessa\", usando parametri differenti, fino a che non ci si ritrova nel caso base, e viene restituito 1 . Ci si potrebbe chiedere come faccia la funzione ricorsiva a restituire il valore complessivo di \\(n!\\) . La risposta \u00e8 da ricercarsi nel modo in cui sono memorizzati i dati durante la ricorsione: infatti, questi vengono organizzati secondo un call stack (traducibile in \"stack di chiamate\"), che conserva al suo interno i risultati derivanti dalle precedenti chiamate a funzione. Questo concetto \u00e8 riassunto nella seguente figura, che mostra il call stack per il calcolo ricorsivo del fattoriale di 4.","title":"11 - Ricorsione"},{"location":"material/02_principles/11_recursion/lecture/#11-ricorsione","text":"Quella della ricorsione \u00e8 una tecnica di programmazione che permette di \"spezzare\" un problema in diverse piccole parti, da trattare una alla volta fino alla risoluzione completa dello stesso. E' quindi in qualche modo assimilabile al paradigma \"divide-et-impera\", tanto caro agli strateghi dell'antica Roma. Nella pratica, si tratta di riapplicare una serie di istruzioni (e, quindi, una funzione) ad istanze sempre pi\u00f9 piccole del problema originario, fino a che non \u00e8 possibile giungere ad una risoluzione diretta; tuttavia, per comprenderne appieno il funzionamento, \u00e8 opportuno procedere con un esempio pratico.","title":"11 - Ricorsione"},{"location":"material/02_principles/11_recursion/lecture/#111-calcolo-del-fattoriale","text":"Il fattoriale di un numero \\(n\\) \u00e8 indicato con \\(n!\\) ed \u00e8 dato dal prodotto di tutti i numeri che vanno da \\(1\\) ad \\(n\\) . Formalmente: \\[ n! = 1 \\cdot 2 \\cdot \\ldots \\cdot (n-1) \\cdot (n) \\] Ad esempio, \\(3! = 6\\) , mentre \\(4! = 24\\) , \\(5! = 120\\) , e via dicendo. Il fattoriale \u00e8 definito per ogni numero intero strettamente positivo, oltre che per lo \\(0\\) , per il quale vale \\(0!=1\\) . Proviamo per prima cosa a calcolare il fattorale usando un ciclo.","title":"11.1 - Calcolo del fattoriale"},{"location":"material/02_principles/11_recursion/lecture/#1111-calcolo-iterativo-del-fattoriale","text":"Calcolare il fattoriale mediante un ciclo \u00e8 molto semplice. Infatti, basta usare la formulazione stessa di fattoriale: fatt = 1; for i che varia da 1 ad n: fatt = fatt * i; endfor return fatt;","title":"11.1.1 - Calcolo iterativo del fattoriale"},{"location":"material/02_principles/11_recursion/lecture/#1112-calcolo-ricorsivo-del-fattoriale","text":"\"Complichiamoci\" la vita, e vediamo come \u00e8 possibile calcolare il fattoriale in maniera ricorsiva. Riprendiamo la definizione di fattoriale, applicando la propriet\u00e0 commutativa: \\[ n! = n \\cdot(n-1) \\ldots 2 \\cdot 1 \\] Notiamo che \\((n - 1)! = (n - 1) \\cdot \\ldots \\cdot 2 \\cdot 1\\) , per cui possiamo scrivere che: \\[ n! = n \\cdot (n - 1)! \\] Abbiamo quindi scomposto il problema del calcolo del fattoriale di \\(n\\) nel problema della moltiplicazione di \\(n\\) per il fattoriale di \\((n-1)\\) ; di conseguenza, \\((n-1)!\\) \u00e8 un sottoproblema di \\(n!\\) . Se provassimo ad estendere il concetto, avremmo che: \\[ n! = n \\cdot (n-1)! = n \\cdot (n-1) \\cdot (n-2)! = \\ldots = n \\cdot (n-1) \\cdot \\ldots \\cdot 1 \\cdot 0! \\] da cui deriva che: \\[ 0! * 1 = 1 = 1! \\Rightarrow \\\\ \\Rightarrow 1! * 2 = 2 = 2! \\Rightarrow \\\\ \\Rightarrow \\ldots \\Rightarrow \\\\ \\Rightarrow (n-1)! * n = n! \\Rightarrow \\\\ \\]","title":"11.1.2 - Calcolo ricorsivo del fattoriale"},{"location":"material/02_principles/11_recursion/lecture/#11121-caso-base-e-ricorsione","text":"Risulta quindi che: nel caso \\(n=0\\) , allora \\(n! = 1\\) ; nel caso \\(n > 0\\) , allora dobbiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\) . Il caso \\(n =0\\) assume il nome di caso base , ed \u00e8 la situazione che cerchiamo per \"terminare\" la ricorsione; alternativamente, dovremo procedere a richiamare ricorsivamente la funzione desiderata.","title":"11.1.2.1 - Caso base e ricorsione"},{"location":"material/02_principles/11_recursion/lecture/#11122-implementazione-della-ricorsione","text":"Proviamo ad implementare la funzione ricorsiva in pseudocodice. Scriviamo: int factorial(int n): if n = 0: return 1; else: return n * factorial(n - 1); endif Analizziamo il comportamento della funzione. Se n \u00e8 maggiore di zero, la funzione restituir\u00e0 il prodotto tra n ed il risultato della funzione factorial applicata ad n - 1 . La funzione quindi \"chiama s\u00e8 stessa\", usando parametri differenti, fino a che non ci si ritrova nel caso base, e viene restituito 1 . Ci si potrebbe chiedere come faccia la funzione ricorsiva a restituire il valore complessivo di \\(n!\\) . La risposta \u00e8 da ricercarsi nel modo in cui sono memorizzati i dati durante la ricorsione: infatti, questi vengono organizzati secondo un call stack (traducibile in \"stack di chiamate\"), che conserva al suo interno i risultati derivanti dalle precedenti chiamate a funzione. Questo concetto \u00e8 riassunto nella seguente figura, che mostra il call stack per il calcolo ricorsivo del fattoriale di 4.","title":"11.1.2.2 - Implementazione della ricorsione"},{"location":"material/02_principles/12_paradigms/lecture/","text":"12 - I paradigmi di programmazione \u00b6 Nel capitolo 6 abbiamo parlato del paradigma della programmazione strutturata riferendoci a tutte quelle tecniche volte ad imprimere una certa struttura nel nostro codice. Abbiamo per\u00f2 anche sottolineato come quello della programmazione strutturata non sia l'unico paradigma di programmazione presente al giorno d'oggi; esistono infatti diversi altri approcci, tutti per\u00f2 riconducibili a due macro-aree, ovvero quelle della programmazione imperativa da un lato, e della programmazione dichiarativa dall'altro. 12.1 - La programmazione imperativa \u00b6 Come suggerito dal termine stesso, il paradigma della programmazione imperativa prevede che il nostro programma espliciti una sequenza ben definita di istruzioni da seguire, integrate secondo le strutture che abbiamo visto quando abbiamo parlato della programmazione strutturata . In generale, questo approccio risulta essere decisamente comprensibile dal programmatore, che si limita ad indicare una sequenza pi\u00f9 o meno articolata di \"ordini\"; tuttavia, \u00e8 importante sottolineare come la maggior chiarezza del paradigma imperativo rispetto a quello dichiarativo comporti contestualmente una maggior verbosit\u00e0 del primo rispetto al secondo. Esempi di linguaggi di programmazione che adottano il paradigma imperativo sono C, C++, Java e Python. Tra i linguaggi di programmazione imperativa si annoverano tre distinti \"stili\" di programmazione, ovvero quello strutturato (che abbiamo gi\u00e0 trattato), quello procedurale e quello modulare. In particolare, nell'approccio procedurale il programma viene suddiviso in piccole task, ciascuna delle quali \u00e8 descritta nel codice mediante una procedura , concetto assimilabile al moderno \"metodo\" o \"funzione\". Il paradigma modulare fa un ulteriore passo in avanti in tal senso, e struttura il programma in una serie di moduli indipendenti combinati tra loro a formare il software definitivo. 12.2 - La programmazione dichiarativa \u00b6 Il paradigma di programmazione dichiarativa prevede che il risultato richiesto sia descritto , e che non siano invece specificate le singole istruzioni da parte dello sviluppatore. In pratica, a differenza del paradigma imperativo, che definisce come arrivare ad un risultato, il paradigma dichiarativo si limita a descrivere ci\u00e0 che si vuole ottenere, posizionandosi di conseguenza pi\u00f9 vicino all'essere umano che al calcolatore (ovvero ad un livello di astrazione pi\u00f9 elevato). Esempi di linguaggi di programmazione che seguono il paradigma imperativo sono Prolog, Lisp o SQL. In analogia al paradigma imperativo, anche quello dichiarativo vede due possibili stili di programmazione, ovvero quello funzionale e quello logico . In ogni caso, i paradigmi dichiarativi sono generalmente pi\u00f9 complessi da utilizzare rispetto a quelli imperativi, in quanto richiedono un elevato apporto logico da parte del programmatore, che invece nel paradigma imperativo deve \"limitarsi\" ad implementare correttamente una sequenza di istruzioni.","title":"12 - Paradigmi di programmazione"},{"location":"material/02_principles/12_paradigms/lecture/#12-i-paradigmi-di-programmazione","text":"Nel capitolo 6 abbiamo parlato del paradigma della programmazione strutturata riferendoci a tutte quelle tecniche volte ad imprimere una certa struttura nel nostro codice. Abbiamo per\u00f2 anche sottolineato come quello della programmazione strutturata non sia l'unico paradigma di programmazione presente al giorno d'oggi; esistono infatti diversi altri approcci, tutti per\u00f2 riconducibili a due macro-aree, ovvero quelle della programmazione imperativa da un lato, e della programmazione dichiarativa dall'altro.","title":"12 - I paradigmi di programmazione"},{"location":"material/02_principles/12_paradigms/lecture/#121-la-programmazione-imperativa","text":"Come suggerito dal termine stesso, il paradigma della programmazione imperativa prevede che il nostro programma espliciti una sequenza ben definita di istruzioni da seguire, integrate secondo le strutture che abbiamo visto quando abbiamo parlato della programmazione strutturata . In generale, questo approccio risulta essere decisamente comprensibile dal programmatore, che si limita ad indicare una sequenza pi\u00f9 o meno articolata di \"ordini\"; tuttavia, \u00e8 importante sottolineare come la maggior chiarezza del paradigma imperativo rispetto a quello dichiarativo comporti contestualmente una maggior verbosit\u00e0 del primo rispetto al secondo. Esempi di linguaggi di programmazione che adottano il paradigma imperativo sono C, C++, Java e Python. Tra i linguaggi di programmazione imperativa si annoverano tre distinti \"stili\" di programmazione, ovvero quello strutturato (che abbiamo gi\u00e0 trattato), quello procedurale e quello modulare. In particolare, nell'approccio procedurale il programma viene suddiviso in piccole task, ciascuna delle quali \u00e8 descritta nel codice mediante una procedura , concetto assimilabile al moderno \"metodo\" o \"funzione\". Il paradigma modulare fa un ulteriore passo in avanti in tal senso, e struttura il programma in una serie di moduli indipendenti combinati tra loro a formare il software definitivo.","title":"12.1 - La programmazione imperativa"},{"location":"material/02_principles/12_paradigms/lecture/#122-la-programmazione-dichiarativa","text":"Il paradigma di programmazione dichiarativa prevede che il risultato richiesto sia descritto , e che non siano invece specificate le singole istruzioni da parte dello sviluppatore. In pratica, a differenza del paradigma imperativo, che definisce come arrivare ad un risultato, il paradigma dichiarativo si limita a descrivere ci\u00e0 che si vuole ottenere, posizionandosi di conseguenza pi\u00f9 vicino all'essere umano che al calcolatore (ovvero ad un livello di astrazione pi\u00f9 elevato). Esempi di linguaggi di programmazione che seguono il paradigma imperativo sono Prolog, Lisp o SQL. In analogia al paradigma imperativo, anche quello dichiarativo vede due possibili stili di programmazione, ovvero quello funzionale e quello logico . In ogni caso, i paradigmi dichiarativi sono generalmente pi\u00f9 complessi da utilizzare rispetto a quelli imperativi, in quanto richiedono un elevato apporto logico da parte del programmatore, che invece nel paradigma imperativo deve \"limitarsi\" ad implementare correttamente una sequenza di istruzioni.","title":"12.2 - La programmazione dichiarativa"},{"location":"material/02_principles/13_adv_data_structures/lecture/","text":"13 - Ancora sulle strutture dati \u00b6 In questa lezione, vedremo prima come progettare una pila ed una coda come degli array, per poi passare a presentare un altro tipo di strutture dati estremamente utilizzate, ovvero grafi ed alberi . 13.1 - Pila come array \u00b6 13.1.1 - Variabili da utilizzare \u00b6 Proviamo adesso ad implementare una pila utilizzando un array. Per farlo, avremo bisogno di tre elementi: un array, che chiameremo stack ; una variabile che indica l'elemento in cima allo stack , che chiameremo top ; una variabile che indica la lunghezza dello stack , che chiameremo capacity . Da qui consegue che: lo stack \u00e8 pieno quando top \u00e8 pari a capacity ; lo stack \u00e8 vuoto quando top \u00e8 pari a 0 . 13.1.2 - Operazioni di push e pop \u00b6 Ricordiamo che lo stack segue una strategia LIFO, per cui una push prevede che sia inserito un nuovo elemento nella parte superiore dell'array (ovvero, all'indice top ). Quindi: push(stack, top, capacity, element): STEP 1 -> top = top + 1; STEP 2 -> if (top >= capacity) return ERROR; STEP 3 -> top = element; Ci\u00f2 implica che: allo STEP 1 viene aumentato il valore attuale di top ; allo STEP 2 viene verificato che top non sia superiore a capacity , e che quindi la pila non sia gi\u00e0 piena; allo STEP 3 l'elemento element viene inserito al posto top dello della pila. L'operazione di pop invece prevede che l'elemento al vertice dello stack sia rimosso: pop(stack, top) STEP 1 -> if (top <= 0): return ERROR; STEP 2 -> element = top; STEP 3 -> top = top - 1; STEP 4 -> return element; Ci\u00f2 implica che: allo STEP 1 si verifica che lo stack non sia vuoto; allo STEP 2 viene assegnato ad element il valore presente al top dello stack ; allo STEP 3 il valore di top viene ridotto di uno; allo STEP 4 viene restituito il valore estratto dallo stack . 13.2 - Coda come array \u00b6 13.2.1 - Variabili da utilizzare \u00b6 Anche in questo caso dovremo usare tre diversi elementi: un array, che chiameremo queue ; una variabile che indica l'elemento da pi\u00f9 tempo in coda, chiamata first ; una variabile che indica la lunghezza della queue , che chiameremo capacity . Ovviamente, come nel caso precedente, se first \u00e8 uguale a capacity allora la coda \u00e8 piena. 13.2.2 - Operazioni di enqueue e dequeue \u00b6 Ricordiamo che la strategia seguita da una coda \u00e8 di tipo FIFO, per cui dovremo definire i metodi enqueue e dequeue . In particolare, il metodo enqueue prevede che al primo posto nell'array sia inserito l'elemento che si vuole aggiungere. enqueue(array, element) STEP 1 -> if (first >= capacity): return ERROR; STEP 2 -> for element in queue: element = prev_element; STEP 3 -> last = new_element; In pratica: allo STEP 1 , controlliamo che la coda non sia gi\u00e0 satura; allo STEP 2 , spostiamo ogni elemento della coda in avanti (in pratica, assegnamo a ciascun elemento il valore dell'elemento precedente nella coda); allo STEP 3 , aggiungiamo il nuovo elemento in ultima posizione. La procedura di dequeue , di converso, comporta la semplice rimozione dell'ultimo elemento nell'array. dequeue(array) STEP 1 -> remove first from queue; STEP 2 -> first = prev_element; In altre parole: allo STEP 1 viene rimosso il primo elemento dalla coda; allo STEP 2 il valore di first viene aggiornato, assegnandovi quello associato all'elemento immediatamente precedente. 13.3 - Grafi \u00b6 Il concetto di grafo pu\u00f2 essere compreso in maniera intuitiva partendo da quelli che sono i nostri contatti sulle reti sociali (possiamo tranquillamente pensare a Facebook). Chiunque abbia un account su Facebook, infatti, ha una serie pi\u00f9 o meno estesa di \"collegamenti\", i quali a loro volta possono essere collegati tra loro, andando a creare una sorta di \"intreccio\" di relazioni. Rappresentando ciascun account con un punto, e tutti i collegamenti mediante delle linee, avremmo una situazione pi\u00f9 o meno simile a quella che vediamo nella figura seguente. Notiamo anche che, nella maggior parte dei casi, la conoscenza tra due persone \u00e8 bidirezionale : ovvero, dato che noi conosciamo una certa persona, questa persona ci conoscer\u00e0 a sua volta. Questo modo di schematizzare una rete sociale avviene mediante una struttura nota come grafo . Formalmente, un grafo \u00e8 definito come una coppia \\(G=(V, E)\\) , dove \\(V\\) \u00e8 l'insieme dei vertici , o nodi (quelli che abbiamo prima chiamato \"punti\"), mentre \\(E\\) \u00e8 l'insieme degli archi , o lati che connette detti vertici (le \"linee\"). Interessante notare come un arco possa essere rappresentato mediante i nodi che connette: infatti, si pu\u00f2 dire che l'arco che connette i vertici \\(u\\) e \\(v\\) \u00e8 descrivibile mediante la coppia \\((u, v)\\) . 13.3.1 - Grafi diretti e non diretti \u00b6 Nell'esempio precedente, abbiamo visto come le relazioni all'interno di un social network siano perlopi\u00f9 bidirezionali. Non \u00e8 quindi possibile individuare una direzione \"specifica\" nell'arco che collega due nodi: l'arco che collega i nodi \\(u\\) e \\(v\\) pu\u00f2 essere inteso sia come un collegamento che da \\(u\\) va verso \\(v\\) , sia, al contrario, come un collegamento che va da \\(v\\) verso \\(u\\) . Una situazione di questo tipo implica la presenza di un grafo non diretto . In un grafo non diretto l'arco \\((u, v)\\) coincide quindi con l'arco \\((v, u)\\) . Per un grafo non diretto possiamo definire la condizione di adiacenza per due vertici \\(u\\) e \\(v\\) : Vertici adiacenti Due vertici \\(u\\) e \\(v\\) sono definiti adiacenti o vicini quando vi \u00e8 un arco che li connette. Contestualmente, possiamo definire il concetto di grado di un vertice: Grado di un vertice Si definisce grado di un vertice \\(u\\) il numero di archi che vi incidono. Ad esempio, se abbiamo cento contatti su Facebook, il nostro \"grado\" all'interno del social network sar\u00e0 proprio pari a 100. Viceversa, se ad ogni arco \u00e8 associata una direzione, otterremo un grafo diretto , nel quale non sar\u00e0 sempre possibile andare indifferentemnete da \\(u\\) a \\(v\\) , e viceversa. Per fare un esempio di grafo indiretto, immaginiamo che i nodi del nostro grafo siano gli incroci di una citt\u00e0, mentre i lati le vie che li connettono; in tal senso, ogni via a senso unico sar\u00e0 un esempio di arco diretto, e percorrobile ( teoricamente ) in un'unica direzione. Per un grafo diretto dovremo ridefinire il concetto di grado , separandolo in due concetti distinti. Grado esterno Si definisce grado esterno , o out-degree , di un vertice \\(u\\) il numero di archi in uscita da \\(u\\) . Grado interno Si definisce grado interno , o in-degree , di un vertice \\(u\\) il numero di archi in ingresso su \\(u\\) . 13.3.2 - Cammini e cicli \u00b6 Prendendo una licenza ed usando un \"gioco di parole\", immaginiamo di voler contattare il contatto di un nostro contatto. Per farlo, potremmo semplicemente chiedere al nostro amico di presentarci il suo amico il quale, ovviamente, non ha un collegamento diretto con noi, ma che risulta essere in qualche modo \"raggiungibile\": esiste, quindi, un percorso o, pi\u00f9 propriamente, un cammino , che mette in relazione noi con la nostra conoscenza futura. Ovviamente, il numero di cammini esistenti tra due nodi \\(u\\) e \\(v\\) \u00e8 potenzialmente molto elevato, se non addirittura infinito: ad esempio, nel caso precedente, potremmo sicuramente costruire una rete di contatti indiretti con la quale arrivare al nostro obiettivo in maniera pi\u00f9 \"larga\". Tuttavia, \u00e8 opportuno sempre cercare il cammino minimo ( shortest path ), che rappresenta il modo pi\u00f9 diretto per arrivare al nostro obiettivo. Definiamo inoltre altre due condizioni. Cicli Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo . Connessione del grafo Un grafo si dice connesso quando esiste almeno un percorso che colleghi due nodi \\((u, v)\\) , \\(\\forall (u, v) \\in V\\) . 13.3.2.1 - Un esempio \u00b6 Facciamo un esempio pratico. Immaginiamo che Bob voglia conoscere Eric; come \u00e8 possibile notare, non esiste alcun grafo che li collega. Tuttavia, Bob ha due strade: la prima \u00e8 quella di chiedere ad Alice di presentargli Charlie, che potrebbe a sua volta introdurgli Eric. La seconda, invece, prevede che Bob si metta in contatto con David, che potr\u00e0 direttamente introdurgli Eric. Abbiamo quindi individuato due cammini tra Bob ed Eric, di cui uno (quello che passa per David) \u00e8 da considerarsi minimo, in quanto tiene conto del numero minimo di vertici e lati intercorrenti tra il nodo di partenza e quello di arrivo. Per quello che riguarda i cicli, quello che va da Alice verso Bob verso David e torna poi ad Alice \u00e8 da considerarsi appunto come tale. 13.3.3 - Grafo pesato \u00b6 E' possibile che a tutti gli archi di un grafo sia associato un peso , ovvero un valore numerico. In uno degli esempi precedenti, ovvero quello delle vie e degli incroci, potremmo associare ad ogni strada un numero indicativo della sua lunghezza in metri: Un grafo i cui archi hanno dei pesi \u00e8 chiamato grafo pesato . Ovviamente, per trovare il cammino minimo in un grafo di questo tipo, dovremo tenere conto del valore dei pesi: nella figura precedente, infatti, TODO: esempio 13.4 - Alberi \u00b6 Un concetto cugino di quello di grafo \u00e8 quello di albero , struttura dati particolarmente usata soprattutto in ambito informatico, che permette di modellare una struttura gerarchica fatta di un nodo radice e di una serie di nodi figli, fino ai nodi foglia , ovvero quelli che non hanno ulteriori successori. Per comprendere al meglio la struttura di un albero, vediamo quella che \u00e8 la \"geneaologia\" della razza umana (in versione volutamente semplificata): In particolare, notiamo come a partire da un \"antenato comune\" (il famoso \"anello mancante\") si siano evoluti diversi rami dell'albero, ognuno afferente ad un diverso genere, di cui gli ultimi esemplari rappresentano i nodi foglia; nel nostro caso, l'Homo sapiens \u00e8 la foglia del ramo rappresentativo del genere Homo. Nota L'albero \u00e8 un grafo, con delle particolari caratteristiche: infatti, \u00e8 non diretto, connesso ed aciclico (ovvero, non presenta alcun ciclo al suo interno). Concludiamo questo excursus citando infine gli alberi binari , caratterizzati dal fatto che ciascun nodo ha (al pi\u00f9) due figli.","title":"13 - Strutture dati avanzate"},{"location":"material/02_principles/13_adv_data_structures/lecture/#13-ancora-sulle-strutture-dati","text":"In questa lezione, vedremo prima come progettare una pila ed una coda come degli array, per poi passare a presentare un altro tipo di strutture dati estremamente utilizzate, ovvero grafi ed alberi .","title":"13 - Ancora sulle strutture dati"},{"location":"material/02_principles/13_adv_data_structures/lecture/#131-pila-come-array","text":"","title":"13.1 - Pila come array"},{"location":"material/02_principles/13_adv_data_structures/lecture/#1311-variabili-da-utilizzare","text":"Proviamo adesso ad implementare una pila utilizzando un array. Per farlo, avremo bisogno di tre elementi: un array, che chiameremo stack ; una variabile che indica l'elemento in cima allo stack , che chiameremo top ; una variabile che indica la lunghezza dello stack , che chiameremo capacity . Da qui consegue che: lo stack \u00e8 pieno quando top \u00e8 pari a capacity ; lo stack \u00e8 vuoto quando top \u00e8 pari a 0 .","title":"13.1.1 - Variabili da utilizzare"},{"location":"material/02_principles/13_adv_data_structures/lecture/#1312-operazioni-di-push-e-pop","text":"Ricordiamo che lo stack segue una strategia LIFO, per cui una push prevede che sia inserito un nuovo elemento nella parte superiore dell'array (ovvero, all'indice top ). Quindi: push(stack, top, capacity, element): STEP 1 -> top = top + 1; STEP 2 -> if (top >= capacity) return ERROR; STEP 3 -> top = element; Ci\u00f2 implica che: allo STEP 1 viene aumentato il valore attuale di top ; allo STEP 2 viene verificato che top non sia superiore a capacity , e che quindi la pila non sia gi\u00e0 piena; allo STEP 3 l'elemento element viene inserito al posto top dello della pila. L'operazione di pop invece prevede che l'elemento al vertice dello stack sia rimosso: pop(stack, top) STEP 1 -> if (top <= 0): return ERROR; STEP 2 -> element = top; STEP 3 -> top = top - 1; STEP 4 -> return element; Ci\u00f2 implica che: allo STEP 1 si verifica che lo stack non sia vuoto; allo STEP 2 viene assegnato ad element il valore presente al top dello stack ; allo STEP 3 il valore di top viene ridotto di uno; allo STEP 4 viene restituito il valore estratto dallo stack .","title":"13.1.2 - Operazioni di push e pop"},{"location":"material/02_principles/13_adv_data_structures/lecture/#132-coda-come-array","text":"","title":"13.2 - Coda come array"},{"location":"material/02_principles/13_adv_data_structures/lecture/#1321-variabili-da-utilizzare","text":"Anche in questo caso dovremo usare tre diversi elementi: un array, che chiameremo queue ; una variabile che indica l'elemento da pi\u00f9 tempo in coda, chiamata first ; una variabile che indica la lunghezza della queue , che chiameremo capacity . Ovviamente, come nel caso precedente, se first \u00e8 uguale a capacity allora la coda \u00e8 piena.","title":"13.2.1 - Variabili da utilizzare"},{"location":"material/02_principles/13_adv_data_structures/lecture/#1322-operazioni-di-enqueue-e-dequeue","text":"Ricordiamo che la strategia seguita da una coda \u00e8 di tipo FIFO, per cui dovremo definire i metodi enqueue e dequeue . In particolare, il metodo enqueue prevede che al primo posto nell'array sia inserito l'elemento che si vuole aggiungere. enqueue(array, element) STEP 1 -> if (first >= capacity): return ERROR; STEP 2 -> for element in queue: element = prev_element; STEP 3 -> last = new_element; In pratica: allo STEP 1 , controlliamo che la coda non sia gi\u00e0 satura; allo STEP 2 , spostiamo ogni elemento della coda in avanti (in pratica, assegnamo a ciascun elemento il valore dell'elemento precedente nella coda); allo STEP 3 , aggiungiamo il nuovo elemento in ultima posizione. La procedura di dequeue , di converso, comporta la semplice rimozione dell'ultimo elemento nell'array. dequeue(array) STEP 1 -> remove first from queue; STEP 2 -> first = prev_element; In altre parole: allo STEP 1 viene rimosso il primo elemento dalla coda; allo STEP 2 il valore di first viene aggiornato, assegnandovi quello associato all'elemento immediatamente precedente.","title":"13.2.2 - Operazioni di enqueue e dequeue"},{"location":"material/02_principles/13_adv_data_structures/lecture/#133-grafi","text":"Il concetto di grafo pu\u00f2 essere compreso in maniera intuitiva partendo da quelli che sono i nostri contatti sulle reti sociali (possiamo tranquillamente pensare a Facebook). Chiunque abbia un account su Facebook, infatti, ha una serie pi\u00f9 o meno estesa di \"collegamenti\", i quali a loro volta possono essere collegati tra loro, andando a creare una sorta di \"intreccio\" di relazioni. Rappresentando ciascun account con un punto, e tutti i collegamenti mediante delle linee, avremmo una situazione pi\u00f9 o meno simile a quella che vediamo nella figura seguente. Notiamo anche che, nella maggior parte dei casi, la conoscenza tra due persone \u00e8 bidirezionale : ovvero, dato che noi conosciamo una certa persona, questa persona ci conoscer\u00e0 a sua volta. Questo modo di schematizzare una rete sociale avviene mediante una struttura nota come grafo . Formalmente, un grafo \u00e8 definito come una coppia \\(G=(V, E)\\) , dove \\(V\\) \u00e8 l'insieme dei vertici , o nodi (quelli che abbiamo prima chiamato \"punti\"), mentre \\(E\\) \u00e8 l'insieme degli archi , o lati che connette detti vertici (le \"linee\"). Interessante notare come un arco possa essere rappresentato mediante i nodi che connette: infatti, si pu\u00f2 dire che l'arco che connette i vertici \\(u\\) e \\(v\\) \u00e8 descrivibile mediante la coppia \\((u, v)\\) .","title":"13.3 - Grafi"},{"location":"material/02_principles/13_adv_data_structures/lecture/#1331-grafi-diretti-e-non-diretti","text":"Nell'esempio precedente, abbiamo visto come le relazioni all'interno di un social network siano perlopi\u00f9 bidirezionali. Non \u00e8 quindi possibile individuare una direzione \"specifica\" nell'arco che collega due nodi: l'arco che collega i nodi \\(u\\) e \\(v\\) pu\u00f2 essere inteso sia come un collegamento che da \\(u\\) va verso \\(v\\) , sia, al contrario, come un collegamento che va da \\(v\\) verso \\(u\\) . Una situazione di questo tipo implica la presenza di un grafo non diretto . In un grafo non diretto l'arco \\((u, v)\\) coincide quindi con l'arco \\((v, u)\\) . Per un grafo non diretto possiamo definire la condizione di adiacenza per due vertici \\(u\\) e \\(v\\) : Vertici adiacenti Due vertici \\(u\\) e \\(v\\) sono definiti adiacenti o vicini quando vi \u00e8 un arco che li connette. Contestualmente, possiamo definire il concetto di grado di un vertice: Grado di un vertice Si definisce grado di un vertice \\(u\\) il numero di archi che vi incidono. Ad esempio, se abbiamo cento contatti su Facebook, il nostro \"grado\" all'interno del social network sar\u00e0 proprio pari a 100. Viceversa, se ad ogni arco \u00e8 associata una direzione, otterremo un grafo diretto , nel quale non sar\u00e0 sempre possibile andare indifferentemnete da \\(u\\) a \\(v\\) , e viceversa. Per fare un esempio di grafo indiretto, immaginiamo che i nodi del nostro grafo siano gli incroci di una citt\u00e0, mentre i lati le vie che li connettono; in tal senso, ogni via a senso unico sar\u00e0 un esempio di arco diretto, e percorrobile ( teoricamente ) in un'unica direzione. Per un grafo diretto dovremo ridefinire il concetto di grado , separandolo in due concetti distinti. Grado esterno Si definisce grado esterno , o out-degree , di un vertice \\(u\\) il numero di archi in uscita da \\(u\\) . Grado interno Si definisce grado interno , o in-degree , di un vertice \\(u\\) il numero di archi in ingresso su \\(u\\) .","title":"13.3.1 - Grafi diretti e non diretti"},{"location":"material/02_principles/13_adv_data_structures/lecture/#1332-cammini-e-cicli","text":"Prendendo una licenza ed usando un \"gioco di parole\", immaginiamo di voler contattare il contatto di un nostro contatto. Per farlo, potremmo semplicemente chiedere al nostro amico di presentarci il suo amico il quale, ovviamente, non ha un collegamento diretto con noi, ma che risulta essere in qualche modo \"raggiungibile\": esiste, quindi, un percorso o, pi\u00f9 propriamente, un cammino , che mette in relazione noi con la nostra conoscenza futura. Ovviamente, il numero di cammini esistenti tra due nodi \\(u\\) e \\(v\\) \u00e8 potenzialmente molto elevato, se non addirittura infinito: ad esempio, nel caso precedente, potremmo sicuramente costruire una rete di contatti indiretti con la quale arrivare al nostro obiettivo in maniera pi\u00f9 \"larga\". Tuttavia, \u00e8 opportuno sempre cercare il cammino minimo ( shortest path ), che rappresenta il modo pi\u00f9 diretto per arrivare al nostro obiettivo. Definiamo inoltre altre due condizioni. Cicli Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo . Connessione del grafo Un grafo si dice connesso quando esiste almeno un percorso che colleghi due nodi \\((u, v)\\) , \\(\\forall (u, v) \\in V\\) .","title":"13.3.2 - Cammini e cicli"},{"location":"material/02_principles/13_adv_data_structures/lecture/#13321-un-esempio","text":"Facciamo un esempio pratico. Immaginiamo che Bob voglia conoscere Eric; come \u00e8 possibile notare, non esiste alcun grafo che li collega. Tuttavia, Bob ha due strade: la prima \u00e8 quella di chiedere ad Alice di presentargli Charlie, che potrebbe a sua volta introdurgli Eric. La seconda, invece, prevede che Bob si metta in contatto con David, che potr\u00e0 direttamente introdurgli Eric. Abbiamo quindi individuato due cammini tra Bob ed Eric, di cui uno (quello che passa per David) \u00e8 da considerarsi minimo, in quanto tiene conto del numero minimo di vertici e lati intercorrenti tra il nodo di partenza e quello di arrivo. Per quello che riguarda i cicli, quello che va da Alice verso Bob verso David e torna poi ad Alice \u00e8 da considerarsi appunto come tale.","title":"13.3.2.1 - Un esempio"},{"location":"material/02_principles/13_adv_data_structures/lecture/#1333-grafo-pesato","text":"E' possibile che a tutti gli archi di un grafo sia associato un peso , ovvero un valore numerico. In uno degli esempi precedenti, ovvero quello delle vie e degli incroci, potremmo associare ad ogni strada un numero indicativo della sua lunghezza in metri: Un grafo i cui archi hanno dei pesi \u00e8 chiamato grafo pesato . Ovviamente, per trovare il cammino minimo in un grafo di questo tipo, dovremo tenere conto del valore dei pesi: nella figura precedente, infatti, TODO: esempio","title":"13.3.3 - Grafo pesato"},{"location":"material/02_principles/13_adv_data_structures/lecture/#134-alberi","text":"Un concetto cugino di quello di grafo \u00e8 quello di albero , struttura dati particolarmente usata soprattutto in ambito informatico, che permette di modellare una struttura gerarchica fatta di un nodo radice e di una serie di nodi figli, fino ai nodi foglia , ovvero quelli che non hanno ulteriori successori. Per comprendere al meglio la struttura di un albero, vediamo quella che \u00e8 la \"geneaologia\" della razza umana (in versione volutamente semplificata): In particolare, notiamo come a partire da un \"antenato comune\" (il famoso \"anello mancante\") si siano evoluti diversi rami dell'albero, ognuno afferente ad un diverso genere, di cui gli ultimi esemplari rappresentano i nodi foglia; nel nostro caso, l'Homo sapiens \u00e8 la foglia del ramo rappresentativo del genere Homo. Nota L'albero \u00e8 un grafo, con delle particolari caratteristiche: infatti, \u00e8 non diretto, connesso ed aciclico (ovvero, non presenta alcun ciclo al suo interno). Concludiamo questo excursus citando infine gli alberi binari , caratterizzati dal fatto che ciascun nodo ha (al pi\u00f9) due figli.","title":"13.4 - Alberi"},{"location":"material/03_c_language/14_intro/lecture/","text":"14 - Introduzione al linguaggio C \u00b6 Il linguaggio C \u00e8 un linguaggio a livello medio-alto inizialmente sviluppato da Dennis M. Ritchie ai Bell Labs. La primissima implementazione del C risale al 1972, ma fu soltanto nel 1978 che venne reso disponibile al grande pubblico il primo draft del linguaggio, in quello che oggi \u00e8 conosciuto come K&R standard . La formalizzazione vera e propria del linguaggio avvenne poi da parte dell'ANSI ( American National Standard Institute ) nel 1988. Al giorno d'oggi, il C \u00e8 ancora uno tra i linguaggi di programmazione pi\u00f9 utilizzati, ed ha applicazioni praticamente ovunque, dai sistemi operativi ai compilatori, passando per database, programmi per smartphone ed editor di testo. 14.1 - Il programma Hello, world! \u00b6 Dopo questa breve (ma dovuta) introduzione \"storica\", partiamo con quella che \u00e8 da sempre la maniera \"classica\" di apprendere un linguaggio di programmazione, ovvero scrivendo il nostro primo programma, chiamato per convenzione Hello, world! ( Ciao, mondo! ). Apriamo Visual Studio (o un editor equivalente) e scriviamo: #include <stdio.h> int main () { // Questo \u00e8 un commento! printf ( \"Hello, World! \\n \" ); return 0 ; } Proviamo ad eseguire il programma usando il tasto Run o premendo F5, e sulla console dovrebbe apparire la scritta Hello, World! . 14.2 - Descrizione del codice \u00b6 Nonostante la loro semplicit\u00e0, in queste poche righe di codice sono riacchiusi i principali concetti sintattici che saranno usati per scrivere programmi ben pi\u00f9 complessi. Vediamoli uno per uno. 14.2.1 - La direttiva #include \u00b6 L'istruzione alla riga 1 \u00e8 chiamata direttiva , ed \u00e8 una parte di codice che viene elaborata in automatico dal programma delegato alla \"comprensione\" del linguaggio C (ovvero, al compilatore). In altre parole, ogni volta che si specifica una direttiva, viene effettuata una determinata azione: in questo caso, viene incluso tutto il codice contenuto all'interno del file stdio.h , che altro non \u00e8 che una delle librerie standard del C, delegata alle operazioni di input ed output da e verso diverse fonti (come schermo, tastiera, stampante, file, etc.). Nota Spesso, la direttiva #include prevede l'utilizzo o dei simboli di maggiore e minore (come in questo caso), oppure di due doppi apici. Nel primo caso, la ricerca del file specificato avviene all'interno dei file \"standard\" del C, mentre nel secondo all'interno della directory attuale. 14.2.2 - Il metodo main \u00b6 Alla riga 3 vediamo quello che \u00e8 l'unico metodo presente in tutti i programmi scritti in C, ovvero il main . Nonostante questo sia in tutto e per tutto una funzione, con parametri accettati in ingresso ed un valore di ritorno, il main rappresenta il punto di accesso del programma, ovvero la parte di codice che verr\u00e0 effettivamente eseguita a runtime, richiamando e \"componendo\", alla bisogna, le altre istruzioni e funzioni invocate dal programma. 14.2.3 - Commenti \u00b6 Alla riga 4 vi \u00e8 una stringa che ha preposti due caratteri di slash (ovvero // ); una stringa di questo tipo \u00e8 chiamata commento , e permette di inserire dei \"suggerimenti\" per facilitare la comprensione del codice. Il commento alla riga 4 \u00e8 un commento a singola linea; ne esistono anche di multilinea , che iniziano con la sequenza /* e terminano con la sequenza */ : /* * Questo \u00e8 un commento multilinea! */ // E questo \u00e8 un commento a linea singola! 14.2.4 - L'istruzione printf \u00b6 L'istruzione alla riga 5 richiama una funzione definita all'interno del file stdio.h che abbiamo invocato in precedenza nella direttiva include , ovvero la funzione printf . Questa accetta in ingresso una stringa (in questo caso \"Hello, World! \\n\" ) e la stampa sul terminale dello schermo. 14.2.5 - L'istruzione di ritorno return \u00b6 Nella testa della funzione main vediamo come viene indicato un valore di ritorno di tipo intero. Di conseguenza, l'istruzione return 0 indica il valore che sar\u00e0 restituito al termine della funzione main . Nota Per convenzione, restituire il valore 0 indica che il programma \u00e8 uscito con successo, mentre altri valori di ritorno, come -1 , indicano l'insorgenza di errori durante l'esecuzione del programma.","title":"14 - Introduzione al C"},{"location":"material/03_c_language/14_intro/lecture/#14-introduzione-al-linguaggio-c","text":"Il linguaggio C \u00e8 un linguaggio a livello medio-alto inizialmente sviluppato da Dennis M. Ritchie ai Bell Labs. La primissima implementazione del C risale al 1972, ma fu soltanto nel 1978 che venne reso disponibile al grande pubblico il primo draft del linguaggio, in quello che oggi \u00e8 conosciuto come K&R standard . La formalizzazione vera e propria del linguaggio avvenne poi da parte dell'ANSI ( American National Standard Institute ) nel 1988. Al giorno d'oggi, il C \u00e8 ancora uno tra i linguaggi di programmazione pi\u00f9 utilizzati, ed ha applicazioni praticamente ovunque, dai sistemi operativi ai compilatori, passando per database, programmi per smartphone ed editor di testo.","title":"14 - Introduzione al linguaggio C"},{"location":"material/03_c_language/14_intro/lecture/#141-il-programma-hello-world","text":"Dopo questa breve (ma dovuta) introduzione \"storica\", partiamo con quella che \u00e8 da sempre la maniera \"classica\" di apprendere un linguaggio di programmazione, ovvero scrivendo il nostro primo programma, chiamato per convenzione Hello, world! ( Ciao, mondo! ). Apriamo Visual Studio (o un editor equivalente) e scriviamo: #include <stdio.h> int main () { // Questo \u00e8 un commento! printf ( \"Hello, World! \\n \" ); return 0 ; } Proviamo ad eseguire il programma usando il tasto Run o premendo F5, e sulla console dovrebbe apparire la scritta Hello, World! .","title":"14.1 - Il programma Hello, world!"},{"location":"material/03_c_language/14_intro/lecture/#142-descrizione-del-codice","text":"Nonostante la loro semplicit\u00e0, in queste poche righe di codice sono riacchiusi i principali concetti sintattici che saranno usati per scrivere programmi ben pi\u00f9 complessi. Vediamoli uno per uno.","title":"14.2 - Descrizione del codice"},{"location":"material/03_c_language/14_intro/lecture/#1421-la-direttiva-include","text":"L'istruzione alla riga 1 \u00e8 chiamata direttiva , ed \u00e8 una parte di codice che viene elaborata in automatico dal programma delegato alla \"comprensione\" del linguaggio C (ovvero, al compilatore). In altre parole, ogni volta che si specifica una direttiva, viene effettuata una determinata azione: in questo caso, viene incluso tutto il codice contenuto all'interno del file stdio.h , che altro non \u00e8 che una delle librerie standard del C, delegata alle operazioni di input ed output da e verso diverse fonti (come schermo, tastiera, stampante, file, etc.). Nota Spesso, la direttiva #include prevede l'utilizzo o dei simboli di maggiore e minore (come in questo caso), oppure di due doppi apici. Nel primo caso, la ricerca del file specificato avviene all'interno dei file \"standard\" del C, mentre nel secondo all'interno della directory attuale.","title":"14.2.1 - La direttiva #include"},{"location":"material/03_c_language/14_intro/lecture/#1422-il-metodo-main","text":"Alla riga 3 vediamo quello che \u00e8 l'unico metodo presente in tutti i programmi scritti in C, ovvero il main . Nonostante questo sia in tutto e per tutto una funzione, con parametri accettati in ingresso ed un valore di ritorno, il main rappresenta il punto di accesso del programma, ovvero la parte di codice che verr\u00e0 effettivamente eseguita a runtime, richiamando e \"componendo\", alla bisogna, le altre istruzioni e funzioni invocate dal programma.","title":"14.2.2 - Il metodo main"},{"location":"material/03_c_language/14_intro/lecture/#1423-commenti","text":"Alla riga 4 vi \u00e8 una stringa che ha preposti due caratteri di slash (ovvero // ); una stringa di questo tipo \u00e8 chiamata commento , e permette di inserire dei \"suggerimenti\" per facilitare la comprensione del codice. Il commento alla riga 4 \u00e8 un commento a singola linea; ne esistono anche di multilinea , che iniziano con la sequenza /* e terminano con la sequenza */ : /* * Questo \u00e8 un commento multilinea! */ // E questo \u00e8 un commento a linea singola!","title":"14.2.3 - Commenti"},{"location":"material/03_c_language/14_intro/lecture/#1424-listruzione-printf","text":"L'istruzione alla riga 5 richiama una funzione definita all'interno del file stdio.h che abbiamo invocato in precedenza nella direttiva include , ovvero la funzione printf . Questa accetta in ingresso una stringa (in questo caso \"Hello, World! \\n\" ) e la stampa sul terminale dello schermo.","title":"14.2.4 - L'istruzione printf"},{"location":"material/03_c_language/14_intro/lecture/#1425-listruzione-di-ritorno-return","text":"Nella testa della funzione main vediamo come viene indicato un valore di ritorno di tipo intero. Di conseguenza, l'istruzione return 0 indica il valore che sar\u00e0 restituito al termine della funzione main . Nota Per convenzione, restituire il valore 0 indica che il programma \u00e8 uscito con successo, mentre altri valori di ritorno, come -1 , indicano l'insorgenza di errori durante l'esecuzione del programma.","title":"14.2.5 - L'istruzione di ritorno return"},{"location":"material/03_c_language/15_fundamentals/exercises/","text":"E15 - Nozioni fondamentali su C \u00b6 Esercizio E15.1 \u00b6 Definire il programma Matematicamente in modo che sia composto da: una libreria trigonometria , al cui interno ci siano le funzioni coseno e seno per il calcolo, rispettivamente, del coseno a partire dal seno e del seno a partire dal coseno ; una libreria aritmetica , composta dalle funzioni aggiungi e moltiplica ; un file main.c all'interno del quale si richiamano le funzioni presenti nelle precedenti librerie. Soluzione S15.1 \u00b6 Ecco una possibile soluzione. Per la libreria trigonometria : // trigonometria.h #ifndef TRIGONOMETRIA_H #define TRIGONOMETRIA_H float coseno ( float seno ); float seno ( float coseno ); #endif // !TRIGONOMETRIA_H // trigonometria.c #include \"trigonometria.h\" #include <math.h> #include <stdio.h> float seno ( float coseno ) { float sin_quad = 1 - ( coseno * coseno ); printf ( \"%f \\n \" , sin_quad ); return sqrtf ( sin_quad ); } float coseno ( float seno ) { float cos_quad = 1 - ( seno * seno ); return sqrtf ( cos_quad ); } Per la libreria aritmetica : // aritmetica.h #ifndef ARITMETICA_H #define ARITMETICA_H int aggiungi ( int a , int b ); int moltiplica ( int a , int b ); #endif // !ARITMETICA_H // aritmetica.c #include \"aritmetica.h\" int aggiungi ( int a , int b ) { return a + b ; } int moltiplica ( int a , int b ) { return a * b ; } Ecco un esempio di file main.c : #include <stdio.h> #include \"aritmetica.h\" #include \"trigonometria.h\" int main () { int somma ; int prodotto ; int i = 2 ; int j = 3 ; somma = aggiungi ( i , j ); prodotto = moltiplica ( i , j ); printf ( \"La somma e' %d \\n \" , somma ); printf ( \"Il prodotto e' %d \\n \" , prodotto ); float cos ; cos = coseno ( 0.5 ); printf ( \"Il coseno e' %f \\n \" , cos ); float sin ; sin = seno ( 0.5 ); printf ( \"Il seno e' %f \\n \" , sin ); }","title":"E15 - Nozioni fondamentali sul C"},{"location":"material/03_c_language/15_fundamentals/exercises/#e15-nozioni-fondamentali-su-c","text":"","title":"E15 - Nozioni fondamentali su C"},{"location":"material/03_c_language/15_fundamentals/exercises/#esercizio-e151","text":"Definire il programma Matematicamente in modo che sia composto da: una libreria trigonometria , al cui interno ci siano le funzioni coseno e seno per il calcolo, rispettivamente, del coseno a partire dal seno e del seno a partire dal coseno ; una libreria aritmetica , composta dalle funzioni aggiungi e moltiplica ; un file main.c all'interno del quale si richiamano le funzioni presenti nelle precedenti librerie.","title":"Esercizio E15.1"},{"location":"material/03_c_language/15_fundamentals/exercises/#soluzione-s151","text":"Ecco una possibile soluzione. Per la libreria trigonometria : // trigonometria.h #ifndef TRIGONOMETRIA_H #define TRIGONOMETRIA_H float coseno ( float seno ); float seno ( float coseno ); #endif // !TRIGONOMETRIA_H // trigonometria.c #include \"trigonometria.h\" #include <math.h> #include <stdio.h> float seno ( float coseno ) { float sin_quad = 1 - ( coseno * coseno ); printf ( \"%f \\n \" , sin_quad ); return sqrtf ( sin_quad ); } float coseno ( float seno ) { float cos_quad = 1 - ( seno * seno ); return sqrtf ( cos_quad ); } Per la libreria aritmetica : // aritmetica.h #ifndef ARITMETICA_H #define ARITMETICA_H int aggiungi ( int a , int b ); int moltiplica ( int a , int b ); #endif // !ARITMETICA_H // aritmetica.c #include \"aritmetica.h\" int aggiungi ( int a , int b ) { return a + b ; } int moltiplica ( int a , int b ) { return a * b ; } Ecco un esempio di file main.c : #include <stdio.h> #include \"aritmetica.h\" #include \"trigonometria.h\" int main () { int somma ; int prodotto ; int i = 2 ; int j = 3 ; somma = aggiungi ( i , j ); prodotto = moltiplica ( i , j ); printf ( \"La somma e' %d \\n \" , somma ); printf ( \"Il prodotto e' %d \\n \" , prodotto ); float cos ; cos = coseno ( 0.5 ); printf ( \"Il coseno e' %f \\n \" , cos ); float sin ; sin = seno ( 0.5 ); printf ( \"Il seno e' %f \\n \" , sin ); }","title":"Soluzione S15.1"},{"location":"material/03_c_language/15_fundamentals/lecture/","text":"15 - Nozioni fondamentali su C \u00b6 In questo breve capitolo illustriamo alcuni concetti fondamentali da tenere a mente quando scriviamo un programma in C. 15.1 - Nozioni generali sulla struttura del programma \u00b6 La struttura di un programma C si basa su una serie di concetti ben definiti. Vediamoli rapidamente. 15.1.1 - Modularit\u00e0 \u00b6 I programmi scritti in C devono essere pensati come modulari , ovvero suddivisi in opportune sezioni (chiamate appunto moduli ) ognuna delle quali contiene informazioni ed istruzioni necessarie ad espletare una certa funzione. Ad esempio, se scrivessimo un ipotetico programma Calcolatrice , potremmo decidere di tenere separati i moduli Algebra , che si occuper\u00e0 delle operazioni algebriche, e Trigonometria , delegato alla gestione delle operazioni di natura trigonometrica. Modularit\u00e0 e funzionalit\u00e0 Idealmente, ciascun modulo deve espletare un'unica funzione ben definita, e non essere in alcun modo interdipendente dagli altri moduli. Tuttavia, molto spesso \u00e8 impossibile evitare completamente dette interdipendenze, per cui ci si assicura prevalentemente che il loro impatto sia minimo. 15.1.2 - File header e file sorgente \u00b6 Quando abbiamo introdotto l' Hello, World abbiamo visto che nella prima riga di codice era importato il file stdio.h , che abbiamo contestualmente detto essere rappresentativo di una libreria delegata alla gestione delle operazioni di input ed output da e verso diversi tipi di sorgente. Un file di questo tipo (ovvero un file con estensione .h ) \u00e8 chiamato file header , e contiene al suo interno una serie di prototipi , ovvero le definizioni di un insieme di funzioni. Ad ogni file header corrisponde un file sorgente , la cui estensione \u00e8 .c , nella quale le funzioni sono effettivamente implementate. Semplificando: in un file header, vi sono soltanto le \"firme\" delle funzioni, mentre nel file sorgente dette funzioni vengono effettivamente implementate. Tip Il motivo alla base della separazione tra file header e sorgenti \u00e8 da ricercarsi nel concetto di modularit\u00e0: infatti, in questo modo \u00e8 possibile separare l'effettiva implementazione di una serie di funzioni dal codice che le user\u00e0, interfacciandovisi esclusivamente mediante l'header. 15.1.2.1 - Un esempio \u00b6 Facciamo un breve esempio. Immaginiamo di voler scrivere il nostro programma calcola che implementa al suo interno due funzioni: aggiungi , che somma due numeri, e moltiplica , che moltiplica detti numeri tra loro. Per implementarlo, avremo bisogno di tre file: un file calcolatrice.c , nel quale sono contenuti i corpi delle funzioni aggiungi e moltiplica ; un file calcolatrice.h , ovvero l'header relativo al sorgente calcolatrice.c ; un file calcola.c , che rappresenta la parte di codice al cui interno \u00e8 contenuto il main . Quindi, il file calcolatrice.h conterr\u00e0 due definizioni: int aggiungi ( int a , int b ); int moltiplica ( int a , int b ); Il file calcolatrice.c conterr\u00e0 invece il corpo delle due funzioni definite nell'header: #include \"calcola.h\" aggiungi ( int a , int b ) { return a + b ; } moltiplica ( int a , int b ) { return a * b ; } Il file calcola.c conterr\u00e0 invece il metodo main : #include <stdio.h> #include \"calcola.h\" int main () { int somma = aggiungi ( 2 , 3 ); int prodotto = moltiplica ( 2 , 3 ); printf ( \"La somma di 2 e 3 e': %d \\n \" , somma ); printf ( \"Il prodotto di 2 per 3 e': %d \\n \" , prodotto ); } Alcune note: nel file header inseriamo esclusivamente i prototipi delle funzioni, senza alcuna implementazione; nel file sorgente includiamo l'header ed implementiamo le funzioni, omettendo il tipo di ritorno ( int in entrambi i casi); nel file principale includiamo l'header da noi definito specificando i doppi apici ; in questo modo, possiamo richiamare le funzioni definite in calcola.h . 15.1.3 - Direttive \u00b6 Abbiamo visto in precedenza come l'uso della direttiva #include permetta di \"incorporare\" all'interno del nostro programma funzioni definite ed implementate esternamente. Tuttavia, la direttiva #include non \u00e8 l'unica esistente: ne esistono infatti di diverse, alcune delle quali pi\u00f9 utilizzate di altre, ma tutte molto importanti. Ad esempio, gli header includono normalmente un riferimento ad almeno altre tre direttive, definite header guards , ovvero: #define : questa direttiva permette di definire un valore di sistema valido all'interno del programma; #ifndef : questa direttiva controlla se il valore immediatamente alla sua destra non \u00e8 gi\u00e0 stato definito mediante la direttiva #define , ed \u00e8 data dalla crasi della direttiva #if (equivalente appunto ad una verifica condizionale) e della direttiva #define \"negata\". Infatti, se analizziamo attentamente il nome della direttiva, possiamo vedere un'assonanza con i termini if not defined ; #endif : questa direttiva indica il termine della condizione di controllo. In base a queste nozioni, normalmente si modifica un header come segue: #ifndef HEADER.H #define HEADER.H // Prototipi delle funzioni... #endif Possiamo trasformare quindi il nostro calcolatrice.h come segue: // calcola.h #ifndef CALCOLA_H #define CALCOLA_H int aggiungi ( int a , int b ); int moltiplica ( int a , int b ); #endif Perch\u00e9 si usano le header guards? Il motivo alla base dell'uso delle header guards riguarda la necessit\u00e0 di evitare l'inclusione ripetuta dello stesso codice. Infatti, potrebbe capitare che l'header calcolatrice.h venga incluso in diverse parti del nostro codice, come ad esempio altri header; per evitare che in fase di compilazione del codice il codice incluso nel file sorgente calcolatrice.c venga \"copiato\" pi\u00f9 volte, si preferisce usare una header guard che fa s\u00ec che la direttiva #define non venga chiamata pi\u00f9 volte con lo stesso argomento. Per una lista completa di direttive C, potete consultare questo indirizzo . 15.2 - Nozioni generali sulla sintassi \u00b6 Vediamo adesso alcune nozioni generali da osservare sulla sintassi dei programmi in C. 15.2.1 - Parole riservate \u00b6 In C, come in ogni altro linguaggio di programmazione, esiste una serie di parole riservate , o keyword che, indicando delle specifiche funzionalit\u00e0 del linguaggio di programmazione, non possono in alcun modo essere utilizzate dall'utente. Normalmente, queste parole chiave si riferiscono ai tipi di una variabile, o indicano l'inizio di una struttura condizionale o di un ciclo, oppure ancora sono utilizzate per particolari funzionalit\u00e0 (come ad esempio le direttive viste in precedenza). Ad esempio, se provassimo a creare una variabile chiamandola int , avremmo un errore: int int = 10 ; error C2632: 'int' non pu\u00f2 essere seguito da 'int' error C2513: 'int' : nessuna variabile dichiarata prima di '=' Un elenco di keyword per il linguaggio C \u00e8 disponibile a questo indirizzo . 15.2.2 - Ambito e parentesi \u00b6 In C, come in molti altri linguaggi, l'uso delle parentesi non \u00e8 arbitrario, e segue una specifica convenzione. In particolare: le parentesi tonde devono essere utilizzate per delimitare i parametri di ingresso di una funzione, o anche una particolare espressione logica od aritmetica; le parentesi quadre definiscono un ambito locale. In altre parole, possiamo usare le parentesi tonde quando definiamo i parametri all'interno del prototipo di una funzione: int nome_funzione ( tipo_1 nome_par_1 , tipo_2 nome_par_2 ); oppure ancora quando valutiamo una condizione o creiamo un ciclo: if ( variabile_a < variabile_b ) // ... for ( int i = 0 ; i <= 10 ; i ++ ) // ... Le parentesi graffe indicano invece l'ambito di una funzione o di una struttura condizionale od iterativa. Ad esempio: aggiungi ( int a , int b ) { // qui inizia l'ambito della funzione aggiungi... return a + b ; } // e qui termina! if ( a < b ) { //qui inizia l'ambito della struttura condizionale... int c = a + b ; } // e qui termina! E le parentesi quadre? Le parentesi quadre hanno un utilizzo specifico per la definizione e l'accesso agli elementi di un array; ne parleremo pi\u00f9 avanti.","title":"15 - Nozioni fondamentali sul C"},{"location":"material/03_c_language/15_fundamentals/lecture/#15-nozioni-fondamentali-su-c","text":"In questo breve capitolo illustriamo alcuni concetti fondamentali da tenere a mente quando scriviamo un programma in C.","title":"15 - Nozioni fondamentali su C"},{"location":"material/03_c_language/15_fundamentals/lecture/#151-nozioni-generali-sulla-struttura-del-programma","text":"La struttura di un programma C si basa su una serie di concetti ben definiti. Vediamoli rapidamente.","title":"15.1 - Nozioni generali sulla struttura del programma"},{"location":"material/03_c_language/15_fundamentals/lecture/#1511-modularita","text":"I programmi scritti in C devono essere pensati come modulari , ovvero suddivisi in opportune sezioni (chiamate appunto moduli ) ognuna delle quali contiene informazioni ed istruzioni necessarie ad espletare una certa funzione. Ad esempio, se scrivessimo un ipotetico programma Calcolatrice , potremmo decidere di tenere separati i moduli Algebra , che si occuper\u00e0 delle operazioni algebriche, e Trigonometria , delegato alla gestione delle operazioni di natura trigonometrica. Modularit\u00e0 e funzionalit\u00e0 Idealmente, ciascun modulo deve espletare un'unica funzione ben definita, e non essere in alcun modo interdipendente dagli altri moduli. Tuttavia, molto spesso \u00e8 impossibile evitare completamente dette interdipendenze, per cui ci si assicura prevalentemente che il loro impatto sia minimo.","title":"15.1.1 - Modularit\u00e0"},{"location":"material/03_c_language/15_fundamentals/lecture/#1512-file-header-e-file-sorgente","text":"Quando abbiamo introdotto l' Hello, World abbiamo visto che nella prima riga di codice era importato il file stdio.h , che abbiamo contestualmente detto essere rappresentativo di una libreria delegata alla gestione delle operazioni di input ed output da e verso diversi tipi di sorgente. Un file di questo tipo (ovvero un file con estensione .h ) \u00e8 chiamato file header , e contiene al suo interno una serie di prototipi , ovvero le definizioni di un insieme di funzioni. Ad ogni file header corrisponde un file sorgente , la cui estensione \u00e8 .c , nella quale le funzioni sono effettivamente implementate. Semplificando: in un file header, vi sono soltanto le \"firme\" delle funzioni, mentre nel file sorgente dette funzioni vengono effettivamente implementate. Tip Il motivo alla base della separazione tra file header e sorgenti \u00e8 da ricercarsi nel concetto di modularit\u00e0: infatti, in questo modo \u00e8 possibile separare l'effettiva implementazione di una serie di funzioni dal codice che le user\u00e0, interfacciandovisi esclusivamente mediante l'header.","title":"15.1.2 - File header e file sorgente"},{"location":"material/03_c_language/15_fundamentals/lecture/#15121-un-esempio","text":"Facciamo un breve esempio. Immaginiamo di voler scrivere il nostro programma calcola che implementa al suo interno due funzioni: aggiungi , che somma due numeri, e moltiplica , che moltiplica detti numeri tra loro. Per implementarlo, avremo bisogno di tre file: un file calcolatrice.c , nel quale sono contenuti i corpi delle funzioni aggiungi e moltiplica ; un file calcolatrice.h , ovvero l'header relativo al sorgente calcolatrice.c ; un file calcola.c , che rappresenta la parte di codice al cui interno \u00e8 contenuto il main . Quindi, il file calcolatrice.h conterr\u00e0 due definizioni: int aggiungi ( int a , int b ); int moltiplica ( int a , int b ); Il file calcolatrice.c conterr\u00e0 invece il corpo delle due funzioni definite nell'header: #include \"calcola.h\" aggiungi ( int a , int b ) { return a + b ; } moltiplica ( int a , int b ) { return a * b ; } Il file calcola.c conterr\u00e0 invece il metodo main : #include <stdio.h> #include \"calcola.h\" int main () { int somma = aggiungi ( 2 , 3 ); int prodotto = moltiplica ( 2 , 3 ); printf ( \"La somma di 2 e 3 e': %d \\n \" , somma ); printf ( \"Il prodotto di 2 per 3 e': %d \\n \" , prodotto ); } Alcune note: nel file header inseriamo esclusivamente i prototipi delle funzioni, senza alcuna implementazione; nel file sorgente includiamo l'header ed implementiamo le funzioni, omettendo il tipo di ritorno ( int in entrambi i casi); nel file principale includiamo l'header da noi definito specificando i doppi apici ; in questo modo, possiamo richiamare le funzioni definite in calcola.h .","title":"15.1.2.1 - Un esempio"},{"location":"material/03_c_language/15_fundamentals/lecture/#1513-direttive","text":"Abbiamo visto in precedenza come l'uso della direttiva #include permetta di \"incorporare\" all'interno del nostro programma funzioni definite ed implementate esternamente. Tuttavia, la direttiva #include non \u00e8 l'unica esistente: ne esistono infatti di diverse, alcune delle quali pi\u00f9 utilizzate di altre, ma tutte molto importanti. Ad esempio, gli header includono normalmente un riferimento ad almeno altre tre direttive, definite header guards , ovvero: #define : questa direttiva permette di definire un valore di sistema valido all'interno del programma; #ifndef : questa direttiva controlla se il valore immediatamente alla sua destra non \u00e8 gi\u00e0 stato definito mediante la direttiva #define , ed \u00e8 data dalla crasi della direttiva #if (equivalente appunto ad una verifica condizionale) e della direttiva #define \"negata\". Infatti, se analizziamo attentamente il nome della direttiva, possiamo vedere un'assonanza con i termini if not defined ; #endif : questa direttiva indica il termine della condizione di controllo. In base a queste nozioni, normalmente si modifica un header come segue: #ifndef HEADER.H #define HEADER.H // Prototipi delle funzioni... #endif Possiamo trasformare quindi il nostro calcolatrice.h come segue: // calcola.h #ifndef CALCOLA_H #define CALCOLA_H int aggiungi ( int a , int b ); int moltiplica ( int a , int b ); #endif Perch\u00e9 si usano le header guards? Il motivo alla base dell'uso delle header guards riguarda la necessit\u00e0 di evitare l'inclusione ripetuta dello stesso codice. Infatti, potrebbe capitare che l'header calcolatrice.h venga incluso in diverse parti del nostro codice, come ad esempio altri header; per evitare che in fase di compilazione del codice il codice incluso nel file sorgente calcolatrice.c venga \"copiato\" pi\u00f9 volte, si preferisce usare una header guard che fa s\u00ec che la direttiva #define non venga chiamata pi\u00f9 volte con lo stesso argomento. Per una lista completa di direttive C, potete consultare questo indirizzo .","title":"15.1.3 - Direttive"},{"location":"material/03_c_language/15_fundamentals/lecture/#152-nozioni-generali-sulla-sintassi","text":"Vediamo adesso alcune nozioni generali da osservare sulla sintassi dei programmi in C.","title":"15.2 - Nozioni generali sulla sintassi"},{"location":"material/03_c_language/15_fundamentals/lecture/#1521-parole-riservate","text":"In C, come in ogni altro linguaggio di programmazione, esiste una serie di parole riservate , o keyword che, indicando delle specifiche funzionalit\u00e0 del linguaggio di programmazione, non possono in alcun modo essere utilizzate dall'utente. Normalmente, queste parole chiave si riferiscono ai tipi di una variabile, o indicano l'inizio di una struttura condizionale o di un ciclo, oppure ancora sono utilizzate per particolari funzionalit\u00e0 (come ad esempio le direttive viste in precedenza). Ad esempio, se provassimo a creare una variabile chiamandola int , avremmo un errore: int int = 10 ; error C2632: 'int' non pu\u00f2 essere seguito da 'int' error C2513: 'int' : nessuna variabile dichiarata prima di '=' Un elenco di keyword per il linguaggio C \u00e8 disponibile a questo indirizzo .","title":"15.2.1 - Parole riservate"},{"location":"material/03_c_language/15_fundamentals/lecture/#1522-ambito-e-parentesi","text":"In C, come in molti altri linguaggi, l'uso delle parentesi non \u00e8 arbitrario, e segue una specifica convenzione. In particolare: le parentesi tonde devono essere utilizzate per delimitare i parametri di ingresso di una funzione, o anche una particolare espressione logica od aritmetica; le parentesi quadre definiscono un ambito locale. In altre parole, possiamo usare le parentesi tonde quando definiamo i parametri all'interno del prototipo di una funzione: int nome_funzione ( tipo_1 nome_par_1 , tipo_2 nome_par_2 ); oppure ancora quando valutiamo una condizione o creiamo un ciclo: if ( variabile_a < variabile_b ) // ... for ( int i = 0 ; i <= 10 ; i ++ ) // ... Le parentesi graffe indicano invece l'ambito di una funzione o di una struttura condizionale od iterativa. Ad esempio: aggiungi ( int a , int b ) { // qui inizia l'ambito della funzione aggiungi... return a + b ; } // e qui termina! if ( a < b ) { //qui inizia l'ambito della struttura condizionale... int c = a + b ; } // e qui termina! E le parentesi quadre? Le parentesi quadre hanno un utilizzo specifico per la definizione e l'accesso agli elementi di un array; ne parleremo pi\u00f9 avanti.","title":"15.2.2 - Ambito e parentesi"},{"location":"material/03_c_language/16_scope/exercises/","text":"E16 - Ambito di una variabile \u00b6 Esercizio E16.1 \u00b6 Scrivere in linguaggio C un programma che definisca due funzioni. Nella prima, chiamata calcola_area_quadrato , viene calcolata e stampata a schermo l'area di un quadrato. Nella seconda, chiamata calcola_perimetro_quadrato , viene calcolato e stampato a schermo il perimetro dello stesso quadrato. Entrambe le funzioni accettano come argomento il parametro lato di tipo intero. Utilizzare, ove possibile, un approccio modulare, suddividendo il codice in header e sorgenti. Soluzione S16.1 \u00b6 Possiamo organizzare il codice rispettando la struttura suggerita da Visual Studio Community o, in alternativa, creando all'interno della stessa cartella tre file, un main.c , che sar\u00e0 il file sorgente principale, un funzioni.c , che sar\u00e0 il sorgente per le funzioni che scriveremo nel codice, ed un funzioni.h , che sar\u00e0 l'header relativo alle stesse funzioni. Di seguito una possibile implementazione. File main.c \u00b6 Il file main.c conterr\u00e0 le istruzioni principali del nostro programma. /** * File main.c. * * Rappresenta il punto di accesso principale al programma. */ #include <stdio.h> #include \"funzioni.h\" int lato = 5 ; int main () { int area = calcola_area_quadrato ( lato ); int perimetro = calcola_perimetro_quadrato ( lato ); return 0 ; } All'interno del file sorgente andremo a: creare una variabile globale chiamata lato a cui sar\u00e0 assegnato il valore 5; definire la funzione main . All'interno della funzione main : invochiamo la funzione calcola_area_quadrato passando come argomento lato ; invochiamo la funzione calcola_perimetro_quadrato passando come argomento lato . File funzioni.h \u00b6 Il file funzioni.h \u00e8 un classico file header, nel quale andremo ad inserire i prototipi delle due funzioni che andremo poi ad implementare nel codice. #ifndef FUNZIONI_H #define FUNZIONI_H int calcola_area_quadrato ( int lato ); int calcola_perimetro_quadrato ( int lato ); #endif File funzioni.c \u00b6 Il file funzioni.c conterr\u00e0 l'implementazione delle funzioni definite nell'header. #include \"funzioni.h\" #include <stdio.h> int calcola_area_quadrato ( int lato ) { int area = lato * lato ; printf ( \"Valore area: %d \\n \" , area ); return area ; } int calcola_perimetro_quadrato ( int lato ) { int perimetro = lato * 4 ; printf ( \"Valore perimetro: %d \\n \" , perimetro ); return perimetro ; } Le funzioni in s\u00e9 sono abbastanza semplici da interpretare, infatti entrambe calcolano rispettivamente area e perimetro di un quadrato, stampano il valore a schermo e restituiscono il valore calcolato.","title":"E16 - Ambito di una variabile"},{"location":"material/03_c_language/16_scope/exercises/#e16-ambito-di-una-variabile","text":"","title":"E16 - Ambito di una variabile"},{"location":"material/03_c_language/16_scope/exercises/#esercizio-e161","text":"Scrivere in linguaggio C un programma che definisca due funzioni. Nella prima, chiamata calcola_area_quadrato , viene calcolata e stampata a schermo l'area di un quadrato. Nella seconda, chiamata calcola_perimetro_quadrato , viene calcolato e stampato a schermo il perimetro dello stesso quadrato. Entrambe le funzioni accettano come argomento il parametro lato di tipo intero. Utilizzare, ove possibile, un approccio modulare, suddividendo il codice in header e sorgenti.","title":"Esercizio E16.1"},{"location":"material/03_c_language/16_scope/exercises/#soluzione-s161","text":"Possiamo organizzare il codice rispettando la struttura suggerita da Visual Studio Community o, in alternativa, creando all'interno della stessa cartella tre file, un main.c , che sar\u00e0 il file sorgente principale, un funzioni.c , che sar\u00e0 il sorgente per le funzioni che scriveremo nel codice, ed un funzioni.h , che sar\u00e0 l'header relativo alle stesse funzioni. Di seguito una possibile implementazione.","title":"Soluzione S16.1"},{"location":"material/03_c_language/16_scope/exercises/#file-mainc","text":"Il file main.c conterr\u00e0 le istruzioni principali del nostro programma. /** * File main.c. * * Rappresenta il punto di accesso principale al programma. */ #include <stdio.h> #include \"funzioni.h\" int lato = 5 ; int main () { int area = calcola_area_quadrato ( lato ); int perimetro = calcola_perimetro_quadrato ( lato ); return 0 ; } All'interno del file sorgente andremo a: creare una variabile globale chiamata lato a cui sar\u00e0 assegnato il valore 5; definire la funzione main . All'interno della funzione main : invochiamo la funzione calcola_area_quadrato passando come argomento lato ; invochiamo la funzione calcola_perimetro_quadrato passando come argomento lato .","title":"File main.c"},{"location":"material/03_c_language/16_scope/exercises/#file-funzionih","text":"Il file funzioni.h \u00e8 un classico file header, nel quale andremo ad inserire i prototipi delle due funzioni che andremo poi ad implementare nel codice. #ifndef FUNZIONI_H #define FUNZIONI_H int calcola_area_quadrato ( int lato ); int calcola_perimetro_quadrato ( int lato ); #endif","title":"File funzioni.h"},{"location":"material/03_c_language/16_scope/exercises/#file-funzionic","text":"Il file funzioni.c conterr\u00e0 l'implementazione delle funzioni definite nell'header. #include \"funzioni.h\" #include <stdio.h> int calcola_area_quadrato ( int lato ) { int area = lato * lato ; printf ( \"Valore area: %d \\n \" , area ); return area ; } int calcola_perimetro_quadrato ( int lato ) { int perimetro = lato * 4 ; printf ( \"Valore perimetro: %d \\n \" , perimetro ); return perimetro ; } Le funzioni in s\u00e9 sono abbastanza semplici da interpretare, infatti entrambe calcolano rispettivamente area e perimetro di un quadrato, stampano il valore a schermo e restituiscono il valore calcolato.","title":"File funzioni.c"},{"location":"material/03_c_language/16_scope/lecture/","text":"16 - Visibilit\u00e0 di una variabile \u00b6 Nella lezione 9 abbiamo trattato dell'ambito di una variabile. Estendiamo il discorso, e parliamo del concetto di visibilit\u00e0 di una variabile nel linguaggio C. Per comprendere il concetto, facciamo un esempio. 16.1 - Un esempio \u00b6 Supponiamo di scrivere un programma C che definisca due funzioni in aggiunta al main , le quali accettano come parametro in ingresso un numero intero rappresentativo del lato di un quadrato. Le due funzioni dovranno, rispettivamente, calcolare l'area ed il perimetro del quadrato; provvediamo quindi all'implementazione delle stesse. In particolare, facciamo in modo che all'interno della funzione calcola_area_quadrato vengano mostrati a schermo i valori dell'area e del perimetro del quadrato. #include <stdio.h> int calcola_area_quadrato ( int lato ) { int area = lato * lato ; printf ( \"Valore area: %d\" , area ); printf ( \"Valore perimetro: %d\" , perimetro ); return area ; } int calcola_perimetro_quadrato ( int lato ) { int perimetro = lato * 4 ; return perimetro ; } Proviamo adesso a richiamare entrambe le funzioni dal main . int main () { int lato = 5 ; int area = calcola_area_quadrato ( lato ); int perimetro = calcola_perimetro_quadrato ( lato ); return 0 ; } Provando ad eseguire questo programma con Visual Studio Community, otterremo in uscita due errori del tipo: E0020: identificatore \"perimetro\" non definito C2065: 'perimetro' : identificatore non dichiarato I due errori precedenti ci suggeriscono che la variabile perimetro non sia \"visibile\", e di conseguenza accessibile , dall'interno dell'ambito definito dalla funzione calcola_area_quadrato . Per risolvere questo errore, possiamo provare a stampare i valori a schermo direttamente dal main . Modifichiamo la funzione calcola_area_quadrato come segue: int calcola_area_quadrato ( int lato ) { int area = lato * lato ; return area ; } Modifichiamo adesso il main : int main () { int lato = 5 ; int area = calcola_area_quadrato ( lato ); int perimetro = calcola_perimetro_quadrato ( lato ); printf ( \"Valore area: %d \\n \" , area ); printf ( \"Valore perimetro: %d \\n \" , perimetro ); return 0 ; } Questa volta, vedremo che l'output a schermo \u00e8 correttamente dato da: Valore area: 25 Valore perimetro: 20 Abbiamo quindi visto come il concetto di ambito di una variabile possa essere foriero di errori se non compreso alla perfezione. Inoltre, \u00e8 preferibile prestare particolare attenzione ai nomi assegnati alle variabili, che idealmente non dovrebbero \"sovrapporsi\" onde evitare confusione (torneremo su quest'ultimo aspetto in seguito quando parleremo di passaggio per valore e per reference ). Inoltre, \u00e8 opportuno tenere sempre a mente che, in caso di ambiguit\u00e0, verr\u00e0 sempre data precedenza alla variabile locale. Ambito delle variabili nel main Contrariamente a quanto si potrebbe pensare, il main non definisce un ambito globale per le variabili . Per verificarlo, proviamo a modificare la funzione calcola area quadrato come segue: int calcola_area_quadrato ( int l ) { printf ( \"Lato: %d \\n \" , lato ); int area = l * l ; return area ; } Noteremo anche in questo caso la coppia di errori E0020 e C2065 , che ci indicheranno la mancanza di visibilit\u00e0 dell'identificativo lato . 16.2 - Un altro esempio \u00b6 Approfondiamo ulteriormente il concetto di visibilit\u00e0 con un altro esempio. Supponiamo, in questo caso, di definire all'interno di un programma C una funzione incrementa . Questa funzione, come suggerisce il nome stesso, ha al suo interno una variabile (locale) di tipo intero chiamata contatore , la quale aumenta di uno ogni volta che incrementa viene chiamata. #include <stdio.h> int incrementa () { int contatore = 0 ; contatore ++ ; return contatore ; } Proviamo a chiamare due volte questa funzione dal main . Cosa ci aspettiamo? int main () { printf ( \"Valore contatore: %d \\n \" , incrementa ()); printf ( \"Valore contatore: %d \\n \" , incrementa ()); return 0 ; } Ovviamente, vedremo a schermo due volte il valore 1 : ci\u00f2 \u00e8 legato al fatto che la variabile contatore ha visibilit\u00e0 limitata all'ambito della funzione incrementa , e quindi viene \"eliminata\" (o, per meglio dire, distrutta ) una volta usciti dall'ambito della funzione stessa. In tal senso, possiamo definire una variabile a visibilit\u00e0 pi\u00f9 \"ampia\", andando a modificare il codice come segue: #include <stdio.h> int contatore = 0 ; void incrementa () { contatore ++ ; } int main () { incrementa (); printf ( \"Valore contatore: %d \\n \" , contatore ); incrementa (); printf ( \"Valore contatore: %d \\n \" , contatore ); return 0 ; } In questo caso, abbiamo definito una variabile globale chiamata contatore , di valore iniziale pari a 0 , che viene incrementata ad ogni chiamata della funzione incrementa() . Ovviamente, l'output sar\u00e0 quello atteso, e vedremo che al termine dell'esecuzione del programma il valore di contatore sar\u00e0 pari a 2 . Il valore di ritorno void Notiamo che la funzione incrementa non restituisce alcun valore, in quanto opera su una variabile di tipo globale. In questo caso, indichiamo come tipo di ritorno void (letteralmente vuoto in inglese).","title":"16 - Ambito di una variabile"},{"location":"material/03_c_language/16_scope/lecture/#16-visibilita-di-una-variabile","text":"Nella lezione 9 abbiamo trattato dell'ambito di una variabile. Estendiamo il discorso, e parliamo del concetto di visibilit\u00e0 di una variabile nel linguaggio C. Per comprendere il concetto, facciamo un esempio.","title":"16 - Visibilit\u00e0 di una variabile"},{"location":"material/03_c_language/16_scope/lecture/#161-un-esempio","text":"Supponiamo di scrivere un programma C che definisca due funzioni in aggiunta al main , le quali accettano come parametro in ingresso un numero intero rappresentativo del lato di un quadrato. Le due funzioni dovranno, rispettivamente, calcolare l'area ed il perimetro del quadrato; provvediamo quindi all'implementazione delle stesse. In particolare, facciamo in modo che all'interno della funzione calcola_area_quadrato vengano mostrati a schermo i valori dell'area e del perimetro del quadrato. #include <stdio.h> int calcola_area_quadrato ( int lato ) { int area = lato * lato ; printf ( \"Valore area: %d\" , area ); printf ( \"Valore perimetro: %d\" , perimetro ); return area ; } int calcola_perimetro_quadrato ( int lato ) { int perimetro = lato * 4 ; return perimetro ; } Proviamo adesso a richiamare entrambe le funzioni dal main . int main () { int lato = 5 ; int area = calcola_area_quadrato ( lato ); int perimetro = calcola_perimetro_quadrato ( lato ); return 0 ; } Provando ad eseguire questo programma con Visual Studio Community, otterremo in uscita due errori del tipo: E0020: identificatore \"perimetro\" non definito C2065: 'perimetro' : identificatore non dichiarato I due errori precedenti ci suggeriscono che la variabile perimetro non sia \"visibile\", e di conseguenza accessibile , dall'interno dell'ambito definito dalla funzione calcola_area_quadrato . Per risolvere questo errore, possiamo provare a stampare i valori a schermo direttamente dal main . Modifichiamo la funzione calcola_area_quadrato come segue: int calcola_area_quadrato ( int lato ) { int area = lato * lato ; return area ; } Modifichiamo adesso il main : int main () { int lato = 5 ; int area = calcola_area_quadrato ( lato ); int perimetro = calcola_perimetro_quadrato ( lato ); printf ( \"Valore area: %d \\n \" , area ); printf ( \"Valore perimetro: %d \\n \" , perimetro ); return 0 ; } Questa volta, vedremo che l'output a schermo \u00e8 correttamente dato da: Valore area: 25 Valore perimetro: 20 Abbiamo quindi visto come il concetto di ambito di una variabile possa essere foriero di errori se non compreso alla perfezione. Inoltre, \u00e8 preferibile prestare particolare attenzione ai nomi assegnati alle variabili, che idealmente non dovrebbero \"sovrapporsi\" onde evitare confusione (torneremo su quest'ultimo aspetto in seguito quando parleremo di passaggio per valore e per reference ). Inoltre, \u00e8 opportuno tenere sempre a mente che, in caso di ambiguit\u00e0, verr\u00e0 sempre data precedenza alla variabile locale. Ambito delle variabili nel main Contrariamente a quanto si potrebbe pensare, il main non definisce un ambito globale per le variabili . Per verificarlo, proviamo a modificare la funzione calcola area quadrato come segue: int calcola_area_quadrato ( int l ) { printf ( \"Lato: %d \\n \" , lato ); int area = l * l ; return area ; } Noteremo anche in questo caso la coppia di errori E0020 e C2065 , che ci indicheranno la mancanza di visibilit\u00e0 dell'identificativo lato .","title":"16.1 - Un esempio"},{"location":"material/03_c_language/16_scope/lecture/#162-un-altro-esempio","text":"Approfondiamo ulteriormente il concetto di visibilit\u00e0 con un altro esempio. Supponiamo, in questo caso, di definire all'interno di un programma C una funzione incrementa . Questa funzione, come suggerisce il nome stesso, ha al suo interno una variabile (locale) di tipo intero chiamata contatore , la quale aumenta di uno ogni volta che incrementa viene chiamata. #include <stdio.h> int incrementa () { int contatore = 0 ; contatore ++ ; return contatore ; } Proviamo a chiamare due volte questa funzione dal main . Cosa ci aspettiamo? int main () { printf ( \"Valore contatore: %d \\n \" , incrementa ()); printf ( \"Valore contatore: %d \\n \" , incrementa ()); return 0 ; } Ovviamente, vedremo a schermo due volte il valore 1 : ci\u00f2 \u00e8 legato al fatto che la variabile contatore ha visibilit\u00e0 limitata all'ambito della funzione incrementa , e quindi viene \"eliminata\" (o, per meglio dire, distrutta ) una volta usciti dall'ambito della funzione stessa. In tal senso, possiamo definire una variabile a visibilit\u00e0 pi\u00f9 \"ampia\", andando a modificare il codice come segue: #include <stdio.h> int contatore = 0 ; void incrementa () { contatore ++ ; } int main () { incrementa (); printf ( \"Valore contatore: %d \\n \" , contatore ); incrementa (); printf ( \"Valore contatore: %d \\n \" , contatore ); return 0 ; } In questo caso, abbiamo definito una variabile globale chiamata contatore , di valore iniziale pari a 0 , che viene incrementata ad ogni chiamata della funzione incrementa() . Ovviamente, l'output sar\u00e0 quello atteso, e vedremo che al termine dell'esecuzione del programma il valore di contatore sar\u00e0 pari a 2 . Il valore di ritorno void Notiamo che la funzione incrementa non restituisce alcun valore, in quanto opera su una variabile di tipo globale. In questo caso, indichiamo come tipo di ritorno void (letteralmente vuoto in inglese).","title":"16.2 - Un altro esempio"},{"location":"material/03_c_language/17_operators/exercises/","text":"E17 - Operatori nel linguaggio C \u00b6 Esercizio E17.1 \u00b6 Scriviamo un programma che calcoli il quadrato di un numero. Soluzione S17.1 \u00b6 #include <stdio.h> int quadrato ( int n ) { return n * n ; // Analogamente potremmo scrivere n ^ 2 } int main () { int l = 3 ; int q = quadrato ( l ); printf ( \"Il quadrato di %d \u00e8 %d \\n \" , l , q ); return 0 ; } Esercizio E17.2 \u00b6 Scriviamo un programma che determini se un numero \u00e8 pari. In tal senso, utilizzare l'operatore di confronto == per confrontare due variabili. Soluzione S17.2 \u00b6 Ecco una possibile soluzione: #include <stdio.h> int numero_pari ( int n ) { if ( n % 2 == 0 ) { return 1 ; } return 0 ; } void scrivi_pari_o_dispari ( int numero , int pari_dispari ) { if ( pari_dispari == 0 ) { printf ( \"Il valore %d \u00e8 dispari\" , numero ); } else if ( pari_dispari == 1 ) { printf ( \"Il valore %d \u00e8 pari\" , numero ); } else { printf ( \"C'\u00e8 stato un errore. Riprovare.\" ); } } int main () { int a = 4 ; int b = 5 ; scrivi_pari_o_dispari ( a , numero_pari ( a )); scrivi_pari_o_dispari ( b , numero_pari ( b )); return 0 ; } Alcune note: nella funzione numero_pari valutiamo un numero come pari se e solo se il resto della divisione dello stesso per due \u00e8 pari a 0; nella funzione scrivi_pari_o_dispari prendiamo il valore in uscita dalla funzione numero_pari e lo usiamo per scrivere a schermo se siamo la condizione di parit\u00e0 \u00e8 rispettata. Esercizio E17.3 \u00b6 Scriviamo un programma che confronti due intervalli di valori \\([a, b]\\) e \\([c, d]\\) , con \\(a\\) , \\(b\\) , \\(c\\) e \\(d\\) numeri interi. Il programma deve stampare a schermo il maggiore tra gli estremi inferiori \\(a\\) e \\(c\\) , il minore tra gli estremi superiori \\(b\\) e \\(d\\) , e stabilire se il numero di elementi presenti nei due intervalli \u00e8 lo stesso. Soluzione S17.3 \u00b6 Ecco una possibile soluzione: #include <stdio.h> void compara_estremi_inferiori ( int a , int c ) { if ( a < c ) { printf ( \"L'estremo inferiore di valore minore \u00e8 %d \\n \" , a ); } else if ( a > c ) { printf ( \"L'estremo inferiore di valore minore \u00e8 %d \\n \" , c ); } else { printf ( \"I due estremi inferiori hanno lo stesso valore \\n \" ); } } void compara_estremi_superiori ( int b , int d ) { if ( b < d ) { printf ( \"L'estremo superiore di valore maggiore \u00e8 %d \\n \" , d ); } else if ( b > d ) { printf ( \"L'estremo superiore di valore maggiore \u00e8 %d \\n \" , b ); } else { printf ( \"I due estremi superiori hanno lo stesso valore \\n \" ); } } void compara_intervalli ( int a , int b , int c , int d ) { int els_ac = c - a ; int els_bd = d - b ; if ( els_ac > els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , a , c , b , d ); } else if ( els_ac < els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , b , d , a , c ); } else { printf ( \"I due intervalli hanno lo stesso numero di elementi\" ); } } int main () { int a = 5 ; int b = 7 ; int c = 10 ; int d = 14 ; compara_estremi_inferiori ( a , c ); compara_estremi_superiori ( b , d ); compara_intervalli ( a , b , c , d ); return 0 ; } Esercizio E17.4 \u00b6 Dati gli intervalli visti nell\u2019esercizio 17.3, scrivere un programma che indichi se questi hanno lo stesso numero di elementi e gli estremi coincidono, oppure se solo una di queste condizioni \u00e8 verificata. Usare solo operatori logici. Soluzione S17.4 \u00b6 Possiamo integrare le seguenti istruzioni nella funzione compara_intervalli . void compara_intervalli ( int a , int b , int c , int d ) { int els_ac = c - a ; int els_bd = d - b ; if ( els_ac > els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , a , c , b , d ); } else if ( els_ac < els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , b , d , a , c ); } else { printf ( \"I due intervalli hanno lo stesso numero di elementi\" ); } if (( a == c ) && ( b == d ) && ( els_ac == els_bd )) { printf ( \"Gli intervalli coincidono, ed i due estremi hanno lo stesso numero di elementi\" ); } else if (( a == c ) && ( b == d ) || ( els_ac == els_bd )) { printf ( \"Gli intervalli coincidono, o i due estremi hanno lo stesso numero di elementi\" ); } } Nota Ovviamente, se gli estremi coincidono allora i due insiemi hanno necessariamente lo stesso numero di elementi. Tuttavia, a scopo di esempio, ignoriamo questo (ovvio) fenomeno.","title":"E17 - Operatori in C"},{"location":"material/03_c_language/17_operators/exercises/#e17-operatori-nel-linguaggio-c","text":"","title":"E17 - Operatori nel linguaggio C"},{"location":"material/03_c_language/17_operators/exercises/#esercizio-e171","text":"Scriviamo un programma che calcoli il quadrato di un numero.","title":"Esercizio E17.1"},{"location":"material/03_c_language/17_operators/exercises/#soluzione-s171","text":"#include <stdio.h> int quadrato ( int n ) { return n * n ; // Analogamente potremmo scrivere n ^ 2 } int main () { int l = 3 ; int q = quadrato ( l ); printf ( \"Il quadrato di %d \u00e8 %d \\n \" , l , q ); return 0 ; }","title":"Soluzione S17.1"},{"location":"material/03_c_language/17_operators/exercises/#esercizio-e172","text":"Scriviamo un programma che determini se un numero \u00e8 pari. In tal senso, utilizzare l'operatore di confronto == per confrontare due variabili.","title":"Esercizio E17.2"},{"location":"material/03_c_language/17_operators/exercises/#soluzione-s172","text":"Ecco una possibile soluzione: #include <stdio.h> int numero_pari ( int n ) { if ( n % 2 == 0 ) { return 1 ; } return 0 ; } void scrivi_pari_o_dispari ( int numero , int pari_dispari ) { if ( pari_dispari == 0 ) { printf ( \"Il valore %d \u00e8 dispari\" , numero ); } else if ( pari_dispari == 1 ) { printf ( \"Il valore %d \u00e8 pari\" , numero ); } else { printf ( \"C'\u00e8 stato un errore. Riprovare.\" ); } } int main () { int a = 4 ; int b = 5 ; scrivi_pari_o_dispari ( a , numero_pari ( a )); scrivi_pari_o_dispari ( b , numero_pari ( b )); return 0 ; } Alcune note: nella funzione numero_pari valutiamo un numero come pari se e solo se il resto della divisione dello stesso per due \u00e8 pari a 0; nella funzione scrivi_pari_o_dispari prendiamo il valore in uscita dalla funzione numero_pari e lo usiamo per scrivere a schermo se siamo la condizione di parit\u00e0 \u00e8 rispettata.","title":"Soluzione S17.2"},{"location":"material/03_c_language/17_operators/exercises/#esercizio-e173","text":"Scriviamo un programma che confronti due intervalli di valori \\([a, b]\\) e \\([c, d]\\) , con \\(a\\) , \\(b\\) , \\(c\\) e \\(d\\) numeri interi. Il programma deve stampare a schermo il maggiore tra gli estremi inferiori \\(a\\) e \\(c\\) , il minore tra gli estremi superiori \\(b\\) e \\(d\\) , e stabilire se il numero di elementi presenti nei due intervalli \u00e8 lo stesso.","title":"Esercizio E17.3"},{"location":"material/03_c_language/17_operators/exercises/#soluzione-s173","text":"Ecco una possibile soluzione: #include <stdio.h> void compara_estremi_inferiori ( int a , int c ) { if ( a < c ) { printf ( \"L'estremo inferiore di valore minore \u00e8 %d \\n \" , a ); } else if ( a > c ) { printf ( \"L'estremo inferiore di valore minore \u00e8 %d \\n \" , c ); } else { printf ( \"I due estremi inferiori hanno lo stesso valore \\n \" ); } } void compara_estremi_superiori ( int b , int d ) { if ( b < d ) { printf ( \"L'estremo superiore di valore maggiore \u00e8 %d \\n \" , d ); } else if ( b > d ) { printf ( \"L'estremo superiore di valore maggiore \u00e8 %d \\n \" , b ); } else { printf ( \"I due estremi superiori hanno lo stesso valore \\n \" ); } } void compara_intervalli ( int a , int b , int c , int d ) { int els_ac = c - a ; int els_bd = d - b ; if ( els_ac > els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , a , c , b , d ); } else if ( els_ac < els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , b , d , a , c ); } else { printf ( \"I due intervalli hanno lo stesso numero di elementi\" ); } } int main () { int a = 5 ; int b = 7 ; int c = 10 ; int d = 14 ; compara_estremi_inferiori ( a , c ); compara_estremi_superiori ( b , d ); compara_intervalli ( a , b , c , d ); return 0 ; }","title":"Soluzione S17.3"},{"location":"material/03_c_language/17_operators/exercises/#esercizio-e174","text":"Dati gli intervalli visti nell\u2019esercizio 17.3, scrivere un programma che indichi se questi hanno lo stesso numero di elementi e gli estremi coincidono, oppure se solo una di queste condizioni \u00e8 verificata. Usare solo operatori logici.","title":"Esercizio E17.4"},{"location":"material/03_c_language/17_operators/exercises/#soluzione-s174","text":"Possiamo integrare le seguenti istruzioni nella funzione compara_intervalli . void compara_intervalli ( int a , int b , int c , int d ) { int els_ac = c - a ; int els_bd = d - b ; if ( els_ac > els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , a , c , b , d ); } else if ( els_ac < els_bd ) { printf ( \"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\" , b , d , a , c ); } else { printf ( \"I due intervalli hanno lo stesso numero di elementi\" ); } if (( a == c ) && ( b == d ) && ( els_ac == els_bd )) { printf ( \"Gli intervalli coincidono, ed i due estremi hanno lo stesso numero di elementi\" ); } else if (( a == c ) && ( b == d ) || ( els_ac == els_bd )) { printf ( \"Gli intervalli coincidono, o i due estremi hanno lo stesso numero di elementi\" ); } } Nota Ovviamente, se gli estremi coincidono allora i due insiemi hanno necessariamente lo stesso numero di elementi. Tuttavia, a scopo di esempio, ignoriamo questo (ovvio) fenomeno.","title":"Soluzione S17.4"},{"location":"material/03_c_language/17_operators/lecture/","text":"17 - Operatori in C \u00b6 In matematica, un operatore \u00e8 comunemente inteso come una azione su uno o pi\u00f9 dati, o operandi . Un semplice esempio \u00e8 dato dai comuni operatori di tipo aritmetico, come quello di somma, che permette (appunto) di sommare le quantit\u00e0 a destra e sinistra dell'operatore + . In questa lezione approfondiremo il concetto di operatore, e ne vedremo alcuni tra i pi\u00f9 utilizzati nel linguaggio C. 17.1 - Operatori ed espressioni \u00b6 Generalmente, nei linguaggi di programmazione esistono due tipi di operatori: gli operatori binari , che agiscono su di una coppia di dati (normalmente a sinistra ed a destra dell'operatore); gli operatori unari , che agiscono su un singolo dato. In particolare, il dato a sinistra dell'operatore \u00e8 chiamato l-value , mentre quello a destra dell'operatore \u00e8 detto r-value . Gli operatori possono essere concatenati all'interno di un' espressione , intesa quindi come sequenza di operatori regolata da due principi: il principio di precedenza , valente soltanto in caso di pi\u00f9 operatori, che prevede che le operazioni ad essere eseguite per prime siano quelle tra parentesi tonde, e che successivamente si segua un ordine da sinistra verso destra; il principio di associativit\u00e0 indica l'ordine con cui sono valutati gli operatori, anche in questo caso prevalentemente da sinistra verso destra. 17.2 - L'operatore di assegnazione \u00b6 L'operatore di assegnazione, contraddistinto dal simbolo uguale = , permette di assegnare un dato valore ad una variabile. Abbiamo gi\u00e0 usato questo operatore pi\u00f9 volte in fase di inizializzazione: int a = 10 ; char c = 'b' ; Importantissimo sottolineare come l'operatore di assegnazione non valuti il valore di una variabile , ma si limiti ad assegnarne uno nuovo. 17.3 - Gli operatori matematici \u00b6 Gli operatori matematici sono quelli coinvolti in tutte le operazioni di tipo aritmetico che \u00e8 possibile effettuare in C, e sono riassunti nella seguente tabella. Operatore Spiegazione + Somma l-value ed r-value. - Sottrae r-value ad l-value. / Divide l-value per r-value. * Moltiplica l-value per r-value. % Calcola il modulo in r-value di l-value. ^ Eleva l-value ad r-value. Particolarmente interessante \u00e8 l'operatore di modulo % : questo, infatti, restituisce il resto della divisione tra l-value ed r-value. Ad esempio: int a = 5 % 2 ; // risultato: 1 int b = 12 % 4 ; // risultato: 0 int c = 17 % 13 ; // risultato: 4 Di estrema importanza sono anche gli operatori di confronto, riassunti nella seguente tabella. Operatore Spiegazione == Verifica che l-value sia uguale ad r-value. > Verifica che l-value sia maggiore di r-value. < Verifica che l-value sia minore di r-value. >= Verifica che l-value sia maggiore o uguale ad r-value. <= Verifica che l-value sia minore o uguale ad r-value. Interessante notare come questi operatori restituiscano un valore di verit\u00e0 , ovvero un vero o un falso a seconda del fatto che la condizione sia rispettata o meno. 17.3 - Operatori booleani \u00b6 Gli operatori booleani regolano le interazioni relative all'algebra di Boole, ovvero quella che gestisce variabili che possono assumere soltanto due valori: vero , convenzionalmente associato al valore 1, e falso , convenzionalmente associato al valore 0. Vediamo insieme quali operazioni fondamentali sono definite dalla logica booleana. 17.3.1 - Cenni di logica booleana \u00b6 17.3.1.1 - Operatori binari \u00b6 17.3.1.1 - Operazione di AND logico \u00b6 L'operazione di AND logico prevede che il risultato sia vero se e solo se sia l-value che r-value sono veri. Di conseguenza, vale la seguente tabella: l-value r-value Risultato 0 0 0 0 1 0 1 0 0 1 1 1 17.3.1.1.2 - Operazione di OR logico \u00b6 L'operazione di OR logico prevede che il risultato sia vero se e solo se almeno uno tra l-value ed r-value \u00e8 vero. Di conseguenza, vale la seguente tabella: l-value r-value Risultato 0 0 0 0 1 1 1 0 1 1 1 1 17.3.1.1.3 - Operazione di XOR logico \u00b6 L'operazione di XOR ( eXclusive OR ) logico prevede che il risultato sia vero se e solo se esattamente uno tra l-value ed r-value \u00e8 vero. Di conseguenza, vale la seguente tabella: l-value r-value Risultato 0 0 0 0 1 1 1 0 1 1 1 0 17.3.1.2 - Operatori logici unari \u00b6 17.3.1.2.1 - Operazione di NOT logico \u00b6 L'unico operatore logico unario \u00e8 l'operatore di NOT logico, che prevede che venga \"negato\" il valore in ingresso all'operatore. Di conseguenza, vale la seguente tabella: value Risultato 0 1 1 0 17.3.2 - Operatori logici nel linguaggio C \u00b6 Il linguaggio C mette a disposizione un operatore per la maggior parte delle operazioni logiche. Detti operatori sono riassunti nella seguente tabella. Operazione Operatore AND && OR || NOT ! Per quello che riguarda lo XOR, questo non \u00e8 messo direttamente a disposizione come operatore logico dal linguaggio C. Tuttavia, \u00e8 possibile ricavarlo come combinazione degli altri operatori fondamentali: farlo \u00e8 lasciato al lettore. Suggerimento Provate a fare un AND dei risultati delle operazioni di AND ed OR. 17.4 - Operatori logici binari \u00b6 Un altro tipo di operatore logico presente nel C \u00e8 quello binario , che opera non pi\u00f9 a livello dell'intero dato, ma a livello di rappresentazione in termini di bit. Nella tabella successiva sono mostrati i principali operatori di questo tipo: Operatore Descrizione >> Right shift << Left shift & AND bit a bit | OR bit a bit ^ XOR bit a bit Soffermiamoci per un attimo sugli operatori di scorrimento. Questi, in buona sostanza, equivalgono a dividere ( right shift ) o moltiplicare ( left shift ) il nostro numero in rappresentazione binaria per 2 elevato all'r-value specificato sull'operatore. Se, ad esempio, abbiamo una variabile di tipo byte pari a 4, e quindi rappresentata in binario ad otto bit come: int 4 = 00000010 ; applicando gli operatori di left shift e right shift otterremo, rispettivamente: a >> 1 ; // 00000010 / 2 = 00000001 a << 1 ; // 00000010 * 2 = 00000100 Per quello che riguarda invece gli operatori binari, questi funzionano esattamente come gli operatori logici classici, ma operano bit a bit. Ad esempio: Operatore a b risultato & 10001011 01011010 00001010 | 10001011 01011010 11011011 ^ 10001011 01011010 11010001 17.5 - Conversione di tipo \u00b6 Chiudiamo il discorso sugli operatori parlando dell'operazione di conversione di tipo , conosciuta anche come casting . Come suggerisce il nome stesso, questa operazione permette di convertire un dato da un tipo (ad esempio, intero) ad un altro (ad esempio, float). Ovviamente, questa operazione deve tenere conto non solo delle differenze di formato, ma anche in termini di memoria occupata. La conversione pu\u00f2 essere di due tipi: nella conversione implicita , gli operatori matematici trattati in precedenza effettuano una conversione \"automatica\", semplificando di solito i tipi pi\u00f9 complessi; nella conversione esplicita , \u00e8 il programmatore che effettua la conversione mediante l'operazione di casting. Vediamo alcuni esempi applicativi, partendo dalla conversione implicita. Provando a sommare due float ed associare al risultato una variabile di tipo int , avviene una conversione implicita. int a = 3.2 + 4.2 ; // il risultato sar\u00e0 \"troncato\" a 7 Un'altra situazione nella quale avviene una conversione implicita \u00e8 quella in cui si prova ad assegnare ad uno short , il cui valore massimo gestibile \u00e8 65535, un valore superiore; in questo caso, il valore verr\u00e0 automaticamente troncato al limite massimo. ushort s = 9999999 ; // sar\u00e0 troncato a 65.535 Per ci\u00f2 che riguarda la conversione esplicita, invece, dobbiamo usare l'operatore di casting, che consiste nella specifica del tipo destinazione tra parentesi tonde. Ad esempio, per convertire un int in float : int a = 3 ; float b = ( float ) a ; Nota sulle conversioni di tipo In generale, \u00e8 consigliabile evitare , per quanto possibile, di effettuare delle conversioni di tipo esplicite. Ovviamente, anche l'uso di conversioni di tipo in forma implicita \u00e8 sconsigliato, perch\u00e9 conduce spesso ad errori di troncamento che, nel migliore dei casi, possono portare a risultati non attesi (e, nel peggiore, compromettere il funzionamento del software).","title":"17 - Operatori in C"},{"location":"material/03_c_language/17_operators/lecture/#17-operatori-in-c","text":"In matematica, un operatore \u00e8 comunemente inteso come una azione su uno o pi\u00f9 dati, o operandi . Un semplice esempio \u00e8 dato dai comuni operatori di tipo aritmetico, come quello di somma, che permette (appunto) di sommare le quantit\u00e0 a destra e sinistra dell'operatore + . In questa lezione approfondiremo il concetto di operatore, e ne vedremo alcuni tra i pi\u00f9 utilizzati nel linguaggio C.","title":"17 - Operatori in C"},{"location":"material/03_c_language/17_operators/lecture/#171-operatori-ed-espressioni","text":"Generalmente, nei linguaggi di programmazione esistono due tipi di operatori: gli operatori binari , che agiscono su di una coppia di dati (normalmente a sinistra ed a destra dell'operatore); gli operatori unari , che agiscono su un singolo dato. In particolare, il dato a sinistra dell'operatore \u00e8 chiamato l-value , mentre quello a destra dell'operatore \u00e8 detto r-value . Gli operatori possono essere concatenati all'interno di un' espressione , intesa quindi come sequenza di operatori regolata da due principi: il principio di precedenza , valente soltanto in caso di pi\u00f9 operatori, che prevede che le operazioni ad essere eseguite per prime siano quelle tra parentesi tonde, e che successivamente si segua un ordine da sinistra verso destra; il principio di associativit\u00e0 indica l'ordine con cui sono valutati gli operatori, anche in questo caso prevalentemente da sinistra verso destra.","title":"17.1 - Operatori ed espressioni"},{"location":"material/03_c_language/17_operators/lecture/#172-loperatore-di-assegnazione","text":"L'operatore di assegnazione, contraddistinto dal simbolo uguale = , permette di assegnare un dato valore ad una variabile. Abbiamo gi\u00e0 usato questo operatore pi\u00f9 volte in fase di inizializzazione: int a = 10 ; char c = 'b' ; Importantissimo sottolineare come l'operatore di assegnazione non valuti il valore di una variabile , ma si limiti ad assegnarne uno nuovo.","title":"17.2 - L'operatore di assegnazione"},{"location":"material/03_c_language/17_operators/lecture/#173-gli-operatori-matematici","text":"Gli operatori matematici sono quelli coinvolti in tutte le operazioni di tipo aritmetico che \u00e8 possibile effettuare in C, e sono riassunti nella seguente tabella. Operatore Spiegazione + Somma l-value ed r-value. - Sottrae r-value ad l-value. / Divide l-value per r-value. * Moltiplica l-value per r-value. % Calcola il modulo in r-value di l-value. ^ Eleva l-value ad r-value. Particolarmente interessante \u00e8 l'operatore di modulo % : questo, infatti, restituisce il resto della divisione tra l-value ed r-value. Ad esempio: int a = 5 % 2 ; // risultato: 1 int b = 12 % 4 ; // risultato: 0 int c = 17 % 13 ; // risultato: 4 Di estrema importanza sono anche gli operatori di confronto, riassunti nella seguente tabella. Operatore Spiegazione == Verifica che l-value sia uguale ad r-value. > Verifica che l-value sia maggiore di r-value. < Verifica che l-value sia minore di r-value. >= Verifica che l-value sia maggiore o uguale ad r-value. <= Verifica che l-value sia minore o uguale ad r-value. Interessante notare come questi operatori restituiscano un valore di verit\u00e0 , ovvero un vero o un falso a seconda del fatto che la condizione sia rispettata o meno.","title":"17.3 - Gli operatori matematici"},{"location":"material/03_c_language/17_operators/lecture/#173-operatori-booleani","text":"Gli operatori booleani regolano le interazioni relative all'algebra di Boole, ovvero quella che gestisce variabili che possono assumere soltanto due valori: vero , convenzionalmente associato al valore 1, e falso , convenzionalmente associato al valore 0. Vediamo insieme quali operazioni fondamentali sono definite dalla logica booleana.","title":"17.3 - Operatori booleani"},{"location":"material/03_c_language/17_operators/lecture/#1731-cenni-di-logica-booleana","text":"","title":"17.3.1 - Cenni di logica booleana"},{"location":"material/03_c_language/17_operators/lecture/#17311-operatori-binari","text":"","title":"17.3.1.1 - Operatori binari"},{"location":"material/03_c_language/17_operators/lecture/#17311-operazione-di-and-logico","text":"L'operazione di AND logico prevede che il risultato sia vero se e solo se sia l-value che r-value sono veri. Di conseguenza, vale la seguente tabella: l-value r-value Risultato 0 0 0 0 1 0 1 0 0 1 1 1","title":"17.3.1.1 - Operazione di AND logico"},{"location":"material/03_c_language/17_operators/lecture/#173112-operazione-di-or-logico","text":"L'operazione di OR logico prevede che il risultato sia vero se e solo se almeno uno tra l-value ed r-value \u00e8 vero. Di conseguenza, vale la seguente tabella: l-value r-value Risultato 0 0 0 0 1 1 1 0 1 1 1 1","title":"17.3.1.1.2 - Operazione di OR logico"},{"location":"material/03_c_language/17_operators/lecture/#173113-operazione-di-xor-logico","text":"L'operazione di XOR ( eXclusive OR ) logico prevede che il risultato sia vero se e solo se esattamente uno tra l-value ed r-value \u00e8 vero. Di conseguenza, vale la seguente tabella: l-value r-value Risultato 0 0 0 0 1 1 1 0 1 1 1 0","title":"17.3.1.1.3 - Operazione di XOR logico"},{"location":"material/03_c_language/17_operators/lecture/#17312-operatori-logici-unari","text":"","title":"17.3.1.2 - Operatori logici unari"},{"location":"material/03_c_language/17_operators/lecture/#173121-operazione-di-not-logico","text":"L'unico operatore logico unario \u00e8 l'operatore di NOT logico, che prevede che venga \"negato\" il valore in ingresso all'operatore. Di conseguenza, vale la seguente tabella: value Risultato 0 1 1 0","title":"17.3.1.2.1 - Operazione di NOT logico"},{"location":"material/03_c_language/17_operators/lecture/#1732-operatori-logici-nel-linguaggio-c","text":"Il linguaggio C mette a disposizione un operatore per la maggior parte delle operazioni logiche. Detti operatori sono riassunti nella seguente tabella. Operazione Operatore AND && OR || NOT ! Per quello che riguarda lo XOR, questo non \u00e8 messo direttamente a disposizione come operatore logico dal linguaggio C. Tuttavia, \u00e8 possibile ricavarlo come combinazione degli altri operatori fondamentali: farlo \u00e8 lasciato al lettore. Suggerimento Provate a fare un AND dei risultati delle operazioni di AND ed OR.","title":"17.3.2 - Operatori logici nel linguaggio C"},{"location":"material/03_c_language/17_operators/lecture/#174-operatori-logici-binari","text":"Un altro tipo di operatore logico presente nel C \u00e8 quello binario , che opera non pi\u00f9 a livello dell'intero dato, ma a livello di rappresentazione in termini di bit. Nella tabella successiva sono mostrati i principali operatori di questo tipo: Operatore Descrizione >> Right shift << Left shift & AND bit a bit | OR bit a bit ^ XOR bit a bit Soffermiamoci per un attimo sugli operatori di scorrimento. Questi, in buona sostanza, equivalgono a dividere ( right shift ) o moltiplicare ( left shift ) il nostro numero in rappresentazione binaria per 2 elevato all'r-value specificato sull'operatore. Se, ad esempio, abbiamo una variabile di tipo byte pari a 4, e quindi rappresentata in binario ad otto bit come: int 4 = 00000010 ; applicando gli operatori di left shift e right shift otterremo, rispettivamente: a >> 1 ; // 00000010 / 2 = 00000001 a << 1 ; // 00000010 * 2 = 00000100 Per quello che riguarda invece gli operatori binari, questi funzionano esattamente come gli operatori logici classici, ma operano bit a bit. Ad esempio: Operatore a b risultato & 10001011 01011010 00001010 | 10001011 01011010 11011011 ^ 10001011 01011010 11010001","title":"17.4 - Operatori logici binari"},{"location":"material/03_c_language/17_operators/lecture/#175-conversione-di-tipo","text":"Chiudiamo il discorso sugli operatori parlando dell'operazione di conversione di tipo , conosciuta anche come casting . Come suggerisce il nome stesso, questa operazione permette di convertire un dato da un tipo (ad esempio, intero) ad un altro (ad esempio, float). Ovviamente, questa operazione deve tenere conto non solo delle differenze di formato, ma anche in termini di memoria occupata. La conversione pu\u00f2 essere di due tipi: nella conversione implicita , gli operatori matematici trattati in precedenza effettuano una conversione \"automatica\", semplificando di solito i tipi pi\u00f9 complessi; nella conversione esplicita , \u00e8 il programmatore che effettua la conversione mediante l'operazione di casting. Vediamo alcuni esempi applicativi, partendo dalla conversione implicita. Provando a sommare due float ed associare al risultato una variabile di tipo int , avviene una conversione implicita. int a = 3.2 + 4.2 ; // il risultato sar\u00e0 \"troncato\" a 7 Un'altra situazione nella quale avviene una conversione implicita \u00e8 quella in cui si prova ad assegnare ad uno short , il cui valore massimo gestibile \u00e8 65535, un valore superiore; in questo caso, il valore verr\u00e0 automaticamente troncato al limite massimo. ushort s = 9999999 ; // sar\u00e0 troncato a 65.535 Per ci\u00f2 che riguarda la conversione esplicita, invece, dobbiamo usare l'operatore di casting, che consiste nella specifica del tipo destinazione tra parentesi tonde. Ad esempio, per convertire un int in float : int a = 3 ; float b = ( float ) a ; Nota sulle conversioni di tipo In generale, \u00e8 consigliabile evitare , per quanto possibile, di effettuare delle conversioni di tipo esplicite. Ovviamente, anche l'uso di conversioni di tipo in forma implicita \u00e8 sconsigliato, perch\u00e9 conduce spesso ad errori di troncamento che, nel migliore dei casi, possono portare a risultati non attesi (e, nel peggiore, compromettere il funzionamento del software).","title":"17.5 - Conversione di tipo"},{"location":"material/03_c_language/18_arrays/exercises/","text":"E18 - Array \u00b6 Esercizio E18.1 \u00b6 Un tensore \u00e8 un array ad \\(n\\) dimensioni contenente valori arbitrari. Creare due tensori di dimensioni \\(3 \\times 3 \\times 3\\) , uno contenente valori itneri, e l'altro contenente valori in formato double . Utilizzare l'operatore sizeof per confrontare lo spazio occupato in memoria dai due tenosri, e visualizzare a schermo tutti i valori dell'array pi\u00f9 \"pesante\". Soluzione S18.1 \u00b6 #include <stdio.h> #include <stdlib.h> #pragma warning(disable : 4996) int main () { int tensore_interi [ 3 ][ 3 ][ 3 ]; double tensore_decimali [ 3 ][ 3 ][ 3 ]; int contatore_interi = 1 ; double contatore_double = 1.0 ; // Popolo i tensori for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { tensore_interi [ i ][ j ][ k ] = contatore_interi ; contatore_interi ++ ; tensore_decimali [ i ][ j ][ k ] = contatore_double ; contatore_double ++ ; } } } // Stampo a schermo for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { printf ( \"L'elemento in posizione [i][j][k] per il tensore di interi e' %d \\n \" , tensore_interi [ i ][ j ][ k ]); } } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { printf ( \"L'elemento in posizione [i][j][k] per il tensore di decimali e' %f \\t \" , tensore_decimali [ i ][ j ][ k ]); } } } if ( sizeof ( tensore_decimali ) > sizeof ( tensore_interi )) { printf ( \"La dimensione del tensore di decimali e': %d \\n \" , sizeof ( tensore_decimali )); } else { printf ( \"La dimensione del tensore di interi e': %d \\n \" , sizeof ( tensore_interi )); } return 0 ; } Esercizio E18.2 \u00b6 Scriviamo un programma che, data in ingresso una stringa rappresentativa di un numero \\(x\\) , con \\(x\\) numero reale o naturale, chiami l\u2019adeguata funzione per convertirlo in una variabile di tipo numerico. Utilizziamo poi il risultato restituito dalla funzione sprintf per visualizzare a schermo il valore della stringa associata ad \\(x\\) . Soluzione S18.2 \u00b6 #include <stdio.h> #include <stdlib.h> #pragma warning(disable : 4996) void determina_intero_decimale ( char numero [ 5 ]) { char stringa [ 32 ]; int length = 5 ; for ( int i = 0 ; i < length ; i ++ ) { if ( numero [ i ] == '.' ) { double valore = atof ( numero ); sprintf ( stringa , \"Il numero %f e' reale \\n \" , valore ); printf ( stringa ); return ; } } int valore = atoi ( numero ); sprintf ( stringa , \"Il numero %d e' un intero \\n \" , valore ); printf ( stringa ); } int main () { char intero [ 5 ] = \"10\" ; char decimale [ 5 ] = \"1.1\" ; determina_intero_decimale ( intero ); determina_intero_decimale ( decimale ); return 0 ; }","title":"E18 - Array in C"},{"location":"material/03_c_language/18_arrays/exercises/#e18-array","text":"","title":"E18 - Array"},{"location":"material/03_c_language/18_arrays/exercises/#esercizio-e181","text":"Un tensore \u00e8 un array ad \\(n\\) dimensioni contenente valori arbitrari. Creare due tensori di dimensioni \\(3 \\times 3 \\times 3\\) , uno contenente valori itneri, e l'altro contenente valori in formato double . Utilizzare l'operatore sizeof per confrontare lo spazio occupato in memoria dai due tenosri, e visualizzare a schermo tutti i valori dell'array pi\u00f9 \"pesante\".","title":"Esercizio E18.1"},{"location":"material/03_c_language/18_arrays/exercises/#soluzione-s181","text":"#include <stdio.h> #include <stdlib.h> #pragma warning(disable : 4996) int main () { int tensore_interi [ 3 ][ 3 ][ 3 ]; double tensore_decimali [ 3 ][ 3 ][ 3 ]; int contatore_interi = 1 ; double contatore_double = 1.0 ; // Popolo i tensori for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { tensore_interi [ i ][ j ][ k ] = contatore_interi ; contatore_interi ++ ; tensore_decimali [ i ][ j ][ k ] = contatore_double ; contatore_double ++ ; } } } // Stampo a schermo for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { printf ( \"L'elemento in posizione [i][j][k] per il tensore di interi e' %d \\n \" , tensore_interi [ i ][ j ][ k ]); } } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { printf ( \"L'elemento in posizione [i][j][k] per il tensore di decimali e' %f \\t \" , tensore_decimali [ i ][ j ][ k ]); } } } if ( sizeof ( tensore_decimali ) > sizeof ( tensore_interi )) { printf ( \"La dimensione del tensore di decimali e': %d \\n \" , sizeof ( tensore_decimali )); } else { printf ( \"La dimensione del tensore di interi e': %d \\n \" , sizeof ( tensore_interi )); } return 0 ; }","title":"Soluzione S18.1"},{"location":"material/03_c_language/18_arrays/exercises/#esercizio-e182","text":"Scriviamo un programma che, data in ingresso una stringa rappresentativa di un numero \\(x\\) , con \\(x\\) numero reale o naturale, chiami l\u2019adeguata funzione per convertirlo in una variabile di tipo numerico. Utilizziamo poi il risultato restituito dalla funzione sprintf per visualizzare a schermo il valore della stringa associata ad \\(x\\) .","title":"Esercizio E18.2"},{"location":"material/03_c_language/18_arrays/exercises/#soluzione-s182","text":"#include <stdio.h> #include <stdlib.h> #pragma warning(disable : 4996) void determina_intero_decimale ( char numero [ 5 ]) { char stringa [ 32 ]; int length = 5 ; for ( int i = 0 ; i < length ; i ++ ) { if ( numero [ i ] == '.' ) { double valore = atof ( numero ); sprintf ( stringa , \"Il numero %f e' reale \\n \" , valore ); printf ( stringa ); return ; } } int valore = atoi ( numero ); sprintf ( stringa , \"Il numero %d e' un intero \\n \" , valore ); printf ( stringa ); } int main () { char intero [ 5 ] = \"10\" ; char decimale [ 5 ] = \"1.1\" ; determina_intero_decimale ( intero ); determina_intero_decimale ( decimale ); return 0 ; }","title":"Soluzione S18.2"},{"location":"material/03_c_language/18_arrays/lecture/","text":"18 - Array in C \u00b6 Nella lezione 10 abbiamo introdotto il concetto di array in questo modo: Definizione di array Un array contiene una sequenza di elementi, tipicamente dello stesso tipo, ed organizzati seguendo un ordine specifico, \"esplorabile\" mediante il concetto di indice . La maggior parte dei linguaggi di programmazione offre un'implementazione nativa di questa struttura dati; ovviamente, il C non fa eccezione. 18.1 - Concetti fondamentali sugli array in C \u00b6 Un array ad \\(n\\) elementi \u00e8 caratterizzato in C da degli indici che vanno da \\(0\\) ad \\(n-1\\) . In altre parole, per accedere al primo elemento dell'array dovremo richiamare l'indice \\(0\\) , per accedere al secondo dovremo richiamare l'indice \\(1\\) , e cos\u00ec via fino all'indice \\(n-1\\) , da usare per accedere all' \\(n\\) -mo elemento. Importante sottolineare anche che il valore di \\(n\\) , ovvero la dimensione dell'array, \u00e8 predefinito ed invariabile: provare a modificare il numero di elementi di un array, infatti, equivale a crearne uno nuovo. Vediamo per\u00f2 adesso come sia possibile creare un nuovo array, o anche accedere ai singoli elementi dello stesso. 18.2 - Operatori notevoli sugli array \u00b6 18.2.1 - L'operatore [] \u00b6 L'operatore [] (ovvero, la coppia di parentesi quadre) viene usato per la definizione ed inizializzazione di un nuovo array. Supponiamo, ad esempio, di voler dichiarare un nuovo array contenente 5 numeri interi; per farlo, potremo usare questa notazione: int mio_array [ 5 ]; In sostanza, la dichiarazione assume quindi una forma del tipo: array_type array_id [ size ]; con array_type tipo degli elementi dell'array, array_id identificatore dell'array, e size numero di elementi dello stesso. Nota In buona sostanza, la dichiarazione di un array \u00e8 praticamente analoga a quella di una variabile. Analogamente, anche l'inizializzazione di un array pu\u00f2 avvenire contestualmente alla dichiarazione: int mio_array [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; Notiamo anche come i valori associati ai membri dell'array siano indicati tra parentesi graffe. In questo caso, possiamo anche omettere la dimensione dell'array, che sar\u00e0 automaticamente inferita dall'r-value: int mio_array [] = { 1 , 2 , 3 , 4 , 5 }; Nota Un array non \u00e8 un l-value, quindi un'espressione del tipo mio_array = {1, 2, 3, 4, 5}; non \u00e8 da ritenersi valida. L'operatore [] \u00e8 usato anche per scrivere o leggere i singoli elementi dell'array. Infatti, l'istruzione: mio_array [ 3 ] = 10 ; ci permette di sovrascrivere l'elemento in posizione 4 dell'array, che adesso sar\u00e0 pari a [1, 2, 3, 10, 5] . Utilizzando invece la notazione: int a = mio_array [ 2 ]; assegneremo alla variabile di tipo intero a il valore 3 . 18.2.2 - L'operatore sizeof \u00b6 Il linguaggio C mette a disposizione l'operatore sizeof per conoscere il numero complessivo di byte occupato in memoria dall'array. Nota Importantissimo sottolineare come l'operatore sizeof restituisca le dimensioni in memoria e non il numero di elementi dell'array! 18.3 - Array multidimensionali \u00b6 Il linguaggio C permette di creare degli array di dimensionalit\u00e0 arbitraria. Nota Ad esempio, una matrice \u00e8 un array di dimensionalit\u00e0 pari a due. Per far questo, possiamo utilizzare una notazione del tipo: array_type array_id [ size_1 ][ size_2 ]; A parte l'uso ripetuto dell'operatore [] , valgono esattamente le stesse regole usate per gli array monodimensionali. Di conseguenza, per definire una matrice \\(3 \\times 3\\) a valori in \\(\\mathbb{R}\\) , potremo scrivere: float matrix [ 3 ][ 3 ]; mentre per inizializzarla: float matrix [ 3 ][ 3 ] = { { 2.0 , 0.0 , 1.0 }, { 1.0 , 3.0 , 2.0 }, { 4.0 , 3.0 , 3.0 } }; ed infine per accedere all'elemento in posizione \\((1, 2)\\) : int el = matrix [ 0 ][ 1 ]; 18.4 - Array e stringhe \u00b6 Una stringa altro non \u00e8 se non una sequenza di caratteri. Interessante notare come le stringhe non siano dati di tipo primitivo; tuttavia, sono estremamente utilizzate, per cui il loro supporto \u00e8 presente in praticamente ogni linguaggio di programmazione. Per capirci, una delle funzioni \"fondamentali\" del C, come la printf , accetta una stringa. Data la loro natura, le stringhe sono rappresentate come degli array di char null terminated . Questo concetto \u00e8 estremamente peculiare: infatti, affinch\u00e9 un array sia riconosciuto come stringa, deve essere composto soltanto da char e, inoltre, il suo ultimo elemento deve essere un null value . Facciamo un esempio: char valid_string [ 6 ] = { 'a' , 'b' , 'c' , 'd' , 'e' , null }; char non_valid_string [ 6 ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; In questo esempio, l'array valid_string sar\u00e0 considerato dal compilatore come una stringa, mentre l'arryay non_valid_string sar\u00e0 un array di tipo char a sei elementi. Ovviamente, usare una notazione come la precedente per scrivere un array risulta oltremodo scomodo, per cui si preferisce utilizzare i doppi apici: char string_with_quotes [ 10 ] = \"abcdef\" ; In questo caso, ovviamente, il terminatore null sar\u00e0 aggiunto automaticamente. Conversione da stringa a tipo numerico Non \u00e8 possibile effettuare nativamente la conversione da stringa a numero intero o float. In tal senso, si utilizzano due funzioni, definite nell'header stdlib.h , ovvero atoi ed atof , che convertono una stringa rispettivamente in intero e float. Conversione da tipo numerico a stringa Per convertire da tipo numerico a stringa, invece, possiamo usare la funzione sprintf , definita in stdio.h . Questa funzione, che restituisce una stringa in uscita, pu\u00f2 accettare degli interi o dei float da inserire all'interno dell'output mediante delle apposite format string . Ad esempio, per convertire il numero 10, potremmo usare l'istruzione sprintf(out_string, \"%d\", 10); . 18.5 - Esercizi \u00b6 Esercizio 1: un tensore \u00e8 un array ad \ud835\udc5b dimensioni contenente valori arbitrari. Creare due tensori di dimensioni 3\u00d73\u00d73, uno contenente valori interi, e l\u2019altro contenente valori in formato double. Usare l\u2019operatore sizeof per confrontarne lo spazio occupato in memoria, e visualizzare a schermo tutti i valori dell\u2019array pi\u00f9 \u2018pesante\u2019. Esercizio 2: scriviamo un programma che, data in ingresso una stringa rappresentativa di un numero \ud835\udc65, con \ud835\udc65 numero reale o naturale, chiami l\u2019adeguata funzione per convertirlo in una variabile di tipo numerico. Utilizziamo poi il risultato restituito dalla funzione sprintf per visualizzare a schermo il valore della stringa associata ad \ud835\udc65.","title":"18 - Array in C"},{"location":"material/03_c_language/18_arrays/lecture/#18-array-in-c","text":"Nella lezione 10 abbiamo introdotto il concetto di array in questo modo: Definizione di array Un array contiene una sequenza di elementi, tipicamente dello stesso tipo, ed organizzati seguendo un ordine specifico, \"esplorabile\" mediante il concetto di indice . La maggior parte dei linguaggi di programmazione offre un'implementazione nativa di questa struttura dati; ovviamente, il C non fa eccezione.","title":"18 - Array in C"},{"location":"material/03_c_language/18_arrays/lecture/#181-concetti-fondamentali-sugli-array-in-c","text":"Un array ad \\(n\\) elementi \u00e8 caratterizzato in C da degli indici che vanno da \\(0\\) ad \\(n-1\\) . In altre parole, per accedere al primo elemento dell'array dovremo richiamare l'indice \\(0\\) , per accedere al secondo dovremo richiamare l'indice \\(1\\) , e cos\u00ec via fino all'indice \\(n-1\\) , da usare per accedere all' \\(n\\) -mo elemento. Importante sottolineare anche che il valore di \\(n\\) , ovvero la dimensione dell'array, \u00e8 predefinito ed invariabile: provare a modificare il numero di elementi di un array, infatti, equivale a crearne uno nuovo. Vediamo per\u00f2 adesso come sia possibile creare un nuovo array, o anche accedere ai singoli elementi dello stesso.","title":"18.1 - Concetti fondamentali sugli array in C"},{"location":"material/03_c_language/18_arrays/lecture/#182-operatori-notevoli-sugli-array","text":"","title":"18.2 - Operatori notevoli sugli array"},{"location":"material/03_c_language/18_arrays/lecture/#1821-loperatore","text":"L'operatore [] (ovvero, la coppia di parentesi quadre) viene usato per la definizione ed inizializzazione di un nuovo array. Supponiamo, ad esempio, di voler dichiarare un nuovo array contenente 5 numeri interi; per farlo, potremo usare questa notazione: int mio_array [ 5 ]; In sostanza, la dichiarazione assume quindi una forma del tipo: array_type array_id [ size ]; con array_type tipo degli elementi dell'array, array_id identificatore dell'array, e size numero di elementi dello stesso. Nota In buona sostanza, la dichiarazione di un array \u00e8 praticamente analoga a quella di una variabile. Analogamente, anche l'inizializzazione di un array pu\u00f2 avvenire contestualmente alla dichiarazione: int mio_array [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; Notiamo anche come i valori associati ai membri dell'array siano indicati tra parentesi graffe. In questo caso, possiamo anche omettere la dimensione dell'array, che sar\u00e0 automaticamente inferita dall'r-value: int mio_array [] = { 1 , 2 , 3 , 4 , 5 }; Nota Un array non \u00e8 un l-value, quindi un'espressione del tipo mio_array = {1, 2, 3, 4, 5}; non \u00e8 da ritenersi valida. L'operatore [] \u00e8 usato anche per scrivere o leggere i singoli elementi dell'array. Infatti, l'istruzione: mio_array [ 3 ] = 10 ; ci permette di sovrascrivere l'elemento in posizione 4 dell'array, che adesso sar\u00e0 pari a [1, 2, 3, 10, 5] . Utilizzando invece la notazione: int a = mio_array [ 2 ]; assegneremo alla variabile di tipo intero a il valore 3 .","title":"18.2.1 - L'operatore []"},{"location":"material/03_c_language/18_arrays/lecture/#1822-loperatore-sizeof","text":"Il linguaggio C mette a disposizione l'operatore sizeof per conoscere il numero complessivo di byte occupato in memoria dall'array. Nota Importantissimo sottolineare come l'operatore sizeof restituisca le dimensioni in memoria e non il numero di elementi dell'array!","title":"18.2.2 - L'operatore sizeof"},{"location":"material/03_c_language/18_arrays/lecture/#183-array-multidimensionali","text":"Il linguaggio C permette di creare degli array di dimensionalit\u00e0 arbitraria. Nota Ad esempio, una matrice \u00e8 un array di dimensionalit\u00e0 pari a due. Per far questo, possiamo utilizzare una notazione del tipo: array_type array_id [ size_1 ][ size_2 ]; A parte l'uso ripetuto dell'operatore [] , valgono esattamente le stesse regole usate per gli array monodimensionali. Di conseguenza, per definire una matrice \\(3 \\times 3\\) a valori in \\(\\mathbb{R}\\) , potremo scrivere: float matrix [ 3 ][ 3 ]; mentre per inizializzarla: float matrix [ 3 ][ 3 ] = { { 2.0 , 0.0 , 1.0 }, { 1.0 , 3.0 , 2.0 }, { 4.0 , 3.0 , 3.0 } }; ed infine per accedere all'elemento in posizione \\((1, 2)\\) : int el = matrix [ 0 ][ 1 ];","title":"18.3 - Array multidimensionali"},{"location":"material/03_c_language/18_arrays/lecture/#184-array-e-stringhe","text":"Una stringa altro non \u00e8 se non una sequenza di caratteri. Interessante notare come le stringhe non siano dati di tipo primitivo; tuttavia, sono estremamente utilizzate, per cui il loro supporto \u00e8 presente in praticamente ogni linguaggio di programmazione. Per capirci, una delle funzioni \"fondamentali\" del C, come la printf , accetta una stringa. Data la loro natura, le stringhe sono rappresentate come degli array di char null terminated . Questo concetto \u00e8 estremamente peculiare: infatti, affinch\u00e9 un array sia riconosciuto come stringa, deve essere composto soltanto da char e, inoltre, il suo ultimo elemento deve essere un null value . Facciamo un esempio: char valid_string [ 6 ] = { 'a' , 'b' , 'c' , 'd' , 'e' , null }; char non_valid_string [ 6 ] = { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; In questo esempio, l'array valid_string sar\u00e0 considerato dal compilatore come una stringa, mentre l'arryay non_valid_string sar\u00e0 un array di tipo char a sei elementi. Ovviamente, usare una notazione come la precedente per scrivere un array risulta oltremodo scomodo, per cui si preferisce utilizzare i doppi apici: char string_with_quotes [ 10 ] = \"abcdef\" ; In questo caso, ovviamente, il terminatore null sar\u00e0 aggiunto automaticamente. Conversione da stringa a tipo numerico Non \u00e8 possibile effettuare nativamente la conversione da stringa a numero intero o float. In tal senso, si utilizzano due funzioni, definite nell'header stdlib.h , ovvero atoi ed atof , che convertono una stringa rispettivamente in intero e float. Conversione da tipo numerico a stringa Per convertire da tipo numerico a stringa, invece, possiamo usare la funzione sprintf , definita in stdio.h . Questa funzione, che restituisce una stringa in uscita, pu\u00f2 accettare degli interi o dei float da inserire all'interno dell'output mediante delle apposite format string . Ad esempio, per convertire il numero 10, potremmo usare l'istruzione sprintf(out_string, \"%d\", 10); .","title":"18.4 - Array e stringhe"},{"location":"material/03_c_language/18_arrays/lecture/#185-esercizi","text":"Esercizio 1: un tensore \u00e8 un array ad \ud835\udc5b dimensioni contenente valori arbitrari. Creare due tensori di dimensioni 3\u00d73\u00d73, uno contenente valori interi, e l\u2019altro contenente valori in formato double. Usare l\u2019operatore sizeof per confrontarne lo spazio occupato in memoria, e visualizzare a schermo tutti i valori dell\u2019array pi\u00f9 \u2018pesante\u2019. Esercizio 2: scriviamo un programma che, data in ingresso una stringa rappresentativa di un numero \ud835\udc65, con \ud835\udc65 numero reale o naturale, chiami l\u2019adeguata funzione per convertirlo in una variabile di tipo numerico. Utilizziamo poi il risultato restituito dalla funzione sprintf per visualizzare a schermo il valore della stringa associata ad \ud835\udc65.","title":"18.5 - Esercizi"},{"location":"material/03_c_language/19_pointers/exercises/","text":"E19 - I puntatori \u00b6 Esercizio E19.1 \u00b6 Definire mediante un'apposita struttura di librerie delle funzioni che: mostrino l'indirizzo di una variabile intera o in formato double ; verifichino che il valore dereferenziato da un puntatore coincida con la variabile; mostrino la differenza tra passaggio per valore e passaggio per reference; descrivano un puntatore a void. Soluzione E19.1 \u00b6 Ecco una possibile soluzione, organizzata creando un'apposita libreria puntatori . // puntatori.h #ifndef PUNTATORI_H #define PUNTATORI_H void mostra_puntatore_intero ( int intero ); void mostra_puntatore_double ( double decimale ); int deferenzia_compara_intero ( int * puntatore_intero , int comparato ); double deferenzia_compara_decimale ( double * puntatore_decimale , double comparato ); int * restituisci_puntatore ( int intero ); void puntatore_a_void ( char ch ); #endif // !PUNTATORI_H // puntatori.c #include <stdio.h> #include \"puntatori.h\" void mostra_puntatore_intero ( int intero ) { int * puntatore = & intero ; printf ( \"L'indirizzo della variabile e': %p \\n \" , puntatore ); } void mostra_puntatore_double ( double decimale ) { double * puntatore = & decimale ; printf ( \"L'indirizzo della variabile e': %p \\n \" , puntatore ); } int * restituisci_puntatore ( int intero ) { return & intero ; } int deferenzia_compara_intero ( int * puntatore_intero , int comparato ) { int puntato = * puntatore_intero ; if ( puntato == comparato ) { printf ( \"La comparazione ha avuto successo! \\n \" ); } return puntato ; } double deferenzia_compara_decimale ( double * puntatore_decimale , double comparato ) { double puntato = * puntatore_decimale ; if ( puntato == comparato ) { printf ( \"La comparazione ha avuto successo! \\n \" ); } return puntato ; } void puntatore_a_void ( char ch ) { void * puntatore ; puntatore = & ch ; printf ( \"Il puntatore a void ha indirizzo: %p \\n \" , puntatore_a_void ); char * puntatore_a_char = ( char * ) puntatore ; // Dereferenziazione printf ( \"La variabile originaria e': %c \\n \" , * puntatore_a_char ); } // main.c #include <stdio.h> #include \"puntatori.h\" #include \"puntatori_funzione.h\" int main () { // Parte 1 int a = 1 ; double b = 0.1 ; mostra_puntatore_intero ( a ); mostra_puntatore_double ( b ); // Parte 2 int c = deferenzia_compara_intero ( & a , a ); double d = deferenzia_compara_decimale ( & b , b ); // Parte 3 int * p = restituisci_puntatore ( a ); if ( p == & a ) { printf ( \"I puntatori combaciano! \\n \" ); } else { printf ( \"I puntatori non combaciano! \\n \" ); } // Parte 4 puntatore_a_void ( 'c' ); return 0 ; }","title":"E19 - Puntatori"},{"location":"material/03_c_language/19_pointers/exercises/#e19-i-puntatori","text":"","title":"E19 - I puntatori"},{"location":"material/03_c_language/19_pointers/exercises/#esercizio-e191","text":"Definire mediante un'apposita struttura di librerie delle funzioni che: mostrino l'indirizzo di una variabile intera o in formato double ; verifichino che il valore dereferenziato da un puntatore coincida con la variabile; mostrino la differenza tra passaggio per valore e passaggio per reference; descrivano un puntatore a void.","title":"Esercizio E19.1"},{"location":"material/03_c_language/19_pointers/exercises/#soluzione-e191","text":"Ecco una possibile soluzione, organizzata creando un'apposita libreria puntatori . // puntatori.h #ifndef PUNTATORI_H #define PUNTATORI_H void mostra_puntatore_intero ( int intero ); void mostra_puntatore_double ( double decimale ); int deferenzia_compara_intero ( int * puntatore_intero , int comparato ); double deferenzia_compara_decimale ( double * puntatore_decimale , double comparato ); int * restituisci_puntatore ( int intero ); void puntatore_a_void ( char ch ); #endif // !PUNTATORI_H // puntatori.c #include <stdio.h> #include \"puntatori.h\" void mostra_puntatore_intero ( int intero ) { int * puntatore = & intero ; printf ( \"L'indirizzo della variabile e': %p \\n \" , puntatore ); } void mostra_puntatore_double ( double decimale ) { double * puntatore = & decimale ; printf ( \"L'indirizzo della variabile e': %p \\n \" , puntatore ); } int * restituisci_puntatore ( int intero ) { return & intero ; } int deferenzia_compara_intero ( int * puntatore_intero , int comparato ) { int puntato = * puntatore_intero ; if ( puntato == comparato ) { printf ( \"La comparazione ha avuto successo! \\n \" ); } return puntato ; } double deferenzia_compara_decimale ( double * puntatore_decimale , double comparato ) { double puntato = * puntatore_decimale ; if ( puntato == comparato ) { printf ( \"La comparazione ha avuto successo! \\n \" ); } return puntato ; } void puntatore_a_void ( char ch ) { void * puntatore ; puntatore = & ch ; printf ( \"Il puntatore a void ha indirizzo: %p \\n \" , puntatore_a_void ); char * puntatore_a_char = ( char * ) puntatore ; // Dereferenziazione printf ( \"La variabile originaria e': %c \\n \" , * puntatore_a_char ); } // main.c #include <stdio.h> #include \"puntatori.h\" #include \"puntatori_funzione.h\" int main () { // Parte 1 int a = 1 ; double b = 0.1 ; mostra_puntatore_intero ( a ); mostra_puntatore_double ( b ); // Parte 2 int c = deferenzia_compara_intero ( & a , a ); double d = deferenzia_compara_decimale ( & b , b ); // Parte 3 int * p = restituisci_puntatore ( a ); if ( p == & a ) { printf ( \"I puntatori combaciano! \\n \" ); } else { printf ( \"I puntatori non combaciano! \\n \" ); } // Parte 4 puntatore_a_void ( 'c' ); return 0 ; }","title":"Soluzione E19.1"},{"location":"material/03_c_language/19_pointers/lecture/","text":"19 - I puntatori \u00b6 Quello di puntatore \u00e8 un concetto estremamente importante per la comprensione del linguaggio C, nonostante possa a volte rivelarsi ostico. In particolare, un puntatore \u00e8, nei fatti, una variabile che contiene l'indirizzo di memoria dove risiede un'altra variabile. Per meglio comprendere questo concetto, osserviamo la seguente figura. Analizziamo brevemente la figura precedente. Ad esempio, la variabile di nome ch , il cui valore \u00e8 pari ad l , risiede nell'indirizzo di memoria 0x100000 ; la variabile bs , intero di valore 2 , risiede nell'indirizzo di memoria immediatamente adiacente, ovvero 0x100001 , e via discorrendo; un puntatore ci permette quindi di tenere traccia di questi valori. Gli indirizzi di memoria Gli indirizzi di memoria, nei fatti, sono rappresentabili mediante variabili di tipo intero. Tuttavia, molto spesso si preferisce utilizzare la notazione esadecimale. Operazioni aritmetiche Dato che gli indirizzi di memoria sono variabili di tipo intero, \u00e8 possibile effettuare su di essi delle operazioni di natura aritmetica. Tuttavia, \u00e8 sconsigliato farlo se non in casi eccezionali. 19.1 - L'operatore & \u00b6 Se invocato su di una variabile, l'operatore & permette di restituirne l'indirizzo, ottenendo quindi il valore associabile ad un puntatore. Ad esempio: printf ( \"%x\" , & ch ); // questa istruzione restituir\u00e0 0x100000 Format specifier per il puntatore Notiamo che il format specifier usato per il puntatore non \u00e8 quello usato per i numeri interi. Di conseguenza, possiamo definire la modalit\u00e0 con cui \u00e8 possibile dichiarare ed inizializzare una variabile da associare ad un puntatore come: char ch = 'l' ; char * puntatore_char = & ch ; La notazione type* indica quindi che stiamo definendo un puntatore ad un tipo specifico; ad esempio, char* \u00e8 un puntatore a char , mentre int* \u00e8 un puntatore ad int , e via dicendo. 19.2 - L'operatore di dereferenziazione \u00b6 Nel contesto dei puntatori, l'operatore * ci permette anche di effettuare la cosiddetta operazione di dereferenziazione , che ci permette di recuperare il valore associato all'indirizzo di memoria cui si riferisce il puntatore. Ad esempio: print ( \"%c\" , * pointer ); // questa istruzione restituir\u00e0 l 19.3 - Passaggio per valore e passaggio per reference \u00b6 Il passaggio di una variabile come argomento di una funzione avviene secondo due diverse modalit\u00e0. Nella prima modalit\u00e0, il passaggio avviene per valore : questo significa che viene creata una copia della variabile, la quale sar\u00e0 mandata in ingresso alla funzione. Ovviamente, ci\u00f2 implica che la variabile originaria non sar\u00e0 modificata. Il secondo modo \u00e8, invece, per reference : in questo caso, viene passato il riferimento all'indirizzo di memoria associato alla variabile in ingresso alla funzione, e la variabile originaria sar\u00e0 quindi modificata. Nota I \"fanatici\" del C affermano che il linguaggio preveda esclusivamente il passaggio per valore. Tuttavia, il passaggio per reference pu\u00f2 essere tranquillamente emulato utilizzando un puntatore come argomento della funzione, come vedremo a breve. 19.3.1 - Passaggio di un puntatore come argomento di una funzione \u00b6 Come abbiamo detto in precedenza, per \"emulare\" un passaggio per reference potremo passare un puntatore come argomento di una funzione. Questo implica, ovviamente, che il passaggio avverr\u00e0 s\u00ec per valore, ma sar\u00e0 relativo ad un indirizzo di memoria! Di conseguenza, ogni operazione effettuata sul puntatore avr\u00e0 esclusiva validit\u00e0 all'interno della funzione, ma la variabile puntata sar\u00e0, nei fatti, passata per reference, e potr\u00e0 essere modificata. In questi casi, si parla (in maniera in qualche modo forzata) di passaggio per indirizzo . Ad esempio: #include <stdio.h> void f ( int * j ) { ( * j ) ++ ; } int main () { int i = 20 ; int * p = & i ; f ( p ); printf ( \"i = %d \\n \" , i ); // i sar\u00e0 pari a 21! return 0 ; } 19.4 - Puntatore a void \u00b6 A volte potrebbe essere necessario creare un puntatore prima che il programma \"conosca\" il tipo della variabile puntata. In questo caso, si utilizza un puntatore a void : void * puntatore_generico ; In pratica, un puntatore di questo tipo pu\u00f2 essere utilizzato come generico placeholder, e non pu\u00f2 essere in alcun modo dereferenziato. Nel momento in cui lo si vorr\u00e0 utilizzare, inoltre, sar\u00e0 necessario effettuare un cast al tipo cui si riferisce: char * puntatore_char = ( char * ) puntatore_generico ; 19.5 - Puntatori ed array \u00b6 Esiste una corrispondenza pratica tra array e puntatori; infatti, dal punto di vista semantico, gli array sono dei particolari tipi di puntatori . Infatti, nel momento in cui si dichiara un array, si alloca la memoria necessaria sia alla struttura dati stessa, sia all'area puntata; \u00e8 per questo, quindi, che \u00e8 necessario definire a priori la lunghezza dell'array, e procedere con un'allocazione di tipo statico. Interessante anche notare come il puntatore associato all'array sia dichiarato costante mediante la keyword const . La conseguenza diretta di questo \u00e8 che l'indirizzo dell'array non \u00e8 modificabile ; una conseguenza indiretta, ma altrettanto importante, \u00e8 che l'array non pu\u00f2 essere usato come l-value. E, in definitiva, \u00e8 questo il motivo per il quale una serie di istruzioni di questo tipo non \u00e8 valida: int lista [ 3 ]; lista = { 1 , 2 , 3 }; 19.6 - Puntatori e funzioni \u00b6 Per una funzione \u00e8 possibile avere un puntatore come valore di ritorno. Ricordiamo che il valore di ritorno \u00e8, come sempre, passato per valore: ci\u00f2 garantisce quindi che il puntatore usato nell'ambito della funzione sia restituito correttamente. Ci\u00f2, tuttavia, non \u00e8 garantito per la variabile puntata, che deve appartenere ad un ambito adeguato (e, quindi, non locale alla funzione), oppure essere dichiarata static . 19.7 - Esercizi \u00b6 Scriviamo le funzioni, mostra_puntatore_intero e mostra_puntatore_decimale , che accettano, rispettivamente, un valore intero ed un valore reale. Le due funzioni non restituiscono alcun valore, e stampano a schermo l'indirizzo di memoria associato alla variabile passata come parametro. Scriviamo le funzioni deferenzia_compara_intero e deferenzia_compara_decimale , che accettano due argomenti in ingresso, ovvero una variabile ed un puntatore alla stessa. Come suggerisce il nome delle funzioni, la prima tratta valori interi, la seconda decimali. Le funzioni devono verificare la correttezza dell'operazione di dereferenziazione, ed in caso affermativo restituire il vlaore della variabile dereferenziata, mentre in caso negativo restituire il valore -1. Scriviamo la restituisci_puntatore che accetta come parametro un intero e restituisce il puntatore allo stesso. Verificare se l\u2019indirizzo associato al puntatore restituito \u00e8 lo stesso ottenuto utilizzando l\u2019operatore & all\u2019interno della funzione chiamante. Scriviamo la funzione puntatore_a_void per creare un puntatore a void da associare poi ad una variabile di tipo char passata in ingresso.","title":"19 - Puntatori"},{"location":"material/03_c_language/19_pointers/lecture/#19-i-puntatori","text":"Quello di puntatore \u00e8 un concetto estremamente importante per la comprensione del linguaggio C, nonostante possa a volte rivelarsi ostico. In particolare, un puntatore \u00e8, nei fatti, una variabile che contiene l'indirizzo di memoria dove risiede un'altra variabile. Per meglio comprendere questo concetto, osserviamo la seguente figura. Analizziamo brevemente la figura precedente. Ad esempio, la variabile di nome ch , il cui valore \u00e8 pari ad l , risiede nell'indirizzo di memoria 0x100000 ; la variabile bs , intero di valore 2 , risiede nell'indirizzo di memoria immediatamente adiacente, ovvero 0x100001 , e via discorrendo; un puntatore ci permette quindi di tenere traccia di questi valori. Gli indirizzi di memoria Gli indirizzi di memoria, nei fatti, sono rappresentabili mediante variabili di tipo intero. Tuttavia, molto spesso si preferisce utilizzare la notazione esadecimale. Operazioni aritmetiche Dato che gli indirizzi di memoria sono variabili di tipo intero, \u00e8 possibile effettuare su di essi delle operazioni di natura aritmetica. Tuttavia, \u00e8 sconsigliato farlo se non in casi eccezionali.","title":"19 - I puntatori"},{"location":"material/03_c_language/19_pointers/lecture/#191-loperatore","text":"Se invocato su di una variabile, l'operatore & permette di restituirne l'indirizzo, ottenendo quindi il valore associabile ad un puntatore. Ad esempio: printf ( \"%x\" , & ch ); // questa istruzione restituir\u00e0 0x100000 Format specifier per il puntatore Notiamo che il format specifier usato per il puntatore non \u00e8 quello usato per i numeri interi. Di conseguenza, possiamo definire la modalit\u00e0 con cui \u00e8 possibile dichiarare ed inizializzare una variabile da associare ad un puntatore come: char ch = 'l' ; char * puntatore_char = & ch ; La notazione type* indica quindi che stiamo definendo un puntatore ad un tipo specifico; ad esempio, char* \u00e8 un puntatore a char , mentre int* \u00e8 un puntatore ad int , e via dicendo.","title":"19.1 - L'operatore &amp;"},{"location":"material/03_c_language/19_pointers/lecture/#192-loperatore-di-dereferenziazione","text":"Nel contesto dei puntatori, l'operatore * ci permette anche di effettuare la cosiddetta operazione di dereferenziazione , che ci permette di recuperare il valore associato all'indirizzo di memoria cui si riferisce il puntatore. Ad esempio: print ( \"%c\" , * pointer ); // questa istruzione restituir\u00e0 l","title":"19.2 - L'operatore di dereferenziazione"},{"location":"material/03_c_language/19_pointers/lecture/#193-passaggio-per-valore-e-passaggio-per-reference","text":"Il passaggio di una variabile come argomento di una funzione avviene secondo due diverse modalit\u00e0. Nella prima modalit\u00e0, il passaggio avviene per valore : questo significa che viene creata una copia della variabile, la quale sar\u00e0 mandata in ingresso alla funzione. Ovviamente, ci\u00f2 implica che la variabile originaria non sar\u00e0 modificata. Il secondo modo \u00e8, invece, per reference : in questo caso, viene passato il riferimento all'indirizzo di memoria associato alla variabile in ingresso alla funzione, e la variabile originaria sar\u00e0 quindi modificata. Nota I \"fanatici\" del C affermano che il linguaggio preveda esclusivamente il passaggio per valore. Tuttavia, il passaggio per reference pu\u00f2 essere tranquillamente emulato utilizzando un puntatore come argomento della funzione, come vedremo a breve.","title":"19.3 - Passaggio per valore e passaggio per reference"},{"location":"material/03_c_language/19_pointers/lecture/#1931-passaggio-di-un-puntatore-come-argomento-di-una-funzione","text":"Come abbiamo detto in precedenza, per \"emulare\" un passaggio per reference potremo passare un puntatore come argomento di una funzione. Questo implica, ovviamente, che il passaggio avverr\u00e0 s\u00ec per valore, ma sar\u00e0 relativo ad un indirizzo di memoria! Di conseguenza, ogni operazione effettuata sul puntatore avr\u00e0 esclusiva validit\u00e0 all'interno della funzione, ma la variabile puntata sar\u00e0, nei fatti, passata per reference, e potr\u00e0 essere modificata. In questi casi, si parla (in maniera in qualche modo forzata) di passaggio per indirizzo . Ad esempio: #include <stdio.h> void f ( int * j ) { ( * j ) ++ ; } int main () { int i = 20 ; int * p = & i ; f ( p ); printf ( \"i = %d \\n \" , i ); // i sar\u00e0 pari a 21! return 0 ; }","title":"19.3.1 - Passaggio di un puntatore come argomento di una funzione"},{"location":"material/03_c_language/19_pointers/lecture/#194-puntatore-a-void","text":"A volte potrebbe essere necessario creare un puntatore prima che il programma \"conosca\" il tipo della variabile puntata. In questo caso, si utilizza un puntatore a void : void * puntatore_generico ; In pratica, un puntatore di questo tipo pu\u00f2 essere utilizzato come generico placeholder, e non pu\u00f2 essere in alcun modo dereferenziato. Nel momento in cui lo si vorr\u00e0 utilizzare, inoltre, sar\u00e0 necessario effettuare un cast al tipo cui si riferisce: char * puntatore_char = ( char * ) puntatore_generico ;","title":"19.4 - Puntatore a void"},{"location":"material/03_c_language/19_pointers/lecture/#195-puntatori-ed-array","text":"Esiste una corrispondenza pratica tra array e puntatori; infatti, dal punto di vista semantico, gli array sono dei particolari tipi di puntatori . Infatti, nel momento in cui si dichiara un array, si alloca la memoria necessaria sia alla struttura dati stessa, sia all'area puntata; \u00e8 per questo, quindi, che \u00e8 necessario definire a priori la lunghezza dell'array, e procedere con un'allocazione di tipo statico. Interessante anche notare come il puntatore associato all'array sia dichiarato costante mediante la keyword const . La conseguenza diretta di questo \u00e8 che l'indirizzo dell'array non \u00e8 modificabile ; una conseguenza indiretta, ma altrettanto importante, \u00e8 che l'array non pu\u00f2 essere usato come l-value. E, in definitiva, \u00e8 questo il motivo per il quale una serie di istruzioni di questo tipo non \u00e8 valida: int lista [ 3 ]; lista = { 1 , 2 , 3 };","title":"19.5 - Puntatori ed array"},{"location":"material/03_c_language/19_pointers/lecture/#196-puntatori-e-funzioni","text":"Per una funzione \u00e8 possibile avere un puntatore come valore di ritorno. Ricordiamo che il valore di ritorno \u00e8, come sempre, passato per valore: ci\u00f2 garantisce quindi che il puntatore usato nell'ambito della funzione sia restituito correttamente. Ci\u00f2, tuttavia, non \u00e8 garantito per la variabile puntata, che deve appartenere ad un ambito adeguato (e, quindi, non locale alla funzione), oppure essere dichiarata static .","title":"19.6 - Puntatori e funzioni"},{"location":"material/03_c_language/19_pointers/lecture/#197-esercizi","text":"Scriviamo le funzioni, mostra_puntatore_intero e mostra_puntatore_decimale , che accettano, rispettivamente, un valore intero ed un valore reale. Le due funzioni non restituiscono alcun valore, e stampano a schermo l'indirizzo di memoria associato alla variabile passata come parametro. Scriviamo le funzioni deferenzia_compara_intero e deferenzia_compara_decimale , che accettano due argomenti in ingresso, ovvero una variabile ed un puntatore alla stessa. Come suggerisce il nome delle funzioni, la prima tratta valori interi, la seconda decimali. Le funzioni devono verificare la correttezza dell'operazione di dereferenziazione, ed in caso affermativo restituire il vlaore della variabile dereferenziata, mentre in caso negativo restituire il valore -1. Scriviamo la restituisci_puntatore che accetta come parametro un intero e restituisce il puntatore allo stesso. Verificare se l\u2019indirizzo associato al puntatore restituito \u00e8 lo stesso ottenuto utilizzando l\u2019operatore & all\u2019interno della funzione chiamante. Scriviamo la funzione puntatore_a_void per creare un puntatore a void da associare poi ad una variabile di tipo char passata in ingresso.","title":"19.7 - Esercizi"},{"location":"material/03_c_language/20_memory/lecture/","text":"20 - Allocazione statica e dinamica della memoria \u00b6 La memoria di un calcolatore \u00e8 tipicamente divisa in tre sezioni: la heap , ovvero una parte di memoria richiamabile all'occorrenza dal programmatore; lo stack , nel quale le variabili vengono dichiarate, inizializzate a runtime, e che agisce secondo una logica LIFO; la code section , dove viene memorizzato il programma a runtime. Questa disposizione della memoria ci permette quindi di allocarla (ovvero assegnarla ) secondo due modalit\u00e0, statica e dinamica . 20.1 - Allocazione statica della memoria \u00b6 L'allocazione statica della memoria prevede che il programma in esecuzione abbia una dimesione prefissata a compile time, la quale non pu\u00f2 essere in alcun modo modificata a runtime. Ovviamente, ci\u00f2 implica che il programmatore sia in grado di definire esattamente a priori i requisiti del suo programma in termini di memoria. Un esempio di allocazione statica della memoria \u00e8 il seguente: int main () { int a ; // prealloco 4 byte long b ; // prealloco 8 byte } Nel codice precedente dichiariamo due variabili, per le quali saranno allocate, rispettivamente, 32 e 64 bit all'interno dello stack. A runtime, a meno che non siano specificate delle apposite operazioni di cast, la quantit\u00e0 di memoria allocata non verr\u00e0 modificata, e sar\u00e0 liberata in automatico soltanto al termine dell'esecuzione dello stesso. Riassumiamo quindi i vantaggi e gli svantaggi dell'allocazione statica. Vantaggi Svantaggi Semplicit\u00e0 di utilizzo. Delega al compilatore dell'allocazione della memoria. Efficiente a runtime. Memoria non necessariamente utilizzata al meglio (specie con array). Necessit\u00e0 di conoscere a priori i requisiti in termini di memoria. Impossibilit\u00e0 di riallocare la memoria a runtime. 20.2 - Allocazione dinamica della memoria \u00b6 A differenza dell'allocazione statica, nell'allocazione dinamica \u00e8 il programmatore a controllare quanta memoria viene allocata. Inoltre, in questo caso, viene utilizzata la memoria heap, e non lo stack. L'allocazione dinamica prevede quindi che la memoria non sia allocata a priori, ovvero a compile time, ma piuttosto a runtime; di conseguenza, pu\u00f2 essere sia assegnata, sia liberata, e farlo in maniera corretta comporta un utilizzo pi\u00f9 efficiente della memoria stessa. Dal punto di vista pratico, la libreria stdlib.h offre una serie di funzioni che permettono l'allocazione dinamica della memoria, che vediamo di seguito. 20.2.1 - La funzione malloc \u00b6 La funzione malloc permette di allocare un certo quantitativo di memoria a runtime, specificando come parametro passato alla funzione il numero di byte da allocare. Quindi, ad esempio: int num_values = 10 ; int * p = ( int * ) malloc ( num_values ); Grazie all'istruzione precedente, avremo allocato spazio sufficiente a contenere dieci numeri interi a quattro byte, ovvero quaranta byte. Inoltre, \u00e8 opportuno notare come la malloc restituisca in uscita un indirizzo di memoria; in questo caso, quindi, \u00e8 necessario effettuare un casting a puntatore ad intero. 20.2.2 - La funzione calloc \u00b6 La funzione calloc offre un vantaggio rispetto alla malloc , inizializzando gli elementi allocati in modo che questi assumano un valore pari a zero. La sintassi \u00e8 la seguente: int num_values = 10 ; int * p = ( int * ) calloc ( num_values , sizeof ( int )) Notiamo subito come vi sia una prima differenza rispetto alla malloc legata al fatto che la funzione accetta due parametri, ovvero il numero di oggetti per i quali \u00e8 richiesta l'allocazione, e la dimensione di ciascun oggetto. Anche in questo caso, la funzione restituisce un indirizzo di memoria. 20.2.3 - La funzione realloc \u00b6 La funzione realloc ci permette di riutilizzare o estendere la memoria che abbiamo allocato in precedenza mediante la malloc o la calloc . In tal senso, la funzione accetta due argomenti, ovvero il tipo del puntatore precedentemente allocato, ed il numero di nuovi elementi da allocare. int new_size = 20 ; p = ( int * ) realloc ( p , new_size ) 20.2.4 - La funzione free \u00b6 Una delle cose pi\u00f9 importanti da tenere a mente quando abbiamo a che fare con l'allocazione dinamica \u00e8 che la memoria deve essere sempre rilasciata qualora non sia pi\u00f9 richiesta. Ci\u00f2 avviene di solito in maniera automatica al termine dell'esecuzione del programma; tuttavia, \u00e8 consigliato effettuare tale rilascio sempre in maniera esplicita. Per farlo, dobbiamo utilizzare la funzione free , passando come argomento il puntatore all'indirizzo di memoria che desideriamo liberare. Facciamo adesso un esempio completo: #include <stdlib.h> int main () { int * p ; p = ( int * ) malloc ( 5 * sizeof ( int )); free ( p ); return 0 ; } Nel codice precedente: alla riga 5, dichiariamo un puntatore ad intero p ; il puntatore viene memorizzato nello stack, e punta all'indirizzo del primo valore di memoria disponibile nell'heap grazie alla malloc (riga 6); una volta terminata la serie di istruzioni da eseguire, la memoria puntata da p viene rilasciata mediante la free . Anche per l'allocazione dinamica possiamo riassumere vantaggi e svantaggi. Vantaggi Svantaggi Allocazione della memoria fatta a runtime. Possibilit\u00e0 di allocare, deallocare e riallocare ulteriore memoria alla bisogna. Maggior tempo di esecuzione richiesto per l'allocazione dinamica. Necessit\u00e0 di gestire la deallocazione della memoria in forma esplicita.","title":"20 - Gestione della memoria"},{"location":"material/03_c_language/20_memory/lecture/#20-allocazione-statica-e-dinamica-della-memoria","text":"La memoria di un calcolatore \u00e8 tipicamente divisa in tre sezioni: la heap , ovvero una parte di memoria richiamabile all'occorrenza dal programmatore; lo stack , nel quale le variabili vengono dichiarate, inizializzate a runtime, e che agisce secondo una logica LIFO; la code section , dove viene memorizzato il programma a runtime. Questa disposizione della memoria ci permette quindi di allocarla (ovvero assegnarla ) secondo due modalit\u00e0, statica e dinamica .","title":"20 - Allocazione statica e dinamica della memoria"},{"location":"material/03_c_language/20_memory/lecture/#201-allocazione-statica-della-memoria","text":"L'allocazione statica della memoria prevede che il programma in esecuzione abbia una dimesione prefissata a compile time, la quale non pu\u00f2 essere in alcun modo modificata a runtime. Ovviamente, ci\u00f2 implica che il programmatore sia in grado di definire esattamente a priori i requisiti del suo programma in termini di memoria. Un esempio di allocazione statica della memoria \u00e8 il seguente: int main () { int a ; // prealloco 4 byte long b ; // prealloco 8 byte } Nel codice precedente dichiariamo due variabili, per le quali saranno allocate, rispettivamente, 32 e 64 bit all'interno dello stack. A runtime, a meno che non siano specificate delle apposite operazioni di cast, la quantit\u00e0 di memoria allocata non verr\u00e0 modificata, e sar\u00e0 liberata in automatico soltanto al termine dell'esecuzione dello stesso. Riassumiamo quindi i vantaggi e gli svantaggi dell'allocazione statica. Vantaggi Svantaggi Semplicit\u00e0 di utilizzo. Delega al compilatore dell'allocazione della memoria. Efficiente a runtime. Memoria non necessariamente utilizzata al meglio (specie con array). Necessit\u00e0 di conoscere a priori i requisiti in termini di memoria. Impossibilit\u00e0 di riallocare la memoria a runtime.","title":"20.1 - Allocazione statica della memoria"},{"location":"material/03_c_language/20_memory/lecture/#202-allocazione-dinamica-della-memoria","text":"A differenza dell'allocazione statica, nell'allocazione dinamica \u00e8 il programmatore a controllare quanta memoria viene allocata. Inoltre, in questo caso, viene utilizzata la memoria heap, e non lo stack. L'allocazione dinamica prevede quindi che la memoria non sia allocata a priori, ovvero a compile time, ma piuttosto a runtime; di conseguenza, pu\u00f2 essere sia assegnata, sia liberata, e farlo in maniera corretta comporta un utilizzo pi\u00f9 efficiente della memoria stessa. Dal punto di vista pratico, la libreria stdlib.h offre una serie di funzioni che permettono l'allocazione dinamica della memoria, che vediamo di seguito.","title":"20.2 - Allocazione dinamica della memoria"},{"location":"material/03_c_language/20_memory/lecture/#2021-la-funzione-malloc","text":"La funzione malloc permette di allocare un certo quantitativo di memoria a runtime, specificando come parametro passato alla funzione il numero di byte da allocare. Quindi, ad esempio: int num_values = 10 ; int * p = ( int * ) malloc ( num_values ); Grazie all'istruzione precedente, avremo allocato spazio sufficiente a contenere dieci numeri interi a quattro byte, ovvero quaranta byte. Inoltre, \u00e8 opportuno notare come la malloc restituisca in uscita un indirizzo di memoria; in questo caso, quindi, \u00e8 necessario effettuare un casting a puntatore ad intero.","title":"20.2.1 - La funzione malloc"},{"location":"material/03_c_language/20_memory/lecture/#2022-la-funzione-calloc","text":"La funzione calloc offre un vantaggio rispetto alla malloc , inizializzando gli elementi allocati in modo che questi assumano un valore pari a zero. La sintassi \u00e8 la seguente: int num_values = 10 ; int * p = ( int * ) calloc ( num_values , sizeof ( int )) Notiamo subito come vi sia una prima differenza rispetto alla malloc legata al fatto che la funzione accetta due parametri, ovvero il numero di oggetti per i quali \u00e8 richiesta l'allocazione, e la dimensione di ciascun oggetto. Anche in questo caso, la funzione restituisce un indirizzo di memoria.","title":"20.2.2 - La funzione calloc"},{"location":"material/03_c_language/20_memory/lecture/#2023-la-funzione-realloc","text":"La funzione realloc ci permette di riutilizzare o estendere la memoria che abbiamo allocato in precedenza mediante la malloc o la calloc . In tal senso, la funzione accetta due argomenti, ovvero il tipo del puntatore precedentemente allocato, ed il numero di nuovi elementi da allocare. int new_size = 20 ; p = ( int * ) realloc ( p , new_size )","title":"20.2.3 - La funzione realloc"},{"location":"material/03_c_language/20_memory/lecture/#2024-la-funzione-free","text":"Una delle cose pi\u00f9 importanti da tenere a mente quando abbiamo a che fare con l'allocazione dinamica \u00e8 che la memoria deve essere sempre rilasciata qualora non sia pi\u00f9 richiesta. Ci\u00f2 avviene di solito in maniera automatica al termine dell'esecuzione del programma; tuttavia, \u00e8 consigliato effettuare tale rilascio sempre in maniera esplicita. Per farlo, dobbiamo utilizzare la funzione free , passando come argomento il puntatore all'indirizzo di memoria che desideriamo liberare. Facciamo adesso un esempio completo: #include <stdlib.h> int main () { int * p ; p = ( int * ) malloc ( 5 * sizeof ( int )); free ( p ); return 0 ; } Nel codice precedente: alla riga 5, dichiariamo un puntatore ad intero p ; il puntatore viene memorizzato nello stack, e punta all'indirizzo del primo valore di memoria disponibile nell'heap grazie alla malloc (riga 6); una volta terminata la serie di istruzioni da eseguire, la memoria puntata da p viene rilasciata mediante la free . Anche per l'allocazione dinamica possiamo riassumere vantaggi e svantaggi. Vantaggi Svantaggi Allocazione della memoria fatta a runtime. Possibilit\u00e0 di allocare, deallocare e riallocare ulteriore memoria alla bisogna. Maggior tempo di esecuzione richiesto per l'allocazione dinamica. Necessit\u00e0 di gestire la deallocazione della memoria in forma esplicita.","title":"20.2.4 - La funzione free"},{"location":"material/03_c_language/21_io_files/lecture/","text":"20 - Tecniche di I/O in C \u00b6 20.1 - Il concetto di stream \u00b6 Il linguaggio C adotta estensivamente il concetto di stream (traducibile in italiano con flusso ) per gestire i meccanismi di interazione di un programma con le sorgenti di input ( ingresso ) o le destinazioni in output ( uscita ). Abbiamo gi\u00e0 usato uno stream, ad esempio, con la funzione printf : in questo caso, infatti, abbiamo creato un flusso dati verso l'utente, mostrando a schermo un certo output definito all'interno del nostro programma. Concettualmente, uno stream \u00e8 assimilabile ad una sorta di \"intermediario\", che permette al nostro programma di gestire indirettamente la sorgente (o destinazione) dei dati. In altre parole, il programma non interagisce direttamente con i dispositivi di input ed output, ma bens\u00ec esclusivamente con lo stream. Ci\u00f2 permette quindi di \"astrarsi\" dall'effettivo dispositivo di interazione, consentendo di utilizzare oggetti e metodi affini in casi eterogenei, come uso di tastiera, stampanti, o anche (e soprattutto) file . 20.2 - I file in C \u00b6 Intuitivamente, sappiamo che i file altro non sono se non degli insiemi di dati , organizati e memorizzati in memoria in maniera ordinata. In particolare, il C riconosce due tipi di file: i primi sono i file di testo , normalmente intelliggibili dall'essere umano, e formati da sequenze di caratteri organizzate in linee, ognuna delle quali termina con l'escape character \\n ; i second sono i file binari , costituiti da sequenze di bit di lunghezza arbitraria, e contenenti dati relativi a programmi, librerie, o altro ancora. Ad ogni modo, i contenuti di un file sono accessibili in C secondo due diverse modalit\u00e0: accedendo ad un file in maniera sequenziale , possiamo accedere a ciascun elemento \"scorrendo\" i precedenti; accedendo ad un file in maniera casuale , o diretta , siamo in grado di accedere direttamente all'elemento che ci interessa. 20.2.1 - Accesso al file \u00b6 20.2.1.1 - Puntatore a FILE \u00b6 Per accedere ad un file, C ci mette a disposizione un apposito puntatore al tipo FILE , definito nell'header stdio.h , che restituisce la locazione iniziale del file a cui si vuole accedere. Questa sintassi va quindi sempre utilizzata qualora si voglia interagire con un file: #include <stdio.h> // ... FILE * fp ; 20.2.1.2 - Apertura del file con fopen \u00b6 Per aprire il file, \u00e8 necessario utilizzare la funzione fopen , contenuta in stdio.h che permette di operare in diverse modalit\u00e0 usando una sintassi del tipo: FILE fopen ( file_name , mode ); In particolare: file_name \u00e8 un array di char che indica il nome del file da aprire; mode \u00e8 un array di char che indica la modalit\u00e0 con cui il file sar\u00e0 aperto. Per quello che riguarda la modalit\u00e0 di apertura del file, si pu\u00f2 scegliere una tra le seguenti: Modo Descrizione File gi\u00e0 esistente? r Apertura di un file in sola lettura. S\u00ec, necessario. r+ Apertura di un file esistente in lettura/scrittura. S\u00ec, necessario. w Creazione di un nuovo file in scrittura. Se il file esiste, ne viene cancellato il contenuto. Non necessario. w+ Creazione di un nuovo file in lettura/scrittura. Se il file esiste, ne viene cancellato il contenuto. Non necessario. a Aggiunta di nuovi contenuti a partire dalla fine del file. Se il file non esiste, viene creato. Non necessario. a+ Aggiunta e lettura di nuovi contenuti a partire dalla fine del file. Se il file non esiste, viene creato. Non necessario. In aggiunta al mode, \u00e8 possibile specificare il tipo di file da aprire, specificando la lettera b (binario) o t (testo). Se quest'ultimo valore non viene specificato, viene supposto il valore t . Ad esempio, per aprire il file di testo prova.txt in modalit\u00e0 di lettura/scrittura, si usano le seguenti istruzioni: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } Nota Nelle istruzioni precedenti, \u00e8 bene notare come venga controllata l'esistenza del file. Con la modalit\u00e0 w un controllo di questo tipo \u00e8 ridondante, ma nel caso si utilizzi la modalit\u00e0 r tale controllo pu\u00f2 rivelarsi critico. 20.2.1.3 - Chiusura di un file con fclose \u00b6 Una volta terminato l'utilizzo del file, \u00e8 necessario chiamare la funzione fclose che, come dice il nome stesso, permette di chiudere lo stream relativo al file stesso. In tal senso, la sintassi che si utilizza \u00e8 la seguente: int fclose ( FILE * fp ); La funzione fclose restituisce un valore intero pari a 0 se il tutto \u00e8 andato a buon fine. Proviamo ad estendere il programma precedente integrando la fclose al termine del file. FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } // Uso del file... fclose ( fp ); 20.2.2 - Scrittura su file \u00b6 La funzione fprintf permette di scrivere su di un file a seguito dell'apertura dello stesso. Come appare evidente anche dall'assonanza, questa funzione \u00e8 simile alla classica prinft , ed adotta una sintassi del tipo: int fprintf ( FILE * fp , char * format , [ args ]) Le differenze principali rispetto alla printf sono quindi due: il primo sta nel fatto che la funzione accetta come primo argomento un puntatore a file; il secondo invece sta nel fatto che la funzione restituisce un intero come valore di ritorno, rappresentativo del numero di caratteri scritto nello stream. Nota Qualora la fprintf restituisca un valore pari alla costante EOF , vorr\u00e0 dire che vi \u00e8 stato un errore nella scrittura dei dati. Facciamo un esempio: #include <stdio.h> #include <stdlib.h> int main () { FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } fprintf ( fp , \"Il file esiste!\" ); fclose ( fp ); } 20.2.3 - Lettura di un input \u00b6 20.2.3.1 - Lettura di uno stream da tastiera: la funzione scanf \u00b6 La funzione scanf ci permette di acquisire una sequenza di caratteri (lettere o cifre) dalla tastiera, memorizzandola in un'opportuna variabile; per i pi\u00f9 attenti, apparir\u00e0 chiaro come questa sia una sorta di funzione \"duale\" alla printf . La sintassi della scanf \u00e8 quella riportata di seguito: scanf ( char * format , [ args ]); Notiamo innazitutto che non vi \u00e8 un valore di ritorno atteso. Infatti, le variabili da \"popolare\" saranno specificate mediante un puntatore tra gli args passati dopo la serie di specificatori di formato associati all'argomento format . Ad esempio, usando l'istruzione: int x ; scanf ( \"%d%, &x); faremo in modo che il valore numerico digitato da tastiera venga salvato nella variabile x . In alternativa, se volessimo salvare un intero ed un decimale, e salvarli nelle variabili x ed y , dovremmo scrivere: int x ; int y ; scanf ( \"%d %f\" , & x , & y ); Nota Nel tempo, l'uso di scanf \u00e8 diventato \"sconsigliato\". Per approfondire, leggete qui . 20.2.3.2 - Lettura di un file: la funzione fscanf \u00b6 In maniera alquanto \"prevedibile\", la funzione fscanf permette di leggere il contenuto di un file; rappresenta quindi la funzione duale alla fprintf , o equivalente alla scanf per file. Vediamo quindi qual \u00e8 il prototipo della funzione: int fscanf ( FILE * fp , char * format , [ args ]); In questo caso, viene restituito un valore intero, che rappresenta il numero di caratteri letti dalla funzione. Inoltre, come primo argomento, avremo sempre il puntatore al file da leggere. 20.2.4 - Fine di un file: la funzione feof \u00b6 Chiudiamo questa carrellata con la funzione feof , che ci permette di capire se ci troviamo o meno alla fine del file. Il corpo di questa funzione \u00e8 definito come: int feof ( FILE * fp ); In particolare, la funzione restituir\u00e0 0 se non \u00e8 ancora stata raggiunta la fine del file, o 1 altrimenti. L'uso della feof pu\u00f2 essere utile nel momento in cui, ad esempio, si legge un file carattere per carattere all'interno di un ciclo, e si vuole uscire dallo stesso quando il file termina. Ad esempio: #include <stdio.h> #include <stdlib.h> #define N 5 int main () { FILE * fp ; char cognome [ 20 ]; char nome [ 20 ]; int i , voto ; if (( fp = fopen ( \"alunni.txt\" , \"rt\" )) == NULL ) { printf ( \"Errore nell'apertura del file'\" ); exit ( 1 ); } while ( ! feof ( fp )){ fscanf ( fp , \"%s %s %d \\n \" , & cognome , & nome , & voto ); printf ( \"cognome: %s, nome: %s, voto: %d \\n \" , cognome , nome , voto ); } fclose ( fp ); return 0 ; }","title":"21 - I/O e file"},{"location":"material/03_c_language/21_io_files/lecture/#20-tecniche-di-io-in-c","text":"","title":"20 - Tecniche di I/O in C"},{"location":"material/03_c_language/21_io_files/lecture/#201-il-concetto-di-stream","text":"Il linguaggio C adotta estensivamente il concetto di stream (traducibile in italiano con flusso ) per gestire i meccanismi di interazione di un programma con le sorgenti di input ( ingresso ) o le destinazioni in output ( uscita ). Abbiamo gi\u00e0 usato uno stream, ad esempio, con la funzione printf : in questo caso, infatti, abbiamo creato un flusso dati verso l'utente, mostrando a schermo un certo output definito all'interno del nostro programma. Concettualmente, uno stream \u00e8 assimilabile ad una sorta di \"intermediario\", che permette al nostro programma di gestire indirettamente la sorgente (o destinazione) dei dati. In altre parole, il programma non interagisce direttamente con i dispositivi di input ed output, ma bens\u00ec esclusivamente con lo stream. Ci\u00f2 permette quindi di \"astrarsi\" dall'effettivo dispositivo di interazione, consentendo di utilizzare oggetti e metodi affini in casi eterogenei, come uso di tastiera, stampanti, o anche (e soprattutto) file .","title":"20.1 - Il concetto di stream"},{"location":"material/03_c_language/21_io_files/lecture/#202-i-file-in-c","text":"Intuitivamente, sappiamo che i file altro non sono se non degli insiemi di dati , organizati e memorizzati in memoria in maniera ordinata. In particolare, il C riconosce due tipi di file: i primi sono i file di testo , normalmente intelliggibili dall'essere umano, e formati da sequenze di caratteri organizzate in linee, ognuna delle quali termina con l'escape character \\n ; i second sono i file binari , costituiti da sequenze di bit di lunghezza arbitraria, e contenenti dati relativi a programmi, librerie, o altro ancora. Ad ogni modo, i contenuti di un file sono accessibili in C secondo due diverse modalit\u00e0: accedendo ad un file in maniera sequenziale , possiamo accedere a ciascun elemento \"scorrendo\" i precedenti; accedendo ad un file in maniera casuale , o diretta , siamo in grado di accedere direttamente all'elemento che ci interessa.","title":"20.2 - I file in C"},{"location":"material/03_c_language/21_io_files/lecture/#2021-accesso-al-file","text":"","title":"20.2.1 - Accesso al file"},{"location":"material/03_c_language/21_io_files/lecture/#20211-puntatore-a-file","text":"Per accedere ad un file, C ci mette a disposizione un apposito puntatore al tipo FILE , definito nell'header stdio.h , che restituisce la locazione iniziale del file a cui si vuole accedere. Questa sintassi va quindi sempre utilizzata qualora si voglia interagire con un file: #include <stdio.h> // ... FILE * fp ;","title":"20.2.1.1 - Puntatore a FILE"},{"location":"material/03_c_language/21_io_files/lecture/#20212-apertura-del-file-con-fopen","text":"Per aprire il file, \u00e8 necessario utilizzare la funzione fopen , contenuta in stdio.h che permette di operare in diverse modalit\u00e0 usando una sintassi del tipo: FILE fopen ( file_name , mode ); In particolare: file_name \u00e8 un array di char che indica il nome del file da aprire; mode \u00e8 un array di char che indica la modalit\u00e0 con cui il file sar\u00e0 aperto. Per quello che riguarda la modalit\u00e0 di apertura del file, si pu\u00f2 scegliere una tra le seguenti: Modo Descrizione File gi\u00e0 esistente? r Apertura di un file in sola lettura. S\u00ec, necessario. r+ Apertura di un file esistente in lettura/scrittura. S\u00ec, necessario. w Creazione di un nuovo file in scrittura. Se il file esiste, ne viene cancellato il contenuto. Non necessario. w+ Creazione di un nuovo file in lettura/scrittura. Se il file esiste, ne viene cancellato il contenuto. Non necessario. a Aggiunta di nuovi contenuti a partire dalla fine del file. Se il file non esiste, viene creato. Non necessario. a+ Aggiunta e lettura di nuovi contenuti a partire dalla fine del file. Se il file non esiste, viene creato. Non necessario. In aggiunta al mode, \u00e8 possibile specificare il tipo di file da aprire, specificando la lettera b (binario) o t (testo). Se quest'ultimo valore non viene specificato, viene supposto il valore t . Ad esempio, per aprire il file di testo prova.txt in modalit\u00e0 di lettura/scrittura, si usano le seguenti istruzioni: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } Nota Nelle istruzioni precedenti, \u00e8 bene notare come venga controllata l'esistenza del file. Con la modalit\u00e0 w un controllo di questo tipo \u00e8 ridondante, ma nel caso si utilizzi la modalit\u00e0 r tale controllo pu\u00f2 rivelarsi critico.","title":"20.2.1.2 - Apertura del file con fopen"},{"location":"material/03_c_language/21_io_files/lecture/#20213-chiusura-di-un-file-con-fclose","text":"Una volta terminato l'utilizzo del file, \u00e8 necessario chiamare la funzione fclose che, come dice il nome stesso, permette di chiudere lo stream relativo al file stesso. In tal senso, la sintassi che si utilizza \u00e8 la seguente: int fclose ( FILE * fp ); La funzione fclose restituisce un valore intero pari a 0 se il tutto \u00e8 andato a buon fine. Proviamo ad estendere il programma precedente integrando la fclose al termine del file. FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } // Uso del file... fclose ( fp );","title":"20.2.1.3 - Chiusura di un file con fclose"},{"location":"material/03_c_language/21_io_files/lecture/#2022-scrittura-su-file","text":"La funzione fprintf permette di scrivere su di un file a seguito dell'apertura dello stesso. Come appare evidente anche dall'assonanza, questa funzione \u00e8 simile alla classica prinft , ed adotta una sintassi del tipo: int fprintf ( FILE * fp , char * format , [ args ]) Le differenze principali rispetto alla printf sono quindi due: il primo sta nel fatto che la funzione accetta come primo argomento un puntatore a file; il secondo invece sta nel fatto che la funzione restituisce un intero come valore di ritorno, rappresentativo del numero di caratteri scritto nello stream. Nota Qualora la fprintf restituisca un valore pari alla costante EOF , vorr\u00e0 dire che vi \u00e8 stato un errore nella scrittura dei dati. Facciamo un esempio: #include <stdio.h> #include <stdlib.h> int main () { FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } fprintf ( fp , \"Il file esiste!\" ); fclose ( fp ); }","title":"20.2.2 - Scrittura su file"},{"location":"material/03_c_language/21_io_files/lecture/#2023-lettura-di-un-input","text":"","title":"20.2.3 - Lettura di un input"},{"location":"material/03_c_language/21_io_files/lecture/#20231-lettura-di-uno-stream-da-tastiera-la-funzione-scanf","text":"La funzione scanf ci permette di acquisire una sequenza di caratteri (lettere o cifre) dalla tastiera, memorizzandola in un'opportuna variabile; per i pi\u00f9 attenti, apparir\u00e0 chiaro come questa sia una sorta di funzione \"duale\" alla printf . La sintassi della scanf \u00e8 quella riportata di seguito: scanf ( char * format , [ args ]); Notiamo innazitutto che non vi \u00e8 un valore di ritorno atteso. Infatti, le variabili da \"popolare\" saranno specificate mediante un puntatore tra gli args passati dopo la serie di specificatori di formato associati all'argomento format . Ad esempio, usando l'istruzione: int x ; scanf ( \"%d%, &x); faremo in modo che il valore numerico digitato da tastiera venga salvato nella variabile x . In alternativa, se volessimo salvare un intero ed un decimale, e salvarli nelle variabili x ed y , dovremmo scrivere: int x ; int y ; scanf ( \"%d %f\" , & x , & y ); Nota Nel tempo, l'uso di scanf \u00e8 diventato \"sconsigliato\". Per approfondire, leggete qui .","title":"20.2.3.1 - Lettura di uno stream da tastiera: la funzione scanf"},{"location":"material/03_c_language/21_io_files/lecture/#20232-lettura-di-un-file-la-funzione-fscanf","text":"In maniera alquanto \"prevedibile\", la funzione fscanf permette di leggere il contenuto di un file; rappresenta quindi la funzione duale alla fprintf , o equivalente alla scanf per file. Vediamo quindi qual \u00e8 il prototipo della funzione: int fscanf ( FILE * fp , char * format , [ args ]); In questo caso, viene restituito un valore intero, che rappresenta il numero di caratteri letti dalla funzione. Inoltre, come primo argomento, avremo sempre il puntatore al file da leggere.","title":"20.2.3.2 - Lettura di un file: la funzione fscanf"},{"location":"material/03_c_language/21_io_files/lecture/#2024-fine-di-un-file-la-funzione-feof","text":"Chiudiamo questa carrellata con la funzione feof , che ci permette di capire se ci troviamo o meno alla fine del file. Il corpo di questa funzione \u00e8 definito come: int feof ( FILE * fp ); In particolare, la funzione restituir\u00e0 0 se non \u00e8 ancora stata raggiunta la fine del file, o 1 altrimenti. L'uso della feof pu\u00f2 essere utile nel momento in cui, ad esempio, si legge un file carattere per carattere all'interno di un ciclo, e si vuole uscire dallo stesso quando il file termina. Ad esempio: #include <stdio.h> #include <stdlib.h> #define N 5 int main () { FILE * fp ; char cognome [ 20 ]; char nome [ 20 ]; int i , voto ; if (( fp = fopen ( \"alunni.txt\" , \"rt\" )) == NULL ) { printf ( \"Errore nell'apertura del file'\" ); exit ( 1 ); } while ( ! feof ( fp )){ fscanf ( fp , \"%s %s %d \\n \" , & cognome , & nome , & voto ); printf ( \"cognome: %s, nome: %s, voto: %d \\n \" , cognome , nome , voto ); } fclose ( fp ); return 0 ; }","title":"20.2.4 - Fine di un file: la funzione feof"},{"location":"material/03_c_language/22_typedef/exercises/","text":"E21 - Struct , typedef ed union \u00b6 Esercizio E21.1 \u00b6 Scrivere un programma che definisca una struct per gli studenti, rappresentante nome, cognome ed et\u00e0, ed una union per il voto di un esame, che pu\u00f2 essere intero o reale. Mostrarne il funzionamento in un'apposita funzione main() . Soluzione S21.1 \u00b6 Ecco una possibile soluzione. #pragma warning(disable: 4996) #include <stdio.h> typedef struct studente { char nome [ 20 ]; char cognome [ 20 ]; int eta ; } STUDENTE ; typedef union voto_esame { int voto_int ; double voto_double ; } VOTO_ESAME ; int main () { // Accedo mediante l'operatore punto STUDENTE primo_studente = { \"\" , \"\" , 0 }; // Popolo printf ( \"Inserire il nome: \" ); if ( scanf ( \"%s\" , primo_studente . nome ) <= 0 ) return -1 ; printf ( \"Inserire il cognome: \" ); if ( scanf ( \"%s\" , primo_studente . cognome ) <= 0 ) return -1 ; printf ( \"Inserire l'eta': \" ); if ( scanf ( \"%d\" , & primo_studente . eta ) <= 0 ) return -1 ; printf ( \"Nome: %s - Cognome: %s - Eta: %d \\n \" , primo_studente . nome , primo_studente . cognome , primo_studente . eta ); // Accedo mediante puntatore STUDENTE secondo_studente = { \"\" , \"\" , 0 }; STUDENTE * puntatore_studente = & secondo_studente ; // Popolo printf ( \"Inserire un nuovo nome: \" ); if ( scanf ( \"%s\" , puntatore_studente -> nome ) <= 0 ) return -1 ; printf ( \"Inserire un nuovo cognome: \" ); if ( scanf ( \"%s\" , puntatore_studente -> cognome ) <= 0 ) return -1 ; printf ( \"Inserire una nuova eta': \" ); if ( scanf ( \"%d\" , & puntatore_studente -> eta ) <= 0 ) return -1 ; printf ( \"Nome: %s - Cognome: %s - Eta: %d \\n \" , secondo_studente . nome , secondo_studente . cognome , secondo_studente . eta ); // Definisco la union VOTO_ESAME voto_primo_esame = { 0 }; VOTO_ESAME voto_secondo_esame = { 0.0 }; VOTO_ESAME * puntatore_primo_esame = & voto_primo_esame ; printf ( \"Inserire il voto (intero) per il primo esame: \" ); if ( scanf ( \"%d\" , & voto_primo_esame . voto_int ) <= 0 ) return -1 ; printf ( \"Inserire il voto (decimale) per il secondo esame: \" ); if ( scanf ( \"%lf\" , & voto_secondo_esame . voto_double ) <= 0 ) return -1 ; printf ( \"Aggiornare il voto (decimale) per il primo esame: \" ); if ( scanf ( \"%lf\" , & puntatore_primo_esame -> voto_double ) <= 0 ) return -1 ; printf ( \"Il voto per il primo esame e' %d (intero) e %lf (decimale) \\n \" , voto_primo_esame . voto_int , voto_primo_esame . voto_double ); return 0 ; }","title":"E22 - Typedef, struct ed union"},{"location":"material/03_c_language/22_typedef/exercises/#e21-struct-typedef-ed-union","text":"","title":"E21 - Struct, typedef ed union"},{"location":"material/03_c_language/22_typedef/exercises/#esercizio-e211","text":"Scrivere un programma che definisca una struct per gli studenti, rappresentante nome, cognome ed et\u00e0, ed una union per il voto di un esame, che pu\u00f2 essere intero o reale. Mostrarne il funzionamento in un'apposita funzione main() .","title":"Esercizio E21.1"},{"location":"material/03_c_language/22_typedef/exercises/#soluzione-s211","text":"Ecco una possibile soluzione. #pragma warning(disable: 4996) #include <stdio.h> typedef struct studente { char nome [ 20 ]; char cognome [ 20 ]; int eta ; } STUDENTE ; typedef union voto_esame { int voto_int ; double voto_double ; } VOTO_ESAME ; int main () { // Accedo mediante l'operatore punto STUDENTE primo_studente = { \"\" , \"\" , 0 }; // Popolo printf ( \"Inserire il nome: \" ); if ( scanf ( \"%s\" , primo_studente . nome ) <= 0 ) return -1 ; printf ( \"Inserire il cognome: \" ); if ( scanf ( \"%s\" , primo_studente . cognome ) <= 0 ) return -1 ; printf ( \"Inserire l'eta': \" ); if ( scanf ( \"%d\" , & primo_studente . eta ) <= 0 ) return -1 ; printf ( \"Nome: %s - Cognome: %s - Eta: %d \\n \" , primo_studente . nome , primo_studente . cognome , primo_studente . eta ); // Accedo mediante puntatore STUDENTE secondo_studente = { \"\" , \"\" , 0 }; STUDENTE * puntatore_studente = & secondo_studente ; // Popolo printf ( \"Inserire un nuovo nome: \" ); if ( scanf ( \"%s\" , puntatore_studente -> nome ) <= 0 ) return -1 ; printf ( \"Inserire un nuovo cognome: \" ); if ( scanf ( \"%s\" , puntatore_studente -> cognome ) <= 0 ) return -1 ; printf ( \"Inserire una nuova eta': \" ); if ( scanf ( \"%d\" , & puntatore_studente -> eta ) <= 0 ) return -1 ; printf ( \"Nome: %s - Cognome: %s - Eta: %d \\n \" , secondo_studente . nome , secondo_studente . cognome , secondo_studente . eta ); // Definisco la union VOTO_ESAME voto_primo_esame = { 0 }; VOTO_ESAME voto_secondo_esame = { 0.0 }; VOTO_ESAME * puntatore_primo_esame = & voto_primo_esame ; printf ( \"Inserire il voto (intero) per il primo esame: \" ); if ( scanf ( \"%d\" , & voto_primo_esame . voto_int ) <= 0 ) return -1 ; printf ( \"Inserire il voto (decimale) per il secondo esame: \" ); if ( scanf ( \"%lf\" , & voto_secondo_esame . voto_double ) <= 0 ) return -1 ; printf ( \"Aggiornare il voto (decimale) per il primo esame: \" ); if ( scanf ( \"%lf\" , & puntatore_primo_esame -> voto_double ) <= 0 ) return -1 ; printf ( \"Il voto per il primo esame e' %d (intero) e %lf (decimale) \\n \" , voto_primo_esame . voto_int , voto_primo_esame . voto_double ); return 0 ; }","title":"Soluzione S21.1"},{"location":"material/03_c_language/22_typedef/lecture/","text":"21 - Struct , typedef ed union \u00b6 Abbiamo visto come il linguaggio C consenta l'utilizzo di una serie di tipi di dati primitivi. Tuttavia, consentirci soltanto questo sarebbe in un certo senso \"limitante\": ad esempio, potremmo voler creare una singola variabile che rappresenti una persona, senza dover necessariamente \"far proliferare\" tutta una serie di sottovariabili contenenti, ad esempio, nome, cognome ed et\u00e0. Per ovviare a questa limitazione, quindi, il C ci mette a disposizione un particolare costrutto rappresentativo di una struttura dati definita dall'utente; come prevedibile, tale costrutto va sotto il nome di struct . 21.1 - Le struct \u00b6 I pi\u00f9 attenti ricorderanno come abbiamo gi\u00e0 visto il concetto di struct durante il nostro excursus sulle strutture dati ; ovviamente, le struct C rappresentano un'implementazione di questa classe di strutture dati, e permettono quindi di \"raggruppare\" diverse variabili tra loro. Ad esempio, potremmo creare una struct che serva a caratterizzare una persona: struct persona { char * nome ; char * cognome ; int eta ; }; In generale, quindi, una struct \u00e8 definita nel modo che segue: struct NOME_STRUCT { tipo_variabile_1 id_variabile_1 ; tipo_variabile_2 id_variabile_2 ; // ... tipo_variabile_n id_variabile_n ; } Nel nostro esempio, una variabile associata alla struct persona avr\u00e0 quindi un array di char relativo al nome, un array di char relativo al cognome, ed un int relativo all'et\u00e0. Proviamo adesso ad utilizzare questa struct : #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona studente ; return 0 ; } Abbiamo creato una variabile di \"tipo\" persona. Potremo accedere a ciascuna delle \"sottovariabili\", o membri, della struct utilizzando l'operatore dot (punto): #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona studente ; studente . nome = \"John\" ; studente . cognome = \"Doe\" ; studente . eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente . name , studente . cognome , studente . eta ); return 0 ; } Abbiamo quindi visto come l'accesso mediante l'operatore punto valga sia in lettura, sia in scrittura. 22.1.1 - Puntatori a struct \u00b6 Possiamo anche definire dei puntatori ad una struttura. In questo caso, per\u00f2, per accedre alla singola propriet\u00e0 della struct , dovremo utilizzare infix (->) #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA * puntatore_studente ; puntatore_studente -> nome = \"John\" ; puntatore_studente -> cognome = \"Doe\" ; puntatore_studente -> eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente -> name , studente -> cognome , studente -> eta ); return 0 ; } 22.2 - Definizione di tipo con typedef \u00b6 Abbiamo visto come le struct ci permettano di \"associare\" diverse variabili tra loro, definendo dei veri e propri \"tipi\" composti da diverse variabili appartenenti a tipi primitivi. Il passo successivo, quindi, \u00e8 quello di \"formalizzare\" queste strutture; per farlo, il linguaggio C ci mette a disposizione la parola chiave typedef che, come suggerisce il nome stesso, consente di creare un tipo definito dall'utente. Ad esempio, potremmo creare un tipo da associare alla struct persona: typedef struct persona { char * nome ; char * cognome ; int eta ; } TIPO_PERSONA ; In questo caso, l'identificativo associato alla struct rimane persona (in minuscolo), mentre il tipo definito a partire dalla struct persona sar\u00e0 TIPO_PERSONA . Potremo quindi creare una variabile di tipo TIPO_PERSONA proprio come se fosse una variabile di tipo primitivo: #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA studente ; // altre istruzioni return 0 ; } Sottolineamo come la definizione di un tipo non sia vincolata ad una struct. Ad esempio, potremmo definire un tipo che rappresenta un puntatore ad intero. #include <stdio.h> typedef int * int_pointer ; int main () { int val = 0.0 ; int_pointer pointer = & val ; printf ( \"Il valore del puntatore e': %p\" , pointer ); return 0 ; } 22.3 - Le union \u00b6 Quando abbiamo parlato di strutture dati abbiamo visto, oltre alle struct , le union . Prevedibilmente, il C ci mette a disposizione oggetti di questo tipo, che risultano essere sintatticamente analoghi alle struct , ma che tuttavia implementano una struttura dati di tipo differente. Vediamo un rapido esempio. #include <stdio.h> typedef union lettura_sensore { double d ; int i ; } LETTURA_SENSORE ; int main () { LETTURA_SENSORE lettura ; lettura . d = 12.0 ; lettura . i = 5 ; } TODO: puntatore, printf","title":"22 - Typedef, struct ed union"},{"location":"material/03_c_language/22_typedef/lecture/#21-struct-typedef-ed-union","text":"Abbiamo visto come il linguaggio C consenta l'utilizzo di una serie di tipi di dati primitivi. Tuttavia, consentirci soltanto questo sarebbe in un certo senso \"limitante\": ad esempio, potremmo voler creare una singola variabile che rappresenti una persona, senza dover necessariamente \"far proliferare\" tutta una serie di sottovariabili contenenti, ad esempio, nome, cognome ed et\u00e0. Per ovviare a questa limitazione, quindi, il C ci mette a disposizione un particolare costrutto rappresentativo di una struttura dati definita dall'utente; come prevedibile, tale costrutto va sotto il nome di struct .","title":"21 - Struct, typedef ed union"},{"location":"material/03_c_language/22_typedef/lecture/#211-le-struct","text":"I pi\u00f9 attenti ricorderanno come abbiamo gi\u00e0 visto il concetto di struct durante il nostro excursus sulle strutture dati ; ovviamente, le struct C rappresentano un'implementazione di questa classe di strutture dati, e permettono quindi di \"raggruppare\" diverse variabili tra loro. Ad esempio, potremmo creare una struct che serva a caratterizzare una persona: struct persona { char * nome ; char * cognome ; int eta ; }; In generale, quindi, una struct \u00e8 definita nel modo che segue: struct NOME_STRUCT { tipo_variabile_1 id_variabile_1 ; tipo_variabile_2 id_variabile_2 ; // ... tipo_variabile_n id_variabile_n ; } Nel nostro esempio, una variabile associata alla struct persona avr\u00e0 quindi un array di char relativo al nome, un array di char relativo al cognome, ed un int relativo all'et\u00e0. Proviamo adesso ad utilizzare questa struct : #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona studente ; return 0 ; } Abbiamo creato una variabile di \"tipo\" persona. Potremo accedere a ciascuna delle \"sottovariabili\", o membri, della struct utilizzando l'operatore dot (punto): #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona studente ; studente . nome = \"John\" ; studente . cognome = \"Doe\" ; studente . eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente . name , studente . cognome , studente . eta ); return 0 ; } Abbiamo quindi visto come l'accesso mediante l'operatore punto valga sia in lettura, sia in scrittura.","title":"21.1 - Le struct"},{"location":"material/03_c_language/22_typedef/lecture/#2211-puntatori-a-struct","text":"Possiamo anche definire dei puntatori ad una struttura. In questo caso, per\u00f2, per accedre alla singola propriet\u00e0 della struct , dovremo utilizzare infix (->) #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA * puntatore_studente ; puntatore_studente -> nome = \"John\" ; puntatore_studente -> cognome = \"Doe\" ; puntatore_studente -> eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente -> name , studente -> cognome , studente -> eta ); return 0 ; }","title":"22.1.1 - Puntatori a struct"},{"location":"material/03_c_language/22_typedef/lecture/#222-definizione-di-tipo-con-typedef","text":"Abbiamo visto come le struct ci permettano di \"associare\" diverse variabili tra loro, definendo dei veri e propri \"tipi\" composti da diverse variabili appartenenti a tipi primitivi. Il passo successivo, quindi, \u00e8 quello di \"formalizzare\" queste strutture; per farlo, il linguaggio C ci mette a disposizione la parola chiave typedef che, come suggerisce il nome stesso, consente di creare un tipo definito dall'utente. Ad esempio, potremmo creare un tipo da associare alla struct persona: typedef struct persona { char * nome ; char * cognome ; int eta ; } TIPO_PERSONA ; In questo caso, l'identificativo associato alla struct rimane persona (in minuscolo), mentre il tipo definito a partire dalla struct persona sar\u00e0 TIPO_PERSONA . Potremo quindi creare una variabile di tipo TIPO_PERSONA proprio come se fosse una variabile di tipo primitivo: #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA studente ; // altre istruzioni return 0 ; } Sottolineamo come la definizione di un tipo non sia vincolata ad una struct. Ad esempio, potremmo definire un tipo che rappresenta un puntatore ad intero. #include <stdio.h> typedef int * int_pointer ; int main () { int val = 0.0 ; int_pointer pointer = & val ; printf ( \"Il valore del puntatore e': %p\" , pointer ); return 0 ; }","title":"22.2 - Definizione di tipo con typedef"},{"location":"material/03_c_language/22_typedef/lecture/#223-le-union","text":"Quando abbiamo parlato di strutture dati abbiamo visto, oltre alle struct , le union . Prevedibilmente, il C ci mette a disposizione oggetti di questo tipo, che risultano essere sintatticamente analoghi alle struct , ma che tuttavia implementano una struttura dati di tipo differente. Vediamo un rapido esempio. #include <stdio.h> typedef union lettura_sensore { double d ; int i ; } LETTURA_SENSORE ; int main () { LETTURA_SENSORE lettura ; lettura . d = 12.0 ; lettura . i = 5 ; } TODO: puntatore, printf","title":"22.3 - Le union"},{"location":"material/04_python/23_intro/exercises/","text":"E23 - Introduzione a Python \u00b6 E23.1 \u00b6 Creiamo una stringa che assuma valore IUL . S23.1 - Soluzione \u00b6 >>> s = 'IUL' E23.2 \u00b6 Valutiamo la lunghezza della stringa creata al punto 23. S23.2 - Soluzione \u00b6 >>> len ( s ) E23.3 \u00b6 Proviamo a creare una lista a partire dalla stringa creata al punto 23. S23.3 - Soluzione \u00b6 >>> l = [ 'IUL' ] >>> l = [ 'I' , 'U' , 'L' ]","title":"E23 - Introduzione al Python"},{"location":"material/04_python/23_intro/exercises/#e23-introduzione-a-python","text":"","title":"E23 - Introduzione a Python"},{"location":"material/04_python/23_intro/exercises/#e231","text":"Creiamo una stringa che assuma valore IUL .","title":"E23.1"},{"location":"material/04_python/23_intro/exercises/#s231-soluzione","text":">>> s = 'IUL'","title":"S23.1 - Soluzione"},{"location":"material/04_python/23_intro/exercises/#e232","text":"Valutiamo la lunghezza della stringa creata al punto 23.","title":"E23.2"},{"location":"material/04_python/23_intro/exercises/#s232-soluzione","text":">>> len ( s )","title":"S23.2 - Soluzione"},{"location":"material/04_python/23_intro/exercises/#e233","text":"Proviamo a creare una lista a partire dalla stringa creata al punto 23.","title":"E23.3"},{"location":"material/04_python/23_intro/exercises/#s233-soluzione","text":">>> l = [ 'IUL' ] >>> l = [ 'I' , 'U' , 'L' ]","title":"S23.3 - Soluzione"},{"location":"material/04_python/23_intro/lecture/","text":"23 - Introduzione a Python \u00b6 Prima di iniziare a parlare del linguaggio Python, \u00e8 opportuno verificare che l'interprete sia installato nel nostro sistema. Per farlo, apriamo un terminale (Shell o Command Prompt, a seconda del nostro sistema), e scriviamo: $ python Se apparir\u00e0 una schermata simile a quella mostrata in figura, Python sar\u00e0 gi\u00e0 correttamente presente nel nostro sistema. In alternativa, dovremo provvedere ad installarlo seguendo la procedura indicata sul sito ufficiale , ed aggiungerlo al path di sistema. 23.1 - Python e tipizzazione \u00b6 23.1.1 - Tipizzazione dinamica \u00b6 Python \u00e8 un linguaggio interpretato ed a tipizzazione dinamica . In breve, questo significa che l'interprete valuta il tipo di ciascuna variabile a runtime, e che questo pu\u00f2 cambiare durante l'esecuzione del programma. Ma, a conti fatti, in cosa si traduce per il programmatore? Beh, molto semplice. Immaginiamo di dover definire ed inizializzare una variabile di tipo intero in un linguaggio a tipizzazione statica , come ad esempio il C++. Per farlo, scriveremo qualcosa simile a: int var = 0 ; In Python, potremo omettere il tipo, che sar\u00e0 inferito direttamente dal valore assegnato alla variabile: var = 0 Immaginiamo ora che la nostra variabile debba diventare un decimale. In C++, dovremo effettuare il casting: float fVar = float ( var ); fVar + 1.1 ; In Python questo non sar\u00e0 necessario, e potremo effettuare direttamente le operazioni desiderate: var + 1.1 # Il risultato sar\u00e0 2.1 Questo pu\u00f2 apparentemente semplificare di molto la vita, in quanto non \u00e8 pi\u00f9 necessario preoccuparsi del tipo della variabile. Non \u00e8 per\u00f2 tutto oro ci\u00f2 che luccica: per comprenderlo, infatti, \u00e8 il momento di parlare del (pilatesco) principio del duck typing . 23.1.1.1 - Duck Typing \u00b6 Il duck typing \u00e8 riassumibile nella seguente massima: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. che in italiano suona pi\u00f9 o meno Se cammina come un papero, e starnazza come un papero, deve essere un papero . Traduciamola brevemente in \"informatichese\". Immaginiamo di istruire il nostro interprete Python ad assegnare alla nostra variabile var il valore di 1 . L'interprete nota che la variabile si \"comporta\" come un numero intero, e quindi \"stabilir\u00e0\" che si tratti proprio di questo. Proviamo ora a sommare a var un valore pari ad 1.1 . Il risultato, come ovvio, sar\u00e0 un numero decimale, e quindi l'interprete \"cambier\u00e0 idea\", in quanto i comportamenti assunti da var sono adesso assimilabili ad una variabile di tipo float . L'utilit\u00e0 del duck typing \u00e8 evidente: permette allo sviluppatore di \"risparmiare\" numerose operazioni di cast, rendendo il codice pi\u00f9 semplice da scrivere e manutenere. Tuttavia, occorre tenerne conto nel momento in cui si usano classi ed oggetti, in quanto l'interprete prover\u00e0 ad inferire ed usare automaticamente un tipo in base al contesto in cui viene usata la variabile, con le comodit\u00e0 (ed i potenziali disastri) che questo comporta. 23.2 - L'interprete Python \u00b6 Nella sezione introduttiva abbiamo visto come installare l'interprete Python, in modo da avere un ambiente di lavoro accessibile direttamente mediante riga di comando. Lanciamolo di nuovo usando il seguente comando da una shell: python Potremo quindi finalmente iniziare ad utilizzare Python. 23.3 - Calcoli e numeri \u00b6 Proviamo ad usare l'interprete come una semplice calcolatrice; per farlo, scriviamo direttamente dopo il simbolo >>> le operazioni che vogliamo eseguire, e premiamo il tasto Invio . Ad esempio: >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2 23.3.1 - Divisioni \u00b6 Le divisioni restituiscono sempre un numero in virgola mobile. Ad esempio: >>> 16 / 3 5.333333333333333 >>> 2 / 2 2.0 Proviamo ora ad usare altri due operatori, molto simili al classico operatore di divisione: >>> 16 // 3 5 >>> 16 % 3 1 Notiamo come in questi casi siano restituiti dei numeri interi. Il perch\u00e9 \u00e8 presto detto: gli operatori // e % calcolano, rispettivamente, il quoziente ed il resto della divisione e, come sappiamo, entrambi sono dei valori interi. 23.3.2 - Elevazione a potenza \u00b6 Per elevare un numero a potenza, \u00e8 necessario usare l'operatore ** , in cui l'operando sinistro \u00e8 la base, mentre quello destro l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256 Tipi numerici in Python Abbiamo finora parlato soltanto di numeri interi e decimali; tuttavia, Python supporta anche altri tipi, come ad esempio Decimal e Fraction . E' inoltre presente un supporto nativo ai numeri complessi, esprimibili usando il suffisso j per indicare la parte immaginaria. 23.4 - Stringhe \u00b6 In Python le stringhe possono indifferentemente essere racchiuse tra virgolette singole e doppie. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Notiamo nella seconda istruzione l'uso del carattere di escape ( \\ ) che precede l'apostrofo; se lo omettessimo, l'interprete ci restituirebbe un errore sintattico ( SyntaxError ): >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota Tutti i caratteri preceduti dal simbolo \\ saranno interpretati come escape character, a meno di aggiungere il simbolo r prima dell'inizio della stringa: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella 23.4.1 - Stringhe su righe multiple \u00b6 Stringhe e liste La maggior parte dei concetti che vedremo nel seguito sono applicabili anche alle liste. Anzi, per essere precisi, derivano proprio dalle liste, in quanto Python considera una stringa un particolare tipo di lista. Le stringhe possono articolarsi su pi\u00f9 righe. Per farlo, possiamo usare le triple-quotes , ovvero tre virgolette di seguito, per indicare l'inizio e la fine della stringa: >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Nota Notiamo nel precedente snippet il carattere \\ , usato per evitare che venga automaticamente inserito dall'interprete il carattere newline ( \\n ) al termine di ogni riga. Infatti, si vede come il newline non sia stato aggiunto nelle righe evidenziate, mentre sia presente nella riga 2. 23.4.2 - Concatenazione di stringhe \u00b6 Concatenare due stringhe in Python \u00e8 estremamente semplice, e basta usare l'operatore + : >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota Se usiamo l'operatore * possiamo concatenare pi\u00f9 volte la stessa stringa: >>> 3 * 'co.' 'co.co.co.' Possiamo anche semplicemente porre le due stringhe l'una di seguito all'altra: >>> \"Py\" \"thon\" 'Python' Attenzione Bisogna fare particolare attenzione a non concatenare un literal (ovvero una stringa racchiusa tra virgolette) ad una variabile di tipo stringa . Se proviamo a farlo, l'interprete ci restituir\u00e0 questo errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax Il consiglio, in questi casi \"ibridi\", \u00e8 quello di usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli; l'approfondimento di tali metodi \u00e8 demandato al lettore. 23.4.3 Indicizzazione di stringhe \u00b6 Python definisce le stringhe come degli array di caratteri ; \u00e8 quindi possibile indicizzarli. Ad esempio: >>> stringa = 'Python' >>> stringa [ 0 ] 'P' Anche i singoli caratteri sono considerati come delle stringhe, ovviamente di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python permette di accedere anche usando degli indici negativi , considerando quindi gli elementi che vanno da destra verso sinistra. In questo caso, l'indice del primo elemento da destra sar\u00e0 indicato con -1 : >>> stringa [ - 1 ] 'n' 23.4.4 - Slicing su stringhe \u00b6 L'operazione di slicing permette di estrarre una certa parte di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j : s ] dove i \u00e8 l'indice iniziale, j quello finale ed s lo step utilizzato. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python' 23.4.5 - Lunghezza di una stringa \u00b6 La funzione len() ci restituisce la lunghezza di una stringa: >>> len ( stringa ) 6 23.4.6 - Immutabilit\u00e0 di una stringa \u00b6 Le stringhe in Python sono immutabili . Come indica la parola stessa, questo significa che non possono essere modificate : se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Suggerimento Possiamo comunque assegnare il nome stringa ad una nuova variabile. 23.5 - Liste \u00b6 Abbiamo gi\u00e0 detto che una stringa altro non \u00e8 se non un caso particolare di lista . La domanda che sorge spontanea \u00e8 quindi: cosa \u00e8 una lista ? Le liste sono uno dei quattro tipi di strutture built-in che Python offre per memorizzare sequenze di dati. Da un punto di vista puramente \"concettuale\", potremmo considerarle alla stregua degli array presenti in altri linguaggi di programmazione, seppur con alcune, significative differenze. Possiamo creare una lista in questo modo: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ] 23.5.1 - Concatenazione, indicizzazione e slicing su liste \u00b6 Come sulle stringhe, sulle liste \u00e8 possibile effettuare operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] 23.5.2 - Alcuni esempi \u00b6 Ecco alcuni esempi di slicing su lista, con annessi risultati ottenibili. Consideriamo la seguente stringa: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 ] Prendiamo gli elementi sugli indice pari (ovvero 0, 2 e 4): >>> l [ 0 :: 2 ] [ 1 , 3 , 5 ] Prendiamo tutti gli elementi a partire dal terzultimo e con indice pari: >>> l [ - 3 :: 2 ] [ 4 , 6 ] Partiamo dal terzultimo elemento, e proseguiamo all'indietro verso l'origine: >>> l [ - 3 :: - 1 ] [ 4 , 3 , 2 , 1 ] Partiamo dall'ultimo elemento e proseguiamo sino al terz'ultimo dall'origine: >>> l [: 3 : - 1 ] [ 6 , 5 ] Prendiamo gli ultimi tre elementi in ordine inverso: >>> l [ len ( l ) - 1 : len ( l ) - 4 : - 1 ] [ 6 , 5 , 4 ] Prendiamo gli elementi agli indici pari in ordine inverso: >>> l [:: - 2 ] [ 6 , 4 , 2 ] 23.5.3 - Mutabilit\u00e0 di una lista \u00b6 A differenza delle stringhe, le liste sono oggetti mutabili . Di conseguenza, possiamo modificarne il contenuto: >>> lista [ 0 ] = 99 >>> lista [ 99 , 2 , 3 , 4 , 5 ] 23.5.4 - Operazioni sulle liste \u00b6 Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] >>> lista [ 99 , 2 , 3 , 4 ] Nota I pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo eliminare tutti gli elementi contenuti in una lista mediante lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Una lista pu\u00f2 contenere elementi tra loro eterogenei. E' addirittura consentito contenere degli iterabili , tra cui altre liste: >>> lista . append ([ 1 , 2 , 3 ]) >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare l'elemento inserito in coda sia esso stesso una lista, e \"conviva\" tranquillamente con gli altri elementi di tipo numerico. Proviamo ad estendere ulteriormente la lista cambiando il primo elemento con una stringa: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]]","title":"23 - Introduzione al Python"},{"location":"material/04_python/23_intro/lecture/#23-introduzione-a-python","text":"Prima di iniziare a parlare del linguaggio Python, \u00e8 opportuno verificare che l'interprete sia installato nel nostro sistema. Per farlo, apriamo un terminale (Shell o Command Prompt, a seconda del nostro sistema), e scriviamo: $ python Se apparir\u00e0 una schermata simile a quella mostrata in figura, Python sar\u00e0 gi\u00e0 correttamente presente nel nostro sistema. In alternativa, dovremo provvedere ad installarlo seguendo la procedura indicata sul sito ufficiale , ed aggiungerlo al path di sistema.","title":"23 - Introduzione a Python"},{"location":"material/04_python/23_intro/lecture/#231-python-e-tipizzazione","text":"","title":"23.1 - Python e tipizzazione"},{"location":"material/04_python/23_intro/lecture/#2311-tipizzazione-dinamica","text":"Python \u00e8 un linguaggio interpretato ed a tipizzazione dinamica . In breve, questo significa che l'interprete valuta il tipo di ciascuna variabile a runtime, e che questo pu\u00f2 cambiare durante l'esecuzione del programma. Ma, a conti fatti, in cosa si traduce per il programmatore? Beh, molto semplice. Immaginiamo di dover definire ed inizializzare una variabile di tipo intero in un linguaggio a tipizzazione statica , come ad esempio il C++. Per farlo, scriveremo qualcosa simile a: int var = 0 ; In Python, potremo omettere il tipo, che sar\u00e0 inferito direttamente dal valore assegnato alla variabile: var = 0 Immaginiamo ora che la nostra variabile debba diventare un decimale. In C++, dovremo effettuare il casting: float fVar = float ( var ); fVar + 1.1 ; In Python questo non sar\u00e0 necessario, e potremo effettuare direttamente le operazioni desiderate: var + 1.1 # Il risultato sar\u00e0 2.1 Questo pu\u00f2 apparentemente semplificare di molto la vita, in quanto non \u00e8 pi\u00f9 necessario preoccuparsi del tipo della variabile. Non \u00e8 per\u00f2 tutto oro ci\u00f2 che luccica: per comprenderlo, infatti, \u00e8 il momento di parlare del (pilatesco) principio del duck typing .","title":"23.1.1 - Tipizzazione dinamica"},{"location":"material/04_python/23_intro/lecture/#23111-duck-typing","text":"Il duck typing \u00e8 riassumibile nella seguente massima: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. che in italiano suona pi\u00f9 o meno Se cammina come un papero, e starnazza come un papero, deve essere un papero . Traduciamola brevemente in \"informatichese\". Immaginiamo di istruire il nostro interprete Python ad assegnare alla nostra variabile var il valore di 1 . L'interprete nota che la variabile si \"comporta\" come un numero intero, e quindi \"stabilir\u00e0\" che si tratti proprio di questo. Proviamo ora a sommare a var un valore pari ad 1.1 . Il risultato, come ovvio, sar\u00e0 un numero decimale, e quindi l'interprete \"cambier\u00e0 idea\", in quanto i comportamenti assunti da var sono adesso assimilabili ad una variabile di tipo float . L'utilit\u00e0 del duck typing \u00e8 evidente: permette allo sviluppatore di \"risparmiare\" numerose operazioni di cast, rendendo il codice pi\u00f9 semplice da scrivere e manutenere. Tuttavia, occorre tenerne conto nel momento in cui si usano classi ed oggetti, in quanto l'interprete prover\u00e0 ad inferire ed usare automaticamente un tipo in base al contesto in cui viene usata la variabile, con le comodit\u00e0 (ed i potenziali disastri) che questo comporta.","title":"23.1.1.1 - Duck Typing"},{"location":"material/04_python/23_intro/lecture/#232-linterprete-python","text":"Nella sezione introduttiva abbiamo visto come installare l'interprete Python, in modo da avere un ambiente di lavoro accessibile direttamente mediante riga di comando. Lanciamolo di nuovo usando il seguente comando da una shell: python Potremo quindi finalmente iniziare ad utilizzare Python.","title":"23.2 - L'interprete Python"},{"location":"material/04_python/23_intro/lecture/#233-calcoli-e-numeri","text":"Proviamo ad usare l'interprete come una semplice calcolatrice; per farlo, scriviamo direttamente dopo il simbolo >>> le operazioni che vogliamo eseguire, e premiamo il tasto Invio . Ad esempio: >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2","title":"23.3 - Calcoli e numeri"},{"location":"material/04_python/23_intro/lecture/#2331-divisioni","text":"Le divisioni restituiscono sempre un numero in virgola mobile. Ad esempio: >>> 16 / 3 5.333333333333333 >>> 2 / 2 2.0 Proviamo ora ad usare altri due operatori, molto simili al classico operatore di divisione: >>> 16 // 3 5 >>> 16 % 3 1 Notiamo come in questi casi siano restituiti dei numeri interi. Il perch\u00e9 \u00e8 presto detto: gli operatori // e % calcolano, rispettivamente, il quoziente ed il resto della divisione e, come sappiamo, entrambi sono dei valori interi.","title":"23.3.1 - Divisioni"},{"location":"material/04_python/23_intro/lecture/#2332-elevazione-a-potenza","text":"Per elevare un numero a potenza, \u00e8 necessario usare l'operatore ** , in cui l'operando sinistro \u00e8 la base, mentre quello destro l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256 Tipi numerici in Python Abbiamo finora parlato soltanto di numeri interi e decimali; tuttavia, Python supporta anche altri tipi, come ad esempio Decimal e Fraction . E' inoltre presente un supporto nativo ai numeri complessi, esprimibili usando il suffisso j per indicare la parte immaginaria.","title":"23.3.2 - Elevazione a potenza"},{"location":"material/04_python/23_intro/lecture/#234-stringhe","text":"In Python le stringhe possono indifferentemente essere racchiuse tra virgolette singole e doppie. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Notiamo nella seconda istruzione l'uso del carattere di escape ( \\ ) che precede l'apostrofo; se lo omettessimo, l'interprete ci restituirebbe un errore sintattico ( SyntaxError ): >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota Tutti i caratteri preceduti dal simbolo \\ saranno interpretati come escape character, a meno di aggiungere il simbolo r prima dell'inizio della stringa: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella","title":"23.4 - Stringhe"},{"location":"material/04_python/23_intro/lecture/#2341-stringhe-su-righe-multiple","text":"Stringhe e liste La maggior parte dei concetti che vedremo nel seguito sono applicabili anche alle liste. Anzi, per essere precisi, derivano proprio dalle liste, in quanto Python considera una stringa un particolare tipo di lista. Le stringhe possono articolarsi su pi\u00f9 righe. Per farlo, possiamo usare le triple-quotes , ovvero tre virgolette di seguito, per indicare l'inizio e la fine della stringa: >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Nota Notiamo nel precedente snippet il carattere \\ , usato per evitare che venga automaticamente inserito dall'interprete il carattere newline ( \\n ) al termine di ogni riga. Infatti, si vede come il newline non sia stato aggiunto nelle righe evidenziate, mentre sia presente nella riga 2.","title":"23.4.1 - Stringhe su righe multiple"},{"location":"material/04_python/23_intro/lecture/#2342-concatenazione-di-stringhe","text":"Concatenare due stringhe in Python \u00e8 estremamente semplice, e basta usare l'operatore + : >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota Se usiamo l'operatore * possiamo concatenare pi\u00f9 volte la stessa stringa: >>> 3 * 'co.' 'co.co.co.' Possiamo anche semplicemente porre le due stringhe l'una di seguito all'altra: >>> \"Py\" \"thon\" 'Python' Attenzione Bisogna fare particolare attenzione a non concatenare un literal (ovvero una stringa racchiusa tra virgolette) ad una variabile di tipo stringa . Se proviamo a farlo, l'interprete ci restituir\u00e0 questo errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax Il consiglio, in questi casi \"ibridi\", \u00e8 quello di usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli; l'approfondimento di tali metodi \u00e8 demandato al lettore.","title":"23.4.2 - Concatenazione di stringhe"},{"location":"material/04_python/23_intro/lecture/#2343-indicizzazione-di-stringhe","text":"Python definisce le stringhe come degli array di caratteri ; \u00e8 quindi possibile indicizzarli. Ad esempio: >>> stringa = 'Python' >>> stringa [ 0 ] 'P' Anche i singoli caratteri sono considerati come delle stringhe, ovviamente di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python permette di accedere anche usando degli indici negativi , considerando quindi gli elementi che vanno da destra verso sinistra. In questo caso, l'indice del primo elemento da destra sar\u00e0 indicato con -1 : >>> stringa [ - 1 ] 'n'","title":"23.4.3 Indicizzazione di stringhe"},{"location":"material/04_python/23_intro/lecture/#2344-slicing-su-stringhe","text":"L'operazione di slicing permette di estrarre una certa parte di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j : s ] dove i \u00e8 l'indice iniziale, j quello finale ed s lo step utilizzato. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python'","title":"23.4.4 - Slicing su stringhe"},{"location":"material/04_python/23_intro/lecture/#2345-lunghezza-di-una-stringa","text":"La funzione len() ci restituisce la lunghezza di una stringa: >>> len ( stringa ) 6","title":"23.4.5 - Lunghezza di una stringa"},{"location":"material/04_python/23_intro/lecture/#2346-immutabilita-di-una-stringa","text":"Le stringhe in Python sono immutabili . Come indica la parola stessa, questo significa che non possono essere modificate : se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Suggerimento Possiamo comunque assegnare il nome stringa ad una nuova variabile.","title":"23.4.6 - Immutabilit\u00e0 di una stringa"},{"location":"material/04_python/23_intro/lecture/#235-liste","text":"Abbiamo gi\u00e0 detto che una stringa altro non \u00e8 se non un caso particolare di lista . La domanda che sorge spontanea \u00e8 quindi: cosa \u00e8 una lista ? Le liste sono uno dei quattro tipi di strutture built-in che Python offre per memorizzare sequenze di dati. Da un punto di vista puramente \"concettuale\", potremmo considerarle alla stregua degli array presenti in altri linguaggi di programmazione, seppur con alcune, significative differenze. Possiamo creare una lista in questo modo: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] [ 1 , 2 , 3 , 4 , 5 ]","title":"23.5 - Liste"},{"location":"material/04_python/23_intro/lecture/#2351-concatenazione-indicizzazione-e-slicing-su-liste","text":"Come sulle stringhe, sulle liste \u00e8 possibile effettuare operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ]","title":"23.5.1 - Concatenazione, indicizzazione e slicing su liste"},{"location":"material/04_python/23_intro/lecture/#2352-alcuni-esempi","text":"Ecco alcuni esempi di slicing su lista, con annessi risultati ottenibili. Consideriamo la seguente stringa: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 ] Prendiamo gli elementi sugli indice pari (ovvero 0, 2 e 4): >>> l [ 0 :: 2 ] [ 1 , 3 , 5 ] Prendiamo tutti gli elementi a partire dal terzultimo e con indice pari: >>> l [ - 3 :: 2 ] [ 4 , 6 ] Partiamo dal terzultimo elemento, e proseguiamo all'indietro verso l'origine: >>> l [ - 3 :: - 1 ] [ 4 , 3 , 2 , 1 ] Partiamo dall'ultimo elemento e proseguiamo sino al terz'ultimo dall'origine: >>> l [: 3 : - 1 ] [ 6 , 5 ] Prendiamo gli ultimi tre elementi in ordine inverso: >>> l [ len ( l ) - 1 : len ( l ) - 4 : - 1 ] [ 6 , 5 , 4 ] Prendiamo gli elementi agli indici pari in ordine inverso: >>> l [:: - 2 ] [ 6 , 4 , 2 ]","title":"23.5.2 - Alcuni esempi"},{"location":"material/04_python/23_intro/lecture/#2353-mutabilita-di-una-lista","text":"A differenza delle stringhe, le liste sono oggetti mutabili . Di conseguenza, possiamo modificarne il contenuto: >>> lista [ 0 ] = 99 >>> lista [ 99 , 2 , 3 , 4 , 5 ]","title":"23.5.3 - Mutabilit\u00e0 di una lista"},{"location":"material/04_python/23_intro/lecture/#2354-operazioni-sulle-liste","text":"Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] >>> lista [ 99 , 2 , 3 , 4 ] Nota I pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo eliminare tutti gli elementi contenuti in una lista mediante lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Una lista pu\u00f2 contenere elementi tra loro eterogenei. E' addirittura consentito contenere degli iterabili , tra cui altre liste: >>> lista . append ([ 1 , 2 , 3 ]) >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare l'elemento inserito in coda sia esso stesso una lista, e \"conviva\" tranquillamente con gli altri elementi di tipo numerico. Proviamo ad estendere ulteriormente la lista cambiando il primo elemento con una stringa: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]]","title":"23.5.4 - Operazioni sulle liste"},{"location":"material/04_python/24_syntax/exercises/","text":"E24 - Programmare in Python \u00b6 E24.1 \u00b6 Scriviamo una funzione che iteri fino a che il valore associato ad un contatore intero \u00e8 minore di 10. Usiamo un ciclo while . S24.1 - Soluzione \u00b6 def itera_while (): i = 0 while i < 10 : i = i + 1 print ( \" {} -ma iterazione\" . format ( i )) Il risultato ottenuto sar\u00e0: >>> itera_while () 1 - ma iterazione 2 - ma iterazione 3 - ma iterazione 4 - ma iterazione 5 - ma iterazione 6 - ma iterazione 7 - ma iterazione 8 - ma iterazione 9 - ma iterazione 10 - ma iterazione E24.2 \u00b6 Scriviamo una funzione che iteri fino a che una condizione booleana non \u00e8 False . Usiamo un ciclo for , ponendo come numero massimo di iterazioni 100 e se necessario, usando il metodo random.randint(a, b) . S24.2 - Soluzione \u00b6 def itera_for (): cond = True for i in range ( 100 ): eval = random . randint ( - 10 , 10 ) print ( 'Valuto numero {} ' . format ( eval )) if eval < 0 : print ( 'Esco' ) cond = False return cond else : print ( 'Continuo' ) return cond Il risultato ottenuto sar\u00e0: >>> itera_for () Valuto numero 6 Continuo Valuto numero 7 Continuo Valuto numero 8 Continuo Valuto numero - 4 Esco False E24.3 \u00b6 Estraiamo tutti gli indici pari di una lista arbitraria di dieci elementi in ordine inverso. Per farlo, usiamo sia la funzione range sia lo slicing. S24.3 - Soluzione \u00b6 def estrai_con_slice ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : return lista [ - 2 :: - 2 ] def estrai_con_range ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : l_out = [] for i in range ( 8 , - 1 , - 2 ): l_out . append ( lista [ i ]) return l_out Il risultato ottenuto sar\u00e0: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> estrai_con_slice ( l ) [ 10 , 8 , 6 , 4 , 2 ] >>> estrai_con_range ( l ) [ 10 , 8 , 6 , 4 , 2 ] E24.4 \u00b6 Utilizzare il pattern matching per stampare a schermo la parola \"Vero\" se il valore di una variabile \u00e8 True , e \"Falso\" altrimenti. S24.4 - Soluzione \u00b6 def match_case ( true_or_false ): match true_or_false : case True : return \"Vero\" case False : return \"Falso\" Il risultato ottenuto sar\u00e0: >>> a = True >>> match_case ( a ) 'Vero' >>> b = False >>> match_case ( b ) 'Falso' E24.5 \u00b6 Creare un metodo che raddoppi una lista passata come argomento in ingresso. Provare ad utilizzare un ciclo for e ricordare la differenza tra shallow e deep copy. S24.5 - Soluzione \u00b6 Potremmo essere tentati di scrivere una funzione come la seguente: def raddoppia_lista ( lista ): for elemento in lista : lista . append ( elemento ) print ( f \"Lista all'iterazione attuale: { lista } \" ) Proviamo a chiamare questa funzione; avremo subito un output ingestibile. Ci\u00f2 \u00e8 legato al fatto che Python \u00e8 fermo in un loop infinito: il metodo agisce sulla lista originaria, che ad ogni iterazione del ciclo \"ingloba\" un altro elemento, provocando di conseguenza un aumento delle dimensioni della lista e, quindi, un'ulteriore iterazione, e cos\u00ec via all'infinito. Possiamo per\u00f2 ottenere il risultato che ci serve usando il metodo deepcopy : from copy import deepcopy def raddoppia_lista_deep ( lista ): lista_appoggio = deepcopy ( lista ) for elemento in lista_appoggio : lista . append ( elemento ) print ( f \"Lista di appoggio: { lista_appoggio } \" ) print ( f \"Lista attuale: { lista } \" ) In questo caso, stiamo creando un'altra variabile, chiamata lista_appoggio , che sar\u00e0 utilizzata come \"buffer\" per aggiungere alla lista originaria gli elementi relativi a s\u00e9 stessa. Provando a chiamare questo codice otterremo il risultato desiderato: >>> raddoppia_lista_deep ([ 1 , 2 ]) Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 ] Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 , 2 ]","title":"E24 - Concetti sintattici fondamentali di Python"},{"location":"material/04_python/24_syntax/exercises/#e24-programmare-in-python","text":"","title":"E24 - Programmare in Python"},{"location":"material/04_python/24_syntax/exercises/#e241","text":"Scriviamo una funzione che iteri fino a che il valore associato ad un contatore intero \u00e8 minore di 10. Usiamo un ciclo while .","title":"E24.1"},{"location":"material/04_python/24_syntax/exercises/#s241-soluzione","text":"def itera_while (): i = 0 while i < 10 : i = i + 1 print ( \" {} -ma iterazione\" . format ( i )) Il risultato ottenuto sar\u00e0: >>> itera_while () 1 - ma iterazione 2 - ma iterazione 3 - ma iterazione 4 - ma iterazione 5 - ma iterazione 6 - ma iterazione 7 - ma iterazione 8 - ma iterazione 9 - ma iterazione 10 - ma iterazione","title":"S24.1 - Soluzione"},{"location":"material/04_python/24_syntax/exercises/#e242","text":"Scriviamo una funzione che iteri fino a che una condizione booleana non \u00e8 False . Usiamo un ciclo for , ponendo come numero massimo di iterazioni 100 e se necessario, usando il metodo random.randint(a, b) .","title":"E24.2"},{"location":"material/04_python/24_syntax/exercises/#s242-soluzione","text":"def itera_for (): cond = True for i in range ( 100 ): eval = random . randint ( - 10 , 10 ) print ( 'Valuto numero {} ' . format ( eval )) if eval < 0 : print ( 'Esco' ) cond = False return cond else : print ( 'Continuo' ) return cond Il risultato ottenuto sar\u00e0: >>> itera_for () Valuto numero 6 Continuo Valuto numero 7 Continuo Valuto numero 8 Continuo Valuto numero - 4 Esco False","title":"S24.2 - Soluzione"},{"location":"material/04_python/24_syntax/exercises/#e243","text":"Estraiamo tutti gli indici pari di una lista arbitraria di dieci elementi in ordine inverso. Per farlo, usiamo sia la funzione range sia lo slicing.","title":"E24.3"},{"location":"material/04_python/24_syntax/exercises/#s243-soluzione","text":"def estrai_con_slice ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : return lista [ - 2 :: - 2 ] def estrai_con_range ( lista ): if len ( lista ) != 10 : print ( 'Errore!' ) return [] else : l_out = [] for i in range ( 8 , - 1 , - 2 ): l_out . append ( lista [ i ]) return l_out Il risultato ottenuto sar\u00e0: >>> l = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] >>> estrai_con_slice ( l ) [ 10 , 8 , 6 , 4 , 2 ] >>> estrai_con_range ( l ) [ 10 , 8 , 6 , 4 , 2 ]","title":"S24.3 - Soluzione"},{"location":"material/04_python/24_syntax/exercises/#e244","text":"Utilizzare il pattern matching per stampare a schermo la parola \"Vero\" se il valore di una variabile \u00e8 True , e \"Falso\" altrimenti.","title":"E24.4"},{"location":"material/04_python/24_syntax/exercises/#s244-soluzione","text":"def match_case ( true_or_false ): match true_or_false : case True : return \"Vero\" case False : return \"Falso\" Il risultato ottenuto sar\u00e0: >>> a = True >>> match_case ( a ) 'Vero' >>> b = False >>> match_case ( b ) 'Falso'","title":"S24.4 - Soluzione"},{"location":"material/04_python/24_syntax/exercises/#e245","text":"Creare un metodo che raddoppi una lista passata come argomento in ingresso. Provare ad utilizzare un ciclo for e ricordare la differenza tra shallow e deep copy.","title":"E24.5"},{"location":"material/04_python/24_syntax/exercises/#s245-soluzione","text":"Potremmo essere tentati di scrivere una funzione come la seguente: def raddoppia_lista ( lista ): for elemento in lista : lista . append ( elemento ) print ( f \"Lista all'iterazione attuale: { lista } \" ) Proviamo a chiamare questa funzione; avremo subito un output ingestibile. Ci\u00f2 \u00e8 legato al fatto che Python \u00e8 fermo in un loop infinito: il metodo agisce sulla lista originaria, che ad ogni iterazione del ciclo \"ingloba\" un altro elemento, provocando di conseguenza un aumento delle dimensioni della lista e, quindi, un'ulteriore iterazione, e cos\u00ec via all'infinito. Possiamo per\u00f2 ottenere il risultato che ci serve usando il metodo deepcopy : from copy import deepcopy def raddoppia_lista_deep ( lista ): lista_appoggio = deepcopy ( lista ) for elemento in lista_appoggio : lista . append ( elemento ) print ( f \"Lista di appoggio: { lista_appoggio } \" ) print ( f \"Lista attuale: { lista } \" ) In questo caso, stiamo creando un'altra variabile, chiamata lista_appoggio , che sar\u00e0 utilizzata come \"buffer\" per aggiungere alla lista originaria gli elementi relativi a s\u00e9 stessa. Provando a chiamare questo codice otterremo il risultato desiderato: >>> raddoppia_lista_deep ([ 1 , 2 ]) Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 ] Lista di appoggio : [ 1 , 2 ] Lista attuale : [ 1 , 2 , 1 , 2 ]","title":"S24.5 - Soluzione"},{"location":"material/04_python/24_syntax/lecture/","text":"24 - Programmare in Python \u00b6 24.1 - Alcuni concetti sintattici fondamentali \u00b6 Oltre al duck typing, esistono altri concetti che caratterizzano la sintassi di Python. Vediamoli brevemente. 24.1.1 - Uso delle parentesi \u00b6 Le parentesi tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse. Ad esempio: a = 2 b = 3 c = 4 r_1 = a + b * c # Valore restituito: 14 r_2 = ( a + b ) * c # Valore restituito: 24 if a > 2 : # Questa notazione \u00e8 valida, ed \u00e8 equivalente ad (a > 2) 2. Le parentesi quadre sono usate per la creazione e l'accesso agli elementi di una struttura dati. # Creo una lista lista = [ 1 , 2 , 3 ] # Accedo al secondo elemento della lista lista [ 1 ] # Il valore acceduto \u00e8 2 3. Le parentesi graffe sono usate per la creazione di un dizionario. dizionario = { 'a' : 1 , 'b' : 2 } # Notiamo che per accedere ad una chiave di un dizionario useremo comunque la parentesi quadra. dizionario [ a ] # Il valore acceduto \u00e8 1, ovvero quello relativo alla chiave 'a' 24.1.2 - Ambito e termine di un'istruzione \u00b6 A differenza del C, che prevede che ogni istruzione sia terminata da un punto e virgola, Python prevede che un'istruzione termini quando si va a capo. Quindi: a = 1 # L'istruzione di assegnazione \u00e8 terminata! In altre parole, si pu\u00f2 omettere il punto e virgola. Per quello che riguarda invece la definizione di un ambito, ad esempio locale all'interno di una funzione, Python si affida ai due punti , che sostituiscono la parentesi graffa di apertura, ed al numero di indentazioni . Ambito e indentazioni In generale, possiamo dire che le istruzioni allo stesso livello di indentazione sono considerate dall'interprete Python come istruzioni appartenenti al medesimo ambito. Quindi: # L'inizio della funzione, e quindi dell'ambito # che questa delimita, \u00e8 contrassegnato dai due punti def funzione (): # Inizio ambito # Il codice deve essere allo stesso livello di indentazione a = 1 a + 1 # ... return 0 Le indentazioni Per ottenere l'indentazione, occorre usare il tasto tab sulla tastiera, oppure quattro spazi. E' comunque estremamente importante non mescolare le due tecniche. 24.2 - Programmazione strutturata \u00b6 Il linguaggio Python utilizza una sintassi per le strutture di controllo differente da quella usata nei tipici linguaggi C-like. 24.2.1 - Istruzioni condizionali ( if ) \u00b6 Partiamo dall'istruzione condizionale if . Questa, in Python, ha una sintassi di questo tipo. if condizione : istruzioni () elif altra_condizione : altre_istruzioni () else : ultime_istruzioni () Notiamo l'utilizzo della keyword elif come crasi della forma else if utilizzata in altri linguaggi di programmazione. Ad esempio, se volessimo verificare il valore di una variabile intera, potremmo scrivere: a = 5 if a < 5 : print ( 'a \u00e8 minore di 5' ) elif a == 5 : print ( 'a \u00e8 uguale a 5' ) else : print ( 'a \u00e8 maggiore di 5' ) L'output di questo controllo sar\u00e0: a \u00e8 uguale a 5 24.2.2 - Pattern matching \u00b6 Fino alla versione 3.10, Python non offriva il costrutto switch/case . A partire da quest'ultima, per\u00f2, il pattern matching \u00e8 stato implementato usando questa sintassi: match command : case \"caso 1\" : istruzioni () case \"altro caso\" : print ( \"Comando sconosciuto\" ) 24.2.3 - Cicli \u00b6 24.2.3.1 - Ciclo for \u00b6 Il ciclo for itera su una sequenza , come una lista o una stringa, ed ha una sintassi del tipo: for elemento in sequenza : istruzioni () Per fare un esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Il risultato che sar\u00e0 stampato a schermo \u00e8: 0 1 2 3 4 Rispetto ai linguaggi \"classici\", quindi, il ciclo for opera esclusivamente sugli iterabili , per cui potrebbe in qualche caso occorrere una riprogettazione del codice. Tuttavia, questa caratteristica di Python comporta anche una maggiore semplicit\u00e0 del codice; ad esempio, vediamo come \u00e8 molto semplice iterare su una stringa: string = \"Python\" for char in string : print ( char ) A schermo vedremo in entrambi i casi il seguente risultato: P y t h o n No free lunches! Come ci ricorda il no free lunches theorem , non esistono pasti gratuiti ! Infatti, la maggiore semplicit\u00e0 sintattica offerta da Python non \u00e8 indolore, ma ha un costo. Uno script Python, infatti, per quanto ottimizzato, non potr\u00e0 quasi mai offrire performance paragonabili ad un codice ottimizzato in C o C++, a meno di non usare particolari (ed avanzati) accorgimenti. 24.2.3.2 - Ciclo while \u00b6 A differenza del ciclo for , il funzionamento del while \u00e8 analogo a quello delle controparti negli altri linguaggi di programmazione. La sintassi generica \u00e8: while ( condizione ): istruzioni () Ad esempio: i = True while ( i ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) else : print ( \"Esco!\" ) i = False Il codice nel blocco precedente non fa altro che generare un valore numerico intero casuale nell'intervallo \\([-5, 5]\\) mediante la funzione randint . Se tale valore \u00e8 superiore a \\(0\\) , il ciclo continua, altrimenti si esce dallo stesso. A schermo vedremo, ad esempio: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola. 24.4 - La funzione range() \u00b6 Riprendiamo adesso il ciclo for visto in precedenza. vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Nonostante il codice sia gi\u00e0 compatto, scrivere manualmente la sequenza da iterare pu\u00f2 facilmente diventare un'operazione abbastanza complessa. Python ci viene quindi in aiuto tramite la funzione range(i, j, s) , che genera una sequenza avente tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4 scriveremo: r = range ( 0 , 5 , 1 ) print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Notiamo che per mandare in output i valori di r dovremo convertirlo in lista ( list(r) ). Qualora omessi, i ed s assumono valori di default rispettivamente 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale ponendo i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ] Esercizio : Proviamo ad iterare su tutti i valori della lista ['Pippo', 'Pluto', 5, 'Paperino'] . Soluzione : Usiamo la funzione range() assieme alla funzione len() : l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] for i in range ( len ( l )): print ( l [ i ]) # Output Pippo Pluto 5 Paperino In pratica, dato che la funzione len(l) ci restituisce il numero di elementi nella lista, ovvero \\(4\\) , stiamo andando a definire un range che va da 0 a 3. A questo punto, ci baster\u00e0 elemento per elemento ai valori contenuti all'interno della lista, ed avremo ottenuto il risultato sperato. 24.5 - Istruzioni break e continue \u00b6 Le istruzioni break e continue permettono rispettivamente di uscire dal ciclo o di saltare all'iterazione successiva . Ad esempio: while ( True ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) continue else : print ( \"Esco!\" ) break print ( \"Sono uscito!\" ) Le istruzioni precedenti usciranno dal ciclo quando viene generato casualmente un numero negativo, mentre continueranno ad iterare quando viene generato casualmente un numero positivo. 24.6 - Definire una funzione \u00b6 In Python \u00e8 possibile definire una funzione in questo modo: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, potr\u00e0 essere omessa l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri opzionali , con valori di default. Esercizio : Creiamo una funzione che concateni ad una lista il doppio dei singoli valori presenti nella stessa. Soluzione : usiamo la funzione append per mettere in coda i nuovi elementi della lista. def raddoppia_lista ( lista ): for i in range ( len ( lista )): lista . append ( l [ i ] * 2 ) l = [ 1 , 2 ] raddoppia_lista ( l ) # Risultato atteso: [1, 2, 2, 4] Esercizio : Creiamo una funzione che generi una lista di elementi casuali tra \\(0\\) e \\(10\\) , usando un parametro opzionale per specificarne la lunghezza. Soluzione : usiamo la funzione append() in accoppiata alla funzione randint() . def genera_lista_casuale ( lunghezza = 5 ): l = [] for i in range ( lunghezza ): l . append ( randint ( 0 , 10 )) return l ... genera_lista_casuale () # Possibile risultato: [3, 1, 2, 0, 6] genera_lista_casuale ( 10 ) # Possibile risultato: [7, 9, 1, 10, 2, 4, 9, 1, 4, 8] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non venga effettuato alcun controllo sui parametri in ingresso. Ci\u00f2 per\u00f2 non significa che non si possa provare a chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; ci\u00f2 tuttavia causer\u00e0 un (prevedibile) errore. 24.6.1 - Passaggio di parametri a funzione \u00b6 Python prevede che i parametri siano passati ad una funzione secondo una modalit\u00e0 ibrida chiamata call-by-assignment . In pratica, il passaggio avviene esclusivamente per valore , ma con effetti differenti su tipi mutabili ed immutabili. Ad esempio, provando a passare un valore primitivo (come un intero), Python si comporter\u00e0 come se si stesse effettuando un passaggio per valore: def raddoppia ( intero ): intero = intero * 2 print ( f 'Valore all \\' interno della funzione: { intero } ' ) Il risultato sar\u00e0: >>> intero = 1 >>> raddoppia ( intero ) \"Valore all'interno della funzione: 2\" >>> print ( f 'Valore all \\' esterno della funzione: { intero } ' ) \"Valore all'interno della funzione: 1\" Ci\u00f2 \u00e8 legato al fatto che il passaggio viene effettuato per valore, per cui la funzione raddoppia agir\u00e0 su una copia della variabile passata come argomento, e non sulla variabile originaria. Se invece usassimo una funzione che modifica una lista: def aggiungi_a_lista ( lista , elemento ): lista . append ( elemento ) print ( f 'Valore all \\' interno della funzione: { lista } ' ) Il risultato sar\u00e0: >>> lista = [ 1 , 2 ] >>> aggiungi_a_lista ( lista , 3 ) \"Valore all'interno della funzione: [1, 2, 3]\" >>> print ( f 'Valore all \\' esterno della funzione: { lista } ' ) \"Valore all'interno della funzione: [1, 2, 3]\" In questo caso, essendo la lista mutabile, il passaggio viene effettuato nei fatti per reference : ci\u00f2 significa che le operazioni comppiute all'interno della funzione aggiungi_a_lista agiranno sulla lista originaria. Shallow e deep copy Di default, Python copia le variabili per mezzo di una shallow copy : ci\u00f2 significa che un'operazione di assignment del tipo a = b fa in modo che a punti allo stesso indirizzo di memoria di b e, di conseguenza, ogni modifica a b si rifletta su a . Per evitare un fenomeno di questo tipo occorre usare una deep copy grazie alla funzione deepcopy della libreria copy . 24.6.2 - L'istruzione pass \u00b6 Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def funzione_vuota (): ... pass ... >>> funzione_vuota () Nota Anche se di primo acchitto potrebbe non essere evidente, esistono diverse situazioni in cui l'istruzione pass risulta essere estremamente utile.","title":"24 - Concetti sintattici fondamentali di Python"},{"location":"material/04_python/24_syntax/lecture/#24-programmare-in-python","text":"","title":"24 - Programmare in Python"},{"location":"material/04_python/24_syntax/lecture/#241-alcuni-concetti-sintattici-fondamentali","text":"Oltre al duck typing, esistono altri concetti che caratterizzano la sintassi di Python. Vediamoli brevemente.","title":"24.1 - Alcuni concetti sintattici fondamentali"},{"location":"material/04_python/24_syntax/lecture/#2411-uso-delle-parentesi","text":"Le parentesi tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse. Ad esempio: a = 2 b = 3 c = 4 r_1 = a + b * c # Valore restituito: 14 r_2 = ( a + b ) * c # Valore restituito: 24 if a > 2 : # Questa notazione \u00e8 valida, ed \u00e8 equivalente ad (a > 2) 2. Le parentesi quadre sono usate per la creazione e l'accesso agli elementi di una struttura dati. # Creo una lista lista = [ 1 , 2 , 3 ] # Accedo al secondo elemento della lista lista [ 1 ] # Il valore acceduto \u00e8 2 3. Le parentesi graffe sono usate per la creazione di un dizionario. dizionario = { 'a' : 1 , 'b' : 2 } # Notiamo che per accedere ad una chiave di un dizionario useremo comunque la parentesi quadra. dizionario [ a ] # Il valore acceduto \u00e8 1, ovvero quello relativo alla chiave 'a'","title":"24.1.1 - Uso delle parentesi"},{"location":"material/04_python/24_syntax/lecture/#2412-ambito-e-termine-di-unistruzione","text":"A differenza del C, che prevede che ogni istruzione sia terminata da un punto e virgola, Python prevede che un'istruzione termini quando si va a capo. Quindi: a = 1 # L'istruzione di assegnazione \u00e8 terminata! In altre parole, si pu\u00f2 omettere il punto e virgola. Per quello che riguarda invece la definizione di un ambito, ad esempio locale all'interno di una funzione, Python si affida ai due punti , che sostituiscono la parentesi graffa di apertura, ed al numero di indentazioni . Ambito e indentazioni In generale, possiamo dire che le istruzioni allo stesso livello di indentazione sono considerate dall'interprete Python come istruzioni appartenenti al medesimo ambito. Quindi: # L'inizio della funzione, e quindi dell'ambito # che questa delimita, \u00e8 contrassegnato dai due punti def funzione (): # Inizio ambito # Il codice deve essere allo stesso livello di indentazione a = 1 a + 1 # ... return 0 Le indentazioni Per ottenere l'indentazione, occorre usare il tasto tab sulla tastiera, oppure quattro spazi. E' comunque estremamente importante non mescolare le due tecniche.","title":"24.1.2 - Ambito e termine di un'istruzione"},{"location":"material/04_python/24_syntax/lecture/#242-programmazione-strutturata","text":"Il linguaggio Python utilizza una sintassi per le strutture di controllo differente da quella usata nei tipici linguaggi C-like.","title":"24.2 - Programmazione strutturata"},{"location":"material/04_python/24_syntax/lecture/#2421-istruzioni-condizionali-if","text":"Partiamo dall'istruzione condizionale if . Questa, in Python, ha una sintassi di questo tipo. if condizione : istruzioni () elif altra_condizione : altre_istruzioni () else : ultime_istruzioni () Notiamo l'utilizzo della keyword elif come crasi della forma else if utilizzata in altri linguaggi di programmazione. Ad esempio, se volessimo verificare il valore di una variabile intera, potremmo scrivere: a = 5 if a < 5 : print ( 'a \u00e8 minore di 5' ) elif a == 5 : print ( 'a \u00e8 uguale a 5' ) else : print ( 'a \u00e8 maggiore di 5' ) L'output di questo controllo sar\u00e0: a \u00e8 uguale a 5","title":"24.2.1 - Istruzioni condizionali (if)"},{"location":"material/04_python/24_syntax/lecture/#2422-pattern-matching","text":"Fino alla versione 3.10, Python non offriva il costrutto switch/case . A partire da quest'ultima, per\u00f2, il pattern matching \u00e8 stato implementato usando questa sintassi: match command : case \"caso 1\" : istruzioni () case \"altro caso\" : print ( \"Comando sconosciuto\" )","title":"24.2.2 - Pattern matching"},{"location":"material/04_python/24_syntax/lecture/#2423-cicli","text":"","title":"24.2.3 - Cicli"},{"location":"material/04_python/24_syntax/lecture/#24231-ciclo-for","text":"Il ciclo for itera su una sequenza , come una lista o una stringa, ed ha una sintassi del tipo: for elemento in sequenza : istruzioni () Per fare un esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Il risultato che sar\u00e0 stampato a schermo \u00e8: 0 1 2 3 4 Rispetto ai linguaggi \"classici\", quindi, il ciclo for opera esclusivamente sugli iterabili , per cui potrebbe in qualche caso occorrere una riprogettazione del codice. Tuttavia, questa caratteristica di Python comporta anche una maggiore semplicit\u00e0 del codice; ad esempio, vediamo come \u00e8 molto semplice iterare su una stringa: string = \"Python\" for char in string : print ( char ) A schermo vedremo in entrambi i casi il seguente risultato: P y t h o n No free lunches! Come ci ricorda il no free lunches theorem , non esistono pasti gratuiti ! Infatti, la maggiore semplicit\u00e0 sintattica offerta da Python non \u00e8 indolore, ma ha un costo. Uno script Python, infatti, per quanto ottimizzato, non potr\u00e0 quasi mai offrire performance paragonabili ad un codice ottimizzato in C o C++, a meno di non usare particolari (ed avanzati) accorgimenti.","title":"24.2.3.1 - Ciclo for"},{"location":"material/04_python/24_syntax/lecture/#24232-ciclo-while","text":"A differenza del ciclo for , il funzionamento del while \u00e8 analogo a quello delle controparti negli altri linguaggi di programmazione. La sintassi generica \u00e8: while ( condizione ): istruzioni () Ad esempio: i = True while ( i ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) else : print ( \"Esco!\" ) i = False Il codice nel blocco precedente non fa altro che generare un valore numerico intero casuale nell'intervallo \\([-5, 5]\\) mediante la funzione randint . Se tale valore \u00e8 superiore a \\(0\\) , il ciclo continua, altrimenti si esce dallo stesso. A schermo vedremo, ad esempio: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola.","title":"24.2.3.2 - Ciclo while"},{"location":"material/04_python/24_syntax/lecture/#244-la-funzione-range","text":"Riprendiamo adesso il ciclo for visto in precedenza. vals = [ 0 , 1 , 2 , 3 , 4 ] for i in vals : print ( i ) Nonostante il codice sia gi\u00e0 compatto, scrivere manualmente la sequenza da iterare pu\u00f2 facilmente diventare un'operazione abbastanza complessa. Python ci viene quindi in aiuto tramite la funzione range(i, j, s) , che genera una sequenza avente tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4 scriveremo: r = range ( 0 , 5 , 1 ) print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Notiamo che per mandare in output i valori di r dovremo convertirlo in lista ( list(r) ). Qualora omessi, i ed s assumono valori di default rispettivamente 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale ponendo i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ] Esercizio : Proviamo ad iterare su tutti i valori della lista ['Pippo', 'Pluto', 5, 'Paperino'] . Soluzione : Usiamo la funzione range() assieme alla funzione len() : l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] for i in range ( len ( l )): print ( l [ i ]) # Output Pippo Pluto 5 Paperino In pratica, dato che la funzione len(l) ci restituisce il numero di elementi nella lista, ovvero \\(4\\) , stiamo andando a definire un range che va da 0 a 3. A questo punto, ci baster\u00e0 elemento per elemento ai valori contenuti all'interno della lista, ed avremo ottenuto il risultato sperato.","title":"24.4 - La funzione range()"},{"location":"material/04_python/24_syntax/lecture/#245-istruzioni-break-e-continue","text":"Le istruzioni break e continue permettono rispettivamente di uscire dal ciclo o di saltare all'iterazione successiva . Ad esempio: while ( True ): if randint ( - 5 , 5 ) > 0 : print ( \"Continuo!\" ) continue else : print ( \"Esco!\" ) break print ( \"Sono uscito!\" ) Le istruzioni precedenti usciranno dal ciclo quando viene generato casualmente un numero negativo, mentre continueranno ad iterare quando viene generato casualmente un numero positivo.","title":"24.5 - Istruzioni break e continue"},{"location":"material/04_python/24_syntax/lecture/#246-definire-una-funzione","text":"In Python \u00e8 possibile definire una funzione in questo modo: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, potr\u00e0 essere omessa l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri opzionali , con valori di default. Esercizio : Creiamo una funzione che concateni ad una lista il doppio dei singoli valori presenti nella stessa. Soluzione : usiamo la funzione append per mettere in coda i nuovi elementi della lista. def raddoppia_lista ( lista ): for i in range ( len ( lista )): lista . append ( l [ i ] * 2 ) l = [ 1 , 2 ] raddoppia_lista ( l ) # Risultato atteso: [1, 2, 2, 4] Esercizio : Creiamo una funzione che generi una lista di elementi casuali tra \\(0\\) e \\(10\\) , usando un parametro opzionale per specificarne la lunghezza. Soluzione : usiamo la funzione append() in accoppiata alla funzione randint() . def genera_lista_casuale ( lunghezza = 5 ): l = [] for i in range ( lunghezza ): l . append ( randint ( 0 , 10 )) return l ... genera_lista_casuale () # Possibile risultato: [3, 1, 2, 0, 6] genera_lista_casuale ( 10 ) # Possibile risultato: [7, 9, 1, 10, 2, 4, 9, 1, 4, 8] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non venga effettuato alcun controllo sui parametri in ingresso. Ci\u00f2 per\u00f2 non significa che non si possa provare a chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; ci\u00f2 tuttavia causer\u00e0 un (prevedibile) errore.","title":"24.6 - Definire una funzione"},{"location":"material/04_python/24_syntax/lecture/#2461-passaggio-di-parametri-a-funzione","text":"Python prevede che i parametri siano passati ad una funzione secondo una modalit\u00e0 ibrida chiamata call-by-assignment . In pratica, il passaggio avviene esclusivamente per valore , ma con effetti differenti su tipi mutabili ed immutabili. Ad esempio, provando a passare un valore primitivo (come un intero), Python si comporter\u00e0 come se si stesse effettuando un passaggio per valore: def raddoppia ( intero ): intero = intero * 2 print ( f 'Valore all \\' interno della funzione: { intero } ' ) Il risultato sar\u00e0: >>> intero = 1 >>> raddoppia ( intero ) \"Valore all'interno della funzione: 2\" >>> print ( f 'Valore all \\' esterno della funzione: { intero } ' ) \"Valore all'interno della funzione: 1\" Ci\u00f2 \u00e8 legato al fatto che il passaggio viene effettuato per valore, per cui la funzione raddoppia agir\u00e0 su una copia della variabile passata come argomento, e non sulla variabile originaria. Se invece usassimo una funzione che modifica una lista: def aggiungi_a_lista ( lista , elemento ): lista . append ( elemento ) print ( f 'Valore all \\' interno della funzione: { lista } ' ) Il risultato sar\u00e0: >>> lista = [ 1 , 2 ] >>> aggiungi_a_lista ( lista , 3 ) \"Valore all'interno della funzione: [1, 2, 3]\" >>> print ( f 'Valore all \\' esterno della funzione: { lista } ' ) \"Valore all'interno della funzione: [1, 2, 3]\" In questo caso, essendo la lista mutabile, il passaggio viene effettuato nei fatti per reference : ci\u00f2 significa che le operazioni comppiute all'interno della funzione aggiungi_a_lista agiranno sulla lista originaria. Shallow e deep copy Di default, Python copia le variabili per mezzo di una shallow copy : ci\u00f2 significa che un'operazione di assignment del tipo a = b fa in modo che a punti allo stesso indirizzo di memoria di b e, di conseguenza, ogni modifica a b si rifletta su a . Per evitare un fenomeno di questo tipo occorre usare una deep copy grazie alla funzione deepcopy della libreria copy .","title":"24.6.1 - Passaggio di parametri a funzione"},{"location":"material/04_python/24_syntax/lecture/#2462-listruzione-pass","text":"Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def funzione_vuota (): ... pass ... >>> funzione_vuota () Nota Anche se di primo acchitto potrebbe non essere evidente, esistono diverse situazioni in cui l'istruzione pass risulta essere estremamente utile.","title":"24.6.2 - L'istruzione pass"},{"location":"material/04_python/25_data_structures/exercises/","text":"E25 - Esercizi sulle strutture dati \u00b6 E25.1 \u00b6 Proviamo a valutare il tempo necessario alle operazioni di insert e pop su una coda in Python usando la libreria time . Confrontiamo il risultato ottenuto con quello ottenibile implementando una coda come una struttura di tipo deque e usando gli opportuni metodi appendleft e popleft . S25.1 - Soluzione \u00b6 from time import time from collections import deque def queue ( queue , pushed = 1 ): tic = time () queue . insert ( 0 , 4 ) queue . pop () toc = time () return tic , toc def queue_con_deque ( queue , pushed = 1 ): tic = time () queue . appendleft ( pushed ) queue . popleft () toc = time () return tic , toc Proviamo a chiamare le due funzioni: queue = list ( range ( 10000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) Avremo un output simile al seguente: Tempo necessario con lista: 0 .08756685256958008 Tempo necessario con deque: 0 .0 E25.2 \u00b6 Selezioniamo tutti i nomi che iniziano con la lettera B dalla seguente lista: lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] Facciamolo usando un ciclo ed una list comprehension. S25.2 - Soluzione \u00b6 Usando un ciclo: output_for = [] for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output_for . append ( nome ) Usando una list comprehension: output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ] E25.3 \u00b6 Ottenere una lista che abbia al suo interno tutti i quadrati dei numeri che vanno da 1 a 10 S25.3 - Soluzione \u00b6 Usando un ciclo: def quadrato ( numero ): return numero ** 2 output = [] for i in range ( 1 , 11 ): output . append ( quadrato ( i )) Usando una list comprehension: output = [ quadrato ( i ) for i in range ( 1 , 11 )] E25.4 \u00b6 Ottenere una lista che abbia la stringa pari in corrispondenza dei numeri pari, mentre quella dispari in corrispondenza dei numeri dispari, per tutti i numeri che vanno da 1 a 10. S25.4 - Soluzione \u00b6 Usando un ciclo: output = [] for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \"pari\" ) else : output . append ( \"dispari\" ) Usando una list comprehension: output = [ \"pari\" if i % 2 == 0 else \"dispari\" for i in range ( 1 , 10 )] Suggerimento Possiamo usare la forma base della list comprehension definendo una funzione accessoria. Ad esempio: def pari_o_dispari ( numero ): if numero % 2 == 0 : return 'pari' else : return 'dispari' E25.5 \u00b6 Scrivere una dict comprehension che permetta di ottenere il dizionario vecchio_o_giovane dato il seguente dizionario: dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } In particolare, il dizionario vecchio_o_giovane avr\u00e0 le stesse chiavi del dizionario di partenza, a cui sar\u00e0 associato il valore giovane soltanto se il valore della chiave del dizionario di partenza \u00e8 inferiore a 65. S25.5 - Soluzione \u00b6 vecchio_o_giovane = { k : 'vecchio' if v > 65 else 'giovane' for ( k , v ) in dizionario . items () } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"E25 - Strutture dati in Python"},{"location":"material/04_python/25_data_structures/exercises/#e25-esercizi-sulle-strutture-dati","text":"","title":"E25 - Esercizi sulle strutture dati"},{"location":"material/04_python/25_data_structures/exercises/#e251","text":"Proviamo a valutare il tempo necessario alle operazioni di insert e pop su una coda in Python usando la libreria time . Confrontiamo il risultato ottenuto con quello ottenibile implementando una coda come una struttura di tipo deque e usando gli opportuni metodi appendleft e popleft .","title":"E25.1"},{"location":"material/04_python/25_data_structures/exercises/#s251-soluzione","text":"from time import time from collections import deque def queue ( queue , pushed = 1 ): tic = time () queue . insert ( 0 , 4 ) queue . pop () toc = time () return tic , toc def queue_con_deque ( queue , pushed = 1 ): tic = time () queue . appendleft ( pushed ) queue . popleft () toc = time () return tic , toc Proviamo a chiamare le due funzioni: queue = list ( range ( 10000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) Avremo un output simile al seguente: Tempo necessario con lista: 0 .08756685256958008 Tempo necessario con deque: 0 .0","title":"S25.1 - Soluzione"},{"location":"material/04_python/25_data_structures/exercises/#e252","text":"Selezioniamo tutti i nomi che iniziano con la lettera B dalla seguente lista: lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] Facciamolo usando un ciclo ed una list comprehension.","title":"E25.2"},{"location":"material/04_python/25_data_structures/exercises/#s252-soluzione","text":"Usando un ciclo: output_for = [] for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output_for . append ( nome ) Usando una list comprehension: output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ]","title":"S25.2 - Soluzione"},{"location":"material/04_python/25_data_structures/exercises/#e253","text":"Ottenere una lista che abbia al suo interno tutti i quadrati dei numeri che vanno da 1 a 10","title":"E25.3"},{"location":"material/04_python/25_data_structures/exercises/#s253-soluzione","text":"Usando un ciclo: def quadrato ( numero ): return numero ** 2 output = [] for i in range ( 1 , 11 ): output . append ( quadrato ( i )) Usando una list comprehension: output = [ quadrato ( i ) for i in range ( 1 , 11 )]","title":"S25.3 - Soluzione"},{"location":"material/04_python/25_data_structures/exercises/#e254","text":"Ottenere una lista che abbia la stringa pari in corrispondenza dei numeri pari, mentre quella dispari in corrispondenza dei numeri dispari, per tutti i numeri che vanno da 1 a 10.","title":"E25.4"},{"location":"material/04_python/25_data_structures/exercises/#s254-soluzione","text":"Usando un ciclo: output = [] for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \"pari\" ) else : output . append ( \"dispari\" ) Usando una list comprehension: output = [ \"pari\" if i % 2 == 0 else \"dispari\" for i in range ( 1 , 10 )] Suggerimento Possiamo usare la forma base della list comprehension definendo una funzione accessoria. Ad esempio: def pari_o_dispari ( numero ): if numero % 2 == 0 : return 'pari' else : return 'dispari'","title":"S25.4 - Soluzione"},{"location":"material/04_python/25_data_structures/exercises/#e255","text":"Scrivere una dict comprehension che permetta di ottenere il dizionario vecchio_o_giovane dato il seguente dizionario: dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } In particolare, il dizionario vecchio_o_giovane avr\u00e0 le stesse chiavi del dizionario di partenza, a cui sar\u00e0 associato il valore giovane soltanto se il valore della chiave del dizionario di partenza \u00e8 inferiore a 65.","title":"E25.5"},{"location":"material/04_python/25_data_structures/exercises/#s255-soluzione","text":"vecchio_o_giovane = { k : 'vecchio' if v > 65 else 'giovane' for ( k , v ) in dizionario . items () } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"S25.5 - Soluzione"},{"location":"material/04_python/25_data_structures/lecture/","text":"25 - Strutture dati in Python \u00b6 25.1 - Liste, pile e code \u00b6 Python ci offre una grande variet\u00e0 di metodi per gestire le liste; troviamo un elenco esaustivo a questo indirizzo . Grazie a questi metodi, \u00e8 possibile costruire una pila o una coda in modo molto pi\u00f9 semplice rispetto ad altri linguaggi. 25.1.1 - Pila \u00b6 Una pila (in inglese stack ) adotta una strategia di accesso ai dati di tipo Last-In, First-Out ( LIFO ). Questo significa che il primo elemento ad uscire (ovvero ad essere analizzato) \u00e8 quello in cima alla pila, ovvero l'ultimo ad esservi entrato. Esempio di pila Un tipico esempio di pila \u00e8 quella dei piatti da lavare. Quasi sicuramente, il piatto in cima alla pila sar\u00e0 l'ultimo che avremo preso dal tavolo; tuttavia, sar\u00e0 anche il primo ad essere lavato. Per implementare una pila a partire da una lista possiamo usare due metodi: il metodo append() ci permette di inserire un nuovo elemento in cima alla pila (ovvero alla posizione \\(n-1\\) -ma, con una lista ad \\(n\\) componenti); il metodo pop(pos) ci permette di estrarre l'elemento in posizione pos . Di default, non specificando alcun valore di pos , estrarremo l'elemento in posizione \\(n-1\\) -ma. Ad esempio: s = [ 1 , 2 , 3 ] s . append ( 4 ) # s sar\u00e0 pari a [1, 2, 3, 4] e = s . pop () # e sar\u00e0 pari a 4, mentre s sar\u00e0 pari a [1, 2, 3] 25.1.2 - Coda \u00b6 Una coda (in inglese queue ) adotta una strategia di accesso ai dati di tipo First-In, First-Out ( FIFO ). In questo caso, il primo elemento ad uscire \u00e8 presente da pi\u00f9 tempo in coda. Esempio di coda Un tipico esempio di coda \u00e8 quella che tutti quanti, prima o poi, abbiamo fatto alle Poste: il primo ad arrivare \u00e8 il primo ad essere servito, poi il secondo, il terzo, e via cos\u00ec. Per implementare una coda a partire da una lista, possiamo usare il metodo pop(pos) con pos = 0 , che ci permetter\u00e0 quindi di estrarre il primo elemento della coda, ed il metodo insert(pos, el) ci permette di inserire alla posizione pos l'elemento el . q = [ 1 , 2 , 3 ] q . insert ( 0 , 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . pop ( 0 ) # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Questo approccio, per quanto semplice, ha uno svantaggio: infatti, i metodi insert() e pop() sono computazionalmente onerosi, in quanto fanno in modo di riallocare lo spazio occupato dagli elementi della lista. In alternativa, possiamo usare una struttura contenuta nella libreria collections e chiamata deque . Il vantaggio sta nel fatto che la deque \u00e8 progettata specificamente per eseguire in maniera efficiente i metodi append() e pop() da entrambi i capi della struttura dati: from collections import deque q = deque ([ 1 , 2 , 3 ]) q . appendleft ( 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . popleft () # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Nota Sottolineamo che q non \u00e8 pi\u00f9 una lista, ma una deque . 25.2 - List comprehension \u00b6 Una delle tecniche pi\u00f9 usate per effettuare delle operazioni sugli elementi di una lista \u00e8 usare la tecnica della list comprehension , che permette di sostituire quasi completamente i classici cicli. Nella forma base, una list comprehension ha una sintassi di questo tipo: lista_output = [ f ( elemento ) for elemento in lista_input ] In altre parole, otterremo in output una lista ( lista_output ) applicando ad ogni elemento della lista originaria ( lista_input ) la funzione f() . Nota Per essere precisi, pi\u00f9 che di lista, sarebbe opportuno parlare di iterabile di input. 25.2.1 - Forma estesa con if-else \u00b6 La list comprehension pu\u00f2 anche includere delle istruzioni condizionali. Un primo esempio \u00e8 la seguente forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] In questo caso, la funzione f() sar\u00e0 chiamata esclusivamente sugli elementi che soddisfano la condizione indicata. Invece, se usassimo questa forma: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] la funzione f() sarebbe invocata su tutti gli elementi che soddisfano la condizione , mentre la funzione g() su tutti quelli che non la soddisfano. Perch\u00e9 usare le list comprehension? Le list comprehension sono utili e versatili, e permettono, in molti casi, di sostituire i classici cicli con una sintassi pi\u00f9 snella. Tuttavia, bisogna fare attenzione a non abusare di questo strumento: infatti, facendolo si rischia di complicare inutilmente il nostro programma, rendendolo poco leggibile e manutenibile. Come regola generale, quindi, ricordiamo il principio del rasoio di Occam: anche se \u00e8 facile innamorarsi delle list comprehension, \u00e8 bene ricordarsi che anche i cicli sono leciti e funzionali , per cui non \u00e8 sempre necessario trovare a tutti i costi una soluzione usando una list comprehension. 25.3 - Le assignment expressions \u00b6 Come apparso dalla trattazione, le list comprehension sono state pensate per approcci puramente iterativi. Di conseguenza, risulta complesso implementare forme di ricorsione. Per ovviare a questo inconveniente, Python introduce, a partire dalla versione 25.8, le assignment expression . Da un punto di vista \"formale\", un'assignment expression permette di assegnare e restituire un valore all'interno di un'unica istruzione mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Vediamo come utilizzare questo concetto per combinare ricorsione e list comprehension. Definiamo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci : >>> fib = [ 0 , 1 ] Vediamo cosa succede se proviamo ad usare una assignment expression in modo da restituire una lista che abbia come primo elemento il secondo della precedente (ovvero 1 ), e come secondo la somma di tutti gli elementi della lista (ovvero 0 + 1 ): >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> fib [ 1 , 1 ] Notiamo che l'operazione ha modificato il valore della lista fib ! A noi, per\u00f2, interessa soltanto la somma degli elementi precedenti della lista (e quindi il secondo valore ottenuto). Per isolarlo, possiamo adoperare l'operatore booleano and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Proviamo a combinare i due passaggi precedenti, ed usare una list comprehension per concatenare i risultati ottenuti per i numeri che vanno fino ad \\(F_9\\) : >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] 25.4 - Tuple \u00b6 Le tuple permettono di rappresentano un insieme di valori eterogenei separadoli da una virgola. Ad esempio: tupla = ( 'hello' , 'world' , 12 ) Un po' come avviene per le liste, uno dei valori della tupla pu\u00f2 a sua volta essere un'altra tupla. Ad esempio: tupla = ( 'hello' , 'world' , ( 1 , 2 )) A differenza di una lista, per\u00f2, le tuple sono immutabili . Ci\u00f2 non implica per\u00f2 che non possano contenere al loro interno oggetti mutabili. Guardiamo il seguente esempio: tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) La tupla avr\u00e0 al suo interno due stringhe (immutabili) ed una lista (mutabile). Proviamo a modificare la lista: tupla [ 2 ] = [ 2 , 2 , 3 ] Apparir\u00e0 un errore simile a questo: Traceback ( most recent call last ) : File \"<stdin>\" , line 1 , in <module> TypeError: 'tuple' object does not support item assignment Come prevedibile, abbiamo avuto un errore di assegnazione legato all'immutabilit\u00e0 della tupla. Proviamo adesso per\u00f2 a modificare direttamente la lista : tupla [ 2 ][ 0 ] = 2 # La tupla sar\u00e0 ('hello', 'world', [2, 2, 3]) L'operazione \u00e8 evidentemente ammissibile, ed il risultato \u00e8 stato proprio quello atteso. Tuple e liste Ad un attento osservatore non sfuggir\u00e0 come tuple e liste siano simili dal punto di vista sintattico, e differiscano in buona sostanza per la mutabilit\u00e0. Da qui discende che le tuple sono estremamente efficaci nel caso si debba esclusivamente accedere agli elementi contenuti, mentre le liste devono essere usate quando \u00e8 anche necessario modificare all'occorrenza detti elementi. 25.5 - Set \u00b6 Anche i set sono molto simili alle liste dal punto di vista sintattico, ma offrono una significativa differenza: infatti, in un set non possono esserci elementi ripetuti . Nota Notiamo un'evidente analogia con il concetto matematico di insieme. La sintassi da usare per creare un set \u00e8 la seguente. insieme = { 1 , \"stringa\" , 2 } Il set ammette al suo interno dati eterogenei, tuttavia non pu\u00f2 contenere al suo interno delle liste o dei dizionari. Questo \u00e8 legato al fatto che i set (cos\u00ec come gli stessi dizionari) sono delle hash table , e quindi sfruttano il concetto di hash per rappresentare i dati contenuti in maniera compatta ed efficiente. Il fatto che le liste ed i dizionari non possano essere rappresentati in questo modo li esclude in automatico dall'includibilit\u00e0 all'interno di un set. Un'altra considerazione da fare \u00e8 che il set non \u00e8 ordinato : ci\u00f2 rende impossibile accedere ad (e modificare ) un elemento del set mediante il suo indice, come succedeva per liste e tuple. Suggerimento I set possono essere usati per isolare gli elementi univoci presenti in una lista. Per farlo, basta convertire la lista in set: l = [ 1 , 2 , 2 , 3 ] # La lista sar\u00e0 [1, 2, 2, 3] s = set ( l ) # Il set sar\u00e0 [1, 2, 3] 25.6 - Dizionari \u00b6 Il quarto ed ultimo tipo di contenitore per sequenze di dati \u00e8 il dizionario , presente anche in altri linguaggi di programmazione con il nome di array associativo o hash map . L'elemento base di un dizionario \u00e8 la coppia chiave - valore , nella quale un certo valore (di qualsiasi tipo) \u00e8 associato ad una determinata chiave (di tipo immutabile). I dizionari hanno diverse caratteristiche comuni ai set, dall'inutilizzabilit\u00e0 delle liste come chiavi al fatto di non permettere chiavi ripetute. Inoltre, le coppie chiave - valore sono accedute, per l'appunto, per chiave, e non in base all'ordine delle coppie. Nota Una differenza tra set e dizionari sta nel fatto che questi ultimi sono ordinati a partire da Python 25.7. Per creare un dizionario, possiamo usare una sintassi simile a quella usata per i set. Ad esempio, per creare un dizionario vuoto: dizionario = {} Possiamo quindi inserire delle coppie chiave - valore in questo modo: dizionario [ 'k' ] = 'v' dizionario [ 1 ] = 'n' # Il dizionario sar\u00e0 {'k': 'v', 1: 'n'} Per accedere al valore associato ad una determinata chiave: dizionario [ 1 ] # Il valore restituito sar\u00e0 'n' 25.6.1 - Chiavi e valori \u00b6 E' possibile recuperare la lista di tutte le chiavi presenti in un dizionario usando il metodo keys() , che restituisce un oggetto di tipo dict_keys , a sua volta convertibile in lista: chiavi = dizionario . keys () # Restituisce dict_keys(['k', 1]), che non \u00e8 una lista! list ( chiavi ) # Restituisce ['k', 1], che \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: valori = dizionario . values () # Restituisce dict_values(['v', 'n']), che non \u00e8 una lista! list ( valori ) # Restituisce ['v', 'n'], che \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: coppie = dizionario . items () # Restituisce dict_items([('k', 'v'), (1, 'n')]) list ( coppie ) # Restituisce una lista di tuple 25.6.2 - Creazione di un dizionario (non vuoto) \u00b6 Abbiamo diversi modi per creare un dizionario non vuoto. 25.6.2.1 - Uso dell'operatore {} \u00b6 Il pi\u00f9 semplice, che \u00e8 quello che useremo pi\u00f9 spesso, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 } 25.6.2.2 - Uso del costruttore dict() \u00b6 Un altro modo \u00e8 usare il metodo costruttore dict() : dizionario = dict ( k1 = 1 , k2 = 2 ) # Il dizionario sar\u00e0 {'k1': 1, 'k2': 2} 25.6.2.3 - Uso della funzione zip \u00b6 Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: chiavi = [ 'k1' , 'k2' ] valori = [ 1 , 2 ] dizionario = dict ( zip ( chiavi , valori )) 25.6.2.4 - Dict comprehension \u00b6 Un modo per ottenere un dizionario a partire da un altro oggetto iterabile \u00e8 la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} print ( quadrati ) # Risultato: {'1': 1, '2': 4, '3': 9, '4': 16, '5': 25, '6': 36, '7': 49, '8': 64, '9': 81}","title":"25 - Strutture dati in Python"},{"location":"material/04_python/25_data_structures/lecture/#25-strutture-dati-in-python","text":"","title":"25 - Strutture dati in Python"},{"location":"material/04_python/25_data_structures/lecture/#251-liste-pile-e-code","text":"Python ci offre una grande variet\u00e0 di metodi per gestire le liste; troviamo un elenco esaustivo a questo indirizzo . Grazie a questi metodi, \u00e8 possibile costruire una pila o una coda in modo molto pi\u00f9 semplice rispetto ad altri linguaggi.","title":"25.1 - Liste, pile e code"},{"location":"material/04_python/25_data_structures/lecture/#2511-pila","text":"Una pila (in inglese stack ) adotta una strategia di accesso ai dati di tipo Last-In, First-Out ( LIFO ). Questo significa che il primo elemento ad uscire (ovvero ad essere analizzato) \u00e8 quello in cima alla pila, ovvero l'ultimo ad esservi entrato. Esempio di pila Un tipico esempio di pila \u00e8 quella dei piatti da lavare. Quasi sicuramente, il piatto in cima alla pila sar\u00e0 l'ultimo che avremo preso dal tavolo; tuttavia, sar\u00e0 anche il primo ad essere lavato. Per implementare una pila a partire da una lista possiamo usare due metodi: il metodo append() ci permette di inserire un nuovo elemento in cima alla pila (ovvero alla posizione \\(n-1\\) -ma, con una lista ad \\(n\\) componenti); il metodo pop(pos) ci permette di estrarre l'elemento in posizione pos . Di default, non specificando alcun valore di pos , estrarremo l'elemento in posizione \\(n-1\\) -ma. Ad esempio: s = [ 1 , 2 , 3 ] s . append ( 4 ) # s sar\u00e0 pari a [1, 2, 3, 4] e = s . pop () # e sar\u00e0 pari a 4, mentre s sar\u00e0 pari a [1, 2, 3]","title":"25.1.1 - Pila"},{"location":"material/04_python/25_data_structures/lecture/#2512-coda","text":"Una coda (in inglese queue ) adotta una strategia di accesso ai dati di tipo First-In, First-Out ( FIFO ). In questo caso, il primo elemento ad uscire \u00e8 presente da pi\u00f9 tempo in coda. Esempio di coda Un tipico esempio di coda \u00e8 quella che tutti quanti, prima o poi, abbiamo fatto alle Poste: il primo ad arrivare \u00e8 il primo ad essere servito, poi il secondo, il terzo, e via cos\u00ec. Per implementare una coda a partire da una lista, possiamo usare il metodo pop(pos) con pos = 0 , che ci permetter\u00e0 quindi di estrarre il primo elemento della coda, ed il metodo insert(pos, el) ci permette di inserire alla posizione pos l'elemento el . q = [ 1 , 2 , 3 ] q . insert ( 0 , 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . pop ( 0 ) # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Questo approccio, per quanto semplice, ha uno svantaggio: infatti, i metodi insert() e pop() sono computazionalmente onerosi, in quanto fanno in modo di riallocare lo spazio occupato dagli elementi della lista. In alternativa, possiamo usare una struttura contenuta nella libreria collections e chiamata deque . Il vantaggio sta nel fatto che la deque \u00e8 progettata specificamente per eseguire in maniera efficiente i metodi append() e pop() da entrambi i capi della struttura dati: from collections import deque q = deque ([ 1 , 2 , 3 ]) q . appendleft ( 4 ) # q sar\u00e0 pari a [4, 1, 2, 3] e = q . popleft () # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3] Nota Sottolineamo che q non \u00e8 pi\u00f9 una lista, ma una deque .","title":"25.1.2 - Coda"},{"location":"material/04_python/25_data_structures/lecture/#252-list-comprehension","text":"Una delle tecniche pi\u00f9 usate per effettuare delle operazioni sugli elementi di una lista \u00e8 usare la tecnica della list comprehension , che permette di sostituire quasi completamente i classici cicli. Nella forma base, una list comprehension ha una sintassi di questo tipo: lista_output = [ f ( elemento ) for elemento in lista_input ] In altre parole, otterremo in output una lista ( lista_output ) applicando ad ogni elemento della lista originaria ( lista_input ) la funzione f() . Nota Per essere precisi, pi\u00f9 che di lista, sarebbe opportuno parlare di iterabile di input.","title":"25.2 - List comprehension"},{"location":"material/04_python/25_data_structures/lecture/#2521-forma-estesa-con-if-else","text":"La list comprehension pu\u00f2 anche includere delle istruzioni condizionali. Un primo esempio \u00e8 la seguente forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] In questo caso, la funzione f() sar\u00e0 chiamata esclusivamente sugli elementi che soddisfano la condizione indicata. Invece, se usassimo questa forma: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] la funzione f() sarebbe invocata su tutti gli elementi che soddisfano la condizione , mentre la funzione g() su tutti quelli che non la soddisfano. Perch\u00e9 usare le list comprehension? Le list comprehension sono utili e versatili, e permettono, in molti casi, di sostituire i classici cicli con una sintassi pi\u00f9 snella. Tuttavia, bisogna fare attenzione a non abusare di questo strumento: infatti, facendolo si rischia di complicare inutilmente il nostro programma, rendendolo poco leggibile e manutenibile. Come regola generale, quindi, ricordiamo il principio del rasoio di Occam: anche se \u00e8 facile innamorarsi delle list comprehension, \u00e8 bene ricordarsi che anche i cicli sono leciti e funzionali , per cui non \u00e8 sempre necessario trovare a tutti i costi una soluzione usando una list comprehension.","title":"25.2.1 - Forma estesa con if-else"},{"location":"material/04_python/25_data_structures/lecture/#253-le-assignment-expressions","text":"Come apparso dalla trattazione, le list comprehension sono state pensate per approcci puramente iterativi. Di conseguenza, risulta complesso implementare forme di ricorsione. Per ovviare a questo inconveniente, Python introduce, a partire dalla versione 25.8, le assignment expression . Da un punto di vista \"formale\", un'assignment expression permette di assegnare e restituire un valore all'interno di un'unica istruzione mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Vediamo come utilizzare questo concetto per combinare ricorsione e list comprehension. Definiamo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci : >>> fib = [ 0 , 1 ] Vediamo cosa succede se proviamo ad usare una assignment expression in modo da restituire una lista che abbia come primo elemento il secondo della precedente (ovvero 1 ), e come secondo la somma di tutti gli elementi della lista (ovvero 0 + 1 ): >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> fib [ 1 , 1 ] Notiamo che l'operazione ha modificato il valore della lista fib ! A noi, per\u00f2, interessa soltanto la somma degli elementi precedenti della lista (e quindi il secondo valore ottenuto). Per isolarlo, possiamo adoperare l'operatore booleano and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Proviamo a combinare i due passaggi precedenti, ed usare una list comprehension per concatenare i risultati ottenuti per i numeri che vanno fino ad \\(F_9\\) : >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ]","title":"25.3 - Le assignment expressions"},{"location":"material/04_python/25_data_structures/lecture/#254-tuple","text":"Le tuple permettono di rappresentano un insieme di valori eterogenei separadoli da una virgola. Ad esempio: tupla = ( 'hello' , 'world' , 12 ) Un po' come avviene per le liste, uno dei valori della tupla pu\u00f2 a sua volta essere un'altra tupla. Ad esempio: tupla = ( 'hello' , 'world' , ( 1 , 2 )) A differenza di una lista, per\u00f2, le tuple sono immutabili . Ci\u00f2 non implica per\u00f2 che non possano contenere al loro interno oggetti mutabili. Guardiamo il seguente esempio: tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) La tupla avr\u00e0 al suo interno due stringhe (immutabili) ed una lista (mutabile). Proviamo a modificare la lista: tupla [ 2 ] = [ 2 , 2 , 3 ] Apparir\u00e0 un errore simile a questo: Traceback ( most recent call last ) : File \"<stdin>\" , line 1 , in <module> TypeError: 'tuple' object does not support item assignment Come prevedibile, abbiamo avuto un errore di assegnazione legato all'immutabilit\u00e0 della tupla. Proviamo adesso per\u00f2 a modificare direttamente la lista : tupla [ 2 ][ 0 ] = 2 # La tupla sar\u00e0 ('hello', 'world', [2, 2, 3]) L'operazione \u00e8 evidentemente ammissibile, ed il risultato \u00e8 stato proprio quello atteso. Tuple e liste Ad un attento osservatore non sfuggir\u00e0 come tuple e liste siano simili dal punto di vista sintattico, e differiscano in buona sostanza per la mutabilit\u00e0. Da qui discende che le tuple sono estremamente efficaci nel caso si debba esclusivamente accedere agli elementi contenuti, mentre le liste devono essere usate quando \u00e8 anche necessario modificare all'occorrenza detti elementi.","title":"25.4 - Tuple"},{"location":"material/04_python/25_data_structures/lecture/#255-set","text":"Anche i set sono molto simili alle liste dal punto di vista sintattico, ma offrono una significativa differenza: infatti, in un set non possono esserci elementi ripetuti . Nota Notiamo un'evidente analogia con il concetto matematico di insieme. La sintassi da usare per creare un set \u00e8 la seguente. insieme = { 1 , \"stringa\" , 2 } Il set ammette al suo interno dati eterogenei, tuttavia non pu\u00f2 contenere al suo interno delle liste o dei dizionari. Questo \u00e8 legato al fatto che i set (cos\u00ec come gli stessi dizionari) sono delle hash table , e quindi sfruttano il concetto di hash per rappresentare i dati contenuti in maniera compatta ed efficiente. Il fatto che le liste ed i dizionari non possano essere rappresentati in questo modo li esclude in automatico dall'includibilit\u00e0 all'interno di un set. Un'altra considerazione da fare \u00e8 che il set non \u00e8 ordinato : ci\u00f2 rende impossibile accedere ad (e modificare ) un elemento del set mediante il suo indice, come succedeva per liste e tuple. Suggerimento I set possono essere usati per isolare gli elementi univoci presenti in una lista. Per farlo, basta convertire la lista in set: l = [ 1 , 2 , 2 , 3 ] # La lista sar\u00e0 [1, 2, 2, 3] s = set ( l ) # Il set sar\u00e0 [1, 2, 3]","title":"25.5 - Set"},{"location":"material/04_python/25_data_structures/lecture/#256-dizionari","text":"Il quarto ed ultimo tipo di contenitore per sequenze di dati \u00e8 il dizionario , presente anche in altri linguaggi di programmazione con il nome di array associativo o hash map . L'elemento base di un dizionario \u00e8 la coppia chiave - valore , nella quale un certo valore (di qualsiasi tipo) \u00e8 associato ad una determinata chiave (di tipo immutabile). I dizionari hanno diverse caratteristiche comuni ai set, dall'inutilizzabilit\u00e0 delle liste come chiavi al fatto di non permettere chiavi ripetute. Inoltre, le coppie chiave - valore sono accedute, per l'appunto, per chiave, e non in base all'ordine delle coppie. Nota Una differenza tra set e dizionari sta nel fatto che questi ultimi sono ordinati a partire da Python 25.7. Per creare un dizionario, possiamo usare una sintassi simile a quella usata per i set. Ad esempio, per creare un dizionario vuoto: dizionario = {} Possiamo quindi inserire delle coppie chiave - valore in questo modo: dizionario [ 'k' ] = 'v' dizionario [ 1 ] = 'n' # Il dizionario sar\u00e0 {'k': 'v', 1: 'n'} Per accedere al valore associato ad una determinata chiave: dizionario [ 1 ] # Il valore restituito sar\u00e0 'n'","title":"25.6 - Dizionari"},{"location":"material/04_python/25_data_structures/lecture/#2561-chiavi-e-valori","text":"E' possibile recuperare la lista di tutte le chiavi presenti in un dizionario usando il metodo keys() , che restituisce un oggetto di tipo dict_keys , a sua volta convertibile in lista: chiavi = dizionario . keys () # Restituisce dict_keys(['k', 1]), che non \u00e8 una lista! list ( chiavi ) # Restituisce ['k', 1], che \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: valori = dizionario . values () # Restituisce dict_values(['v', 'n']), che non \u00e8 una lista! list ( valori ) # Restituisce ['v', 'n'], che \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: coppie = dizionario . items () # Restituisce dict_items([('k', 'v'), (1, 'n')]) list ( coppie ) # Restituisce una lista di tuple","title":"25.6.1 - Chiavi e valori"},{"location":"material/04_python/25_data_structures/lecture/#2562-creazione-di-un-dizionario-non-vuoto","text":"Abbiamo diversi modi per creare un dizionario non vuoto.","title":"25.6.2 - Creazione di un dizionario (non vuoto)"},{"location":"material/04_python/25_data_structures/lecture/#25621-uso-delloperatore","text":"Il pi\u00f9 semplice, che \u00e8 quello che useremo pi\u00f9 spesso, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 }","title":"25.6.2.1 - Uso dell'operatore {}"},{"location":"material/04_python/25_data_structures/lecture/#25622-uso-del-costruttore-dict","text":"Un altro modo \u00e8 usare il metodo costruttore dict() : dizionario = dict ( k1 = 1 , k2 = 2 ) # Il dizionario sar\u00e0 {'k1': 1, 'k2': 2}","title":"25.6.2.2 - Uso del costruttore dict()"},{"location":"material/04_python/25_data_structures/lecture/#25623-uso-della-funzione-zip","text":"Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: chiavi = [ 'k1' , 'k2' ] valori = [ 1 , 2 ] dizionario = dict ( zip ( chiavi , valori ))","title":"25.6.2.3 - Uso della funzione zip"},{"location":"material/04_python/25_data_structures/lecture/#25624-dict-comprehension","text":"Un modo per ottenere un dizionario a partire da un altro oggetto iterabile \u00e8 la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} print ( quadrati ) # Risultato: {'1': 1, '2': 4, '3': 9, '4': 16, '5': 25, '6': 36, '7': 49, '8': 64, '9': 81}","title":"25.6.2.4 - Dict comprehension"},{"location":"material/04_python/26_classes/exercises/","text":"E26 - Programmazione orientata agli oggetti in Python \u00b6 E26.1 \u00b6 Scrivere una classe Persona applicando i concetti visti durante la lezione. S26.1 - Soluzione \u00b6 Scriviamo la classe Persona come segue: class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe. E26.2 \u00b6 Creiamo due classi: la prima \u00e8 la classe Quadrato , che modella tutti i quadrati; la seconda \u00e8 la classe Cerchio , che modella tutti i cerchi. Entrambe devono discendere da una classe base chiamata Figura . S26.2 - Soluzione \u00b6 from abc import ABC , abstractmethod from math import pi class Figura ( ABC ): @property def perimetro ( self ): return self . __perimetro @property def area ( self ): return self . __area @abstractmethod def perimetro ( self ): pass @abstractmethod def area ( self ): pass class Quadrato ( Figura ): def __init__ ( self , lato ): self . lato = lato @property def lato ( self ): return self . __lato @lato . setter def lato ( self , value ): self . __lato = value def perimetro ( self ): return self . lato * 4 def area ( self ): return self . lato ** 2 class Cerchio ( Figura ): def __init__ ( self , raggio ): self . raggio = raggio @property def raggio ( self ): return self . __raggio @raggio . setter def raggio ( self , value ): self . __raggio = value def perimetro ( self ): return 2 * pi * self . raggio def area ( self ): return pi * ( self . raggio ** 2 ) # Esempio di uso q = Quadrato ( 5 ) print ( 'Lato: {} - Perimetro: {} - Area: {} ' . format ( q . lato , q . perimetro (), q . area ())) c = Cerchio ( 5 ) print ( 'Raggio: {} - Perimetro: {} - Area: {} ' . format ( c . raggio , c . perimetro (), c . area ()))","title":"E26 - OOP in Python"},{"location":"material/04_python/26_classes/exercises/#e26-programmazione-orientata-agli-oggetti-in-python","text":"","title":"E26 - Programmazione orientata agli oggetti in Python"},{"location":"material/04_python/26_classes/exercises/#e261","text":"Scrivere una classe Persona applicando i concetti visti durante la lezione.","title":"E26.1"},{"location":"material/04_python/26_classes/exercises/#s261-soluzione","text":"Scriviamo la classe Persona come segue: class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.","title":"S26.1 - Soluzione"},{"location":"material/04_python/26_classes/exercises/#e262","text":"Creiamo due classi: la prima \u00e8 la classe Quadrato , che modella tutti i quadrati; la seconda \u00e8 la classe Cerchio , che modella tutti i cerchi. Entrambe devono discendere da una classe base chiamata Figura .","title":"E26.2"},{"location":"material/04_python/26_classes/exercises/#s262-soluzione","text":"from abc import ABC , abstractmethod from math import pi class Figura ( ABC ): @property def perimetro ( self ): return self . __perimetro @property def area ( self ): return self . __area @abstractmethod def perimetro ( self ): pass @abstractmethod def area ( self ): pass class Quadrato ( Figura ): def __init__ ( self , lato ): self . lato = lato @property def lato ( self ): return self . __lato @lato . setter def lato ( self , value ): self . __lato = value def perimetro ( self ): return self . lato * 4 def area ( self ): return self . lato ** 2 class Cerchio ( Figura ): def __init__ ( self , raggio ): self . raggio = raggio @property def raggio ( self ): return self . __raggio @raggio . setter def raggio ( self , value ): self . __raggio = value def perimetro ( self ): return 2 * pi * self . raggio def area ( self ): return pi * ( self . raggio ** 2 ) # Esempio di uso q = Quadrato ( 5 ) print ( 'Lato: {} - Perimetro: {} - Area: {} ' . format ( q . lato , q . perimetro (), q . area ())) c = Cerchio ( 5 ) print ( 'Raggio: {} - Perimetro: {} - Area: {} ' . format ( c . raggio , c . perimetro (), c . area ()))","title":"S26.2 - Soluzione"},{"location":"material/04_python/26_classes/lecture/","text":"26 - Programmazione orientata agli oggetti in Python \u00b6 Python offre un esteso supporto alla programmazione orientata agli oggetti. Prima di proseguire, per\u00f2, \u00e8 opportuno introdurre brevemente questo concetto. 26.1 - La programmazione orientata agli oggetti \u00b6 Quello della programmazione orientata agli oggetti (OOP) \u00e8 un paradigma di programmazione che permette di creare nuovi tipi definiti dall'utente, da intendersi come complementari ai tipi definiti dal linguaggio di programmazione. In tal senso, la OOP sposta il focus dalle funzioni , centrali nei linguaggi come il C e nel paradigma procedurale, ai dati . In tal senso, si arriva a dire che nella OOP tutto \u00e8 un oggetto . 26.1.1 - Classi \u00b6 Una classe \u00e8 un prototipo per un determinato tipo di dati definito dall'utente. Ad esempio: la classe Studente rappresenta tutte le propriet\u00e0 e le azioni associate ad uno studente; la classe Auto rappresenta tutte le propriet\u00e0 e le azioni associate ad un'auto; la classe Motore definisce i comportamenti dei motori; e via discorrendo. In generale, quindi, pu\u00f2 esistere una classe per ogni tipologia di oggetti presenti nel mondo, sia esso reale o informatico. Importante \u00e8 non confondere la classe con il singolo oggetto , chiamato istanza . Ad esempio: lo studente Angelo Cardellicchio \u00e8 un'istanza della classe Studente ; l'auto Opel Corsa targata AB 123 CD \u00e8 un'istanza della classe Auto ; l'auto Hyundai Tucson CD 321 AB \u00e8 un'istanza della classe Auto ; l'auto Opel Corsa targata AA 123 CC \u00e8 un'altra istanza della classe Auto . 26.1.1.1 - Metodi ed attributi \u00b6 Ogni classe ha dei metodi , che caratterizzano delle azioni che \u00e8 possibile effettuare su ogni istanza della classe, e degli attributi , ovvero delle caratteristiche dell'istanza. In particolare, ogni nuovo tipo, chiamato classe , avr\u00e0 opportuni attributi e metodi , ognuno dei quali accessibile dall'esterno mediante opportuni modificatori . Ad esempio, l'auto Opel Corsa targata AB 123 CD ha una casa costruttrice (Opel), un modello (Corsa), una targa (AB 123 CD), una cilindrata, e via dicendo. 26.2 - Classi in Python \u00b6 Per definire una classe, dovremo usare la parola chiave class : class NomeClasse ( ClasseBase ): # Attributi e metodi di classe... Con la sintassi precedente, abbiamo creato una classe chiamata NomeClasse discendente da una classe base ( ClasseBase ). 26.3 - Il metodo __init__ \u00b6 La maggior parte dei linguaggi di programmazione utilizza il concetto di costruttore per creare un'istanza di una classe. Il Python, tuttavia, non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione dei singoli attributi dell'istanza. Da qui deriva il nome del metodo, ovvero __init__ : class NomeClasse ( ClasseBase ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Unpacking Con la sintassi *args e **kwargs vogliamo rappresentare l'azione di unpacking di (rispettivamente) una lista ed un dizionario, mediante la quale stiamo passando tutti i valori contenuti all'interno della sequenza. Occorre prestare particolare attenzione all'uso della keyword self , che permette di riferirsi alla specifica istanza di una classe (per chi ha familiarit\u00e0 con i linguaggi come il C++, \u00e8 concettualmente simile alla parola chiave this ). Ad esempio: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome self . _cognome = cognome self . __eta = eta Questo snippet ci permette di evidenziare quattro punti: la classe generica object , da cui derivano tutte le classi Python (ma la cui dichiarazione pu\u00f2 comunque essere omessa); il funzionamento della parola chiave self , che permette di associare agli attributi della singola istanza un determinato valore; la possibilit\u00e0 di inserire tra i parametri dei valori opzionali e di default (in questo caso eta , che di default vale 18 ); la presenza di uno o due simboli _ ( underscore ) davanti ad alcuni attributi. Approfondiamo brevemente il punto 26. 26.4 - Modificatori di accesso \u00b6 Python prevede l'uso di modificatori di accesso ai dati; nello specifico, troviamo i classici public , protected e private . Tuttavia, a differenza di altri linguaggi, per distinguere tra i tre modificatori di accesso si utilizzano uno o due underscore come suffisso al nome dell'attributo; in particolare, usare un underscore singolo indica un attributo protected, mentre un underscore doppio indica un attributo private . Nel nostro caso: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome # Membro \"public\" self . _cognome = cognome # Membro \"protected\" self . __eta = eta # Membro \"private\" Attenzione Nonostante il modificatore di accesso, \u00e8 possibile accedere ai membri protetti dall'esterno della classe. Infatti: >>> p = Persona ( 'Jax' , 'Teller' ) >>> print ( p . nome ) >>> print ( p . _cognome ) Jax Teller Questo non vale per gli attributi privati: >>> try: >>> print ( p.__eta ) >>> except AttributeError: >>> print ( 'Et\u00e0 \u00e8 privato!' ) Et\u00e0 \u00e8 privato! Questa sintassi pu\u00f2 ovviamente essere utilizzata per definire dei metodi protetti o privati. Suggerimento La sintassi che abbiamo mostrato nello snippet precedente \u00e8 relativa alla gestione delle eccezioni . 26.5 - Metodi \u00b6 La sintassi per definire il metodo di una classe \u00e8 analoga a quella usata per definire una funzione. def metodo ( self , * args , ** kwargs ): pass Esiste tuttavia una differenza fondamentale: infatti, il primo attributo di un metodo appartenente ad una classe \u00e8 sempre un riferimento all'istanza tramite la parola chiave self . Tale riferimento non va specificato quando il metodo viene chiamato dall'esterno: # ... p = Persona () # p \u00e8 un'istanza di Persona p . metodo ( parametro ) # richiamo il metodo dall'istanza # ... Nel codice precedente, abbiamo usato l'operatore . per accedere a metodo definito all'interno della classe Persona . Approfondiamo adesso alcune particolari tipologie di metodi, ottenibili usando determinati decorator (cfr. appendice B). 26.5.1 - Metodi di classe \u00b6 Il decorator @classmethod ci permette di definire i cosiddetti metodi di classe : @classmethod def builder_stringa ( cls , stringa : str ): nome , cognome , eta = stringa . split ( ' ' ) return Persona ( nome , cognome , eta ) A differenza dei metodi standard, i metodi di classe hanno un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi che si applicano all'intera classe , e non alla singola istanza. Un tipico esempio di utilizzo di un metodo di classe \u00e8 mostrato nello snippet precedente, nel quale stiamo creando un oggetto di classe Persona a partire da una stringa. Curiosit\u00e0 Il metodo precedente \u00e8, di fatto, un'implementazione del design pattern Builder. Per richiamare un metodo di classe occorre riferirsi al nome della classe stessa, e non ad una singola istanza: >>> persona = Person . builder_stringa ( 'Bobby Munson 58' ) >>> print ( \" {} {} \" . format ( persona . nome , persona . _cognome )) Bobby Munson 26.5.2 - Metodi statici \u00b6 Mediante il decoratore @staticmethod possiamo definire un metodo statico . In Python il funzionamento di un metodo di questo tipo \u00e8 riassumibile in un comportamento assimilabile ad una funzione \"semplice\", definita per\u00f2 all'interno della classe, e richiamabile su istanze della stessa. Ad esempio: @staticmethod def nome_valido ( nome ): if len ( nome ) < 2 : return False else : return True Questo metodo \u00e8 quindi liberamente richiamabile mediante l'operatore . da una singola istanza: >>> print ( persona . nome_valido ( 'Li' )) True Un'altra possibilit\u00e0 \u00e8 richiamarlo sulla classe stessa: >>> print ( Persona . nome_valido ( 'X' )) False 26.5.3 - Metodi astratti \u00b6 Possiamo definire dei metodi astratti (cfr. Appendice C) mediante il decorator @abstractmethod . Per farlo, la nostra classe deve discendere dalla classe ABC (acronimo che sta per Abstract Base Class ), contenuta nel package abc : from abc import ABC class ClasseBase ( ABC ): # ... @abstractmethod def metodo_da_sovrascrivere ( self ): pass I metodi contrassegnati con il decorator @abstractmethod dovranno essere implementati nelle classi derivate (in altre parole, dovremo farne l' override ): class ClasseDerivata ( ClasseBase ): # ... def metodo_da_sovrascrivere ( self ): # ... 26.6 - Le propriet\u00e0 \u00b6 In molti linguaggi di programmazione si usano tradizionalmente i metodi accessori ( getter ) e modificatori ( setter ) per accedere agli attributi delle istanze di una classe. Python non vieta di farlo: ad esempio, possiamo scrivere un metodo get_nome(self) per accedere al nome di una persona, ed un metodo set_nome(self, nome) per impostare detta propriet\u00e0. Tuttavia, \u00e8 possibile usare una sintassi pi\u00f9 compatta (e, in definitiva, maggiormente pythonic ) mediante il decorator @property , che rappresenta una funzione a quattro parametri: property ( fget = None , fset = None , fdel = None , doc = None ) In particolare: fget \u00e8 la funzione usata per recuperare il valore dell'attributo; fset \u00e8 la funzione usata per impostare il valore dell'attributo; fdel \u00e8 la funzione per rimuovere l'attributo; doc \u00e8 la funzione per documentare e descrivere l'attributo. Grazie a property , potremo seguire le \"best practice\" della OOP, rendendo privati gli attributi della classe ed accedendovi mediante opportuni metodi. class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.","title":"26 - OOP in Python"},{"location":"material/04_python/26_classes/lecture/#26-programmazione-orientata-agli-oggetti-in-python","text":"Python offre un esteso supporto alla programmazione orientata agli oggetti. Prima di proseguire, per\u00f2, \u00e8 opportuno introdurre brevemente questo concetto.","title":"26 - Programmazione orientata agli oggetti in Python"},{"location":"material/04_python/26_classes/lecture/#261-la-programmazione-orientata-agli-oggetti","text":"Quello della programmazione orientata agli oggetti (OOP) \u00e8 un paradigma di programmazione che permette di creare nuovi tipi definiti dall'utente, da intendersi come complementari ai tipi definiti dal linguaggio di programmazione. In tal senso, la OOP sposta il focus dalle funzioni , centrali nei linguaggi come il C e nel paradigma procedurale, ai dati . In tal senso, si arriva a dire che nella OOP tutto \u00e8 un oggetto .","title":"26.1 - La programmazione orientata agli oggetti"},{"location":"material/04_python/26_classes/lecture/#2611-classi","text":"Una classe \u00e8 un prototipo per un determinato tipo di dati definito dall'utente. Ad esempio: la classe Studente rappresenta tutte le propriet\u00e0 e le azioni associate ad uno studente; la classe Auto rappresenta tutte le propriet\u00e0 e le azioni associate ad un'auto; la classe Motore definisce i comportamenti dei motori; e via discorrendo. In generale, quindi, pu\u00f2 esistere una classe per ogni tipologia di oggetti presenti nel mondo, sia esso reale o informatico. Importante \u00e8 non confondere la classe con il singolo oggetto , chiamato istanza . Ad esempio: lo studente Angelo Cardellicchio \u00e8 un'istanza della classe Studente ; l'auto Opel Corsa targata AB 123 CD \u00e8 un'istanza della classe Auto ; l'auto Hyundai Tucson CD 321 AB \u00e8 un'istanza della classe Auto ; l'auto Opel Corsa targata AA 123 CC \u00e8 un'altra istanza della classe Auto .","title":"26.1.1 - Classi"},{"location":"material/04_python/26_classes/lecture/#26111-metodi-ed-attributi","text":"Ogni classe ha dei metodi , che caratterizzano delle azioni che \u00e8 possibile effettuare su ogni istanza della classe, e degli attributi , ovvero delle caratteristiche dell'istanza. In particolare, ogni nuovo tipo, chiamato classe , avr\u00e0 opportuni attributi e metodi , ognuno dei quali accessibile dall'esterno mediante opportuni modificatori . Ad esempio, l'auto Opel Corsa targata AB 123 CD ha una casa costruttrice (Opel), un modello (Corsa), una targa (AB 123 CD), una cilindrata, e via dicendo.","title":"26.1.1.1 - Metodi ed attributi"},{"location":"material/04_python/26_classes/lecture/#262-classi-in-python","text":"Per definire una classe, dovremo usare la parola chiave class : class NomeClasse ( ClasseBase ): # Attributi e metodi di classe... Con la sintassi precedente, abbiamo creato una classe chiamata NomeClasse discendente da una classe base ( ClasseBase ).","title":"26.2 - Classi in Python"},{"location":"material/04_python/26_classes/lecture/#263-il-metodo-__init__","text":"La maggior parte dei linguaggi di programmazione utilizza il concetto di costruttore per creare un'istanza di una classe. Il Python, tuttavia, non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione dei singoli attributi dell'istanza. Da qui deriva il nome del metodo, ovvero __init__ : class NomeClasse ( ClasseBase ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Unpacking Con la sintassi *args e **kwargs vogliamo rappresentare l'azione di unpacking di (rispettivamente) una lista ed un dizionario, mediante la quale stiamo passando tutti i valori contenuti all'interno della sequenza. Occorre prestare particolare attenzione all'uso della keyword self , che permette di riferirsi alla specifica istanza di una classe (per chi ha familiarit\u00e0 con i linguaggi come il C++, \u00e8 concettualmente simile alla parola chiave this ). Ad esempio: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome self . _cognome = cognome self . __eta = eta Questo snippet ci permette di evidenziare quattro punti: la classe generica object , da cui derivano tutte le classi Python (ma la cui dichiarazione pu\u00f2 comunque essere omessa); il funzionamento della parola chiave self , che permette di associare agli attributi della singola istanza un determinato valore; la possibilit\u00e0 di inserire tra i parametri dei valori opzionali e di default (in questo caso eta , che di default vale 18 ); la presenza di uno o due simboli _ ( underscore ) davanti ad alcuni attributi. Approfondiamo brevemente il punto 26.","title":"26.3 - Il metodo __init__"},{"location":"material/04_python/26_classes/lecture/#264-modificatori-di-accesso","text":"Python prevede l'uso di modificatori di accesso ai dati; nello specifico, troviamo i classici public , protected e private . Tuttavia, a differenza di altri linguaggi, per distinguere tra i tre modificatori di accesso si utilizzano uno o due underscore come suffisso al nome dell'attributo; in particolare, usare un underscore singolo indica un attributo protected, mentre un underscore doppio indica un attributo private . Nel nostro caso: class Persona ( object ): def __init__ ( self , nome , cognome , eta = 18 ): self . nome = nome # Membro \"public\" self . _cognome = cognome # Membro \"protected\" self . __eta = eta # Membro \"private\" Attenzione Nonostante il modificatore di accesso, \u00e8 possibile accedere ai membri protetti dall'esterno della classe. Infatti: >>> p = Persona ( 'Jax' , 'Teller' ) >>> print ( p . nome ) >>> print ( p . _cognome ) Jax Teller Questo non vale per gli attributi privati: >>> try: >>> print ( p.__eta ) >>> except AttributeError: >>> print ( 'Et\u00e0 \u00e8 privato!' ) Et\u00e0 \u00e8 privato! Questa sintassi pu\u00f2 ovviamente essere utilizzata per definire dei metodi protetti o privati. Suggerimento La sintassi che abbiamo mostrato nello snippet precedente \u00e8 relativa alla gestione delle eccezioni .","title":"26.4 - Modificatori di accesso"},{"location":"material/04_python/26_classes/lecture/#265-metodi","text":"La sintassi per definire il metodo di una classe \u00e8 analoga a quella usata per definire una funzione. def metodo ( self , * args , ** kwargs ): pass Esiste tuttavia una differenza fondamentale: infatti, il primo attributo di un metodo appartenente ad una classe \u00e8 sempre un riferimento all'istanza tramite la parola chiave self . Tale riferimento non va specificato quando il metodo viene chiamato dall'esterno: # ... p = Persona () # p \u00e8 un'istanza di Persona p . metodo ( parametro ) # richiamo il metodo dall'istanza # ... Nel codice precedente, abbiamo usato l'operatore . per accedere a metodo definito all'interno della classe Persona . Approfondiamo adesso alcune particolari tipologie di metodi, ottenibili usando determinati decorator (cfr. appendice B).","title":"26.5 - Metodi"},{"location":"material/04_python/26_classes/lecture/#2651-metodi-di-classe","text":"Il decorator @classmethod ci permette di definire i cosiddetti metodi di classe : @classmethod def builder_stringa ( cls , stringa : str ): nome , cognome , eta = stringa . split ( ' ' ) return Persona ( nome , cognome , eta ) A differenza dei metodi standard, i metodi di classe hanno un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi che si applicano all'intera classe , e non alla singola istanza. Un tipico esempio di utilizzo di un metodo di classe \u00e8 mostrato nello snippet precedente, nel quale stiamo creando un oggetto di classe Persona a partire da una stringa. Curiosit\u00e0 Il metodo precedente \u00e8, di fatto, un'implementazione del design pattern Builder. Per richiamare un metodo di classe occorre riferirsi al nome della classe stessa, e non ad una singola istanza: >>> persona = Person . builder_stringa ( 'Bobby Munson 58' ) >>> print ( \" {} {} \" . format ( persona . nome , persona . _cognome )) Bobby Munson","title":"26.5.1 - Metodi di classe"},{"location":"material/04_python/26_classes/lecture/#2652-metodi-statici","text":"Mediante il decoratore @staticmethod possiamo definire un metodo statico . In Python il funzionamento di un metodo di questo tipo \u00e8 riassumibile in un comportamento assimilabile ad una funzione \"semplice\", definita per\u00f2 all'interno della classe, e richiamabile su istanze della stessa. Ad esempio: @staticmethod def nome_valido ( nome ): if len ( nome ) < 2 : return False else : return True Questo metodo \u00e8 quindi liberamente richiamabile mediante l'operatore . da una singola istanza: >>> print ( persona . nome_valido ( 'Li' )) True Un'altra possibilit\u00e0 \u00e8 richiamarlo sulla classe stessa: >>> print ( Persona . nome_valido ( 'X' )) False","title":"26.5.2 - Metodi statici"},{"location":"material/04_python/26_classes/lecture/#2653-metodi-astratti","text":"Possiamo definire dei metodi astratti (cfr. Appendice C) mediante il decorator @abstractmethod . Per farlo, la nostra classe deve discendere dalla classe ABC (acronimo che sta per Abstract Base Class ), contenuta nel package abc : from abc import ABC class ClasseBase ( ABC ): # ... @abstractmethod def metodo_da_sovrascrivere ( self ): pass I metodi contrassegnati con il decorator @abstractmethod dovranno essere implementati nelle classi derivate (in altre parole, dovremo farne l' override ): class ClasseDerivata ( ClasseBase ): # ... def metodo_da_sovrascrivere ( self ): # ...","title":"26.5.3 - Metodi astratti"},{"location":"material/04_python/26_classes/lecture/#266-le-proprieta","text":"In molti linguaggi di programmazione si usano tradizionalmente i metodi accessori ( getter ) e modificatori ( setter ) per accedere agli attributi delle istanze di una classe. Python non vieta di farlo: ad esempio, possiamo scrivere un metodo get_nome(self) per accedere al nome di una persona, ed un metodo set_nome(self, nome) per impostare detta propriet\u00e0. Tuttavia, \u00e8 possibile usare una sintassi pi\u00f9 compatta (e, in definitiva, maggiormente pythonic ) mediante il decorator @property , che rappresenta una funzione a quattro parametri: property ( fget = None , fset = None , fdel = None , doc = None ) In particolare: fget \u00e8 la funzione usata per recuperare il valore dell'attributo; fset \u00e8 la funzione usata per impostare il valore dell'attributo; fdel \u00e8 la funzione per rimuovere l'attributo; doc \u00e8 la funzione per documentare e descrivere l'attributo. Grazie a property , potremo seguire le \"best practice\" della OOP, rendendo privati gli attributi della classe ed accedendovi mediante opportuni metodi. class Persona (): def __init__ ( self , nome , cognome , eta ): self . nome = nome self . cognome = cognome self . eta = eta @property def nome ( self ): return self . __nome @nome . setter def nome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __nome = value @property def cognome ( self ): return self . __cognome @cognome . setter def cognome ( self , value ): if len ( value ) < 2 : raise ValueError ( 'La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.' ) else : self . __cognome = value @property def eta ( self ): return self . __eta @eta . setter def eta ( self , value ): if value < 0 : raise ValueError ( \"L'et\u00e0 non pu\u00f2 essere negativa.\" ) else : self . __eta = value Alcune note: abbiamo riscritto la classe Persona in modo da trasformare tutti gli attributi in propriet\u00e0; per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa; oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input. Vediamo come usare la nostra nuova classe: >>> draco = Persona ( 'Draco' , 'Malfoy' , 12 ) >>> print ( draco . nome ) Draco >>> print ( draco . eta ) 12 >>> hermione = PersonProperty ( '' , 'Granger' , 18 ) ValueError : La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri . Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.","title":"26.6 - Le propriet\u00e0"},{"location":"material/04_python/27_modules/lecture/","text":"27 - Script e moduli \u00b6 Quando si usa Python la tentazione \u00e8 quella di interagire direttamente con l'interprete, lanciandolo da terminale ed eseguendo di volta in volta le istruzioni necessarie. Ovviamente questo approccio, seppur immediato, presenta diversi svantaggi. Ad esempio: non avremo a disposizione il syntax highlighting offerto da una normale IDE; non potremo recuperare il codice una volta chiuso l'interprete; non potremo n\u00e9 modificare, n\u00e9 verificare facilmente il funzionamento del codice. Appare quindi evidente come usare l'interprete non sia un modo ottimale di sviluppare codice Python. Di conseguenza, sar\u00e0 necessario definire, mediante la nostra IDE di riferimento, dei veri e propri script che saranno salvati sotto forma di file con estensione .py , ognuno dei quali contenenti una serie di istruzioni necessarie all'esecuzione del nostro programma. 27.1 - Il primo script \u00b6 Proviamo quindi a creare il nostro primo script Python. Per farlo, apriamo la nostra IDE di riferimento, come Visual Studio Code, e creiamo un file chiamato main.py , all'interno del quale inseriremo il seguente codice: # main.py def hello_world (): print ( 'Hello, world' ) hello_world () Adesso apriamo un terminale, spostiamoci nella cartella nel quale abbiamo salvato questo script, ed eseguiamolo: cd cartella_dove_risiede_lo_script python main.py Le due istruzioni precedenti: servono a cambiare cartella ( change directory , cd ), spostandoci nella cartella dove risiede lo script; dicono all'interprete Python di lanciare lo script main.py . A schermo, se tutto \u00e8 andato per il verso giusto, apparir\u00e0 la scritta Hello, world : Hello, world 27.2 - I moduli \u00b6 Quando le dimensioni della nostra code base (ovvero la quantit\u00e0 di codice che scriviamo nel nostro programma) iniziano ad essere particolarmente \"ingombranti\", \u00e8 opportuno adottare un approccio modulare , separando in file differenti parti di codice delegate a funzioni eterogenee. Facciamo un esempio. Immaginiamo di voler scrivere un programma che definisca delle funzioni per calcolare l'area delle principali figure geometriche. Modifichiamo quindi il nostro file main.py come segue: def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 area_quadrato = calcola_area_quadrato ( 4 ) area_rettangolo = calcola_area_rettangolo ( 2 , 3 ) area_triangolo = calcola_area_triangolo ( 2 , 3 ) Immaginiamo di voler quindi aggiungere una funzione di calcolo trigonometrico: import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) tangente_pi = calcola_tangente ( math . pi ) Il codice del nostro file main.py comprender\u00e0 adesso funzioni di tipo geometrico e trigonometrico. Cosa succederebbe se volessimo integrare delle funzioni di calcolo integrale, o di altro tipo? Ovviamente, ci sarebbe da un lato un aumento delle dimensioni della code base, dall'altro un \"mix\" tra funzioni che afferiscono ad ambiti differenti (seppur simili tra loro). Una buona idea sarebbe quindi quella di separare le diverse parti del programma, magari raggruppando le funzioni geometriche nel file geometria.py , le funzioni trigonometriche nel file trigonometria.py , e via discorrendo. Questi file, che conterranno al loro interno prevalentemente funzioni (ma non solo), sono chiamati moduli . Nota La linea che distingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile fare confusione ed utilizzarli in maniera \"intercambiabile\". Sottolineamo per\u00f2 che, idealmente, gli script devono contenere al loro interno soltanto del codice che sar\u00e0 eseguito , mentre i moduli solo del codice che sar\u00e0 invocato da uno o pi\u00f9 script. Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file geometria.py , l'interprete associer\u00e0 a quel modulo il nome geometria . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ . 27.2.1 - I moduli geometria e trigonometria \u00b6 Creiamo adesso il file geometria.py , all'interno del quale \"sposteremo\" le funzioni definite in precedenza per il calcolo geometrico. # geometria.py def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 Analogamente, nel file trigonometria.py andremo a definire la funzione per il calcolo della tangente. import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) Riscriviamo ora il file main.py : import geometria import trigonometria if __name__ == \"__main__\" : print ( geometria . calcola_area_quadrato ( 4 )) print ( trigonometria . calcola_tangente ( math . pi )) Possiamo notare due cose. In primis, stiamo richiamando le funzioni calcola_area_quadrato() e calcola_tangente() definite nei moduli geometria e trigonometria , rispettivamente. Questi moduli sono importati all'interno del nostro script mediante la direttiva import . Alle righe 5 e 6, la \"strana\" sintassi mostrata serve a dichiarare quello che \u00e8 il main , ovvero il punto di \"accesso\" al codice del nostro programma. Il main \u00e8 normalmente presente in tutti i linguaggi di programmazione, alle volte sotto forme un po' differenti da quella qui mostrata; tuttavia, nel caso di script particolarmente semplici, il main pu\u00f2 essere tranquillamente omesso, in quanto l'interprete riuscir\u00e0 ad eseguirlo in maniera autonoma. Proviamo a lanciare lo script; per farlo, digitiamo l'istruzione python main.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i valori dell'area di un quadrato e della tangente di \\(\\pi\\) . 27.3 - Usare gli import \u00b6 Relativamente al modulo geometria , abbiamo usato esclusivamente la funzione calcola_area_quadrato() , \"trascurando\" le altre due funzioni comunque presenti nel modulo. In queste circostanze, possiamo usare una versione modificata della direttiva import , che assume la seguente forma: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from geometria import calcola_area_quadrato In questo modo, possiamo importare solamente quello che ci serve, il che risulta particolarmente utile a migliorare l'efficienza del nostro codice; il perch\u00e9 sar\u00e0 chiaro a breve. 27.3.1 - Alias \u00b6 La direttiva import ci permette di definire anche degli alias, particolarmente utili nel caso si usino dei nomi di package complessi. Ad esempio: import trigonometria as tr print ( tr . calcola_tangente ( math . pi )) 27.4 - La funzione dir() \u00b6 La funzione dir() restituisce una lista con tutti i nomi (sia di funzione, sia di classe) definiti da un modulo. Ad esempio: >>> dir ( geometria ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'calcola_area_quadrato' , 'calcola_area_rettangolo' , 'calcola_area_triangolo' ] E' interessante notare come, oltre a funzioni, classi e variabili da noi definite, nel modulo geometria siano automaticamente definite altre variabili, che saranno importate usando import: import geometria if __name__ == \"__main__\" : print ( geometria . __file__ ) print ( geometria . calcola_area_quadrato ( 4 )) Notiamo che saremo in grado di accedere alla variabile __file__ del modulo geometria , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non \u00e8 quasi mai utile, ma comporta un ulteriore carico sul codice, da cui diventa evidente l'importanza dell'opportuno uso della direttiva from . 27.5 - Moduli della libreria standard \u00b6 Python ha diversi moduli appartenenti ad una libreria standard, i quali sono automaticamente disponibili a valle dell'installazione dell'interprete. Alcuni tra i pi\u00f9 utilizzati sono: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Per una lista esaustiva, si rimanda alla Python Library Reference . 27.6 - Package \u00b6 Chiudiamo la trattazione con un accenno ai package , ovvero a delle vere e proprie \"collezioni\" che raggruppano moduli tra loro coerenti, in modo da facilitarne il successivo accesso. In pratica, i package non sono altro se non delle cartelle contenenti pi\u00f9 moduli (quindi, file con estensione nome_modulo.py ), oltre ad un file, chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package e, occasionalmente, contiene delle istruzioni di inizializzazione del package. Per poter accedere ad un modulo contenuto all'interno di un package, possiamo usare la direttiva import , modificandola come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"27 - Moduli e script in Python"},{"location":"material/04_python/27_modules/lecture/#27-script-e-moduli","text":"Quando si usa Python la tentazione \u00e8 quella di interagire direttamente con l'interprete, lanciandolo da terminale ed eseguendo di volta in volta le istruzioni necessarie. Ovviamente questo approccio, seppur immediato, presenta diversi svantaggi. Ad esempio: non avremo a disposizione il syntax highlighting offerto da una normale IDE; non potremo recuperare il codice una volta chiuso l'interprete; non potremo n\u00e9 modificare, n\u00e9 verificare facilmente il funzionamento del codice. Appare quindi evidente come usare l'interprete non sia un modo ottimale di sviluppare codice Python. Di conseguenza, sar\u00e0 necessario definire, mediante la nostra IDE di riferimento, dei veri e propri script che saranno salvati sotto forma di file con estensione .py , ognuno dei quali contenenti una serie di istruzioni necessarie all'esecuzione del nostro programma.","title":"27 - Script e moduli"},{"location":"material/04_python/27_modules/lecture/#271-il-primo-script","text":"Proviamo quindi a creare il nostro primo script Python. Per farlo, apriamo la nostra IDE di riferimento, come Visual Studio Code, e creiamo un file chiamato main.py , all'interno del quale inseriremo il seguente codice: # main.py def hello_world (): print ( 'Hello, world' ) hello_world () Adesso apriamo un terminale, spostiamoci nella cartella nel quale abbiamo salvato questo script, ed eseguiamolo: cd cartella_dove_risiede_lo_script python main.py Le due istruzioni precedenti: servono a cambiare cartella ( change directory , cd ), spostandoci nella cartella dove risiede lo script; dicono all'interprete Python di lanciare lo script main.py . A schermo, se tutto \u00e8 andato per il verso giusto, apparir\u00e0 la scritta Hello, world : Hello, world","title":"27.1 - Il primo script"},{"location":"material/04_python/27_modules/lecture/#272-i-moduli","text":"Quando le dimensioni della nostra code base (ovvero la quantit\u00e0 di codice che scriviamo nel nostro programma) iniziano ad essere particolarmente \"ingombranti\", \u00e8 opportuno adottare un approccio modulare , separando in file differenti parti di codice delegate a funzioni eterogenee. Facciamo un esempio. Immaginiamo di voler scrivere un programma che definisca delle funzioni per calcolare l'area delle principali figure geometriche. Modifichiamo quindi il nostro file main.py come segue: def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 area_quadrato = calcola_area_quadrato ( 4 ) area_rettangolo = calcola_area_rettangolo ( 2 , 3 ) area_triangolo = calcola_area_triangolo ( 2 , 3 ) Immaginiamo di voler quindi aggiungere una funzione di calcolo trigonometrico: import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) tangente_pi = calcola_tangente ( math . pi ) Il codice del nostro file main.py comprender\u00e0 adesso funzioni di tipo geometrico e trigonometrico. Cosa succederebbe se volessimo integrare delle funzioni di calcolo integrale, o di altro tipo? Ovviamente, ci sarebbe da un lato un aumento delle dimensioni della code base, dall'altro un \"mix\" tra funzioni che afferiscono ad ambiti differenti (seppur simili tra loro). Una buona idea sarebbe quindi quella di separare le diverse parti del programma, magari raggruppando le funzioni geometriche nel file geometria.py , le funzioni trigonometriche nel file trigonometria.py , e via discorrendo. Questi file, che conterranno al loro interno prevalentemente funzioni (ma non solo), sono chiamati moduli . Nota La linea che distingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile fare confusione ed utilizzarli in maniera \"intercambiabile\". Sottolineamo per\u00f2 che, idealmente, gli script devono contenere al loro interno soltanto del codice che sar\u00e0 eseguito , mentre i moduli solo del codice che sar\u00e0 invocato da uno o pi\u00f9 script. Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file geometria.py , l'interprete associer\u00e0 a quel modulo il nome geometria . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ .","title":"27.2 - I moduli"},{"location":"material/04_python/27_modules/lecture/#2721-i-moduli-geometria-e-trigonometria","text":"Creiamo adesso il file geometria.py , all'interno del quale \"sposteremo\" le funzioni definite in precedenza per il calcolo geometrico. # geometria.py def calcola_area_quadrato ( lato ): return lato * lato def calcola_area_rettangolo ( base , altezza ): return base * altezza def calcola_area_triangolo ( base , altezza ): return ( base * altezza ) / 2 Analogamente, nel file trigonometria.py andremo a definire la funzione per il calcolo della tangente. import math def calcola_tangente ( angolo ): return math . sin ( angolo ) / math . cos ( angolo ) Riscriviamo ora il file main.py : import geometria import trigonometria if __name__ == \"__main__\" : print ( geometria . calcola_area_quadrato ( 4 )) print ( trigonometria . calcola_tangente ( math . pi )) Possiamo notare due cose. In primis, stiamo richiamando le funzioni calcola_area_quadrato() e calcola_tangente() definite nei moduli geometria e trigonometria , rispettivamente. Questi moduli sono importati all'interno del nostro script mediante la direttiva import . Alle righe 5 e 6, la \"strana\" sintassi mostrata serve a dichiarare quello che \u00e8 il main , ovvero il punto di \"accesso\" al codice del nostro programma. Il main \u00e8 normalmente presente in tutti i linguaggi di programmazione, alle volte sotto forme un po' differenti da quella qui mostrata; tuttavia, nel caso di script particolarmente semplici, il main pu\u00f2 essere tranquillamente omesso, in quanto l'interprete riuscir\u00e0 ad eseguirlo in maniera autonoma. Proviamo a lanciare lo script; per farlo, digitiamo l'istruzione python main.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i valori dell'area di un quadrato e della tangente di \\(\\pi\\) .","title":"27.2.1 - I moduli geometria e trigonometria"},{"location":"material/04_python/27_modules/lecture/#273-usare-gli-import","text":"Relativamente al modulo geometria , abbiamo usato esclusivamente la funzione calcola_area_quadrato() , \"trascurando\" le altre due funzioni comunque presenti nel modulo. In queste circostanze, possiamo usare una versione modificata della direttiva import , che assume la seguente forma: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from geometria import calcola_area_quadrato In questo modo, possiamo importare solamente quello che ci serve, il che risulta particolarmente utile a migliorare l'efficienza del nostro codice; il perch\u00e9 sar\u00e0 chiaro a breve.","title":"27.3 - Usare gli import"},{"location":"material/04_python/27_modules/lecture/#2731-alias","text":"La direttiva import ci permette di definire anche degli alias, particolarmente utili nel caso si usino dei nomi di package complessi. Ad esempio: import trigonometria as tr print ( tr . calcola_tangente ( math . pi ))","title":"27.3.1 - Alias"},{"location":"material/04_python/27_modules/lecture/#274-la-funzione-dir","text":"La funzione dir() restituisce una lista con tutti i nomi (sia di funzione, sia di classe) definiti da un modulo. Ad esempio: >>> dir ( geometria ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'calcola_area_quadrato' , 'calcola_area_rettangolo' , 'calcola_area_triangolo' ] E' interessante notare come, oltre a funzioni, classi e variabili da noi definite, nel modulo geometria siano automaticamente definite altre variabili, che saranno importate usando import: import geometria if __name__ == \"__main__\" : print ( geometria . __file__ ) print ( geometria . calcola_area_quadrato ( 4 )) Notiamo che saremo in grado di accedere alla variabile __file__ del modulo geometria , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non \u00e8 quasi mai utile, ma comporta un ulteriore carico sul codice, da cui diventa evidente l'importanza dell'opportuno uso della direttiva from .","title":"27.4 - La funzione dir()"},{"location":"material/04_python/27_modules/lecture/#275-moduli-della-libreria-standard","text":"Python ha diversi moduli appartenenti ad una libreria standard, i quali sono automaticamente disponibili a valle dell'installazione dell'interprete. Alcuni tra i pi\u00f9 utilizzati sono: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Per una lista esaustiva, si rimanda alla Python Library Reference .","title":"27.5 - Moduli della libreria standard"},{"location":"material/04_python/27_modules/lecture/#276-package","text":"Chiudiamo la trattazione con un accenno ai package , ovvero a delle vere e proprie \"collezioni\" che raggruppano moduli tra loro coerenti, in modo da facilitarne il successivo accesso. In pratica, i package non sono altro se non delle cartelle contenenti pi\u00f9 moduli (quindi, file con estensione nome_modulo.py ), oltre ad un file, chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package e, occasionalmente, contiene delle istruzioni di inizializzazione del package. Per poter accedere ad un modulo contenuto all'interno di un package, possiamo usare la direttiva import , modificandola come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"27.6 - Package"},{"location":"material/05_algorithms/29_sorting/lecture/","text":"14 - Algoritmi di ordinamento \u00b6 Uno dei problemi pi\u00f9 \"classici\" nello studio degli algoritmi \u00e8 quello di ordinare una lista di elementi affini (ovvero dello stesso tipo). Questo problema, soltanto apparentemnete banale, ha in realt\u00e0 numerosi riscontri pratici, in quanto capita molto spesso di dover ordinare una lista secondo un certo criterio (ad esempio, un elenco di nomi in ordine alfabetico, oppure i prezzi di diversi beni in ordine ascendente). Per far questo, nel tempo sono stati definiti diversi algoritmi detti di ordinamento o, in inglese, sorting algorithms . Vediamone alcuni tra i pi\u00f9 conosciuti. 14.1 - Selection sort \u00b6 Il primo algoritmo che vedremo \u00e8 chiamato selection sort . Questo \u00e8 un algoritmo di tipo iterativo , che analizza quindi un elemento della lista alla volta alla ricerca dell'elemento minore; per comprendere appieno il funzionamento dell'algoritmo, \u00e8 opportuno utilizzare un esempio concreto. 14.1.1 - Esempio e formalizzazione \u00b6 Immaginiamo quindi di voler ordinare un mazzo di dieci carte dalla pi\u00f9 piccola alla pi\u00f9 grande. Per farlo, seguiamo questi passi: disponiamo tutte le carte presenti nel mazzo in un'unica fila; cerchiamo la carta pi\u00f9 piccola, e posizioniamola all'estrema sinistra del mazzo; dividiamo la fila in due parti: nella parte pi\u00f9 a sinistra inseriamo le carte gi\u00e0 ordinate, mentre in quella destra quelle da ordinare; prendiamo dalla fila di destra la carta pi\u00f9 piccola, posizionandola a destra dell'ultimo elemento della fila di sinistra; reiteriamo il passo 4 fino a che non vi sono pi\u00f9 carte nella fila di destra. Volendo, \u00e8 possibile formalizzare i passi precedenti come segue. Dato un vettore \\(x\\) fatto da \\(n\\) numeri interi: Associare ad \\(i\\) il primo indice dell'array, ovvero \\(i = 0\\) , ed a \\(j\\) l'ultimo, ovvero \\(j = n-1\\) . Associare alla variabile \\(m\\) il valore di \\(x(0)\\) , supponendo che \\(m\\) sia il valore pi\u00f9 piccolo attualmente presente all'interno dell'array. Confrontare \\(m\\) con tutti gli elementi \\(x(k), k \\in (0, n-1]\\) . Se \\(x(k) < m\\) per qualche \\(k\\) , allora \\(m = x(k)\\) . Aumentare il valore di \\(i\\) di un'unit\u00e0. Reiterare le istruzioni 3-4 fino a che \\(i = x(n-1)\\) . 14.1.2 - Esempio pratico \u00b6 Immaginiamo di avere un array di numeri interi, i cui elementi assumono valore [12, 4, 8, 7, 2] . Seguiamo i passi evidenziati in precedenza per l'algoritmo. Step 1 : imponiamo \\(i = 0, j = 4\\) . Step 2 : imponiamo \\(m = x(0) = 12\\) . Step 3 : dal confronto, emerge che \\(x(1) = 4 < m \\Rightarrow m = x(1)\\) . Continuando per\u00f2 ad incrementare \\(i\\) , notiamo che \\(x(4) = 2 < m \\Rightarrow m = x(4)\\) . Step 4 : poniamo \\(i = i + 1 = 2\\) . Step 5 : reiteriamo le istruzioni 3-4 fino a che \\(i = 4\\) , ottenendo l'array finale. In altre parole: START CICLO 0 x = [12, 4, 8, 7, 2]; i = 0; j = 4; min = x(0) = 12; CICLO 1 x = [2, 12, 4, 8, 7]; i = 1; j = 4; min = x(1) = 12; CICLO 2 x = [2, 4, 12, 8, 7]; i = 2; j = 4; min = x(2) = 12; CICLO 3 x = [2, 4, 7, 12, 8]; i = 3; j = 4; min = x(3) = 12; CICLO 4 x = [2, 4, 7, 8, 12]; i = 4; j = 4; min = x(4) = 12; STOP 14.1.3 - Analisi della complessit\u00e0 computazionale dell'algoritmo \u00b6 L'algoritmo di selection sort cicla su tutti gli \\(n\\) indici di un array. Per comprendere quante operazioni sono necessarie a completare l'ordinamento, dovremo contare il numero di comparazioni necessarie ad individuare l'elemento \"minore\" attualmente presente all'interno dell'array. In particolare, alla prima iterazione (con \\(i = 0\\) ), avremo la necessit\u00e0 di effettuare \\(n\\) operazioni di comparazione, una per ogni elemento dell'array; alla seconda, con \\(i = 1\\) , dovremo fare \\(n - 1\\) confronti, alla terza \\(n - 2\\) , e cos\u00ec via. Ci\u00f2 implica che avremo bisogno di un numero di operazioni pari a: \\[ C_T = n + (n - 1) + \\ldots + 2 + 1 = \\frac{n^2}{2} + \\frac{n}{2} \\] La complessit\u00e0 di caso peggiore tiene conto del limite asintotico del valore precedente, ed \u00e8 chiaramente pari ad un \\(O(n^2)\\) . 14.2 - Insertion sort \u00b6 Il secondo algoritmo che vedremo \u00e8 l' insertion sort . Per introdurlo, partiamo dal un altro modo \u00e8 l\u2019insertion sort. Immaginiamo che stimao giocando un gioco di carte. Stiamo tenendo delle carte in mano, e tutte queste carte sono ordinate. Il dealer ci d\u00e0 esattamente una nuova carta. Si deve metterla nel posto corretto in modo che la carta cheabbiamo in mano siano ancora ordinate. Nel selection sort, ogni elemento che aggiungiamo all\u2019array ordinato non pu\u00f2 essere pi\u00f9 piccolo degli elementi gi\u00e0 presenti nell\u2019arry ordinato. Ma nel nostro esempio, la nuova carta pu\u00f2 essere pi\u00f9 piccola delle carte che abbiamo gi\u00e0 in mano, per cui dobbiamo andare gi\u00f9 nella linea, comparando le nuove card con ognuna delle carte in mano, fino a che non troviamo un posto epr inserirla. Inseriamo la nuova carta nel punto giusto, e nuovamente la nostra mano ha delle card completamente ordinate. Quindi il dealer ci da un\u2019altra carta, e si ripete la stesa procedura. Quindi un\u2019altra carta, e via dicendo, fino a che il dealer non ci d\u00e0 pi\u00f9 alcuna carta. Questa \u00e8 l\u2019idea dietro linsertion sort. Iterare nelle posizsioni dell\u2019array, a partire dall\u2019indice 1. COn ogni nuova posizione \u00e8 come la nuova carta che civieen data dal dealer, e dobbiamo inserirla nel psto corretto nel subarray ordinato a sinistra di quella posizione. Immaginiamo che il subarray dall\u2019indice 0 all\u2019indice 5 sia gi\u00e0 ordinato, e vogliamo inserire l\u2019ekemeto attuamlmente all\u2019indice 6 in questo subarray gi\u00e0 ordinato, in modo che il subarray dall\u2019indice 0 all\u2019indice 6 sia ordinato. 2 3 7 8 10 13 5 PER ARRIVARE A 2 3 5 7 9 10 13 Per inserire l\u2019eeento in posizione 6 nel subarray alla sua sinsitra, compariamo ripetutatmente questo con gli elementi alla sua sinistra, andando da destra verso sinistra. Chiamaiamo quindi l\u00ecelemento in posizione 6 chiave. ogni volta che capiamo che la chiave \u00e8 inferiroe di un elemento alla sua sinistra, lo spostiamo verso destra, dal momento che sappiamo che la chiave dovr\u00e0 andare alla sinistra di quell\u2019elemento. Dovremo fare altre due cose per far funzionare questa idea: dovremo avere un\u2019operazione slide (che sposta un elemento di una posizione a destra), e dovremo salvare il valore della chiave in un puno separato. Nel nostro esempio, : 1.- inseriamo l\u2019elemento all\u2019indice 6 in ua variabile chiamata key compariamo key con l\u2019elemento alla posizione 5. sappiamo che key \u00e8 inferiore all\u2019elemento in posizione 5, quindi faccioamo lo slide di questo alla posizione 6. Notiamo che l\u2019operazione di slide si limita a copiare l\u2019eemento una posizione a destra. Quindi, compariamo key con l\u2019elemento in posizione 4. troviamo che key \u00e8 inferiore, e reiteriamo la procedura. Quando l\u2019elemento\u00e8 inferiore di key, non effettuiamo l\u2019operazione di slide. Invece, lasciamo la variabile key in quella posizione, immediatamente all\u2019elemento a destra. Il risultato \u00e8 \u2018ordinamento di tutto l\u2019array. Il nome dell\u2019insertion sort deriva dal fatto che questo inserisce ripetutamente un elemento nel subarray a sinistra dell\u2019elemento che sta valutando. Di conseguenza, nel caso generale, si parte considerando sempre il primo elemento del subarray (o meglio un subarray di un elemento), che non pu\u00f2 non essere ordinato (\u00e8 ordinato rispetto a se stesso). La prima chiave sar\u00e0 quindi l\u2019elemento con indice 1. 10 7 3 13 7 10 3 13 A questo punto, il subarray ordinato va da 0 ad 1, quindi il nuovo key \u00e8 indice 2. compariamo questo con quelli a sinistra ed abbiamo: 7 10 3 13 7 3 10 13 3 7 10 13 Ci sono un paio di situazioni limite. Il primo \u00e8 quando l\u2019elemento chiave \u00e8 inferiore a tutti gli elementi nel subarray ordinato; il secondo \u00e8 qunado invece \u00e8 superiore. Nel primo, ogni elemento del subarray deve effettuare uno slide, nel secondo non ci sono slide da effettuare. pseudocdice chiamo insert per inserire l\u2019elemento cheinizia all\u2019indice 1 nell\u2019array ordinato all\u2019indice 0. chiamo insert per insierire l\u2019elemento che inizia all\u2019indice 2 nell\u2019array ordinato in un indice che va da 0 ad 1. \u2026 Chiamo insert per insserire l\u2019elemento che inizia all\u2019indice n-1 nell\u2019array ordinato nell\u2019indice che va da 0 ad n - 2. analisi come nel caso del selection sort, l\u2019insertion sort fa un loop sugli indici dell\u2019array. chiama semplicemente insert sugli elementi di indice che vanno da 1 ad n-1. Ogni chiamata ad insert richiede un certo periodo di tempo. Prendiamo una situazione nella quale chiamoiamo insrt ed il valore che viene inserito nel subarray \u00e8 inferiore ad ogni elemento nel sybarray. Quindi, ogni elemento nel subarray dovr\u00e0 effettuare lo slide di una posizione a sinistra. Per cui, in generale, se stiamo inserendo un nuovo elemento in un subarray con k elementi, tutti i k elementi dovranno effettuare uno slide di una posizione. Pitutosto che contare esattamente quante linee di codice dobbiamo usare, diciamo che questo numero \u00e8 c. Quindi, potremmo aver bisogno di c * k linee per inserire un valore in un subarray di k elementi. Supponiamo che ad ogni chiamata ad insert, il valore che venga inserito sia inferirore ad ogni elmento nel subarray alla sua sinsitra. Quando chiamiamo insert la prima vlta, con k = 1. La seconda volta, k = 2. La terza volta, k = 3. E via, fino all\u2019ultima volta, quando k = n -1. Quinid, il tempo totale speso ad inserire qualcosa nel sub array \u00e8 c * (1 + 2 + .. + n-1). Anche in questo caso abbiamo una serie aritmetica. Tornando alla notazione, O(n^2). Molto probabilmente, per\u00f2, l\u2019insertion sort potrebbe avere meno tempo necessario (ad esempio, questo accadrebbe nel caso avessimo un array gi\u00e0 ordinato). Per\u00f2 non \u00e8 detto, quindi \u00e8 necessario sempre e comunque considerare un tempo pari a O(n^2). Potremmo per\u00f2 considerare il caso migliroe, che avrebbe un O(n) (in questo caso l\u2019array \u00e8 gi\u00e0 quasi ordinato). 14.3 - Quick sort \u00b6 Descrizione dell'algoritmo \u00b6 Cos\u00ec come il merge sort, il quick sort utilizza l'approccio divide-and-conquer , ed \u00e8 ovviamente un algoritmo di tipo ricorsivo. Tuttavia, laddove nel merge sort lo step divide \u00e8 praticamente ininfluente, ed \u00e8 il combine ad essere quello pi\u00f9 rilevante per il riordinamento, nel quick sort i ruoli si invertono. Ecco quindi come si articolano i tre diversi step del divide-and-conquer nel quick sort. Divide e procedura di partitioning \u00b6 Nel passo divide , scegliamo un elemento dell'array array[l,r] chiamato elemento pivot . A questo punto, gli elementi presenti nell'array saranno disposti in modo che: tutti gli elementi minori o uguali del pivot siano alla sua sinistra ; tutti gli elementi strettamente maggiori del pivot siano alla sua destra . Questa procedura \u00e8 chiamata partitioning (partizionamento). Nota Non ci interessa l'ordine relativo degli elementi a sinistra o a destra del pivot. Nella pratica, vedremo come conviene scegliere come pivot sempre l'elemento pi\u00f9 a destra nell'array, ovvero array[r] . Ad esempio, con il nostro array [8, 4, 5, 12, 7] , il pivot ad essere scelto alla prima iterazione sar\u00e0 proprio il 7 . Dopo il partizionamento, l'array sar\u00e0 riscritto come [4, 5, 7, 8, 12] , ed indicheremo con q il nuovo indice del pivot (in questo caso, q = 2 ). Nota Il fatto che siamo riusciti a riordinare l'array in una sola mossa \u00e8 puramente fortuito. Conquer \u00b6 Nel passo conquer ordiniamo in maniera ricorsiva gli array array[l, q-1] (ovvero tutti gli elementi minori o uguali al pivot) ed array[q+1, r] (ovvero tutti gli elementi maggiori del pivot). Combine \u00b6 Come accennato in precedenza, il passo combine non fa effettivamente niente, dato che tutti gli elementi a sinistra del pivot saranno ordinati, e lo stesso varr\u00e0 per gli elementi a destra dello stesso. Partitioning \u00b6 Abbiamo visto che il \"lavoro\" vero e proprio dell'algoritmo di quick sort avviene durante lo step divide ; ricordiamo inoltre che \u00e8 opportuno scegliere come pivot l'elemento pi\u00f9 a destra nell'array sotto analisi. Dopo aver scelto il pivot, dividiamo il nostro array come segue. Per prima cosa, usiamo due indici, chiamati \\(q\\) e \\(j\\) , per dividere l'array in quattro gruppi. La variabile q sar\u00e0 quella che contiene il riferimento all'indice nel quale inseriremo il pivot; la variabile j invece sar\u00e0 usata come contatore. In particolare, avremo: un gruppo \\(L\\) , in cui saranno inseriti tutti gli elementi di array[l, q-1] (ovvero quelli minori o uguali al pivot); un gruppo \\(G\\) , in cui saranno inseriti tutti gli elementi di array[q+1, j-1] (ovvero quelli maggiori del pivot); un gruppo \\(U\\) , in cui saranno inseriti tutti gli elementi di array[j, r-1] (ovvero quelli la cui relazione con il pivot non \u00e8 conosciuta perch\u00e9 non ancora comparati). Il pivot \u00e8 contraddistinto con array[r] . All'inizio, sia q sia j sono uguali ad l . Ad ogni step, si compara array[j] , ovvero l'elemento pi\u00f9 a sinistra del gruppo \\(U\\) , con il pivot. Se array[j] \u00e8 maggiore del pivot, ci limitiamo ad incrementare il valore di j ; se invece array[j] \u00e8 inferiore al pivot, allora lo sostituiamo con array[q] , aumentando contestualmente j e q . Una volta arrivati al pivot, il gruppo \\(U\\) risulta essere vuoto. A quel punto, sostituiamo il pivot con l'elemento pi\u00f9 a sinistra del gruppo \\(G\\) , ovvero sostituendo array[r] con array[q] . Questo cambio mette il pivot sempre tra i gruppi \\(L\\) e \\(G\\) . Analisi computazionale \u00b6 Passo combine \u00b6 Verifichiamo che il costo legato allo step combine sia in \\(O(n)\\) . L'operazione di unione avviene in tre parti: nella prima, creiamo i due array left e right ; fino a che ci sono degli elementi non copiati da left o right in array , compariamo il primo elemento non ancora copiato di left a quello non ancora copiato di right , e copiamo il minore in array ; una volta che abbiamo copiato tutti gli elementi da left (o right ) in array , copiamo ogni elemento rimanente da right (o left ) in array . E' chiaro che, al massimo, dovremo effettuare n comparazioni ed n operazioni di copia. Ci\u00f2 significa che, al pi\u00f9, avremo \\(2 \\cdot n\\) operazioni, per cui la complessit\u00e0 sar\u00e0 in un \\(O(n)\\) . Analisi di caso peggiore \u00b6 Per effettuare l'analisi della complessit\u00e0 globale dell'algoritmo, consideriamo i tempi di esecuzione di ciascuno degli step coinvolti. Assumiamo, al solito, di stare ordinando un array ad \\(n\\) elementi. Nel passo divide , abbiamo bisogno di un tempo costante, ed indipendente dalla dimensione degli array coinvolti. Infatti, stiamo semplicemente calcolando il valore medio tra l ed r , per cui abbiamo bisogno di un'unica operazione. Nel passo conquer , ordiniamo ricorsivamente due sotto-array di approsimativamente \\(n/2\\) elementi. Nel passo combine , uniamo \\(n\\) elementi, ed abbiamo gi\u00e0 verificato avere bisogno di un \\(O(n)\\) . Considerando i passi divide e combine assieme, notiamo che il tempo necessario al divide \u00e8 trascurabile, per cui possiamo considerare solo quello per il combine . Resta da calcolare il tempo necessario al conquer . Per mantenere le cose semplici, consideriamo \\(n\\) pari e potenza di due (nel caso \\(n\\) sia dispari, il calcolo della complessit\u00e0 non cambia molto). Notiamo poi che l'esecuzione del merge sort su un array ad \\(n\\) elementi richieder\u00e0 (approssimativamente) lo stesso tempo dell'esecuzione di due merge sort su array ad \\(n/2\\) elementi, ciascuno dei quali richiede il doppio dell'esecuzione del merge sort su un array ad \\(n/4\\) elementi, e cos\u00ec via. Ricordando che il merge sort pu\u00f2 essere visto come un albero binario, \u00e8 evidente come ad ogni livello successivo dell'albero il numero di problemi raddoppi , mentre il tempo necessario alla risoluzione di un singolo problema si dimezzi . Questi due effetti si annullano reciprocamente, per cui potremo dire che, ad ogni livello, avremo bisogno al pi\u00f9 di \\(n\\) operazioni. Il tempo totale necessario \u00e8 quindi considerando un \\(O(n)\\) per ogni livello dell'albero prodotto dal merge sort. Con \\(c\\) livelli, avremo che il tempo totale necessario sar\u00e0 al pi\u00f9 \\(c \\cdot n\\) . Qual \u00e8 quindi il valore di \\(c\\) ? Dato che stiamo parlando di un albero binario, e che stiamo considerando un valore di \\(n\\) pari e potenza di due, sappiamo che \\(c = log_2n\\) . Di conseguenza, il tempo necessario per il merge sort sar\u00e0 dato da \\(n\\) (ovvero il numero di operazioni da effettuare a ciascun livello) moltiplicato per \\(c\\) (il numero di livelli), ovvero un \\(O(n \\cdot log_n2)\\) .","title":"14 - Algoritmi di ordinamento"},{"location":"material/05_algorithms/29_sorting/lecture/#14-algoritmi-di-ordinamento","text":"Uno dei problemi pi\u00f9 \"classici\" nello studio degli algoritmi \u00e8 quello di ordinare una lista di elementi affini (ovvero dello stesso tipo). Questo problema, soltanto apparentemnete banale, ha in realt\u00e0 numerosi riscontri pratici, in quanto capita molto spesso di dover ordinare una lista secondo un certo criterio (ad esempio, un elenco di nomi in ordine alfabetico, oppure i prezzi di diversi beni in ordine ascendente). Per far questo, nel tempo sono stati definiti diversi algoritmi detti di ordinamento o, in inglese, sorting algorithms . Vediamone alcuni tra i pi\u00f9 conosciuti.","title":"14 - Algoritmi di ordinamento"},{"location":"material/05_algorithms/29_sorting/lecture/#141-selection-sort","text":"Il primo algoritmo che vedremo \u00e8 chiamato selection sort . Questo \u00e8 un algoritmo di tipo iterativo , che analizza quindi un elemento della lista alla volta alla ricerca dell'elemento minore; per comprendere appieno il funzionamento dell'algoritmo, \u00e8 opportuno utilizzare un esempio concreto.","title":"14.1 - Selection sort"},{"location":"material/05_algorithms/29_sorting/lecture/#1411-esempio-e-formalizzazione","text":"Immaginiamo quindi di voler ordinare un mazzo di dieci carte dalla pi\u00f9 piccola alla pi\u00f9 grande. Per farlo, seguiamo questi passi: disponiamo tutte le carte presenti nel mazzo in un'unica fila; cerchiamo la carta pi\u00f9 piccola, e posizioniamola all'estrema sinistra del mazzo; dividiamo la fila in due parti: nella parte pi\u00f9 a sinistra inseriamo le carte gi\u00e0 ordinate, mentre in quella destra quelle da ordinare; prendiamo dalla fila di destra la carta pi\u00f9 piccola, posizionandola a destra dell'ultimo elemento della fila di sinistra; reiteriamo il passo 4 fino a che non vi sono pi\u00f9 carte nella fila di destra. Volendo, \u00e8 possibile formalizzare i passi precedenti come segue. Dato un vettore \\(x\\) fatto da \\(n\\) numeri interi: Associare ad \\(i\\) il primo indice dell'array, ovvero \\(i = 0\\) , ed a \\(j\\) l'ultimo, ovvero \\(j = n-1\\) . Associare alla variabile \\(m\\) il valore di \\(x(0)\\) , supponendo che \\(m\\) sia il valore pi\u00f9 piccolo attualmente presente all'interno dell'array. Confrontare \\(m\\) con tutti gli elementi \\(x(k), k \\in (0, n-1]\\) . Se \\(x(k) < m\\) per qualche \\(k\\) , allora \\(m = x(k)\\) . Aumentare il valore di \\(i\\) di un'unit\u00e0. Reiterare le istruzioni 3-4 fino a che \\(i = x(n-1)\\) .","title":"14.1.1 - Esempio e formalizzazione"},{"location":"material/05_algorithms/29_sorting/lecture/#1412-esempio-pratico","text":"Immaginiamo di avere un array di numeri interi, i cui elementi assumono valore [12, 4, 8, 7, 2] . Seguiamo i passi evidenziati in precedenza per l'algoritmo. Step 1 : imponiamo \\(i = 0, j = 4\\) . Step 2 : imponiamo \\(m = x(0) = 12\\) . Step 3 : dal confronto, emerge che \\(x(1) = 4 < m \\Rightarrow m = x(1)\\) . Continuando per\u00f2 ad incrementare \\(i\\) , notiamo che \\(x(4) = 2 < m \\Rightarrow m = x(4)\\) . Step 4 : poniamo \\(i = i + 1 = 2\\) . Step 5 : reiteriamo le istruzioni 3-4 fino a che \\(i = 4\\) , ottenendo l'array finale. In altre parole: START CICLO 0 x = [12, 4, 8, 7, 2]; i = 0; j = 4; min = x(0) = 12; CICLO 1 x = [2, 12, 4, 8, 7]; i = 1; j = 4; min = x(1) = 12; CICLO 2 x = [2, 4, 12, 8, 7]; i = 2; j = 4; min = x(2) = 12; CICLO 3 x = [2, 4, 7, 12, 8]; i = 3; j = 4; min = x(3) = 12; CICLO 4 x = [2, 4, 7, 8, 12]; i = 4; j = 4; min = x(4) = 12; STOP","title":"14.1.2 - Esempio pratico"},{"location":"material/05_algorithms/29_sorting/lecture/#1413-analisi-della-complessita-computazionale-dellalgoritmo","text":"L'algoritmo di selection sort cicla su tutti gli \\(n\\) indici di un array. Per comprendere quante operazioni sono necessarie a completare l'ordinamento, dovremo contare il numero di comparazioni necessarie ad individuare l'elemento \"minore\" attualmente presente all'interno dell'array. In particolare, alla prima iterazione (con \\(i = 0\\) ), avremo la necessit\u00e0 di effettuare \\(n\\) operazioni di comparazione, una per ogni elemento dell'array; alla seconda, con \\(i = 1\\) , dovremo fare \\(n - 1\\) confronti, alla terza \\(n - 2\\) , e cos\u00ec via. Ci\u00f2 implica che avremo bisogno di un numero di operazioni pari a: \\[ C_T = n + (n - 1) + \\ldots + 2 + 1 = \\frac{n^2}{2} + \\frac{n}{2} \\] La complessit\u00e0 di caso peggiore tiene conto del limite asintotico del valore precedente, ed \u00e8 chiaramente pari ad un \\(O(n^2)\\) .","title":"14.1.3 - Analisi della complessit\u00e0 computazionale dell'algoritmo"},{"location":"material/05_algorithms/29_sorting/lecture/#142-insertion-sort","text":"Il secondo algoritmo che vedremo \u00e8 l' insertion sort . Per introdurlo, partiamo dal un altro modo \u00e8 l\u2019insertion sort. Immaginiamo che stimao giocando un gioco di carte. Stiamo tenendo delle carte in mano, e tutte queste carte sono ordinate. Il dealer ci d\u00e0 esattamente una nuova carta. Si deve metterla nel posto corretto in modo che la carta cheabbiamo in mano siano ancora ordinate. Nel selection sort, ogni elemento che aggiungiamo all\u2019array ordinato non pu\u00f2 essere pi\u00f9 piccolo degli elementi gi\u00e0 presenti nell\u2019arry ordinato. Ma nel nostro esempio, la nuova carta pu\u00f2 essere pi\u00f9 piccola delle carte che abbiamo gi\u00e0 in mano, per cui dobbiamo andare gi\u00f9 nella linea, comparando le nuove card con ognuna delle carte in mano, fino a che non troviamo un posto epr inserirla. Inseriamo la nuova carta nel punto giusto, e nuovamente la nostra mano ha delle card completamente ordinate. Quindi il dealer ci da un\u2019altra carta, e si ripete la stesa procedura. Quindi un\u2019altra carta, e via dicendo, fino a che il dealer non ci d\u00e0 pi\u00f9 alcuna carta. Questa \u00e8 l\u2019idea dietro linsertion sort. Iterare nelle posizsioni dell\u2019array, a partire dall\u2019indice 1. COn ogni nuova posizione \u00e8 come la nuova carta che civieen data dal dealer, e dobbiamo inserirla nel psto corretto nel subarray ordinato a sinistra di quella posizione. Immaginiamo che il subarray dall\u2019indice 0 all\u2019indice 5 sia gi\u00e0 ordinato, e vogliamo inserire l\u2019ekemeto attuamlmente all\u2019indice 6 in questo subarray gi\u00e0 ordinato, in modo che il subarray dall\u2019indice 0 all\u2019indice 6 sia ordinato. 2 3 7 8 10 13 5 PER ARRIVARE A 2 3 5 7 9 10 13 Per inserire l\u2019eeento in posizione 6 nel subarray alla sua sinsitra, compariamo ripetutatmente questo con gli elementi alla sua sinistra, andando da destra verso sinistra. Chiamaiamo quindi l\u00ecelemento in posizione 6 chiave. ogni volta che capiamo che la chiave \u00e8 inferiroe di un elemento alla sua sinistra, lo spostiamo verso destra, dal momento che sappiamo che la chiave dovr\u00e0 andare alla sinistra di quell\u2019elemento. Dovremo fare altre due cose per far funzionare questa idea: dovremo avere un\u2019operazione slide (che sposta un elemento di una posizione a destra), e dovremo salvare il valore della chiave in un puno separato. Nel nostro esempio, : 1.- inseriamo l\u2019elemento all\u2019indice 6 in ua variabile chiamata key compariamo key con l\u2019elemento alla posizione 5. sappiamo che key \u00e8 inferiore all\u2019elemento in posizione 5, quindi faccioamo lo slide di questo alla posizione 6. Notiamo che l\u2019operazione di slide si limita a copiare l\u2019eemento una posizione a destra. Quindi, compariamo key con l\u2019elemento in posizione 4. troviamo che key \u00e8 inferiore, e reiteriamo la procedura. Quando l\u2019elemento\u00e8 inferiore di key, non effettuiamo l\u2019operazione di slide. Invece, lasciamo la variabile key in quella posizione, immediatamente all\u2019elemento a destra. Il risultato \u00e8 \u2018ordinamento di tutto l\u2019array. Il nome dell\u2019insertion sort deriva dal fatto che questo inserisce ripetutamente un elemento nel subarray a sinistra dell\u2019elemento che sta valutando. Di conseguenza, nel caso generale, si parte considerando sempre il primo elemento del subarray (o meglio un subarray di un elemento), che non pu\u00f2 non essere ordinato (\u00e8 ordinato rispetto a se stesso). La prima chiave sar\u00e0 quindi l\u2019elemento con indice 1. 10 7 3 13 7 10 3 13 A questo punto, il subarray ordinato va da 0 ad 1, quindi il nuovo key \u00e8 indice 2. compariamo questo con quelli a sinistra ed abbiamo: 7 10 3 13 7 3 10 13 3 7 10 13 Ci sono un paio di situazioni limite. Il primo \u00e8 quando l\u2019elemento chiave \u00e8 inferiore a tutti gli elementi nel subarray ordinato; il secondo \u00e8 qunado invece \u00e8 superiore. Nel primo, ogni elemento del subarray deve effettuare uno slide, nel secondo non ci sono slide da effettuare. pseudocdice chiamo insert per inserire l\u2019elemento cheinizia all\u2019indice 1 nell\u2019array ordinato all\u2019indice 0. chiamo insert per insierire l\u2019elemento che inizia all\u2019indice 2 nell\u2019array ordinato in un indice che va da 0 ad 1. \u2026 Chiamo insert per insserire l\u2019elemento che inizia all\u2019indice n-1 nell\u2019array ordinato nell\u2019indice che va da 0 ad n - 2. analisi come nel caso del selection sort, l\u2019insertion sort fa un loop sugli indici dell\u2019array. chiama semplicemente insert sugli elementi di indice che vanno da 1 ad n-1. Ogni chiamata ad insert richiede un certo periodo di tempo. Prendiamo una situazione nella quale chiamoiamo insrt ed il valore che viene inserito nel subarray \u00e8 inferiore ad ogni elemento nel sybarray. Quindi, ogni elemento nel subarray dovr\u00e0 effettuare lo slide di una posizione a sinistra. Per cui, in generale, se stiamo inserendo un nuovo elemento in un subarray con k elementi, tutti i k elementi dovranno effettuare uno slide di una posizione. Pitutosto che contare esattamente quante linee di codice dobbiamo usare, diciamo che questo numero \u00e8 c. Quindi, potremmo aver bisogno di c * k linee per inserire un valore in un subarray di k elementi. Supponiamo che ad ogni chiamata ad insert, il valore che venga inserito sia inferirore ad ogni elmento nel subarray alla sua sinsitra. Quando chiamiamo insert la prima vlta, con k = 1. La seconda volta, k = 2. La terza volta, k = 3. E via, fino all\u2019ultima volta, quando k = n -1. Quinid, il tempo totale speso ad inserire qualcosa nel sub array \u00e8 c * (1 + 2 + .. + n-1). Anche in questo caso abbiamo una serie aritmetica. Tornando alla notazione, O(n^2). Molto probabilmente, per\u00f2, l\u2019insertion sort potrebbe avere meno tempo necessario (ad esempio, questo accadrebbe nel caso avessimo un array gi\u00e0 ordinato). Per\u00f2 non \u00e8 detto, quindi \u00e8 necessario sempre e comunque considerare un tempo pari a O(n^2). Potremmo per\u00f2 considerare il caso migliroe, che avrebbe un O(n) (in questo caso l\u2019array \u00e8 gi\u00e0 quasi ordinato).","title":"14.2 - Insertion sort"},{"location":"material/05_algorithms/29_sorting/lecture/#143-quick-sort","text":"","title":"14.3 - Quick sort"},{"location":"material/05_algorithms/29_sorting/lecture/#descrizione-dellalgoritmo","text":"Cos\u00ec come il merge sort, il quick sort utilizza l'approccio divide-and-conquer , ed \u00e8 ovviamente un algoritmo di tipo ricorsivo. Tuttavia, laddove nel merge sort lo step divide \u00e8 praticamente ininfluente, ed \u00e8 il combine ad essere quello pi\u00f9 rilevante per il riordinamento, nel quick sort i ruoli si invertono. Ecco quindi come si articolano i tre diversi step del divide-and-conquer nel quick sort.","title":"Descrizione dell'algoritmo"},{"location":"material/05_algorithms/29_sorting/lecture/#divide-e-procedura-di-partitioning","text":"Nel passo divide , scegliamo un elemento dell'array array[l,r] chiamato elemento pivot . A questo punto, gli elementi presenti nell'array saranno disposti in modo che: tutti gli elementi minori o uguali del pivot siano alla sua sinistra ; tutti gli elementi strettamente maggiori del pivot siano alla sua destra . Questa procedura \u00e8 chiamata partitioning (partizionamento). Nota Non ci interessa l'ordine relativo degli elementi a sinistra o a destra del pivot. Nella pratica, vedremo come conviene scegliere come pivot sempre l'elemento pi\u00f9 a destra nell'array, ovvero array[r] . Ad esempio, con il nostro array [8, 4, 5, 12, 7] , il pivot ad essere scelto alla prima iterazione sar\u00e0 proprio il 7 . Dopo il partizionamento, l'array sar\u00e0 riscritto come [4, 5, 7, 8, 12] , ed indicheremo con q il nuovo indice del pivot (in questo caso, q = 2 ). Nota Il fatto che siamo riusciti a riordinare l'array in una sola mossa \u00e8 puramente fortuito.","title":"Divide e procedura di partitioning"},{"location":"material/05_algorithms/29_sorting/lecture/#conquer","text":"Nel passo conquer ordiniamo in maniera ricorsiva gli array array[l, q-1] (ovvero tutti gli elementi minori o uguali al pivot) ed array[q+1, r] (ovvero tutti gli elementi maggiori del pivot).","title":"Conquer"},{"location":"material/05_algorithms/29_sorting/lecture/#combine","text":"Come accennato in precedenza, il passo combine non fa effettivamente niente, dato che tutti gli elementi a sinistra del pivot saranno ordinati, e lo stesso varr\u00e0 per gli elementi a destra dello stesso.","title":"Combine"},{"location":"material/05_algorithms/29_sorting/lecture/#partitioning","text":"Abbiamo visto che il \"lavoro\" vero e proprio dell'algoritmo di quick sort avviene durante lo step divide ; ricordiamo inoltre che \u00e8 opportuno scegliere come pivot l'elemento pi\u00f9 a destra nell'array sotto analisi. Dopo aver scelto il pivot, dividiamo il nostro array come segue. Per prima cosa, usiamo due indici, chiamati \\(q\\) e \\(j\\) , per dividere l'array in quattro gruppi. La variabile q sar\u00e0 quella che contiene il riferimento all'indice nel quale inseriremo il pivot; la variabile j invece sar\u00e0 usata come contatore. In particolare, avremo: un gruppo \\(L\\) , in cui saranno inseriti tutti gli elementi di array[l, q-1] (ovvero quelli minori o uguali al pivot); un gruppo \\(G\\) , in cui saranno inseriti tutti gli elementi di array[q+1, j-1] (ovvero quelli maggiori del pivot); un gruppo \\(U\\) , in cui saranno inseriti tutti gli elementi di array[j, r-1] (ovvero quelli la cui relazione con il pivot non \u00e8 conosciuta perch\u00e9 non ancora comparati). Il pivot \u00e8 contraddistinto con array[r] . All'inizio, sia q sia j sono uguali ad l . Ad ogni step, si compara array[j] , ovvero l'elemento pi\u00f9 a sinistra del gruppo \\(U\\) , con il pivot. Se array[j] \u00e8 maggiore del pivot, ci limitiamo ad incrementare il valore di j ; se invece array[j] \u00e8 inferiore al pivot, allora lo sostituiamo con array[q] , aumentando contestualmente j e q . Una volta arrivati al pivot, il gruppo \\(U\\) risulta essere vuoto. A quel punto, sostituiamo il pivot con l'elemento pi\u00f9 a sinistra del gruppo \\(G\\) , ovvero sostituendo array[r] con array[q] . Questo cambio mette il pivot sempre tra i gruppi \\(L\\) e \\(G\\) .","title":"Partitioning"},{"location":"material/05_algorithms/29_sorting/lecture/#analisi-computazionale","text":"","title":"Analisi computazionale"},{"location":"material/05_algorithms/29_sorting/lecture/#passo-combine","text":"Verifichiamo che il costo legato allo step combine sia in \\(O(n)\\) . L'operazione di unione avviene in tre parti: nella prima, creiamo i due array left e right ; fino a che ci sono degli elementi non copiati da left o right in array , compariamo il primo elemento non ancora copiato di left a quello non ancora copiato di right , e copiamo il minore in array ; una volta che abbiamo copiato tutti gli elementi da left (o right ) in array , copiamo ogni elemento rimanente da right (o left ) in array . E' chiaro che, al massimo, dovremo effettuare n comparazioni ed n operazioni di copia. Ci\u00f2 significa che, al pi\u00f9, avremo \\(2 \\cdot n\\) operazioni, per cui la complessit\u00e0 sar\u00e0 in un \\(O(n)\\) .","title":"Passo combine"},{"location":"material/05_algorithms/29_sorting/lecture/#analisi-di-caso-peggiore","text":"Per effettuare l'analisi della complessit\u00e0 globale dell'algoritmo, consideriamo i tempi di esecuzione di ciascuno degli step coinvolti. Assumiamo, al solito, di stare ordinando un array ad \\(n\\) elementi. Nel passo divide , abbiamo bisogno di un tempo costante, ed indipendente dalla dimensione degli array coinvolti. Infatti, stiamo semplicemente calcolando il valore medio tra l ed r , per cui abbiamo bisogno di un'unica operazione. Nel passo conquer , ordiniamo ricorsivamente due sotto-array di approsimativamente \\(n/2\\) elementi. Nel passo combine , uniamo \\(n\\) elementi, ed abbiamo gi\u00e0 verificato avere bisogno di un \\(O(n)\\) . Considerando i passi divide e combine assieme, notiamo che il tempo necessario al divide \u00e8 trascurabile, per cui possiamo considerare solo quello per il combine . Resta da calcolare il tempo necessario al conquer . Per mantenere le cose semplici, consideriamo \\(n\\) pari e potenza di due (nel caso \\(n\\) sia dispari, il calcolo della complessit\u00e0 non cambia molto). Notiamo poi che l'esecuzione del merge sort su un array ad \\(n\\) elementi richieder\u00e0 (approssimativamente) lo stesso tempo dell'esecuzione di due merge sort su array ad \\(n/2\\) elementi, ciascuno dei quali richiede il doppio dell'esecuzione del merge sort su un array ad \\(n/4\\) elementi, e cos\u00ec via. Ricordando che il merge sort pu\u00f2 essere visto come un albero binario, \u00e8 evidente come ad ogni livello successivo dell'albero il numero di problemi raddoppi , mentre il tempo necessario alla risoluzione di un singolo problema si dimezzi . Questi due effetti si annullano reciprocamente, per cui potremo dire che, ad ogni livello, avremo bisogno al pi\u00f9 di \\(n\\) operazioni. Il tempo totale necessario \u00e8 quindi considerando un \\(O(n)\\) per ogni livello dell'albero prodotto dal merge sort. Con \\(c\\) livelli, avremo che il tempo totale necessario sar\u00e0 al pi\u00f9 \\(c \\cdot n\\) . Qual \u00e8 quindi il valore di \\(c\\) ? Dato che stiamo parlando di un albero binario, e che stiamo considerando un valore di \\(n\\) pari e potenza di due, sappiamo che \\(c = log_2n\\) . Di conseguenza, il tempo necessario per il merge sort sar\u00e0 dato da \\(n\\) (ovvero il numero di operazioni da effettuare a ciascun livello) moltiplicato per \\(c\\) (il numero di livelli), ovvero un \\(O(n \\cdot log_n2)\\) .","title":"Analisi di caso peggiore"},{"location":"material/05_algorithms/30_searching/lecture/","text":"15 - Algoritmi di ricerca \u00b6 Vediamo in ultimo gli algoritmi di ricerca. 15.1 - Ricerca binaria \u00b6 Introduzione al problema \u00b6 Supponiamo di voler trovare un determinato elemento all'interno di una lista di valori, come ad esempio il numero di un nostro contatto all'interno della nostra rubrica (ovviamente, supponiamo di non voler utilizzare la funzionalit\u00e0 di ricerca integrata nella rubrica stessa). Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica. Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare ( linear search ). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto? Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2 , che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice. Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search . Definizione del problema Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata . Descrizione dell'algoritmo \u00b6 L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli . Facciamo un rapido esempio per capire al meglio di cosa si tratta. Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento . Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore . Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra. La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false , ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore . Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta. La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore . Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0. Il gioco prosegue come segue. ROUND 3 -------------------------------- ALICE -> 62 --- BOB -> INFERIORE -------------------------------- ROUND 4 -------------------------------- ALICE -> 56 --- BOB -> SUPERIORE -------------------------------- ROUND 5 -------------------------------- ALICE -> 59 --- BOB -> SUPERIORE -------------------------------- ROUND 6 (BOB IMPALLIDISCE) -------------------------------- ALICE -> 61 --- BOB -> INFERIORE -------------------------------- ROUND 7 (BOB TREMANTE...) -------------------------------- ALICE -> 60 --- BOB -> PAGARE In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato. Fase di progettazione. \u00b6 Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc. Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice , e poi definirne il flow chart. TODO: da qui Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole. Ecco un'implementazione step-by-step: sia min = 1 e max = n troviamo il valore medio tra min e max, arrotondato ad un intero se abbiamo trovato il numero, fermiamoci. altrimenti se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1 se l'ipotesi era troppo altra, impostiamo max a n/2 - 1 torniamo al passo 2 TODO: flow chart \u00b6 Complessit\u00e0 computazionale \u00b6 Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi. Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica. L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta. Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni. Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni. Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\) . Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\) . Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\) , fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22. Nota I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22. Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente. 15.2 - Ricerca in ampiezza \u00b6 Descrizione dell'algoritmo \u00b6 La ricerca in ampiezza , o, in inglese, breath-first search ( BFS ), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi. Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\) , oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi. Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda . Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi. BFS sugli alberi \u00b6 Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero. La BFS opera considerando due parametri: il nodo attualmente ispezionato; i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato. In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i il nodo radice , ovvero quello da cui parte la ricerca; la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice; il predecessore del nodo Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore \u00e8 la distanza , che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\) . Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8. Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\) , la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste. TODO: esempio vertice isolato Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\) . TODO: ESEMPIO SU ALBERO Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null. L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda. In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue(). TODO: esempio su albero Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\) . In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\) . Analisi della BFS \u00b6 Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\) ? La risposta \u00e8 un tempo pari a \\(O(V + E)\\) . Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\) , che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi: \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\) , allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\) . Se, per\u00f2, abbiamo \\(|E| < |V|\\) , allora: \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\) . Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\) . In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\) , \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\) . Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\) ? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a null , per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.","title":"15 - Algoritmi di ricerca"},{"location":"material/05_algorithms/30_searching/lecture/#15-algoritmi-di-ricerca","text":"Vediamo in ultimo gli algoritmi di ricerca.","title":"15 - Algoritmi di ricerca"},{"location":"material/05_algorithms/30_searching/lecture/#151-ricerca-binaria","text":"","title":"15.1 - Ricerca binaria"},{"location":"material/05_algorithms/30_searching/lecture/#introduzione-al-problema","text":"Supponiamo di voler trovare un determinato elemento all'interno di una lista di valori, come ad esempio il numero di un nostro contatto all'interno della nostra rubrica (ovviamente, supponiamo di non voler utilizzare la funzionalit\u00e0 di ricerca integrata nella rubrica stessa). Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica. Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare ( linear search ). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto? Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2 , che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice. Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search . Definizione del problema Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata .","title":"Introduzione al problema"},{"location":"material/05_algorithms/30_searching/lecture/#descrizione-dellalgoritmo","text":"L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli . Facciamo un rapido esempio per capire al meglio di cosa si tratta. Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento . Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore . Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra. La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false , ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore . Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta. La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore . Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0. Il gioco prosegue come segue. ROUND 3 -------------------------------- ALICE -> 62 --- BOB -> INFERIORE -------------------------------- ROUND 4 -------------------------------- ALICE -> 56 --- BOB -> SUPERIORE -------------------------------- ROUND 5 -------------------------------- ALICE -> 59 --- BOB -> SUPERIORE -------------------------------- ROUND 6 (BOB IMPALLIDISCE) -------------------------------- ALICE -> 61 --- BOB -> INFERIORE -------------------------------- ROUND 7 (BOB TREMANTE...) -------------------------------- ALICE -> 60 --- BOB -> PAGARE In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato.","title":"Descrizione dell'algoritmo"},{"location":"material/05_algorithms/30_searching/lecture/#fase-di-progettazione","text":"Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc. Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice , e poi definirne il flow chart. TODO: da qui Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole. Ecco un'implementazione step-by-step: sia min = 1 e max = n troviamo il valore medio tra min e max, arrotondato ad un intero se abbiamo trovato il numero, fermiamoci. altrimenti se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1 se l'ipotesi era troppo altra, impostiamo max a n/2 - 1 torniamo al passo 2","title":"Fase di progettazione."},{"location":"material/05_algorithms/30_searching/lecture/#todo-flow-chart","text":"","title":"TODO: flow chart"},{"location":"material/05_algorithms/30_searching/lecture/#complessita-computazionale","text":"Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi. Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica. L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta. Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni. Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni. Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\) . Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\) . Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\) , fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22. Nota I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22. Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente.","title":"Complessit\u00e0 computazionale"},{"location":"material/05_algorithms/30_searching/lecture/#152-ricerca-in-ampiezza","text":"","title":"15.2 - Ricerca in ampiezza"},{"location":"material/05_algorithms/30_searching/lecture/#descrizione-dellalgoritmo_1","text":"La ricerca in ampiezza , o, in inglese, breath-first search ( BFS ), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi. Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\) , oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi. Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda . Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi.","title":"Descrizione dell'algoritmo"},{"location":"material/05_algorithms/30_searching/lecture/#bfs-sugli-alberi","text":"Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero. La BFS opera considerando due parametri: il nodo attualmente ispezionato; i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato. In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i il nodo radice , ovvero quello da cui parte la ricerca; la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice; il predecessore del nodo Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore \u00e8 la distanza , che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\) . Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8. Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\) , la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste. TODO: esempio vertice isolato Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\) . TODO: ESEMPIO SU ALBERO Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null. L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda. In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue(). TODO: esempio su albero Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\) . In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\) .","title":"BFS sugli alberi"},{"location":"material/05_algorithms/30_searching/lecture/#analisi-della-bfs","text":"Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\) ? La risposta \u00e8 un tempo pari a \\(O(V + E)\\) . Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\) , che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi: \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\) , allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\) . Se, per\u00f2, abbiamo \\(|E| < |V|\\) , allora: \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\) . Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\) . In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\) , \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\) . Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\) ? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a null , per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.","title":"Analisi della BFS"},{"location":"material/appendix/01_vs_comm/guide/","text":"Appendice A - Installazione di Visual Studio Community \u00b6 Andare al seguente indirizzo , e selezionare l'opzione Scarica Visual Studio . Si aprir\u00e0 un'altra pagina, e verr\u00e0 scaricato un file chiamato VisualStudioSetup.exe (o similari nel caso di installazione via MacOS). Lanciarlo per avviare il programma di installazione. Confermare la procedura di installazione di Visual Studio Installer . Una volta terminato il download dei file necessari, apparir\u00e0 la schermata di Visual Studio Installer . Selezionare la versione Community, ed attendere il termine della procedura di installazione. Selezionare Modifica . Si aprir\u00e0 l'interfaccia mostrata in figura. Selezioniamo la casella di spunta a destra di Sviluppo di applicazioni desktop con C++ , premiamo il pulsante Modifica in basso a destra, ed attendiamo il termine dell'installazione.","title":"A - Installazione di VS Community"},{"location":"material/appendix/01_vs_comm/guide/#appendice-a-installazione-di-visual-studio-community","text":"Andare al seguente indirizzo , e selezionare l'opzione Scarica Visual Studio . Si aprir\u00e0 un'altra pagina, e verr\u00e0 scaricato un file chiamato VisualStudioSetup.exe (o similari nel caso di installazione via MacOS). Lanciarlo per avviare il programma di installazione. Confermare la procedura di installazione di Visual Studio Installer . Una volta terminato il download dei file necessari, apparir\u00e0 la schermata di Visual Studio Installer . Selezionare la versione Community, ed attendere il termine della procedura di installazione. Selezionare Modifica . Si aprir\u00e0 l'interfaccia mostrata in figura. Selezioniamo la casella di spunta a destra di Sviluppo di applicazioni desktop con C++ , premiamo il pulsante Modifica in basso a destra, ed attendiamo il termine dell'installazione.","title":"Appendice A - Installazione di Visual Studio Community"},{"location":"material/appendix/02_python_vs_code/guide/","text":"Appendice B - Configurazione dell'ambiente di sviluppo Python \u00b6 Installazione di Python \u00b6 Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Iniziare la procedura di installazione (ad esempio, in Windows, cliccando sull'eseguibile appena scaricato). E' fortemente consigliato aggiungere Python al proprio PATH spuntando l'opportuna casella durante l'installazione , come mostrato in figura. Una volta completata la procedura di installazione, aprire uno shell (ad esempio, il prompt dei comandi), e digitare python . Se tutto \u00e8 andato per il verso giusto, apparir\u00e0 una schermata simile alla successiva. Installazione di Visual Studio Code \u00b6 Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Seguire la procedura di installazione mostrata a schermo. E' anche in questo caso consigliata l'aggiunta di Visual Studio Code al path, come mostrato in figura.","title":"B - Installazione di Python e VS Code"},{"location":"material/appendix/02_python_vs_code/guide/#appendice-b-configurazione-dellambiente-di-sviluppo-python","text":"","title":"Appendice B - Configurazione dell'ambiente di sviluppo Python"},{"location":"material/appendix/02_python_vs_code/guide/#installazione-di-python","text":"Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Iniziare la procedura di installazione (ad esempio, in Windows, cliccando sull'eseguibile appena scaricato). E' fortemente consigliato aggiungere Python al proprio PATH spuntando l'opportuna casella durante l'installazione , come mostrato in figura. Una volta completata la procedura di installazione, aprire uno shell (ad esempio, il prompt dei comandi), e digitare python . Se tutto \u00e8 andato per il verso giusto, apparir\u00e0 una schermata simile alla successiva.","title":"Installazione di Python"},{"location":"material/appendix/02_python_vs_code/guide/#installazione-di-visual-studio-code","text":"Andare al seguente indirizzo , e selezionare la versione adatta al proprio sistema operativo. Seguire la procedura di installazione mostrata a schermo. E' anche in questo caso consigliata l'aggiunta di Visual Studio Code al path, come mostrato in figura.","title":"Installazione di Visual Studio Code"},{"location":"material/appendix/03_oop/lecture/","text":"Appendice C - Principi di Programmazione Orientata agli Oggetti \u00b6 La programmazione orientata agli oggetti (in inglese object-oriented programming , OOP ) \u00e8 un paradigma di programmazione che sposta il focus dalle funzioni ai dati . In particolare, la OOP prevede che tutto sia un oggetto : una qualsiasi variabile \u00e8 interpretata come un oggetto, cos\u00ec come anche le funzioni stesse (in alcuni linguaggi). Ci\u00f2 si estende ovviamente anche ai tipi definiti dall'utente, che assumono il nome di classi . Facciamo un esempio. La classe Persona \u00b6 Immaginiamo di voler definire una struttura dati che contenga al suo interno le informazioni necessarie a definire una persona, come nome, cognome, genere ed et\u00e0. Per farlo, ovviamente, dovremo \"unire\" tra di loro diversi dati primitivi: potremo usare una stringa per il nome, una per il cognome, una per il genere e, infine, un intero per l'et\u00e0. In tal senso, possiamo creare quindi la classe Persona , che avr\u00e0 quattro attributi , come mostrato in figura. Sottolineamo come una classe rappresenti tutte le possibili persone : infatti, si cerca di creare delle strutture dati generiche , che abbiano degli attributi comuni a tutte le possibili istanze . Nel nostro caso, sappiamo che ogni persona ha un nome, un cognome, un genere ed un'et\u00e0, quindi usiamo questi quattro valori come attributi di classe. Differenza tra classe ed istanza Abbiamo detto che una classe rappresenta tutte le possibili istanze della stessa. Ci\u00f2 si traduce, nel nostro esempio, nel fatto che la classe Persona \u00e8 in grado di rappresentare tutte le persone, e un'istanza della classe Persona \u00e8 una singola variabile, o oggetto, che rappresenta una certa persona. Per capirci: un'istanza di Persona \u00e8 \"Angelo, Cardellicchio, Uomo, 37\", mentre un'altra istanza \u00e8 data da \"Frank, Hood, Uomo, 42\", un'altra ancora da \"Camilla, Lilla, Donna, 55\", e cos\u00ec via. Ovviamente, potremo in qualche modo agire con degli opportuni metodi su questi attributi. Ad esempio, se avessimo a disposizione anche il luogo e la data di nascita, potremmo creare un metodo calcola_cf che, per l'appunto, permette di generare il codice fiscale di una singola istanza. Oltre al concetto di classe, tuttavia, la OOP definisce altri tre concetti base. Vediamoli di seguito. Concetto 1: Ereditariet\u00e0 \u00b6 Per ereditariet\u00e0 si intende la capacit\u00e0 di una classe di \"discendere\" da un'altra. Non dobbiamo, per\u00f2, pensare al nostro albero genealogico: infatti, noi abbiamo parte delle caratteristiche di ciascuno dei nostri genitori, mentre una classe figlia eredita in toto le caratteristiche di una classe madre. Ad esempio, potremmo definire la classe Studente come figlia della classe Persona , cui aggiunger\u00e0 i seguenti attributi: Possiamo visualizzare questa relazione in ordine gerarchico come segue: Da notare che la classe Studente pu\u00f2 aggiungere anche dei metodi, oltre che degli attributi a quelli offerti da Persona , come ad esempio genera_media_voto . In ultimo, notiamo come ogni istanza di Studente \u00e8 un'istanza di Persona , ma non \u00e8 vero il contrario , e quindi non tutte le persone sono degli studenti. Per aiutarci a comprendere questo concetto, possiamo visualizzare gli insiemi delle istanze di Persona e di Studente : Generalizzazione e specializzazione La relazione di ereditariet\u00e0 pu\u00f2 anche essere vista in termini di generalizzazione e specializzazione . In questo contesto, la classe Studente \u00e8 una specializzazione di Persona , in quanto sottende ad un insieme pi\u00f9 specifico; al contrario, le persone sono viste come una generalizzazione degli studenti. Ereditariet\u00e0 multipla e multilivello Alcuni linguaggi, compreso Python, offrono la possibilit\u00e0 di ereditare da pi\u00f9 classi; tale concetto \u00e8 chiamato ereditariet\u00e0 multipla . Se invece stabiliamo una vera e propria gerarchia di classi, con una classe \"nonna\", una \"madre\" ed una \"figlia\", avremo una struttura multilivello . Concetto 2: Incapsulamento \u00b6 Il concetto di incapsulamento prevede che sia possibile accedere ad un metodo (o anche ad un attributo) di una classe esclusivamente mediante la sua interfaccia verso il mondo esterno . Vediamo cosa significa. Immaginiamo di voler calcolare il codice fiscale di una persona: dovremo seguire una procedura ben precisa e moderatamente complessa, che potremo tranquillamente \"nascondere\" al codice che usa la classe Persona , il quale dovr\u00e0 semplicemente invocare il metodo calcola_cf . Tuttavia, se volessimo seguire il principio di modularit\u00e0, che ci suggerisce di \"suddividere\" funzioni complesse in maniera tale da renderle pi\u00f9 semplici, dovremmo creare altre funzioni ausiliarie, che potrebbero calcolare la rappresentazione di nome e cognome ( calcola_nc ) e i dati alfanumerici derivanti da luogo e data di nascita ( calcola_ld ). Ovviamente, non vi \u00e8 il bisogno di accedere dall'esterno della classe a questi metodi, in quanto hanno valenza esclusiva nell'ambito del calcolo del codice fiscale: per questo motivo, li si potr\u00e0 dichiarare come privati , e potranno essere acceduti soltanto dall'interno della classe . In questo modo, la classe mantiene un'interfaccia stabile ed essenziale verso l'esterno: il codice che usa la classe avr\u00e0 sempre un punto di accesso ben definito e, nel caso si debbano modificare dei comportamenti interni alla classe, non sar\u00e0 influenzato da dette modifiche. Ad esempio, infatti, se per qualche motivo si decidesse di cambiare l'ordine con cui si mostrano nel codice fiscale la rappresentazione del cognome e del nome, basterebbe modificare il metodo calcola_nome_cognome_codice_fiscale , ed il resto dell'implementazione (sia della classe, sia del codice chiamante) non ne sarebbe influenzata. Concetto 3: Polimorfismo \u00b6 Il concetto di polimorfismo prevede che sia possibile modificare il comportamento associato ad un metodo a seconda della classe che lo utilizza. Immaginiamo ad esempio di specializzare la classe Studente in due ulteriori rappresentazioni, ovvero StudenteUniversitario e StudenteScolastico . Ovviamente, il metodo genera_media_voto sar\u00e0 ereditato da entrambe le classi; tuttavia, l'implementazione dovr\u00e0 essere necessariamente differente, in quanto la media di laurea \u00e8 pesata in modo diverso rispetto alla classica media aritmetica usata nelle scuole fino alla secondaria. Il polimorfismo ci permette di raggiungere questo obiettivo: potremo effettuare una procedura di override del metodo genera_media_voto che, pur conservando la stessa firma, avr\u00e0 differenti implementazioni nelle classi StudenteUniversitario e StudenteScolastico . Ovviamente, il fatto che il metodo conservi la stessa firma rappresenta un vantaggio paragonabile a quello ottenuto mediante il polimorfismo: infatti, un programmatore potr\u00e0 usare il metodo genera_media_voto alla stessa maniera per uno studente universitario ed uno di scuola media secondaria, senza per questo dover tenere a mente due diverse interfacce.","title":"C - Programmazione orientata agli oggetti"},{"location":"material/appendix/03_oop/lecture/#appendice-c-principi-di-programmazione-orientata-agli-oggetti","text":"La programmazione orientata agli oggetti (in inglese object-oriented programming , OOP ) \u00e8 un paradigma di programmazione che sposta il focus dalle funzioni ai dati . In particolare, la OOP prevede che tutto sia un oggetto : una qualsiasi variabile \u00e8 interpretata come un oggetto, cos\u00ec come anche le funzioni stesse (in alcuni linguaggi). Ci\u00f2 si estende ovviamente anche ai tipi definiti dall'utente, che assumono il nome di classi . Facciamo un esempio.","title":"Appendice C - Principi di Programmazione Orientata agli Oggetti"},{"location":"material/appendix/03_oop/lecture/#la-classe-persona","text":"Immaginiamo di voler definire una struttura dati che contenga al suo interno le informazioni necessarie a definire una persona, come nome, cognome, genere ed et\u00e0. Per farlo, ovviamente, dovremo \"unire\" tra di loro diversi dati primitivi: potremo usare una stringa per il nome, una per il cognome, una per il genere e, infine, un intero per l'et\u00e0. In tal senso, possiamo creare quindi la classe Persona , che avr\u00e0 quattro attributi , come mostrato in figura. Sottolineamo come una classe rappresenti tutte le possibili persone : infatti, si cerca di creare delle strutture dati generiche , che abbiano degli attributi comuni a tutte le possibili istanze . Nel nostro caso, sappiamo che ogni persona ha un nome, un cognome, un genere ed un'et\u00e0, quindi usiamo questi quattro valori come attributi di classe. Differenza tra classe ed istanza Abbiamo detto che una classe rappresenta tutte le possibili istanze della stessa. Ci\u00f2 si traduce, nel nostro esempio, nel fatto che la classe Persona \u00e8 in grado di rappresentare tutte le persone, e un'istanza della classe Persona \u00e8 una singola variabile, o oggetto, che rappresenta una certa persona. Per capirci: un'istanza di Persona \u00e8 \"Angelo, Cardellicchio, Uomo, 37\", mentre un'altra istanza \u00e8 data da \"Frank, Hood, Uomo, 42\", un'altra ancora da \"Camilla, Lilla, Donna, 55\", e cos\u00ec via. Ovviamente, potremo in qualche modo agire con degli opportuni metodi su questi attributi. Ad esempio, se avessimo a disposizione anche il luogo e la data di nascita, potremmo creare un metodo calcola_cf che, per l'appunto, permette di generare il codice fiscale di una singola istanza. Oltre al concetto di classe, tuttavia, la OOP definisce altri tre concetti base. Vediamoli di seguito.","title":"La classe Persona"},{"location":"material/appendix/03_oop/lecture/#concetto-1-ereditarieta","text":"Per ereditariet\u00e0 si intende la capacit\u00e0 di una classe di \"discendere\" da un'altra. Non dobbiamo, per\u00f2, pensare al nostro albero genealogico: infatti, noi abbiamo parte delle caratteristiche di ciascuno dei nostri genitori, mentre una classe figlia eredita in toto le caratteristiche di una classe madre. Ad esempio, potremmo definire la classe Studente come figlia della classe Persona , cui aggiunger\u00e0 i seguenti attributi: Possiamo visualizzare questa relazione in ordine gerarchico come segue: Da notare che la classe Studente pu\u00f2 aggiungere anche dei metodi, oltre che degli attributi a quelli offerti da Persona , come ad esempio genera_media_voto . In ultimo, notiamo come ogni istanza di Studente \u00e8 un'istanza di Persona , ma non \u00e8 vero il contrario , e quindi non tutte le persone sono degli studenti. Per aiutarci a comprendere questo concetto, possiamo visualizzare gli insiemi delle istanze di Persona e di Studente : Generalizzazione e specializzazione La relazione di ereditariet\u00e0 pu\u00f2 anche essere vista in termini di generalizzazione e specializzazione . In questo contesto, la classe Studente \u00e8 una specializzazione di Persona , in quanto sottende ad un insieme pi\u00f9 specifico; al contrario, le persone sono viste come una generalizzazione degli studenti. Ereditariet\u00e0 multipla e multilivello Alcuni linguaggi, compreso Python, offrono la possibilit\u00e0 di ereditare da pi\u00f9 classi; tale concetto \u00e8 chiamato ereditariet\u00e0 multipla . Se invece stabiliamo una vera e propria gerarchia di classi, con una classe \"nonna\", una \"madre\" ed una \"figlia\", avremo una struttura multilivello .","title":"Concetto 1: Ereditariet\u00e0"},{"location":"material/appendix/03_oop/lecture/#concetto-2-incapsulamento","text":"Il concetto di incapsulamento prevede che sia possibile accedere ad un metodo (o anche ad un attributo) di una classe esclusivamente mediante la sua interfaccia verso il mondo esterno . Vediamo cosa significa. Immaginiamo di voler calcolare il codice fiscale di una persona: dovremo seguire una procedura ben precisa e moderatamente complessa, che potremo tranquillamente \"nascondere\" al codice che usa la classe Persona , il quale dovr\u00e0 semplicemente invocare il metodo calcola_cf . Tuttavia, se volessimo seguire il principio di modularit\u00e0, che ci suggerisce di \"suddividere\" funzioni complesse in maniera tale da renderle pi\u00f9 semplici, dovremmo creare altre funzioni ausiliarie, che potrebbero calcolare la rappresentazione di nome e cognome ( calcola_nc ) e i dati alfanumerici derivanti da luogo e data di nascita ( calcola_ld ). Ovviamente, non vi \u00e8 il bisogno di accedere dall'esterno della classe a questi metodi, in quanto hanno valenza esclusiva nell'ambito del calcolo del codice fiscale: per questo motivo, li si potr\u00e0 dichiarare come privati , e potranno essere acceduti soltanto dall'interno della classe . In questo modo, la classe mantiene un'interfaccia stabile ed essenziale verso l'esterno: il codice che usa la classe avr\u00e0 sempre un punto di accesso ben definito e, nel caso si debbano modificare dei comportamenti interni alla classe, non sar\u00e0 influenzato da dette modifiche. Ad esempio, infatti, se per qualche motivo si decidesse di cambiare l'ordine con cui si mostrano nel codice fiscale la rappresentazione del cognome e del nome, basterebbe modificare il metodo calcola_nome_cognome_codice_fiscale , ed il resto dell'implementazione (sia della classe, sia del codice chiamante) non ne sarebbe influenzata.","title":"Concetto 2: Incapsulamento"},{"location":"material/appendix/03_oop/lecture/#concetto-3-polimorfismo","text":"Il concetto di polimorfismo prevede che sia possibile modificare il comportamento associato ad un metodo a seconda della classe che lo utilizza. Immaginiamo ad esempio di specializzare la classe Studente in due ulteriori rappresentazioni, ovvero StudenteUniversitario e StudenteScolastico . Ovviamente, il metodo genera_media_voto sar\u00e0 ereditato da entrambe le classi; tuttavia, l'implementazione dovr\u00e0 essere necessariamente differente, in quanto la media di laurea \u00e8 pesata in modo diverso rispetto alla classica media aritmetica usata nelle scuole fino alla secondaria. Il polimorfismo ci permette di raggiungere questo obiettivo: potremo effettuare una procedura di override del metodo genera_media_voto che, pur conservando la stessa firma, avr\u00e0 differenti implementazioni nelle classi StudenteUniversitario e StudenteScolastico . Ovviamente, il fatto che il metodo conservi la stessa firma rappresenta un vantaggio paragonabile a quello ottenuto mediante il polimorfismo: infatti, un programmatore potr\u00e0 usare il metodo genera_media_voto alla stessa maniera per uno studente universitario ed uno di scuola media secondaria, senza per questo dover tenere a mente due diverse interfacce.","title":"Concetto 3: Polimorfismo"},{"location":"material/slides/","text":"Slides proiettate a lezione \u00b6 Argomento Link 1 - Introduzione all'informatica 2 - Introduzione agli algoritmi 3 - Rappresentazione binaria e decimale 4 - Tipi di dato 5 - Diagrammi di flusso 6 - Programmazione strutturata 7 - Complessit\u00e0 computazionale 8 - Variabili 9 - Funzioni 10 - Strutture dati 11 - Ricorsione 13 - Strutture dati avanzate 14 - Introduzione al C 15 - Nozioni fondamentali sul C 16 - Ambito di una variabile 17 - Operatori in C 18 - Array in C 19 - Puntatori 20 - Gestione della memoria 21 - I/O e file 22 - Typedef, struct ed union 23 - Introduzione al Python 24 - Concetti sintattici fondamentali di Python 25 - Strutture dati in Python 26 - OOP in Python Appendice C - Principi di OOP","title":"Slides proiettate a lezione"},{"location":"material/slides/#slides-proiettate-a-lezione","text":"Argomento Link 1 - Introduzione all'informatica 2 - Introduzione agli algoritmi 3 - Rappresentazione binaria e decimale 4 - Tipi di dato 5 - Diagrammi di flusso 6 - Programmazione strutturata 7 - Complessit\u00e0 computazionale 8 - Variabili 9 - Funzioni 10 - Strutture dati 11 - Ricorsione 13 - Strutture dati avanzate 14 - Introduzione al C 15 - Nozioni fondamentali sul C 16 - Ambito di una variabile 17 - Operatori in C 18 - Array in C 19 - Puntatori 20 - Gestione della memoria 21 - I/O e file 22 - Typedef, struct ed union 23 - Introduzione al Python 24 - Concetti sintattici fondamentali di Python 25 - Strutture dati in Python 26 - OOP in Python Appendice C - Principi di OOP","title":"Slides proiettate a lezione"}]}