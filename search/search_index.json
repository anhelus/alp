{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Corso di Informatica","text":"<p>Benvenuti!</p> <p>Negli anni passati, questo sito \u00e8 stato utilizzato per mettere a disposizione degli studenti del materiale per studiare i Corsi di Informatica da me tenuti nelle diverse Istituzioni Universitarie che hanno avuto l'ardire di ospitarmi come docente.</p> <p>Nonostante ci siano alcune Universit\u00e0 che tutt'ora persistono nell'errore, credo sia importante \"astrarre\" la (pseudo) conoscenza contenuta in questo sito dallo specifico Corso Universitario di riferimento, e renderla disponibile alle masse di entusiasti esploratori dell'ignoto (?).</p> <p>In altre parole, il mio obiettivo \u00e8 quello di andare a raccogliere e contestualizzare il materiale prodotto (e, per mia colpa, \"sparso\"), dandogli un tentativo di filo conduttore, di modo da rendere l'esperienza quanto pi\u00f9 piacevole e scorrevole, per quanto questo possa essere \"possibile\" nel contesto di quello che, in fin dei conti, \u00e8 un corso di Informatica.</p> <p>Cosa significa questo per l'ignaro studente? In pratica, due cose:</p> <ol> <li>Il materiale contenuto in questo sito non \u00e8 strettamente rappresentativo del materiale dell'esame a cui lo studente fa riferimento. In pratica, se (per esempio) siamo studenti del Corso di Informatica dell'Ingegneria, vedremo qui e l\u00ec riferimenti ad argomenti non trattati durante il corso, e che non saranno quindi oggetto di esame.</li> <li>Il materiale contenuto in questo sito \u00e8 un approfondimento degli argomenti trattati durante il corso, quindi studiarlo non pu\u00f2 far altro che aumentare le possibilit\u00e0 di prendere un voto molto alto.</li> </ol> <p>Fatta questa doverosa premessa, che invito i malcapitati studenti a leggere e comprendere, non mi resta che augurarvi buona lettura, andando ad introdurre il concetto di Informatica.</p>"},{"location":"material/01_intro/01_intro_inf/","title":"1.1 - Introduzione all'informatica","text":""},{"location":"material/01_intro/01_intro_inf/#una-definizione-di-informatica","title":"Una definizione di Informatica","text":"<p>Non c'\u00e8 modo migliore che partire con una definizione per introdurre l'informatica. Per farlo, partiamo da una (breve) analisi del termine.</p> <p>Informatica \u00e8, infatti, una crasi delle parole infor(mazione) ed (auto)matica, e ci\u00f2 suggerisce che la disciplina tratti, in maniera generica, di automatizzazione dell'informazione. Ci\u00f2, tradotto in \"linguaggio corrente\", implica la gestione automatizzata di informazioni.</p> <p>Ed \u00e8 proprio questo il focus dell'informatica: gestire in maniera automatica una serie (pi\u00f9 o meno rilevante) di informazioni</p> <p>Questo, infatti, \u00e8 la traduzione italiana del francese informatique, crasi delle parole informa(tion) ed (automa)tique. Intuitivamente, possiamo dedurre che la disciplina tratti quindi di \"informazioni automatiche\" o, per meglio dire, automatizzazione delle informazioni.</p> <p>E, se ci pensiamo, \u00e8 proprio di quello che si occupa l'informatica, ovvero di gestire in maniera automatica una serie pi\u00f9 o meno rilevante di informazioni, correlate ad un qualsiasi aspetto della nostra vita, siano esse le nostre foto su Facebook, il nostro libretto universitario oppure i dati dei nostri conti corrente bancari: tutte queste informazioni vengono elaborate in maniera (pi\u00f9 o meno) automatica.</p> <p>Proviamo ad arricchire questa prima, un po' generica, definizione. Per farlo, sfruttiamo un'altra denominazione straniera, ovvero quella inglese, lingua nella quale l'informatica \u00e8 chiamata computer science. Quello che notiamo di questa definizione \u00e8 il termine science, che ci suggerisce come l'informatica, in realt\u00e0, sia basata su solide fondamenta scientifiche: per capirci, infatti, i \"padri fondatori\" della materia erano prevalentemente dei matematici, uno fra tutti il celebre Alan Turing.</p> <p>L'ultimo fattore da tenere in conto \u00e8 che l'informatica rappresenta uno vero e proprio pilastro della societ\u00e0 moderna. Tutto ci\u00f2 che utilizziamo al giorno d'oggi, dallo smartphone che stiamo usando per leggere questo documento, al computer mediante il quale \u00e8 stato scritto, fino ad arrivare alle nostre auto, o anche ai termostati nelle nostre caldaie, sono basati su tutte le evoluzioni informatiche (ed elettroniche) succedutesi a partire dal Secondo Dopoguerra.</p> <p>Ecco, quindi, che possiamo dare una definizione pi\u00f9 completa di informatica, presa direttamente dal dizionario Oxford Languages:</p> <p>L'informatica</p> <p>L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico.</p> <p>Ora, non \u00e8 tanto importante memorizzare questa definizione, quanto piuttosto comprenderne la portata: l'informatica \u00e8 ovunque, e conoscerla ci d\u00e0 l'accesso alle porte di quello che \u00e8 il mondo odierno.</p>"},{"location":"material/01_intro/01_intro_inf/#informatica-ed-informazione","title":"Informatica ed informazione","text":"<p>Esiste un'altra definizione di informatica, questa volta legata al concetto di informazione, quest'ultima a sua volta definita come insieme di dati ed intepretazione degli stessi.</p> <p>In particolare, l'informatica pu\u00f2 essere definita come studio teorico, analisi, progettazione, realizzazione ed applicazione degli algoritmi che descrivono e trasformano l'informazione. </p> <p>L'informatica ai tempi dei mobilifici svedesi</p> <p>Immaginiamo di doverci recare presso una nota catena di mobilifici svedesi per acquistare un tavolino. Questo sar\u00e0 composto da una serie di componenti, come viti, bulloni, o pannelli, che andranno a costituire i dati a nostra disposizione. Contestualmente, avremo a disposizione un manuale da utilizzare per realizzare il mobile, che rappresenta l'interpretazione da dare agli stessi. Concettualmente, l'informatica studia l'algoritmo, definito sul manuale (interpretazione), che, a partire dalle componenti (dati) permette di ottenere il risultato desiderato.</p> <p>I pi\u00f9 attenti avranno sicuramente notato come manchi ancora qualcosa alle definizioni ed ai concetti che abbiamo introdotto finora. Infatti, l'informatica \u00e8 cos\u00ec presente nelle nostre vite perch\u00e9 permette di svolgere in maniera semplice e trasparente compiti complessi. Ad esempio, il sistema di controllo della stabilit\u00e0 della nostra auto si abilita in maniera automatica, e ci impedisce di fare staccate degne del Valentino Rossi del 2004 grazie ad un sistema informatico. Stesso vale per il sistema che ci permette di acquistare l'ultimo gadget alla moda dal nostro sito di e-commerce preferito: con la semplice pressione di un tasto svolgeremo \"automaticamente\" una serie di operazioni che, un tempo, avrebbero previsto il recarsi fisicamente in negozio, scegliere il prodotto, consegnare i contanti al commesso, e ritornare a casa col bottino.</p> <p>Ci\u00f2 ci riconduce al concetto di automazione: l'informatica, infatti, utilizza quasi sempre sistemi automatizzati di gestione dell'informazione.</p> <p>Ovviamente, esistono sorgenti di informazioni diverse: ad esempio, l'informazione pu\u00f2 provenire da Internet, oppure da un hard disk attaccato al nostro computer, o anche in un video visto su YouTube. Contestualmente, le tipologie di informazione sono eterogenee: le informazioni provenienti da Internet sono di tipo testuale, mentre i video sono chiaramente multimediali. La natura eterogenea delle informazioni richiede quindi una rappresentazione uniforme. Vediamo come questo sia reso possibile dal concetto di linguaggio.</p>"},{"location":"material/01_intro/01_intro_inf/#linguaggi","title":"Linguaggi","text":"<p>Ora, per comprendere e veicolare l'informazione dobbiamo tenere in conto alcuni fattori. Il primo, e forse il pi\u00f9 intuitivo, \u00e8 che l'informazione deve essere in qualche modo \"scritta\" o \"letta\" su un supporto fisico. La seconda, invece, \u00e8 che per veicolare con efficacia l'informazione \u00e8 necessario adottare un insieme di regole condivise che ne permettano l'interpretazione; questo insieme di regole \u00e8 comunemente chiamato linguaggio.</p> <p>L'informatica ai tempi dei mobilifici svedesi</p> <p>Nel mobilificio di cui sopra il supporto fisico scelto per veicolare l'informazione \u00e8 (come prevedibile) il manuale, sia esso cartaceo o in formato PDF. Il linguaggio usato per veicolare l'informazione \u00e8 invece di tipo grafico, anche se ai pi\u00f9 pu\u00f2 apparire poco comprensibile.</p> <p>Un linguaggio \u00e8 costituito da due commponenti:</p> <ul> <li>un alfabeto, che altro non \u00e8 se non un insiemme di simboli;</li> <li>una grammatica, definita nel senso di insieme di regole sintattiche e semantiche che permettono di strutturare ed interpretare i simboli dell'alfabeto.</li> </ul> <p>Esempio classico di alfabeto \u00e8 quello latino, che utilizziamo comunemente per scrivere in occidente; tale alfabeto, se strutturato secondo regole sintattiche e semantiche proprie di una grammatica, permette di veicolare informazione scritta in un certo linguaggio. Ad esempio, il testo che state leggendo questo testo \u00e8, sperabilmente, italiano.</p> <p>Quanti simboli in un alfabeto?</p> <p>Affinch\u00e9 abbia un senso commpiuto, un alfabeto deve avere almeno due simboli distinti. Usare un unico simbolo sarebbe quantomeno irrealistico.</p> <p>La scelta di un linguaggio segue essenzialmente due criteri, esplicitati di seguito.</p> <ol> <li>Universalit\u00e0: questo criterio implica che i sistemi che elaborano l'informazione adottino un linguaggio universalmente condiviso, di modo tale che due dispositivi differenti siano in grado di comunicare tra loro. Immaginiamo ad esempio che bel problema sarebbe non poter comunicare con la nostra dolce met\u00e0 se questa avesse uno smartphone basato su un sistema operativo diverso da quello del nostro!</li> <li>Semplicit\u00e0: questo criterio \u00e8 legato alla natura reale, e non astratta, dei dispositivi coinvolti nell'elaborazione automatica dell'informazione. I nostri computer e smartphone, infatti, altro non sono se non un \"ammasso\" di circuiti elettronici, i quali operano essenzialmente come interruttori. S\u00ec, esattamente come quello che vi permette di accendere o spegnere la luce nella vostra stanza, soltanto molto pi\u00f9 in piccolo: infatti, ciascuno di questi interruttori, chiamati transistor, occupa soltanto un paio di nanometri. La nostra esperienza ci dice che gli interruttori sono estremamente semplici da operare: infatti, possono essere soltanto aperti, non facendo quindi scorrere la corrente (e facendo s\u00ec che la lampadina sia spenta), o chiusi, facendo scorrere la corrente al loro interno, ed accendendo la lampadina. In altri termini, gli interruttori hanno soltanto due possibili stati.</li> </ol> <p>Ovviamente, esiste un linguaggio che soddisfa entrambi i requisiti precedentemente menzionati. Questo linguaggio deve adottare un sistema di simboli quanto pi\u00f9 semplice possibile, ed essere adatto ad effettuare operazioni di tipo numerico; un linguaggio che soddisfa tutti questi requisiti \u00e8 quello binario, nel quale sono contenuti esclusivamente i simboli \\(0\\) ed \\(1\\).</p> <p>Prima di approfondire i concetti alla base dell'utilizzo del codice binario, tuttavia, \u00e8 importante discutere di come si rappresentano i dati in un elaboratore.</p>"},{"location":"material/01_intro/02_data_repr/","title":"1.2 - Rappresentazione dei dati","text":"<p>Nella scorsa lezione abbiamo introdotto i concetti legati alla rappresentazione dell'informazione all'interno di sistemi automatici. Tuttavia, \u00e8 importante approfondire ulteriormente il modo in cui questa informazione viene gestita.</p>"},{"location":"material/01_intro/02_data_repr/#i-tipi-di-dato","title":"I tipi di dato","text":"<p>Partiamo da una domanda: quali sono i tipi di dato che possiamo voler rappresentare? Per dare una risposta, possiamo pensare a quello che caratterizza il mondo attorno a noi.</p> <p>Pensiamo alla seguente frase:</p> <p>La casa di mattoni di colore rosso, con le sue cinque mura, \u00e8 bella.</p> <p>Ora, al di l\u00e0 dell'informazione (evidentemente importantissima) contenuta nella frase precedente, notiamo che abbiamo informazioni relative a:</p> <ol> <li>il colore della casa;</li> <li>il metodo di costruzione della casa;</li> <li>il numero di mura della casa;</li> <li>la bellezza della casa.</li> </ol> <p>Ragioniamoci su un attimo: scopriremo che abbiamo diverse tipologie di dato che possiamo rappresentare. Vediamole insieme.</p> <p>Pericolo</p> <p>Attenzione: un ingegnere civile potrebbe avere malori nel prosieguo della lettura. Perdonatemi per le eccessive ed atroci semplificazioni.</p>"},{"location":"material/01_intro/02_data_repr/#di-che-categoria-e-la-nostra-casa","title":"Di che categoria \u00e8 la nostra casa?","text":"<p>Partiamo dal metodo di costruzione della casa. In questo caso, come abbiamo potuto vedere, sono stati utilizzati dei mattoni; tuttavia, sappiamo benissimo che esistono diverse tecniche di costruzione, alcune che prevedono l'utilizzo del cemento armato, altre che prevedono l'uso del legno, altre ancora ibride. Avremo, quindi, diverse categorie di case; il dato associato a questa informazione, quindi, risulter\u00e0 essere di tipo categorico. </p> <p>Altri dati categorici</p> <p>Il lettore pi\u00f9 attento noter\u00e0 che vi \u00e8 un altro dato categorico all'interno della rappresentazione precedente. Stiamo, ovviamente, parlando del colore dei mattoni utilizzati.</p>"},{"location":"material/01_intro/02_data_repr/#quante-mura-abbiamo","title":"Quante mura abbiamo?","text":"<p>Altra importantissima informazione estrapolabile dalla frase precedente \u00e8 quella relativa al numero di mura presenti all'interno della casa, ovvero cinque (probabilmente, uno sar\u00e0 un divisorio, a meno di eventuali licenze poetiche del costruttore). Ci\u00f2 suggerisce l'esistenza di un altro tipo di dato, ovvero quello numerico.</p> <p>Da notare che, in questo caso, il numero di mura \u00e8 intero. Nella realt\u00e0, tuttavia, esistono anche numeri non interi, globalmente noti come reali. Di conseguenza, esisteranno due tipi di dato numerico: il dato di tipo intero, o numerale discreto, ed il dato di tipo reale, o numerale continuo.</p>"},{"location":"material/01_intro/02_data_repr/#che-bella-questa-casa","title":"Che bella questa casa!","text":"<p>L'ultima informazione che siamo in grado di estrapolare \u00e8 quella fornita dal nostro gusto estetico, che ci suggerisce come la casa sia in qualche modo gradevole (o, pi\u00f9 propriamente, bella). Questa informazione pu\u00f2 essere associata ad una serie di valori che possono essere ordinati in maniera semanticamente crescente o decrescente. Per capirci, una casa bella \u00e8 pi\u00f9 gradevole di una brutta, ma meno gradevole di una fantastica. Il quarto tipo di dato \u00e8, quindi, ordinale.</p>"},{"location":"material/01_intro/02_data_repr/#riassumendo","title":"Riassumendo...","text":"<p>Riassumendo, abbiamo quattro tipologie di dati, come mostrati nella seguente tabella.</p> Tipo di dato Descrizione Esempio Categorico Dato che descrive informazione il cui valore \u00e8 all'interno di un insieme limitato di categorie Rosso, verde, blu Ordinale Dato che descrive informazione il cui valore \u00e8 semanticamente ordinabile Orrendo, brutto, bello, fantastico Numerale discreto Dato che descrive informazione associata a numeri interi 1, 2, 100 Numerale continuo Dato che descrive informazione associata a numeri continui \\(\\pi\\), 2.45, \\(\\sqrt{2}\\)"},{"location":"material/01_intro/02_data_repr/#come-rappresentare-i-dati-in-un-sistema-informativo","title":"Come rappresentare i dati in un sistema informativo","text":"<p>Alcuni dei tipi precedentemente descritti possono essere abbastanza complessi da rappresentare in un sistema informativo; ci\u00f2 vale in particolare per i dati categorici e per quelli ordinali.</p> <p>Il motivo di questa difficolt\u00e0 \u00e8 presto spiegato: potenzialmente, infatti, \u00e8 necessario rappresentare un numero molto elevato di possibilit\u00e0, in entrambi i casi. E, come ben sappiamo, le risorse di un calcolatore sono finite: di conseguenza, bisogna trovare una maniera per usare una rappresentazione comune e condivisa di tutti i tipi di dato.</p> <p>Ragioniamo un attimo su quale potrebbe essere un formato ottimale per ottenere questa rappresentazione.</p> <p>Partiamo chiedendoci quale tra i quattro tipi sia il pi\u00f9 \"semplice\" da utilizzare. La risposta, ovviamente, \u00e8 il tipo numerale discreto: maneggiare numeri interi \u00e8 intrinsecamente meno complesso del maneggiare numeri continui o insiemi potenzialmente infiniti di parole.</p> <p>Fatto questo, dobbiamo chiederci se sia possibile, in qualche modo, rappresentare le altre categorie sotto forma di numero intero. Partiamo dai dati categorici.</p>"},{"location":"material/01_intro/02_data_repr/#categorici-come-interi","title":"Categorici come interi","text":"<p>Per rappresentare un dato categorico come intero, dovremo usare il cosiddetto metodo del dizionario. Nella pratica, ad ogni possibile categoria sar\u00e0 associato un numero intero, e questo sar\u00e0 usato per rappresentare detta categoria. Un esempio \u00e8 ci\u00f2 che avviene nella seguente tabella.</p> Categoria Intero associato Rosso 1 Blu 2 Verde 3 <p>Grazie al dizionario definito nella tabella precedente, potremo rappresentare la categoria \"rosso\" mediante il numero 1, la \"verde\" mediante il 3, e via discorrendo. L'aggiornamento del dizionario a seguito di una nuova categoria \u00e8 volutamente lasciato al lettore.</p> <p>Operazioni definite sul tipo categorico</p> <p>Da sottolineare come l'unica operazione definibile su un tipo di dato categorico sia quella di uguaglianza, che risponde alla domanda la categoria di X \u00e8 uguale alla categoria di Y? Per metterla in italiano, il colore del primo mattone \u00e8 uguale a quello del secondo\"? Ovviamente, questa operazione \u00e8 *preservata dal dizionario: se due mattoni sono rossi, la loro rappresentazione in numero intero sar\u00e0 sempre pari ad \\(1\\).</p>"},{"location":"material/01_intro/02_data_repr/#ordinali-come-interi","title":"Ordinali come interi","text":"<p>La rappresentazione di un dato ordinale come intero usiamo invece il metodo dell'enumerazione. Innazitutto, ordinamo i valori secondo il loro significato semantico. Ad esempio:</p> <ol> <li>orrendo</li> <li>brutto</li> <li>bello</li> <li>fantastico</li> </ol> <p>Fatto questo, potremo associare un numero intero ad ogni valore, in maniera crescente. S\u00ec, lo avevamo gi\u00e0 fatto, ma \u00e8 comunque opportuno consultare la seguente tabella.</p> Ordinale Intero associato Orrendo 1 Brutto 2 Bello 3 Fantastico 4 <p>Operazioni definite sul tipo ordinale</p> <p>In caso di tipo ordinale, possiamo definire la relazione di ordine, che ovviamente l'enumerazione preserva. In altre parole, se consideriamo \"migliore\" un qualcosa di bello rispetto ad un qualcosa di orrendo, il valore associato al bello (ovvero, tre) sar\u00e0 maggiore o uguale a quello associato all'orrendo (nella nostra enumerazione, uno).</p> <p>Siamo quindi adesso in grado di individuare le diverse tipologie di dato che \u00e8 possibile avere all'interno di un contenitore informativo. Nella prossima lezione andremo a vedere come vengono codificate, dal punto di vista \"fisico\", le informazioni all'interno di un calcolatore.</p> <p>Numeri reali e numeri interi</p> <p>Abbiamo volutamente tralasciato la questione relativa ai numeri reali, che tratteremo pi\u00f9 estesamente quando parleremo della rappresentazione a virgola mobile nel sistema binario; per adesso, ci\u00f2 che ci interessa \u00e8 che la risposta \u00e8 s\u00ec, possiamo usare i numerali discreti per rappresentare numerali continui.</p>"},{"location":"material/01_intro/03_dig_an/","title":"1.3 - Codifica analogica e digitale","text":"<p>Nella lezione precedente abbiamo introdotto i diversi tipi di dato che possono essere sfruttati per la rappresentazione dell'informazione. Abbiamo per\u00f2 accennato anche ad un limite intrinseco di questa rappresentazione, ovvero la necessit\u00e0 di poterla rappresentare all'interno di un calcolatore reale.</p> <p>Cerchiamo di capire cosa questa necessit\u00e0 implichi. Un computer, per quanto potente ed avanzato, ha una capacit\u00e0 di memorizzazione finita. Ci\u00f2 significa, in altre parole, che la quantit\u00e0 di dati che \u00e8 possibile immagazzinarvi non pu\u00f2 andare oltre un certo quantitativo, per grande che questo sia. Questo \u00e8 contrario ai principi fisici del mondo che ci circonda, che risulta essere composto da un numero praticamente infinito di informazioni.</p> <p>Finitezza del mondo</p> <p>Prima di imbracciare torce e forconi, i fisici vorranno porre particolare accento alla parola praticamente.</p> <p>La conseguenza di questa contraddizione \u00e8 che non \u00e8 possibile immagazzinare tutta l'informazione del mondo reale all'interno di un calcolatore elettronico. Possiamo, per\u00f2, codificarla in maniera tale che risulti essere (virtualmente) indistinguibile; per farlo, per\u00f2, dovremo introdurre i concetti di segnali e codifica analogica e digitale.</p>"},{"location":"material/01_intro/03_dig_an/#segnali-e-codifica","title":"Segnali e codifica","text":""},{"location":"material/01_intro/03_dig_an/#segnali-analogici","title":"Segnali analogici","text":"<p>I segnali analogici sono quelli propri del mondo che ci circonda. Un esempio \u00e8 la voce umana, cos\u00ec come la musica, o ancora tutto ci\u00f2 che vediamo. Questi segnali sono continui: in analogia con il concetto matematico di funzione continua, li possiamo esperire senza particolari \"salti\". Ci\u00f2 implica quindi che la struttura dell'entit\u00e0 informativa sia definita all'interno di un certo range di numeri reali, e possa quindi assumere un insieme praticamente infinito di valori.</p> <p>Un segnale analogico, per essere trasmesso, deve essere codificato, ovvero tradotto in qualche altro tipo di segnale gestibile dall'apparato di trasmissione e/o ricezione. Pensiamo ai telefoni di una volta: questi non prevedevano certo un \"magico\" altoparlante che interconnetteva i due interlocutori, ma un vero e proprio circuito, che collegava il microfono nel nostro apparecchio all'altoparlante di quello del nostro amico (e viceversa), lungo il quale veniva trasmesso il segnale relativo alla voce dei conversanti. Questo circuito, ovviamente, non aveva alcun calcolatore al suo interno: doveva limitarsi a replicare una versione compatta della nostra voce da un capo all'altro, per cui era necessario trovare un modo per farlo senza perdere troppa dell'informazione presente nel segnale originario. Il modo per farlo era modificare questo segnale agendo sulla sua rappresentazione in frequenza, ampiezza, o fase.</p> <p>Modulazione</p> <p>Tutto sar\u00e0 pi\u00f9 chiaro quando vi interfaccerete con materie come Teoria dei Segnali e Comunicazioni Elettriche. O forse no.</p> <p>Ora, la codifica analogica permette di mantenere una certa analogia tra la struttura dell'entit\u00e0 di informazione originaria e quella codificata. Tuttavia, \u00e8 una codifica difficile da gestire, prona ad interferenze, rumore e ad un fenomeno chiamato aliasing. Inoltre, non \u00e8 adatta a situazioni nelle quali il segnale pu\u00f2 essere rappresentato sotto un'altra forma, non continua, ma numerica. In questi casi, \u00e8 necessario guardare alla codifica digitale.</p>"},{"location":"material/01_intro/03_dig_an/#segnali-digitali","title":"Segnali digitali","text":"<p>Continuiamo con la comunicazione telefonica, e pensiamo a come avviene al giorno d'oggi. I nostri smartphone hanno al loro interno un microfono, un altoparlante ed un'antenna, che ricreano a grandi linee ci\u00f2 che c'era nei telefoni di una volta. Oltre ci\u00f2, tuttavia, dispongono anche di un computer, che pu\u00f2 essere sfruttato per codificare l'informazione della nostra voce (in trasmissione) o quella del nostro interlocutore (in ricezione). Per farlo, possiamo pensare di codificare il segnale analogico in ingresso (o uscita) in maniera digitale, convertendolo quindi da un'onda meccanica a valori continui in un insieme di numeri, i quali saranno trasmessi in maniera pi\u00f9 semplice ed efficace sulla rete di telecomunicazioni.</p> <p>Il concetto alla base della codifica digitale \u00e8 quindi questo: prendere un'informazione analogica, selezionare un numero finito (ma appropriato) di configurazioni distinte ammissibili, e rappresentare l'informazione iniziale all'interno di una di queste configurazioni. In questo caso, dato che stiamo \"discretizzando\" un valore analogico, si fa spesso il paragone con una funzione di tipo discreto.</p>"},{"location":"material/01_intro/03_dig_an/#un-vantaggio-su-tutti-il-rumore","title":"Un vantaggio su tutti: il rumore","text":"<p>La scelta della codifica digitale pone un insieme di vantaggi non indifferente, che compensano la maggiore complessit\u00e0 delle tecniche e degli apparati coinvolti. Il vantaggio principale, per\u00f2, sta nella robustezza al rumore.</p> <p>Immaginiamo di voler fare una telefonata dal nostro smartphone: la ricezione sar\u00e0 sicuramente differente tra una stanza schermata ed una zona nelle vicinanze di un'antenna per telecomunicazioni. In altri termini, l'ambiente circostante pu\u00f2 introdurre del rumore nell'informazione gestita e trasmessa da un sistema fisico come lo smartphone o, per rimanere pi\u00f9 vicini al nostro ambito, il computer.</p> <p>Ci\u00f2 \u00e8 evidentemente un problema in caso di rappresentazione analogica, in quanto questa, come gi\u00e0 detto, \u00e8 continua: ci\u00f2 implica la presenza di un numero potenzialmente infinito di possibili \"configurazioni\" dell'informazione che, se alterate, sarebbero pi\u00f9 difficili da ricondurre allo stato originario. Una rappresentazione discreta come quella digitale, invece, limita il numero di possibili configurazioni, rendendo quindi pi\u00f9 semplice isolare l'informazione originaria dal rumore.</p>"},{"location":"material/01_intro/03_dig_an/#campionamento-e-quantizzazione","title":"Campionamento e quantizzazione","text":"<p>Immaginiamo di visualizzare il segnale analogico associato alla nostra voce. Per farlo, pensiamo a quali informazioni vengono veicolate, ed al modo in cui lo sono. Intuitivamente, avremo due componenti: una potenzialmente \"illimitata\", data dal \"tempo\" associato all'emissione di un particolare suono, ed un'altra \"limitata\" all'interno di un range, associata (ad esempio) all'intensit\u00e0 del nostro tono. </p> <p>Rappresentare la voce</p> <p>Ovviamente, potremmo estendere questa analisi ad altri \"assi\", come ad esempio la frequenza della nostra voce, ma, per semplicit\u00e0, evitiamo.</p> <p>Questa rappresentazione pu\u00f2 essere visualizzata su un semplice piano cartesiano, in cui all'asse delle ascisse viene associato il tempo \\(t\\), mentre all'asse delle ordinate l'intensit\u00e0 della nostra voce a quel determinato istante temporale.</p> <p>Ora, \u00e8 facile verificare come questa informazione sia continua su entrambi gli assi: abbiamo infiniti valori sull'asse temporale, ma anche sull'asse delle intensit\u00e0, nonostante questi siano comunque limitati ad un certo range. Per digitalizzare il segnale, quindi, dovremo effettuare due operazioni: la prima preveder\u00e0 l'isolamento di un certo numero di campioni rilevanti nel tempo, mentre la seconda andr\u00e0 ad assegnare a tali campioni dei valori fissi, suddividendo l'intervallo iniziale in un numero pi\u00f9 o meno elevato di quanti di informazione.</p> <p>In breve, dovremo dapprima campionare il segnale, misurandolo ad intervalli regolari, per poi quantizzarlo, suddividendo il range in cui possono ricadere questi valori in \\(N\\) possibili intervalli, anch'essi regolari, ognuno dei quali rappresentato da un unico valore in uscita (ad esempio, quello medio).</p>"},{"location":"material/01_intro/03_dig_an/#conclusioni","title":"Conclusioni","text":"<p>Abbiamo accennato in breve alla differenza tra segnale (e codifica) analogico e digitale. Tuttavia, manca ancora un pezzo al nostro puzzle, che vedremo nella prossima lezione, relativo al sistema numerico che usiamo per rapprentare la nostra codifica.</p>"},{"location":"material/01_intro/04_num_sis/","title":"1.4 - Sistemi di numerazione","text":"<p>Nella precedente lezione abbiamo visto la differenza tra codifica analogica e digitale, ma non abbiamo parlato di un aspetto fondamentale, ovvero del sistema da utilizzare, nei fatti, per rappresentare le nostre informazioni.</p> <p>Per introdurre questo aspetto, dovremo dare un'ulteriore definizione di informazione, stavolta in relazione al concetto di messaggio definito all'interno di un linguaggio. </p>"},{"location":"material/01_intro/04_num_sis/#messaggi-linguaggi-ed-informazione","title":"Messaggi, linguaggi ed informazione","text":"<p>Formalmente, il messaggio \u00e8 una delle possibili combinazioni dei simboli appartenenti ad un certo linguaggio: per esempio, tutte le frasi che trovate in queste dispense sono dei messaggi, appartenenti (si spera!) ad un insieme di regole sintattiche e semantiche definite come \"linguaggio italiano\". L'informazione pu\u00f2 quindi essere definita come la misura dell'ampiezza della classe alla quale appaprtiene un dato messaggio.</p> <p>La definizione \u00e8 un po' criptica, quindi cerchiamo di spiegarla tramite un esempio. Consideriamo un messaggio del tipo XXXX, con X uno dei simboli dell'alfabeto anglosassone, ovvero quello composto da \\(26\\) caratteri. Possibili messaggi di questo tipo sono quindi CIAO, OKAY, CARA, VELA, e via discorrendo. Ci\u00f2 implica che il numero di possibili combinazioni sar\u00e0 dato dal numero di possibili caratteri (\\(26\\)) elevato per il numero di caratteri contenuti nel messaggio (\\(4\\)). L'informazione sar\u00e0 esattamente questo valore, ovvero \\(26^4\\).</p> <p>Significato delle possibili combinazioni</p> <p>Ovviamente, non tutte le combinazioni possibili avranno un senso compiuto.</p>"},{"location":"material/01_intro/04_num_sis/#misurare-linformazione","title":"Misurare l'informazione","text":"<p>L'informazione viene comunemente misurata in bit. Questa parola \u00e8 in realt\u00e0 una crasi delle parole binary e digit; di conseguenza, ci torneremo quando parleremo della codifica binaria.</p> <p>Per adesso, ci basti sapere che il numero di informazione associato ad ogni messaggio \u00e8 dato, per convenzione, dal logaritmo in base \\(2\\) dell'ampiezza della classe dei messaggi. In altre parole, per il caso precedente:</p> \\[ Informazione = \\log_{2} 26^4 \\] <p>Facciamo un esempio. Sia dato un messaggio di tipo XXYYY, con X simbolo dell'alfabeto anglosassone, ed Y simbolo numerico. In questo caso, l'informazione totale sar\u00e0 data da:</p> \\[ Informazione = 26 \\cdot 26 \\cdot 10 \\cdot 10 \\cdot 10 = 26^2 \\cdot 10^3 \\] <p>La misura in bit di questa informazione sar\u00e0 quindi:</p> \\[ Informazione_{bit} = \\log_2 (26^2 \\cdot 10^3) \\]"},{"location":"material/01_intro/04_num_sis/#codificare-numeri","title":"Codificare numeri","text":"<p>Dopo aver definito il concetto di informazione in relazione a quello di messaggio, ed aver visto come calcolarne il contributo in bit, possiamo introdurre i sistemi di numerazione che, come suggerisce la parola stessa, altro non sono se non degli schemi per la codifica di numeri. Semplice.</p> <p>Per asservire a questo scopo, un sistema di numerazione deve avere alcune caratteristiche e propriet\u00e0, ovvero essere definito da:</p> <ul> <li>cifre, per rappresentare i numeri;</li> <li>regole, da applicare per costruire e combinare numeri.</li> </ul> <p>Sulla base di queste definizioni, \u00e8 possibile definire due categorie di sistemi di numerazione.</p>"},{"location":"material/01_intro/04_num_sis/#sistemi-addizionali","title":"Sistemi addizionali","text":"<p>Nei sistemi addizionali, ogni simbolo ha un valore fisso, indipendentemente dalla posizione che occupa.</p> <p>Un esempio classico di sistema di numerazione addizionale \u00e8 quello romano. In particolare, in questo sistema a sette simboli (che ricordiamo essere \\(I=5,V=5,X=10,L=50,C=100,M=1000\\)), il valore di ciascun simbolo viene sempre sommato a quello alla sua destra, a patto che quest'ultimo sia minore o uguale. Ad esempio:</p> \\[ XV = 10 + 5 \\] <p>o ancora:</p> \\[ XVII = 10 + 5 + 1 + 1 \\] <p>Ovviamente, non abbiamo considerato l'eventualit\u00e0 in cui il simbolo alla destra sia maggiore. In questo caso, avverr\u00e0 una sottrazione (o, equivalentemente, un'addizione, ma considerando il simbolo a sinistra cambiato di segno). Ad esempio:</p> \\[ XC = -10 + 100 \\] <p>Combinando i due concetti:</p> \\[ XCV = -10 + 100 + 5 \\]"},{"location":"material/01_intro/04_num_sis/#sistemi-posizionali","title":"Sistemi posizionali","text":"<p>Nei sistemi posizionali, invece, il valore di ogni cifra dipende dalla sua posizione all'interno del numero. In pratica, ad ogni posizione \u00e8 associato un certo \"peso\", che aumenta partendo da destra ed andando verso sinistra. Ogni numero, inoltre, \u00e8 associato ad una base \\(b\\), la quale verr\u00e0 utilizzata per stabilire il \"peso\" da utilizzare nella valutazione complessiva della cifra.</p> <p>Facciamo un esempio considerando il classico sistema decimale. Possiamo esprimere il numero \\(123\\) come:</p> \\[ 123 = 1 \\cdot 100 + 2 \\cdot 10 + 3 \\cdot 1 \\] <p>ovvero:</p> \\[ 123 = 1 \\cdot 10^2 + 2 \\cdot 10^1 + 3 \\cdot 10^0 \\] <p>Ancora:</p> \\[ 52 = 5 \\cdot 10 + 2 \\cdot 1 = 5 \\cdot 10^1 + 2 \\cdot 10^0 \\] <p>In questo caso, dato che stiamo parlando del sistema di numerazione decimale, la base \\(b\\) sar\u00e0 pari a \\(10\\).</p> <p>In linea generale, la formulazione di un numero posizionale \\(N\\) ad \\(m\\) cifre espresso in base \\(b\\) \u00e8 data dalla seguente:</p> \\[ N = c_{m-1} \\cdot b^{m-1} + c_{m-2} \\cdot b^{m-2} + \\ldots + c_1 \\cdot b^1 + c_0 \\cdot b^0 \\] <p>dove \\(c_{m-1}, c_{m-2}, \\ldots, c_0\\) sono i coefficienti associati a ciascuna delle cifre presenti nel numero.</p> <p>Il sistema di numerazione correntemente usato, come i lettori pi\u00f9 attenti avranno avuto modo di intuire, \u00e8 un sistema di numerazione posizionale in base decimale. Nella prossima lezione vedremo come il sistema pi\u00f9 usato in informatica sia quello binario.</p>"},{"location":"material/01_intro/05_sis_bin/","title":"1.5 - Sistema binario","text":"<p>Nella precedente lezione abbiamo introdotto il concetto di sistema di numerazione, parlando in maniera approfondita di sistema addizionale e sistema posizionale, facendo quindi l'esempio di numeri romani ed arabi, rispettivamente.</p> <p>Numeri arabi</p> <p>Prima di \"aiutarli a casa loro\", ricordiamoci sempre che l'intera scienza moderna si basa su una simbologia che non abbiamo inventato noi europei.</p>"},{"location":"material/01_intro/05_sis_bin/#perche-binario","title":"Perch\u00e9 binario?","text":"<p>Adesso, posto che abbiamo messo un punto sul fatto che, per far gestire informazione al nostro calcolatore, dovremo utilizzare un sistema numerico, ci interessa trovare quello che, in qualche modo, sia il pi\u00f9 vicino possibile al funzionamento fisico dell'elaboratore. Di conseguenza, dobbiamo proprio ppartire da quest'ultimo: cosa \u00e8, quindi, un elaboratore?</p> <p>Detto nella maniera pi\u00f9 semplice possibile, un elaboratore \u00e8 un insieme di circuiti elettrici che, organizzati in maniera opportuna, fanno scorrere della corrente in maniera tale da trasformare un input in un output. Semplice, giusto? Beh, non proprio: questi \"circuiti\" sono di dimensione nanometrica, e ve ne sono miliardi per ogni singolo processore. Tuttavia, il funzionamento \u00e8 sempre lo stesso: ognuno di questi circuiti viene governato da degli interruttori, chiamati transistor, che possono essere aperti (e, quindi, senza passaggio di corrente al loro interno) o chiusi (e che quindi permettono il passaggio di corrente). Dato che il funzionamento del processore \u00e8 legato a due differenti situazioni (aperto e chiuso), avremo bisogno di un sistema di numerazione in grado di modellare proprio questi due stati, ovvero il sistema binario.</p>"},{"location":"material/01_intro/05_sis_bin/#caratteristiche-del-sistema-binario","title":"Caratteristiche del sistema binario","text":"<p>Il sistema di numerazione binario \u00e8 basato sulla base \\(2\\), ovvero quella pi\u00f9 piccola possibile. Essendo la base pari a \\(2\\), saranno permesse soltanto due cifre, ovvero \\(0\\) ed \\(1\\).</p> <p>Sistema binario e bit</p> <p>Se ricordate, abbiamo in precedenza introdotto il concetto di bit, affermando fosse una crasi di binary e digit, ovvero cifra binaria. Ecco spiegato il motivo.</p> <p>Il sistema binario presenta quindi il vantaggio fondamentale di permettere di stabilire, in maniera relativamente semplice, una corrispondenza biunivoca con i possibili stati di funzionamento dei circuiti elettrici ed elettronici. Ci\u00f2 viene tuttavia al costo di una maggiore complessit\u00e0, dato che \u00e8 necessario utilizzare un numero di cifre pi\u00f9 elevato per rappresentare lo stesso numero. Ad esempio, per rappresentare un numero a \\(2\\) cifre decimali, ovvero tutti quelli compresi tra \\(10\\) e \\(99\\), sono necessarie da \\(3\\) a \\(7\\) cifre binarie, ovvero quelle che servono a rappresentare i numeri compresi tra \\(8\\) (che \u00e8 pari a \\(2^3\\)) fino a \\(128\\) (che \u00e8 pari a \\(2^7\\)).</p>"},{"location":"material/01_intro/05_sis_bin/#conversioni-di-base","title":"Conversioni di base","text":"<p>L'esempio legato alla diversa complessit\u00e0 della rappresentazione di un dato numero in sistemi differenti ci permette di introdurre il concetto di conversione di base. I numeri, infatti, sono concetti astratti, rappresentabili in modo equivalente in qualsiasi base di numerazione, a seconda di quanti simboli possono essere tra loro combinati; la conversione di base \u00e8 l'operazione matematica con cui si passa da una base di numerazione adll'altra.</p>"},{"location":"material/01_intro/05_sis_bin/#conversione-da-decimale-a-base-b","title":"Conversione da decimale a base \\(B\\)","text":""},{"location":"material/01_intro/05_sis_bin/#numeri-interi","title":"Numeri interi","text":"<p>In generale, la conversione di un numero intero \\(N\\) da decimale (ovvero base \\(10\\)) ad una certa base \\(B\\) avviene dividendo ripetutamente \\(N\\) per \\(B\\), fino ad ottenere un quoziente \\(0\\), e recuperando i resti in ordine inverso alla loro determinazione. Complicato, giusto? Non proprio.</p> <p>Facciamo un esempio con base \\(2\\): dovremo dividere ripetutamente il numero \\(N\\) per \\(2\\), fermandoci soltanto quando otteniamo un quoziente nullo. A quel punto, prenderemo (in ordine inverso) i resti delle divisioni effettuate, con le quali formeremo il numero convertito. Quindi, se \\(N=10\\):</p> Valore diviso Base Quoziente Resto \\(10\\) \\(2\\) \\(5\\) \\(0\\) \\(5\\) \\(2\\) \\(2\\) \\(1\\) \\(2\\) \\(2\\) \\(1\\) \\(0\\) \\(1\\) \\(2\\) \\(0\\) \\(1\\) <p>In base alla tabella precedente, ed alla regola che abbiamo definito, il risultato della conversione \u00e8 dato da \\(1010\\).</p>"},{"location":"material/01_intro/05_sis_bin/#numeri-frazionari","title":"Numeri frazionari","text":"<p>Gli stessi principi si applicano ai numeri frazionari. In questi casi, \u00e8 necessario moltiplicare ripetutamente la parte frazionaria per la base \\(B\\), e considerare il risultato \\(P\\) di questo prodotto. In particolare, \\(P\\) avr\u00e0 una parte intera (che chiameremo P.I.) ed una parte frazionaria (che chiameremo P.F.); ai nostri scopi, continueremo a moltiplicare fino a che non otterremo una P.F. pari a \\(0\\), e considereremo come risultato della conversione le parti intere prese nell'ordine di moltiplicazione. Ad esempio:</p> Valore moltiplicato Base Prodotto P.I. P.F. \\(0.25\\) \\(2\\) \\(0.5\\) \\(0\\) \\(5\\) \\(0.5\\) \\(2\\) \\(1\\) \\(1\\) \\(0\\) <p>In questo caso, la rappresentazione in binario di \\(0.25\\) sar\u00e0 quindi \\(01\\). Di conseguenza, se volessimo rappresentare in binario \\(10.25\\), dovremmo scrivere \\(1010.01\\).</p> <p>Esiste, per i numeri frazionari, anche la possibilit\u00e0 di trovarsi davanti a rappresentazioni in cui la conversione non converge, ovvero continua all'infinito. Ad esempio:</p> Valore moltiplicato Base Prodotto P.I. P.F. \\(0.6\\) \\(2\\) \\(1.2\\) \\(1\\) \\(2\\) \\(0.2\\) \\(2\\) \\(0.4\\) \\(0\\) \\(4\\) \\(0.4\\) \\(2\\) \\(0.8\\) \\(0\\) \\(8\\) \\(0.8\\) \\(2\\) \\(1.6\\) \\(0\\) \\(4\\) \\(0.6\\) \\(2\\) \\(1.2\\) \\(1\\) \\(2\\) <p>Notiamo due cose:</p> <ol> <li>quando il prodotto ha una parte intera superiore ad \\(1\\), questa andr\u00e0 riportata a zero nella moltiplicazione successiva;</li> <li>potremmo continuare ad effettuare un numero indefinito di moltiplicazioni, e non convergeremmo mai.</li> </ol> <p>In quest'ultimo caso, quindi, dovremo imporre un'ulteriore condizione, ovvero quella relativa al numero massimo di bit da utilizzare, giunti al quale termineremo l'operazione di conversione, approssimando il risultato ottenuto. Nel nostro caso, volendo usare una rappresentazione a \\(9\\) bit, \\(10.6\\) sar\u00e0 dato da \\(1010.10001\\).</p>"},{"location":"material/01_intro/05_sis_bin/#bit-byte-e-word","title":"Bit, byte e word","text":"<p>Abbiamo gi\u00e0 visto una rappresentazione informale di bit, come componente \"fondamentale\" dell'informazione. In maniera pi\u00f9 formale, possiamo adesso darne una definizione.</p> <p>Il Bit</p> <p>Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori \\(0\\) (interpretabile come falso, o circuito aperto) o \\(1\\) (interpretabile come vero, o circuito chiuso).</p> <p>Dalla definizione di bit segue quella (altrettanto importante) di byte, comunemente associata ad una sequenza di valori binari arbitrari ma con lunghezza pari ad otto bit.</p> <p>I valori del byte</p> <p>Quanti sono i valori che \u00e8 possibile rappresentare mediante un byte? Per rispondere alla domanda, riprendiamo le nozioni viste quando abbiamo parlato di informazione. In particolare, sappiamo che una sequenza di \\(K\\) bit pu\u00f2 rappresentare al pi\u00f9 \\(2^K\\) combinazioni di bit; quindi, se \\(K=8\\), allora potremo rappresentare al pi\u00f9 \\(2^8=256\\) valori.</p> <p>Possiamo infine definire come word (parola) una sequenza di \\(N\\) byte, con \\(N\\) dipendente da fattori contestuali, come il tipo di processore utilizzato. Ad esempio, i processori dei nostri PC sono in grado di gestire parole ad otto byte, ovvero \\(64\\) bit. Ci\u00f2 influenza il numero di valori che pu\u00f2 essere gestito dal processore: vedremo questo argomento maggiormente nel dettaglio nella prossima lezione.</p>"},{"location":"material/01_intro/06_data_types/","title":"1.6 - Dimensione dei dati","text":"<p>Nella lezione precedente abbiamo accennato al fatto che i calcolatori hanno a disposizione una word la cui dimensione dipende dall'architettura del processore; ci\u00f2 implica che ogni tipo di dato (cui abbiamo gi\u00e0 accennato) avr\u00e0 una dimensione prefissata. Scendiamo pi\u00f9 nel dettaglio.</p>"},{"location":"material/01_intro/06_data_types/#dati-numerici","title":"Dati numerici","text":""},{"location":"material/01_intro/06_data_types/#numeri-interi","title":"Numeri interi","text":"<p>Partiamo dai dati di tipo numerico intero. In questo caso, il limite legato alla dimensione della word impone che il massimo valore numerico trattabile da un calcolatore sia pari a \\(2^N\\), con \\(N\\) dimensione della parola. Nella pratica, se abbiamo una parola a \\(32\\) bit, il valore massimo gestibile dal processore sar\u00e0 pari a \\(2^{32}\\) (o, considerando lo \\(0\\), \\(2^{32}-1\\)). Nella maggior parte dei processori odierni, la parola \u00e8 a \\(64\\) bit, per cui il valore massimo gestibile dal processore sar\u00e0 di \\(2^{64}\\).</p> <p>Nota</p> <p>Ricordiamo che \\(2^{64} = 18.446.743.073.709.551.616\\). Il limite appare quindi abbastanza permissivo. Tuttavia, se sommassimo \\(1\\) a \\(2^{64}\\), il valore restituito sarebbe pari a zero o, pi\u00f9 probabilmente, il programma andrebbe in errore.</p>"},{"location":"material/01_intro/06_data_types/#interi-e-segno","title":"Interi e segno","text":"<p>Ricordiamo come i numeri interi siano dotati di segno: avremo quindi sia numeri negativi, sia numeri positivi. Ci\u00f2 non andr\u00e0 a modificare il numero di valori rappresentabili, che saranno sempre \\(2^{64}\\), quanto piuttosto il range dei valori rappresentati, che sar\u00e0 egualmente suddiviso tra valori negativi e positivi, e quindi centrato sullo \\(0\\). Avremo quindi \\(\\frac{2^{64}}{2}\\) valori positivi, e \\(\\frac{2^{64}}{2}\\) valori negativi; in altre parole, potremo rappresentare i numeri tra \\(-2^{63}\\) a \\(2^{63}\\).</p> <p>Facciamo un esempio pi\u00f9 facilmente digeribile, considerando come word una parola ad otto bit. In questo caso:</p> <ul> <li>considerando solo lo zero ed i valori strettamente positivi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^{8}-1\\);</li> <li>considerando anche i valori negativi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{8-1}\\) e \\(127 = -2^{8-1}-1\\). Ovviamente, anche in questo caso consideriamo lo zero.</li> </ul> <p>Nella seguente tabella, sono riassunti alcuni tra i tipi di valore intero pi\u00f9 comune, differenziati a seconda della loro lunghezza.</p> Tipo di dato Lunghezza Valore minimo assumibile Valore massimo assumibile <code>bit</code> 1 bit 0 1 <code>ubyte</code> 8 bit 0 255 <code>byte</code> 8 bit -128 127 <code>ushort</code> 16 bit 0 \\(2^{16} - 1\\) = 65535 <code>short</code> 16 bit -32768 32767 <code>uint</code> 32 bit 0 \\(2^{32} - 1\\) = 4294967295 <code>int</code> 32 bit \\(-2^{31}\\) = 2147483648 \\(2^{31} - 1\\) = 2147483647 <code>ulong</code> 64 bit 0 \\(2^{64} - 1\\) <code>long</code> 64 bit \\(-2^{63}\\) \\(2^{63} - 1\\) <p>Il simbolo <code>u</code></p> <p>I pi\u00f9 attenti avranno notato la presenza del simbolo <code>u</code> nelle notazioni che includono solo i valori positivi. Intuitivamente, la <code>u</code> sta per unsigned, ovvero \"senza segno\".</p>"},{"location":"material/01_intro/06_data_types/#numeri-reali","title":"Numeri reali","text":"<p>Cos\u00ec come i numeri interi, anche i numeri reali devono essere rappresentati mediante un'approssimazione finita che tenga conto della dimensione della word. Dato che i numeri reali sono composti da una parte intera e da una frazionaria, dovremo trovare una maniera per rappresentare entrambe utilizzando i bit messi a disposizione dalla word. Per farlo, avremo due possibili rappresentazioni, che vediamo di seguito.</p>"},{"location":"material/01_intro/06_data_types/#rappresentazione-a-virgola-fissa","title":"Rappresentazione a virgola fissa","text":"<p>Nella rappresentazione a virgola fissa (in inglese fixed point) viene usato un numero prefissato di bit per la parte intera, mentre i rimanenti sono usati per la parte decimale. Quindi, supponendo di usare \\(32\\) bit per la parte intera, ed altrettanti per la parte decimale, il numero pi\u00f9 grande che sar\u00e0 possibile rappresentare avr\u00e0 \\(2^{32}-1\\), ed altrettanto come parte frazionaria.</p> <p>Questa rappresentazione, seppur semplice da utilizzare, ha un grosso problema legato all'ottimizzazione delle risorse. Immaginiamo ad esempio di avere una word ad \\(8\\) bit, equalmente ripartiti tra parte intera e frazionaria, e voler rappresentare il numero \\(1.62515\\): per rappresentare la parte intera avremo bisogno soltanto di un bit, mentre per la parte frazionaria dovremmo usare pi\u00f9 dei quattro bit riservati, per cui avremo necessit\u00e0 di troncare il risultato, con una rappresentazione quindi incompleta.</p>"},{"location":"material/01_intro/06_data_types/#rappresentazione-a-virgola-mobile","title":"Rappresentazione a virgola mobile","text":"<p>La rappresentazione a virgola mobile (in inglese floating point) si basa sui concetti di mantissa, o significando, base, ed esponente. Formalmente, un numero \\(n\\) pu\u00f2 essere espresso come:</p> \\[ n = M \\cdot b^e \\] <p>In particolare, la mantissa \\(M\\) sar\u00e0 compresa tra \\(0\\) ed \\(1\\), e sar\u00e0 quel numero che, moltiplicato per la base \\(b\\) elevata all'esponente \\(e\\), dar\u00e0 di nuovo \\(n\\). Ad esempio, volendo rappresentare il valore \\(n = 5.2\\) in virgola mobile, scriveremo:</p> \\[ n = 0.52 \\cdot 10^1 \\] <p>Questa notazione, in cui la parte frazionaria \u00e8 compresa tra \\(0\\) ed \\(1\\), mentre quella intera \u00e8 pari a \\(0\\), \u00e8 detta normalizzata. </p> <p>!!!note \"Notazioni equivalenti     Equivalentemente, potremmo scrivere \\(n = 0.052 * 10^2\\), oppure \\(n = 52 * 10^{-1}\\). Tuttavia, \u00e8 la notazione normalizzata quella ad essere usata per convenzione.</p> <p>La rappresentazione in virgola mobile ha il vantaggio di popter rappresentare un insieme di valori molto pi\u00f9 ampio rispetto a quello rappresentabile in virgola fissa. Immaginiamo, ad esempio, di voler rappresentare il numero \\(100000\\), avendo per\u00f2 a disposizione soltanto \\(5\\) simboli. Con una rappresentazione a virgola fissa non potremmo farlo; con una rappresentazione a virgola mobile, invece, potremo usare l'equivalenza:</p> \\[ n = 0.1 \\cdot 10^5 \\] <p>Dato che dovremo memorizzare esclusivamente la mantissa e l'esponente, avremo bisogno soltanto di due simboli, rispettando i vincoli imposti.</p> <p>Mantissa e base decimale</p> <p>In questo esempio, abbiamo utilizzato la base decimale per semplicit\u00e0. Tuttavia, gli stessi concetti si estendono all'utilizzo della base binaria.</p>"},{"location":"material/01_intro/06_data_types/#caratteri","title":"Caratteri","text":"<p>Anche la rappresentazione dei caratteri che troviamo sulle nostre tastiere deve avvenire in binario e, di conseguenza, \u00e8 soggetta alle stesse limitazioni che abbiamo visto sussistere nel caso dei numeri.</p> <p>Alcuni potrebbero pensare, di primo acchitto, che questo non sia un problema: nell'alfabeto latino, ad esempio, abbiamo al pi\u00f9 26 caratteri, per cui basterebbero \\(5\\) bit per rappresentarli tutti. Giusto? Beh, non proprio.</p> <p>Quando si parla di carattere, si parla di qualsiasi simbolo che \u00e8 possibile rappresentare sul nostro calcolatore, inclusi anche, ad esempio, la chiocciola, o l'underscore, cos\u00ec come caratteri dell'alfabeto greco o cirillico.</p> <p>Ci\u00f2 implica la presenza di un'enorme variet\u00e0 di caratteri, che ha portato alla necessit\u00e0 di una rappresentazione comprensiva ed uniforme, richiedendo quindi molti pi\u00f9 bit dei \\(5\\) inizialmente preventivati. Inoltre, \u00e8 necessario usare una corrispondenza biunivoca tra simbolo e numero intero, definita mediante opportune tabelle, e che segue standard come l'ASCII e l'UNICODE.</p>"},{"location":"material/01_intro/06_data_types/#conclusioni","title":"Conclusioni","text":"<p>Abbiamo visto come siano rappresentati in memoria alcuni tipi di dati, e come la dimensione occupata da questi cambi con le caratteristiche della parola usata pepr rappresentarli.</p> <p>A questo punto, ci manca un ultimo tassello per la nostra panoramica sui concetti alla base dell'informatica: infatti, dovremo vedere come le variabili binarie si combinano tra loro sfruttando i concetti dell'algebra booleana.</p>"},{"location":"material/01_intro/07_boole/01_intro/","title":"1.7.1 - Algebra booleana","text":"<p>Abbiamo gi\u00e0 detto che gli elaboratori si basano sui circuiti elettronici digitali che, ad alto livello, possono essere visti come un insieme pi\u00f9 o meno complesso di interruttori, proprio come quelli che possiamo trovare in un normalissimo impianto elettrico.</p> <p>Per capirci meglio, pensiamo agli interruttori presenti nelle nostre case: questi sono caratterizzati esclusivamente da due stati di funzionamento, ovvero aperto e chiuso. Nello stato di funzionamento aperto, il circuito viene \"interrotto\", rendendo impossibile il passaggio della corrente; ci\u00f2, di conseguenza, impedisce che le lampadine nella stanza si accendano. Nello stato di funzionamento chiuso, invece, la corrente scorre normalmente nel circuito, illuminando le lampadine presenti nella stanza.</p> <p>Interruttori e resistenza</p> <p>I pi\u00f9 esperti noteranno che il circuito aperto ha resistenza infinita, il che significa che la corrente che scorre \u00e8 nulla. Invece, il circuito chiuso ha resistenza nulla, il che significa che la corrente che scorre \u00e8 massima (non infinita).</p> <p>Sfruttando il funzionamento base dei circuiti, \u00e8 possibile modellare delle situazioni pi\u00f9 o meno complesse. Facciamo un semplice esempio nel mondo reale: immaginiamo due stanze adiancenti, ciascuna dotata di una porta dalla quale \u00e8 possibile dedurre se la luce sia o meno accesa all'interno della singola stanza. Ponendoci come osservatori esterni, potremo trovarci in una tra le seguenti casistiche:</p> <ul> <li>caso 1: entrambe le luci sono accese, per cui \u00e8 plausibile che ci siano due persone, una in ciascuna stanza;</li> <li>caso 2: entrambe le luci sono spente, per cui \u00e8 plausibile che non ci sia nessuno;</li> <li>caso 3: una luce \u00e8 accesa, per cui \u00e8 plausibile che ci sia una persona nella stanza illuminata.</li> </ul> <p>Se ponessimo quindi la domanda c'\u00e8 qualcuno in casa, potremmo rispondere in maniera affermativa nel caso 1 (c'\u00e8 una persona nella prima stanza, ed una persona nella seconda) e nel caso 3 (c'\u00e8 una persona nella prima stanza o nella seconda stanza), ed in maniera negativa nel caso 2. Immaginiamo di estendere questo scenario ad una casa a pi\u00f9 stanze: \u00e8 facile comprendere come, combinando delle semplici informazioni di tipo binario, si riesca a modellare uno scenario arbitrariamente complesso.</p> <p>Interpretazione del risultato ottenuto</p> <p>Notiamo come l'osservazione dello stato di accensione delle luci non ci permetta di definire con certezza quante persone ci sono in casa, ma soltanto che c'\u00e8 qualcuno in casa. In altri termini, non possiamo dare una risposta quantitativa, ma soltanto una binaria.</p> <p>A questo punto \u00e8 lecito farsi una domanda: esiste un modo formale per determinare se \u00e8 presente una persona in casa a partire dalle precedenti considerazioni partendo da una serie di regole ben definite? Prevedibilmente, la risposta a questa domanda \u00e8 affermativa, ed \u00e8 definita grazie alle regole introdotte dall'algebra di Boole.</p> <p>Formalmente, l'algebra di Boole venne introdotta nel XIX secolo da Boole allo scopo di scomporre ed analizzare in maniera algebrica problemi di logica proposizionale.</p> <p>Questo tipo di logica si basa sulla presenza delle cosiddette proposizioni logiche, ovvero degli \"enunciati\" che possono assumere valore vero o falso. Per fare un esempio \"banale\", proviamo ad osservare la seguente figura.</p> <p></p> <p>Guardando l'immagine precedente, \u00e8 facile dire che la proposizione la palla \u00e8 dentro la scatola assume valore vero, cos\u00ec come lo assumono proposizioni del tipo la palla \u00e8 verde e la scatola \u00e8 blu. Ci\u00f2 non vale per altre proposizioni, come ad esempio la scatola \u00e8 dentro la palla oppure la scatola \u00e8 rossa.</p> <p>Da notare come ognuna di queste proposizioni sia atomica, o semplice, nel senso che viene espresso esclusivamente un predicato: ad esempio, il rapporto intercorrente tra palla e scatola, oppure ancora il colore di uno dei due oggetti. Un quadro completo della situazione richiederebbe l'uso di predicati composti da pi\u00f9 proposizioni atomiche: ad esempio, la palla \u00e8 dentro la scatola E la palla \u00e8 verde E la scatola \u00e8 blu.</p> <p>L'algebra Booleana si occupa di formulare un insieme di regole per definire se i predicati composti siano veri o falsi a partire dai singoli predicati che li compongono. Per farlo, si avvale di una serie di operazioni fondamentali, che approfondiremo nella prossima lezione.</p>"},{"location":"material/01_intro/07_boole/02_ops/","title":"1.7.2 - Le operazioni fondamentali dell'algebra booleana","text":"<p>Le tre operazioni fondamentali dell'algebra di Boole sono quelle di \\(AND\\), \\(OR\\) e \\(NOT\\). Queste operazioni ci permettono di verificare la veridicit\u00e0 di predicati composti di complessit\u00e0 arbitraria: ad esempio, nel caso visto in precedenza, i tre predicati semplici sono combinati tra loro utilizzando una regola di tipo \\(AND\\).</p> <p>Approfondiamo ognuna di queste regole nel dettaglio.</p>"},{"location":"material/01_intro/07_boole/02_ops/#loperazione-di-and-logico","title":"L'operazione di AND logico","text":"<p>L'operazione di AND logico \u00e8 un'operazione di tipo binario chiamata anche prodotto logico. Il fatto che l'operazione AND sia binaria implica che siano coinvolti due predicati: riprendendo il nostro esempio, il primo predicato potrebbe essere la palla \u00e8 dentro la scatola, mentre il secondo la palla \u00e8 verde. Combinandoli, potremo scrivere che:</p> \\[ la palla \u00e8 dentro la scatola AND la palla \u00e8 verde \\] <p>il che equivarr\u00e0 a dire che la palla verde \u00e8 dentro la scatola.</p> <p>Appare quindi evidente come il prodotto logico non sia altro se non una funzione che permette di \"comporre\" diversi predicati semplici, andando a definire una condizione composta che risulta essere vera se e solo se tutti i predicati semplici al suo interno sono a loro volta veri. Per comprendere quest'ultima affermazione diamo un'occhiata alla figura successiva, nella quale la palla \u00e8 adesso gialla.</p> <p></p> <p>In questo caso, la palla \u00e8 sempre all'interno della scatola, quindi il predicato la palla \u00e8 dentro la scatola continuer\u00e0 ad essere vero. Tuttavia, il predicato la palla \u00e8 verde non sar\u00e0 pi\u00f9 verificato, in quanto la palla avr\u00e0 il colore giallo; di conseguenza, il prodotto logico, rappresentativo della concomitanza delle singole affermazioni, non sar\u00e0 pi\u00f9 vero.</p> <p>Queste considerazioni ci permettono di scrivere la cosiddetta tabella delle verit\u00e0, ovvero una tabella nella quale possiamo diagrammare tutti i possibili stati assumibili dai predicati atomici, assieme al corrispondente stato assunto dal predicato composto.</p> <p>La costruzione della tabella delle verit\u00e0 \u00e8 strettamente dipendente dal numero di predicati semplici implicati nell'operazione valutata. Nel caso del prodotto logico, l'operazione \u00e8 di tipo binario, per cui abbiamo due predicati atomici che, per comodit\u00e0, chiameremo \\(p_1\\) e \\(p_2\\). Ovviamente, le possibili combinazioni di questi predicati sono date dal prodotto cartesiano dei possibili stati che ciascuno pu\u00f2 assumere (vero e falso); di conseguenza, essendo due gli stati assumibili da \\(p_1\\), e due quelli assumibili da \\(p_2\\), avremo un totale di \\(n_c = 2 \\cdot 2 = 4\\) possibili combinazioni. Stante questa valutazione, potremo costruire la tabella delle verit\u00e0 in questo modo: avremo in primis due colonne, una per ciascun predicato semplice, pi\u00f9 una ulteriore colonna per rappresentare il valore assunto dal predicato composto a partire dai valori corrispondenti dei predicati semplici. Per quello che riguarda il numero di righe, invece, queste saranno quattro, ovvero tutte quelle necessarie a diagrammare le possibili combinazioni assunte dai predicati semplici, con la corrispondente combinazione assunta dal predicato composto. Il risultato per l'AND logico \u00e8 il seguente.</p> \\(p_1\\) \\(p_2\\) \\(\\times\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(1\\) \\(0\\) \\(1\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(1\\) <p>La tabella rispecchia ci\u00f2 che abbiamo detto in precedenza, ovvero che il prodotto \u00e8 vero soltanto se i due predicati semplici sono veri. Associando, al solito, il valore \\(1\\) alla verit\u00e0, ed il valore \\(0\\) al falso, vediamo come la tabella delle verit\u00e0 faccia in modo che il risultato sia \\(1\\) soltanto se \\(p_1=1\\) e \\(p_2=1\\). In definitiva, possiamo dedurre che:</p> <p>Prodotto logico</p> <p>L'output atteso del prodotto logico sar\u00e0 vero se e solo se \\(p_1\\) \u00e8 vero e \\(p_2\\) \u00e8 vero. In caso contrario, l'output atteso del prodotto logico sar\u00e0 falso.</p> <p>Proviamo a vedere cosa accade nella nostra situazione, sostituendo \\(p_1\\) e \\(p_2\\) con i valori \"effettivi\" del predicato:</p> <ul> <li>se la palla NON \u00e8 dentro la scatola e la palla NON \u00e8 verde, allora il predicato derivante dal prodotto logico la palla \u00e8 dentro la scatola E la palla \u00e8 verde \u00e8 FALSO;</li> <li>se la palla NON \u00e8 dentro la scatola e la palla \u00e8 verde, allora il predicato derivante dal prodotto logico la palla \u00e8 dentro la scatola E la palla \u00e8 verde \u00e8 FALSO;</li> <li>se la palla \u00e8 dentro la scatola e la palla NON \u00e8 verde, allora il predicato derivante dal prodotto logico la palla \u00e8 dentro la scatola E la palla \u00e8 verde \u00e8 FALSO;</li> <li>se e solo se la palla \u00e8 dentro la scatola e la palla \u00e8 verde, allora il predicato derivante dal prodotto logico la palla \u00e8 dentro la scatola E la palla \u00e8 verde \u00e8 VERO.</li> </ul> <p>Al prodotto logico \u00e8 associata una porta logica, mostrata nella figura sottostante, rappresentativa della forma grafica convenzionalmente associata.</p> <p></p> <p>Perch\u00e9 prodotto?</p> <p>Il lettore pi\u00f9 attento si star\u00e0 chiedendo da dove derivi la dicitura prodotto. Per capirlo, basta osservare la tabella delle verit\u00e0: il risultato sar\u00e0 \\(1\\) soltanto quando entrambi i predicati hanno valore \\(1\\), proprio come il classico prodotto algebrico.</p>"},{"location":"material/01_intro/07_boole/02_ops/#loperazione-di-or-logico","title":"L'operazione di OR logico","text":"<p>L'operazione di OR logico \u00e8 un'operazione di tipo binario chiamata anche somma logica. Cos\u00ec come il prodotto, anche la somma logica implica il coinvolgimento di due predicati, ma il funzionamento \u00e8 (come ovvio) leggermente differente. Cerchiamo di comprenderla usando i predicati gi\u00e0 introdotti.</p> <p>In precedenza, infatti, abbiamo introdotto due possibili colori per la nostra palla, ovvero il verde ed il giallo. Questo implica che la palla \u00e8 verde OPPURE la palla \u00e8 gialla. Queste due condizioni sono mutualmente esclusive: nel nostro mondo, quindi, la palla non pu\u00f2 contemporaneamente essere gialla e verde. Questo pu\u00f2 essere modellato secondo questa tabella delle verit\u00e0:</p> \\(p_1\\) \\(p_2\\) \\(+\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(1\\) \\(0\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) <p>Cerchiamo anche in questo caso di comprendere cosa accada basandoci su valori di \\(p_1\\) e \\(p_2\\) \"comprensibili\":</p> <ul> <li>se la palla NON \u00e8 gialla e la palla NON \u00e8 verde, allora il predicato derivante dalla somma logica la palla \u00e8 gialla OPPURE la palla \u00e8 verde \u00e8 FALSO;</li> <li>se la palla NON \u00e8 gialla ma la palla \u00e8 verde, allora il predicato derivante dalla somma logica la palla \u00e8 gialla OPPURE la palla \u00e8 verde \u00e8 VERO;</li> <li>se la palla \u00e8 gialla ma la palla NON \u00e8 verde, allora il predicato derivante dalla somma logica la palla \u00e8 gialla OPPURE la palla \u00e8 verde \u00e8 VERO;</li> <li>se la palla \u00e8 gialla ma la palla \u00e8 verde, allora il predicato derivante dalla somma logica la palla \u00e8 gialla OPPURE la palla \u00e8 verde \u00e8 VERO;</li> </ul> <p>Da ci\u00f2 deriva la definizione della somma logica.</p> <p>Somma logica</p> <p>L'output atteso della somma logica sar\u00e0 vero se almeno uno tra i predicati \\(p_1\\) e \\(p_2\\) risulta essere vero, e falso altrimenti.</p> <p>Anche alla somma logica \u00e8 associata una porta, mostrata nella figura successiva.</p> <p></p> <p>Perch\u00e9 somma?</p> <p>Il fatto che questa operazione sia detta di somma deriva dal fatto che, cos\u00ec come per il prodotto, il risultato sia in qualche modo riconducibile a quello ottenibile seguendo le regole dell'aritmetica standard.</p>"},{"location":"material/01_intro/07_boole/02_ops/#loperazione-di-not-logico","title":"L'operazione di NOT logico","text":"<p>L'operazione di NOT logico \u00e8 definita come negazione logica. A differenza delle operazioni di AND ed OR, la NOT \u00e8 un'operazione unaria che, prevedibilmente, interessa un unico predicato, che sar\u00e0 negato a valle dell'applicazione dell'operazione.</p> <p>Capirne il funzionamento \u00e8 semplice: ad esempio, negare il fatto che la palla \u00e8 dentro la scatola implica che la palla non sia dentro la scatola, e viceversa. Dal punto di vista della tabella della verit\u00e0, la NOT \u00e8 esplicitata come segue.</p> \\(A\\) \\(\\overline{A}\\) \\(0\\) \\(1\\) \\(1\\) \\(0\\) <p>Anche alla negazione logica \u00e8 associata una porta, mostrata nella figura successiva.</p> <p></p>"},{"location":"material/01_intro/07_boole/03_ops_properties/","title":"1.7.3 - Propriet\u00e0 delle operazioni fondamentali","text":""},{"location":"material/01_intro/07_boole/03_ops_properties/#operazioni-con-n-predicati","title":"Operazioni con \\(n\\) predicati","text":"<p>Nella lezione precedente abbiamo introdotto le operazioni fondamentali dell'algebra booleana. In particolare, abbiamo visto come le operazioni di somma e prodotto logici siano di tipo binario, ovvero definite per una coppia di predicati, mentre la negazione sia unaria.</p> <p>Nonostante questo, \u00e8 possibile estendere le considerazioni fatte per una logica a due variabili ad una ad \\(n\\) variabili. Prendiamo, ad esempio, il seguente predicato composto:</p> <p> la palla \u00e8 tonda AND la palla \u00e8 verde AND la palla \u00e8 nella scatola </p> <p>Questo predicato altro non \u00e8 se un prodotto logico tra tre predicati semplici e, proprio come nel caso pi\u00f9 semplice, sar\u00e0 vero se e solo se tutti i predicati sono veri.</p> <p>Si pu\u00f2 ragionare allo stesso modo per la somma logica. Immaginiamo di avere il predicato composto:</p> <p> la palla \u00e8 tonda OR la palla \u00e8 verde OR la palla \u00e8 nella scatola </p> <p>In questo caso, il predicato composto sar\u00e0 sempre vero, a meno che tutti i singoli predicati non siano falsi.</p> <p>A questo punto \u00e8 possibile generalizzare la somma ed il prodotto logico come segue. Indicando con \\(+\\) l'operazione di somma logica, e con \\(\\times\\) quella di prodotto logico, varranno le seguenti regole.</p> Somma logica di \\(n\\) variabili indipendenti <p>Date \\(n\\) variabili binarie indipendenti, la loro somma logica \u00e8:</p> \\[ x_1 + x_2 + \\ldots + x_n = \\begin{cases} 1, &amp; \\exists x_i = 1, &amp; i \\in 1, \\ldots, n \\\\ 0, &amp; \\not \\exists x_i = 1, &amp; i \\in 1, \\ldots, n \\end{cases} \\] <p>In altre parole, il risultato della somma logica di \\(n\\) variabili \u00e8 pari ad \\(1\\) se almeno una delle \\(n\\) variabili \u00e8 anch'essa pari ad \\(1\\).</p> Prodotto logico di \\(n\\) variabili indipendenti <p>Date \\(n\\) variabili binarie indipendenti, il loro prodotto logico \u00e8:</p> \\[ x_1 \\times x_2 \\times \\ldots \\times x_n = \\begin{cases} 0, &amp; \\exists x_i = 0, &amp; i \\in 1, \\ldots, n \\\\ 1, &amp; x_1 = x_2 = \\ldots = x_n \\end{cases} \\]"},{"location":"material/01_intro/07_boole/03_ops_properties/#proprieta-delle-operazioni-logiche-fondamentali","title":"Propriet\u00e0 delle operazioni logiche fondamentali","text":"<p>Alle tre operazioni logiche fondamentali sono associate alcune propriet\u00e0 fondamentali, che richiamano le equivalenti propriet\u00e0 aritmetiche. In particolare, alle operazioni di \\(AND\\) ed \\(OR\\) sono associate tre diverse propriet\u00e0 che, come vedremo, sono concettualmente analoghe a quelle definite nell'aritmetica classica.</p>"},{"location":"material/01_intro/07_boole/03_ops_properties/#proprieta-commutativa","title":"Propriet\u00e0 commutativa","text":"<p>La prima \u00e8 la propriet\u00e0 commutativa, per la quale il risultato di somma e prodotto logico rimangono invariati cambiando l'ordine dei singoli predicati. Quindi:</p> <p> la palla \u00e8 tonda AND la palla \u00e8 verde </p> <p>equivale a:</p> <p> la palla \u00e8 verde AND la palla \u00e8 tonda </p> <p>cos\u00ec come:</p> <p> la palla \u00e8 tonda OR la palla \u00e8 verde </p> <p>equivale a:</p> <p> la palla \u00e8 verde OR la palla \u00e8 tonda </p> <p>Formalmente, dati due predicati \\(p_1, p_2\\):</p> \\[ \\begin{align} OR \\Leftrightarrow p_1 + p_2 = p_2 + p_1 \\\\ AND \\Leftrightarrow p_1 \\times p_2 = p_2 \\times p_1 \\end{align} \\] Tabelle della verit\u00e0 <p>Per dimostrare la propriet\u00e0 commutativa, possiamo usare le tabelle della verit\u00e0. Per l'operazione di \\(AND\\):</p> \\(p_1\\) \\(p_2\\) \\(p_1 \\times p_2\\) \\(p_2 \\times p_1\\) 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 <p>Per l'operazione di \\(OR\\):</p> \\(p_1\\) \\(p_2\\) \\(p_1 + p_2\\) \\(p_2 + p_1\\) 0 0 0 0 0 1 1 1 1 0 1 1 1 1 1 1"},{"location":"material/01_intro/07_boole/03_ops_properties/#proprieta-associativa","title":"Propriet\u00e0 associativa","text":"<p>La seconda propriet\u00e0 notevole \u00e8 quella associativa, per la quale \u00e8 possibile associare un prodotto o una somma logica mediante relazioni di precedenza senza per questo variare il risultato atteso. In altri termini, immaginiamo di avere i seguenti predicati:</p> <p> la palla \u00e8 tonda AND la palla \u00e8 verde AND la palla \u00e8 nella scatola </p> <p>Il valore di verit\u00e0 di questo predicato sar\u00e0 equivalente a quello dei seguenti:</p> <p> (la palla \u00e8 tonda AND la palla \u00e8 verde) AND la palla \u00e8 nella scatola </p> <p>In pratica, nel secondo predicato, verificheremo dapprima che la palla sia tonda e verde, e poi che sia nella scatola, laddove nel primo verificheremo le tre condizioni contemporaneamente. Stesse considerazioni valgono per le operazioni di somma logica. </p> <p>Causalit\u00e0 delle verifiche</p> <p>Da notare come questa formulazione abbia come ipotesi \"forte\" il fatto che non vi sia alcuna relazione di causalit\u00e0 tra le propriet\u00e0 associate. In pratica, si suppone che il fatto che si verifichi in primis che la palla sia tonda e verde non abbia alcuna influenza o causalit\u00e0 sul fatto che la palla sia nella scatola.</p> <p>Formalmente, dati \\(3\\) predicati del tipo \\(p_1,p_2,p_3\\):</p> \\[ \\begin{align} OR \\Leftrightarrow p_1 + p_2 + p_3 = p_1 + (p_2 + p_3) \\\\ AND \\Leftrightarrow p_1 \\times p_2 \\times p_3 = p_1 \\times (p_2 \\times p_3) \\end{align} \\] Tabelle della verit\u00e0 <p>Usiamo le tabelle della verit\u00e0 per verificare la propriet\u00e0 associativa. Indicando \\(p_{or}\\) il predicato originario avremo per la \\(AND\\):</p> \\(p_1\\) \\(p_2\\) \\(p_3\\) \\(p_2 \\times p_3\\) \\(p_1 \\times (p_2 \\times p_3)\\) \\(p_{or}\\) 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 1 1 <p>Mentre per la \\(OR\\):</p> \\(p_1\\) \\(p_2\\) \\(p_3\\) \\(p_2 + p_3\\) \\(p_1 + (p_2 + p_3)\\) \\(p_{or}\\) 0 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 1 1 1 1 0 1 1 1 0 0 1 1 1 1 1 0 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1"},{"location":"material/01_intro/07_boole/03_ops_properties/#proprieta-distributiva","title":"Propriet\u00e0 distributiva","text":"<p>L'ultima propriet\u00e0 notevole \u00e8 quella distributiva del prodotto rispetto alla somma. Anche questa propriet\u00e0 richiama la corrispondente propriet\u00e0 aritmetica, e pu\u00f2 essere esplicitata come segue.</p> <p>Vogliamo valutare che:</p> <p> la palla \u00e8 tonda AND la palla \u00e8 verde OR la palla \u00e8 tonda AND la palla \u00e8 nella scatola </p> <p>In pratica, vorremo valutare se la palla sia tonda e verde (primo prodotto logico) oppure se sia tonda e nella scatola (secondo prodotto logico). La propriet\u00e0 distributiva ci dice che il precedente predicato equivale a scrivere:</p> <p> la palla \u00e8 tonda AND (la palla \u00e8 verde OR la palla \u00e8 nella scatola) </p> <p>Staremo quindi valutando se la palla \u00e8 verde oppure nella scatola e, conseguentemente, se sia tonda. Formalmente, quindi, dati tre predicati \\(p_1, p_2, p_3\\):</p> \\[ p_1 \\times p_2 + p_1 \\times p_3 = p_1 \\times (p_2 + p_3) \\] Tabelle della verit\u00e0 <p>Anche in questo caso, le tabelle della verit\u00e0 ci permettono di confermare l'eguaglianza. Indicando \\(p_{or}\\) il predicato originario, avremo:</p> \\(p_1\\) \\(p_2\\) \\(p_3\\) \\(p_1 \\times p_2\\) \\(p_1 \\times p_3\\) \\(p_{or}\\) 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 1 0 1 0 0 1 0 0 0 1 0 1 0 1 1 0 1 1 0 0 0 1 1 1 1 1 1 <p>Se adesso indichiamo con \\(p_{d}\\) il predicato associato alla propriet\u00e0 distributiva, avremo:</p> \\(p_1\\) \\(p_2\\) \\(p_3\\) \\(p_2 + p_3\\) \\(p_d\\) 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 1 0 1 1 0 0 1 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 1 1"},{"location":"material/01_intro/07_boole/03_ops_properties/#identita-delloperatore-not","title":"Identit\u00e0 dell'operatore \\(NOT\\)","text":"<p>Chiudiamo questa carrellata illustrando brevemente tre delle identit\u00e0 che valgono per l'operatore \\(NOT\\).</p> <p>Partiamo dalla seguente espressione:</p> <p> la palla \u00e8 tonda OR la palla non \u00e8 tonda </p> <p>In questo caso, vediamo come il precedente predicato composto sia sempre vero. Ci\u00f2 \u00e8 legato al fatto che i due predicati semplici si complementano andando, se considerati congiuntamente, a coprire la totalit\u00e0 dei possibili casi esperibili nel mondo reale. Volendo essere meno formali, quindi, potremmo dire che il precedente predicato esprime il concetto al fatto che la palla o \u00e8 tonda, o non lo \u00e8.</p> <p>Formalmente, quindi, potremo scriivere:</p> \\[ p + \\overline{p} = 1 \\] <p>Consideriamo adesso la seguente espressione:</p> <p> la palla \u00e8 tonda AND la palla non \u00e8 tonda </p> <p>Estendendo il ragionamento precedente, questo predicato non potr\u00e0 mai essere vero, perch\u00e9 implicherebbe che la palla sia contestualmente tonda e non tonda, il che, ovviamente, non avviene nella realt\u00e0. Formalmente:</p> \\[ p + \\overline{p} = 0 \\] <p>Infine, consideriamo l'espressione:</p> <p> NOT (NOT la palla \u00e8 tonda) </p> <p>In pratica, l'espressione all'interno delle parentesi nega il predicato, implicando che la palla non sia tonda. Tuttavia, il \\(NOT\\) esterno nega la negazione, il che ovviamente ci riporta al caso iniziale. Formalmente:</p> \\[ \\overline{\\overline{x}} = x \\] <p>Queste sono le basi per l'interpretazione dei principi dell'algebra booleana; nella prossima lezione andremo ad approfondire alcune leggi notevoli.</p>"},{"location":"material/01_intro/07_boole/04_laws/","title":"1.7.4 - Leggi dell'algebra booleana","text":"<p>Nella scorsa lezione abbiamo esplicitato le pi\u00f9 importanti propriet\u00e0 delle operazioni fondamentali dell'algebra booleana. Vediamo quindi quali sono alcune tra le leggi fondamentali che governano questa disciplina.</p>"},{"location":"material/01_intro/07_boole/04_laws/#legge-dellidempotenza","title":"Legge dell'idempotenza","text":"<p>Immaginiamo il seguente predicato:</p> <p> la palla \u00e8 tonda OR vero </p> <p>Il predicato \u00e8 una somma logica tra il valore vero ed una proposizione semplice. Come \u00e8 facile intuire, il predicato composto sar\u00e0 sempre vero, grazie alla presenza del valore vero. Se invece il predicato composto fosse nella forma:</p> <p> la palla \u00e8 tonda OR falso </p> <p>allora sar\u00e0 vero se e solo se la palla \u00e8 tonda. Proviamo adesso a scrivere il seguente predicato composto:</p> <p> la palla \u00e8 tonda OR la palla \u00e8 tonda </p> <p>In questo caso, il risultato sar\u00e0 vero se la palla \u00e8 tonda (e, quindi, il predicato \\(p\\) \u00e8 vero), e falso altrimenti (e, quindi, se \\(p\\) \u00e8 falso). Formalmente, avremo che:</p> \\[ \\begin{cases} p + 1 = 1 \\\\ p + 0 = p \\\\ p + p = p \\end{cases} \\] <p>Appare quindi evidente come lo \\(0\\) logico, ovvero il falso, sia l'elemento neutro della somma logica, ovvero l'elemento che, se applicato in somma logica ad un predicato \\(p\\), ne mantiene inalterata la veridicit\u00e0.</p> <p>Cosa accade se consideriamo il prodotto logico al posto della somma? Nel primo caso, avremo:</p> <p> la palla \u00e8 tonda AND vero </p> <p>La precedente proposizione \u00e8 strettamente dipendente dal valore di \\(p\\): infatti, se \\(p\\) \u00e8 vero, anche il predicato lo sar\u00e0. Il seguente predicato invece:</p> <p> la palla \u00e8 tonda AND falso </p> <p>sar\u00e0 sempre falso, in quanto risulter\u00e0 essere il prodotto di un predicato logico \\(p\\) per uno zero logico. Infine:</p> <p> la palla \u00e8 tonda AND la palla \u00e8 tonda </p> <p>sar\u00e0 vero se la palla \u00e8 tonda, e falso altrimenti. Volendo scrivere formalmente queste relazioni, avremo che:</p> \\[ \\begin{cases} p \\times 1 = p \\\\ p \\times 0 = 0 \\\\ p \\times p = p \\end{cases} \\] <p>In questo caso, quindi, sar\u00e0 il vero, ovvero l'\\(1\\) logico, l'elemento neutro.</p> <p>Queste condizioni ci permettono di derivare le leggi dell'idempotenza, definibili come:</p> \\[ \\begin{cases} p + p = p \\\\ p \\times p = p \\end{cases} \\]"},{"location":"material/01_intro/07_boole/04_laws/#legge-dellassorbimento","title":"Legge dell'assorbimento","text":"<p>Partiamo dalla seguente espressione.</p> <p> la palla \u00e8 tonda OR la palla \u00e8 tonda AND la palla \u00e8 verde </p> <p>Analizziamola partendo dal prodotto logico.</p> <ul> <li>Se la palla \u00e8 tonda e verde, il prodotto sar\u00e0 vero. In questo caso, quindi, la somma logica sar\u00e0 sicuramente vera, ed il risultato sar\u00e0 vero.</li> <li>Se la palla \u00e8 tonda ma non verde, il prodotto sar\u00e0 falso. Tuttavia, la somma logica sar\u00e0 comunque vera, per cui il risultato complessivo sar\u00e0 sempre vero.</li> <li>Se la palla \u00e8 verde ma non tonda, il prodotto sar\u00e0 falso, e la somma logica sar\u00e0 anch'essa falsa, per cui il risultato complessivo sar\u00e0 falso.</li> </ul> <p>Da qui deriva la formulazione della legge dell'assorbimento, che dice che, dati due predicati \\(p_1\\) e \\(p_2\\):</p> \\[ p_1 + p_1 \\times p_2 = p_1 \\] <p>Possiamo verificare il tutto usando delle opportune tabelle della verit\u00e0, ponendo \\(p_{AND} = p_1 \\times p_2\\) e \\(p_{c} = p_1 + p_{AND}\\).</p> \\(p_1\\) \\(p_2\\) \\(p_{AND}\\) \\(p_{c}\\) 0 0 0 0 1 0 0 1 0 1 0 0 1 1 1 1"},{"location":"material/01_intro/07_boole/04_laws/#leggi-di-de-morgan","title":"Leggi di De Morgan","text":"<p>Le leggi di De Morgan mettono in relazione le funzioni base dell'algebra booleana, ovvero le funzioni \\(OR\\), \\(AND\\) e \\(NOT\\), dimostrandone l'intrinseca ridondanza. In altre parole, ogni operazione logica pu\u00f2 essere espressa in funzione delle altre. Ci\u00f2 pu\u00f2 essere sfruttato per trasformare una funzione booleana complessa, rendendola pi\u00f9 facilmente realizzabile dal punto di vista circuitale.</p> <p>Per comprendere le leggi di De Morgan, possiamo partire dal solito esempio.</p> <p> NOT (la palla \u00e8 tonda OR la palla \u00e8 verde) </p> <p>L'espressione precedente valuta la veridicit\u00e0 della negazione della somma logica tra i predicati la palla \u00e8 tonda e la palla \u00e8 verde. In pratica, il predicato tra parentesi \\(p_{OR}\\) sar\u00e0 vero soltanto se la palla \u00e8 tonda o verde. Tuttavia, dato che il predicato composto nega \\(p_{OR}\\), per cui il risultato complessivo sar\u00e0 vero soltanto se \\(p_{OR}\\) \u00e8 falso (e quindi se la palla non \u00e8 tonda e non \u00e8 verde). Questo ci porta ad un'altra possibile formulazione del predicato:</p> <p> NOT la palla \u00e8 tonda AND NOT la palla \u00e8 verde </p> <p>In questo caso, effettuiamo il prodotto logico tra due negazioni, ottenendo un valore vero se e solo se entrambi i predicati negati sono originariamente falsi.</p> <p>Analogamente possiamo verificare che un predicato nella forma:</p> <p> NOT (la palla \u00e8 tonda AND la palla \u00e8 verde) </p> <p>sar\u00e0 vero soltanto se la palla non \u00e8 tonda o non \u00e8 verde, per cui la forma equivalente \u00e8:</p> <p> NOT la palla \u00e8 tonda OR NOT la palla \u00e8 verde </p> <p>Queste equivalenze possono essere scritte formalmente come segue:</p> \\[ \\begin{align} \\overline{(x_1 + x_2)} = \\overline{x_1} \\times \\overline{x_2} \\\\ \\overline{(x_1 \\times x_2)} = \\overline{x_1} + \\overline{x_2} \\end{align} \\] <p>Le equazioni 1 e 2 rappresentano le due leggi di De Morgan.</p> <p>Tabelle della verit\u00e0</p> <p>Verifichiamo le leggi di De Morgan sfruttando le tabelle della verit\u00e0. Per la prima legge potremo scrivere:</p> \\(x_1\\) \\(x_2\\) \\(x_1 + x_2\\) \\(\\overline{x_1 + x_2}\\) 0 0 0 1 0 1 1 0 1 0 1 0 1 1 1 0 <p>che equivale a:</p> \\(\\overline{x_1}\\) \\(\\overline{x_2}\\) \\(\\overline{x_1} \\times \\overline{x_2}\\) 1 1 1 1 0 0 0 1 0 0 0 0 <p>Per la seconda:</p> \\(x_1\\) \\(x_2\\) \\(x_1 \\times x_2\\) \\(\\overline{x_1 \\times x_2}\\) 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 0 <p>che equivale a:</p> \\(\\overline{x_1}\\) \\(\\overline{x_2}\\) \\(\\overline{x_1} + \\overline{x_2}\\) 1 1 1 1 0 1 0 1 1 0 0 0"},{"location":"material/01_intro/07_boole/04_laws/#tabelle-della-verita-per-le-funzioni-composte","title":"Tabelle della verit\u00e0 per le funzioni composte","text":"<p>Le tabelle della verit\u00e0 possono essere utilizzate anche per definire funzioni composte e non riconducibili a combinazioni \"standard\" delle tre funzioni logiche fondamentali. Immaginiamo ad esempio di avere i tre seguenti predicati:</p> <p> la palla \u00e8 tonda </p> <p> la palla \u00e8 verde </p> <p> la palla \u00e8 nella scatola </p> <p>Vogliamo ottenere una funzione logica \\(F\\) che sia vera quando solo e soltanto due dei predicati precedenti (che, per comodit\u00e0, chiameremo \\(p_1, p_2, p_3\\)) sono veri. Per caratterizzare \\(F\\), allora, potremo scrivere la tabella delle verit\u00e0 come:</p> \\(p_1\\) \\(p_2\\) \\(p_3\\) \\(F\\) 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 0 <p>Determinare come si combinano i singoli predicati mediante le operazioni fondamentali pu\u00f2 essere particolarmente complesso. Possiamo quindi effettuare una sorta di reverse engineering della tabella delle verit\u00e0, scoprendo quindi che:</p> <ul> <li>\\(F\\) \u00e8 vero quando \\(p_2\\) e \\(p_3\\) sono veri, e \\(p_1\\) \u00e8 falso;</li> <li>\\(F\\) \u00e8 vero quando \\(p_1\\) e \\(p_3\\) sono veri, e \\(p_2\\) \u00e8 falso;</li> <li>\\(F\\) \u00e8 vero quando \\(p_1\\) e \\(p_2\\) sono veri, e \\(p_3\\) \u00e8 falso.</li> </ul> <p>Ne consegue che:</p> \\[ F = \\overline{p_1} p_2 p_3 + p_1 \\overline{p_2} p_3 + p_1 p_2 \\overline{p_3} \\] <p>In altre parole, la nostra funzione composta sar\u00e0 vera se una delle tre condizioni composte \u00e8 verificata:</p> <ul> <li>la palla \u00e8 verde e nella scatola, ma non tonda;</li> <li>la palla \u00e8 tonda e nella scatola, ma non verde;</li> <li>la palla \u00e8 tonda e verde, ma non nella scatola.</li> </ul> <p>Questa tecnica pu\u00f2 essere quindi usata per creare funzioni composte di complessit\u00e0 arbitraria.</p>"},{"location":"material/01_intro/07_boole/04_laws/#conclusioni","title":"Conclusioni","text":"<p>Nel corso di questa parte, abbiamo visto quali sono i concetti base dell'informatica, parlando della trattazione numerica binaria e delle relazioni legate all'algebra booleana. Nella prossima parte, prenderemo dimestichezza con le basi della programmazione.</p>"},{"location":"material/02_programming/01_algorithms/lecture/","title":"2.1 Introduzione agli algoritmi","text":"<p>In questa sezione discuteremo uno degli strumenti fondamentali dell'informatica, ma non solo: gli algoritmi.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#problemi-e-soluzioni","title":"Problemi e soluzioni","text":"<p>Tutti avremo notato come la realt\u00e0 che ci circonda sia piena di problemi. Ad esempio:</p> <ul> <li>come mi preparer\u00f2 da mangiare per stasera?</li> <li>riuscir\u00f2 ad avere una misera pensione?</li> <li>come monto il mobile Ikea?</li> <li>come supero l'esame di Informatica?</li> </ul> <p>Questi problemi (soprattutto l'ultimo) sono risolvibili utilizzando un semplice approccio che, di base, consiste nell'individuare una soluzione. Ad esempio:</p> <ul> <li>per mangiare, dovr\u00f2 prendere gli ingredienti, mescolarli secondo una ricetta e, una volta completata la preparazione, godermeli.</li> <li>per avere una misera pensione, devo lavorare per i prossimi (tanti) anni, versare i contributi, crearmi un fondo pensione integrativo, ed incrociare le dita (soprattutto).</li> <li>per montare il mobile Ikea, devo seguire le singole, comprensibilissime, istruzioni presenti sul manuale di montaggio.</li> <li>per superare l'esame, devo studiare l'intero programma e preparare gli opportuni esercizi.</li> </ul> <p>Nota</p> <p>Per l'ultima soluzione, si consiglia anche l'uso di strumenti scaramantici e votivi di vario tipo.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#formulazione-di-un-problema","title":"Formulazione di un problema","text":"<p>A questo punto \u00e8 lecita una domanda: cosa significa formulare un problema? E' presto detto: il problema \u00e8 un quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Ok, cerchiamo di scomporre questa formulazione.</p> <ol> <li>Il problema \u00e8 un quesito, ovvero una domanda che richiede una risposta, alle volte aperta (cosa mangio? dove andiamo?), altre chiusa (come monto il mobile?).</li> <li>Per trovare una soluzione al quesito posto dal problema, avremo bisogno di almeno un ente risolutore, inteso come entit\u00e0, fisica o logica, che si occuper\u00e0 di implementare tutti gli step atti a risolvere il problema. Ad esempio, nel caso del mobile Ikea, l'ente risolutore saremo noi, o chi ci aiuter\u00e0 a montarlo.</li> <li>L'ente deve poter quindi partire da elementi noti e condizioni fissate e, quindi, avere una visione dello stato iniziale del mondo. Ad esempio, dovr\u00e0 conoscere il senso della vite (orario).</li> </ol> <p>Alcuni esempi di quesito, ente e stato iniziale sono riportati nella seguente tabella.</p> Quesito Ente risolutore Stato iniziale del mondo Come montare il mobile che abbiamo appena acquistato dall'IKEA? Montatore Collocazione desiderata del mobile, numero e tipo di pezzi, attrezzi necessari... Come calcolare l'ipotenusa di un triangolo rettangolo? Studente Base, altezza, teorema di Pitagora Come dimostare l'ipotesi di Riemann? Studente Banali regole basilari di aritmetica"},{"location":"material/02_programming/01_algorithms/lecture/#risoluzione-di-un-problema","title":"Risoluzione di un problema","text":"<p>DA QUI</p>"},{"location":"material/02_programming/01_algorithms/lecture/#22-risolvere-un-problema","title":"2.2 - Risolvere un problema","text":"<p>La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati: i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni, o stati, e le differenze tra di essi.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#221-problemi-e-soluzioni","title":"2.2.1 Problemi e soluzioni","text":"<p>Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come. Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema.</p> <p>Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi, come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\).</p> <p>Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#222-costruire-la-soluzione","title":"2.2.2 - Costruire la soluzione","text":"<p>Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero:</p> <ul> <li>le operazioni atomiche disponibili;</li> <li>il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse.</li> </ul>"},{"location":"material/02_programming/01_algorithms/lecture/#2221-operazioni-atomiche","title":"2.2.2.1 Operazioni atomiche","text":"<p>Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere:</p> <ul> <li>sommare due numeri;</li> <li>fare un passo in avanti;</li> <li>finalizzare una transazione sul proprio conto corrente bancario.</li> </ul> <p>Esempi di operazioni non atomiche sono invece:</p> <ul> <li>risolvere un'equazione di secondo grado;</li> <li>correre per dieci metri;</li> <li>effettuare un versamento ed un prelievo sul proprio conto corrente bancario.</li> </ul> <p>Nota sulla somma</p> <p>Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una</p> <p>Nota sul conto corrente bancario</p> <p>La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.).</p>"},{"location":"material/02_programming/01_algorithms/lecture/#2222-combinare-operazioni-atomiche","title":"2.2.2.2 Combinare operazioni atomiche","text":"<p>Le operazioni atomiche possono essere combinate in due modi:</p> <ul> <li>effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario);</li> <li>effettuandole in parallelo.</li> </ul> <p>Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero:</p> <ul> <li>mantenere indipendenti le singole operazioni;</li> <li>coordinare pi\u00f9 esecutori, o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo.</li> </ul> <p>Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino?</p> <p>Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#2223-determinare-linsieme-di-operatori","title":"2.2.2.3 Determinare l'insieme di operatori","text":"<p>Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#2224-da-soluzione-ad-algoritmo","title":"2.2.2.4 Da soluzione ad algoritmo","text":"<p>La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto).</p> <p>L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#23-un-esempio","title":"2.3 - Un esempio","text":"<p>Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#231-formulazione-del-problema","title":"2.3.1 - Formulazione del problema","text":"<p>Dati due numeri interi \\(c_1\\) e \\(c_2\\), rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\), calcolarne l'ipotenusa \\(i\\).</p>"},{"location":"material/02_programming/01_algorithms/lecture/#232-dati","title":"2.3.2 - Dati","text":"<p>Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#233-algoritmo-risolutivo-in-operazioni-atomiche-o-quasi","title":"2.3.3 - Algoritmo risolutivo (in operazioni atomiche, o quasi)","text":"<ol> <li>Calcolare il quadrato di \\(c_1\\).</li> <li>Calcolare il quadrato di \\(c_2\\).</li> <li>Sommare i quadrati calcolati ai punti 1 e 2.</li> <li>Calcolare la radice quadrata della somma ottenuta al punto 3.</li> </ol>"},{"location":"material/02_programming/01_algorithms/lecture/#234-svolgimento-numerico","title":"2.3.4 Svolgimento numerico","text":""},{"location":"material/02_programming/01_algorithms/lecture/#dati","title":"Dati","text":"\\[ \\begin{eqnarray} c_1 &amp;= 3 \\\\ c_2 &amp;= 4 \\\\ \\end{eqnarray} \\]"},{"location":"material/02_programming/01_algorithms/lecture/#passi-dellalgoritmo","title":"Passi dell'algoritmo","text":"\\[ \\begin{eqnarray} \\text{Step 1} &amp; \\rightarrow &amp; {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} &amp; \\rightarrow &amp; {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} &amp; \\rightarrow &amp; v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} &amp; \\rightarrow &amp; \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] <p>Il risultato \u00e8 \\(v_4 = 5\\).</p>"},{"location":"material/02_programming/01_algorithms/lecture/#24-caratteristiche-degli-algoritmi-risolutivi","title":"2.4 - Caratteristiche degli algoritmi risolutivi","text":"<p>Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali.</p> <ol> <li>finitezza: gli algoritmi sono finiti, sia dal punto di vista spaziale, sia da quello temporale;</li> <li>generalit\u00e0: gli algoritmi sono generici, ovvero rappresentano una soluzione ad un'intera classe di problemi;</li> <li>completezza: gli algoritmi sono completi, e quindi possono risolvere tutte le istanze del problema;</li> <li>non ambiguit\u00e0: gli algoritmi non sono ambigui, e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili;</li> <li>eseguibilit\u00e0: gli algoritmi sono eseguibili, nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo.</li> </ol> <p>Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8:</p> <ol> <li>pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito;</li> <li>pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi);</li> <li>le istruzioni sono chiare e non equivocabili;</li> <li>le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata.</li> </ol>"},{"location":"material/02_programming/01_algorithms/lecture/#241-determinismo","title":"2.4.1 Determinismo","text":"<p>Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico.</p> <p>Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso.</p>"},{"location":"material/02_programming/01_algorithms/lecture/#242-input-output-e-variabili","title":"2.4.2 Input, Output e Variabili","text":"<p>Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output.</p> <p>E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici.</p> <p>Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO).</p> <p>Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto, chiamati variabili. Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.</p>"},{"location":"material/02_programming/02_structured/01_intro/lecture/","title":"2.2.1 La Programmazione Strutturata","text":"<p>Ai pi\u00f9 \"esperti\" tra i lettori sar\u00e0 capitato di leggere del codice prodotto negli anni '70 ed '80, in linguaggi come il BASIC, simile a qualcosa di questo tipo:</p> <pre><code>10 dim i\n20 i = 0\n30 i = i + 1\n40 if i &lt;= 10 then goto 70\n50 print \"Programma terminato.\"\n60 end\n70 print i &amp; \" al quadrato = \" &amp; i * i\n80 goto 30\n</code></pre> <p>Un codice in questa forma (per la cronaca: il codice \u00e8 tratto direttamente da Wikipedia) \"intreccia\" le istruzioni tra loro: ad esempio, alla riga <code>80</code> notiamo come la presenza della (famigerata) istruzione <code>goto</code> imponga di tornare alla riga <code>30</code>, con la <code>70</code> richiamata dalla <code>40</code> qualora si verifichi una determinata condizione.</p> <p>Il codice appare quindi simile ad un \"piatto di spaghetti\", i quali si intrecciano ed ingarbugliano tra loro, confondendosi alla vista; ed \u00e8 proprio per questo che scrivere un codice com il precedente \u00e8 associato alla pratica, divenuta con tempo un antipattern (ovvero, una pratica da sconsigliare), dello spaghetti coding.</p> <p>Lo spaghetti coding rende il nostro programma difficile da interpretare, non solo da parte di altri, ma anche da noi stessi quando lo andiamo a riaprire dopo un po' di tempo. Per questo motivo, nel tempo, sono andati sempre pi\u00f9 diffondendosi nuovi e pi\u00f9 efficaci paradigmi di programmazione, come quella imperativa, orientata agli oggetti e, pi\u00f9 recentemente, funzionale. Tutti, per\u00f2, partivano da un presupposto: dare una struttura al codice. E, in tal senso, l'assunto da cui si parte \u00e8 sempre e solo uno, ovvero il teorema di Bohm e Jacopini.</p>"},{"location":"material/02_programming/02_structured/01_intro/lecture/#il-teorema-di-bohm-jacopini","title":"Il teorema di Bohm-Jacopini","text":"<p>Il teorema di Bohm - Jacopini venne enunciato nel 1966, ed afferma che qualsiasi algoritmo pu\u00f2 essere implementato (sia sotto forma di codice, sia sotto forma di flow chart) utilizzando esclusivamente le cosiddette tre strutture di controllo, ovvero sequenza, selezione e ciclo. Le implicazioni sono ovviamente importantissime, e ci permettono di semplificare enormemente il nostro lavoro.</p> <p>In tal senso, per\u00f2, \u00e8 necessario conoscere in maniera appropriata le diverse strutture di controllo, che saranno quindi illustrate di seguito.</p>"},{"location":"material/02_programming/02_structured/01_intro/lecture/#sequenza","title":"Sequenza","text":"<p>La sequenza prevede che una serie di istruzioni siano realizzate sequenzialmente, ovvero l'una in cascata all'altra. Immaginiamo ad esempio di dover calcolare la distanza euclidea tra due punti, ovvero <code>a</code> e <code>b</code>, di cui conosciamo le coordinate \\((x_a, y_a)\\) ed \\((x_b, y_b)\\). In pseudo-codice (ovvero, in un linguaggio simbolico usato per esprimere l'algoritmo senza per questo richiamare necessariamente un linguaggio di programmazione esistente) potremmo esprimere la sequenza come:</p> <pre><code>distanza_x = (x_a - x_b)^2;\ndistanza_y = (y_a - y_b)^2;\ndistanza = (distanza_x + distanza_y)^(1/2);\n</code></pre> <p>La sequenza di operazioni sar\u00e0 quella mostrata nella seguente figura:</p> <p></p> <p>Come si pu\u00f2 notare, il flusso delle istruzioni \u00e8 unico, e queste sono eseguite l'una di seguito all'altra, ovverosia in maniera sequenziale.</p>"},{"location":"material/02_programming/02_structured/01_intro/lecture/#selezione","title":"Selezione","text":"<p>La selezione prevede invece che il flusso delle istruzioni possa diramarsi tra due diversi rami, mutualmente esclusivi, al verificarsi o meno di una condizione.</p> <p>In particolare, la selezione \u00e8 rappresentata mediante il costrutto IF - THEN - ELSE, il cui funzionamento pu\u00f2 essere riassunto in linguaggio naturale come segue:</p> <p>L'IF - THEN - ELSE in linguaggio naturale</p> <p>IF (se) la condizione \u00e8 verificata, THEN (allora) esegui le istruzioni su di un ramo, ELSE (altrimenti) esegui le istruzioni sull'altro ramo.</p> <p>Per comprendere meglio il funzionamento della selezione, immaginiamo di voler comparare due numeri \\(a\\) e \\(b\\). Di nuovo, esprimiamo la selezione in pseudo-codice:</p> <pre><code>a = 1;\nb = 2;\nif (a &gt; b):\n    then scrivi \"a \u00e8 maggiore di b\"\nelse:\n    scrivi \"b \u00e8 maggiore di a\"\n</code></pre> <p>I due rami del programma sono quindi rappresentati dal THEN e dall'ELSE, mentre la condizione dall'IF. Graficamente:</p> <p></p>"},{"location":"material/02_programming/02_structured/01_intro/lecture/#i-costrutti-else-if-e-switch","title":"I costrutti ELSE IF e SWITCH","text":"<p>Il costrutto IF - THEN - ELSE limita i rami in cui un programma pu\u00f2 derivare a due. Tuttavia, nella realt\u00e0, potrebbe essere necessario avere pi\u00f9 rami; in questi casi, ci viene in aiuto il costrutto ELSE IF, che permette di specificare ulteriori divergenze del programma. Ad esempio:</p> <pre><code>a = 1;\nb = 2;\nif (a &gt; b):\n    then scrivi \"a \u00e8 maggiore di b\"\nelse if (a uguale b):\n    then scrivi \"a \u00e8 uguale a b\"\nelse:\n    scrivi \"b \u00e8 maggiore di a\"\n</code></pre> <p>Vediamo subito come il costrutto ci permetta di ovviare ad una \"mancanza\" del programma precedente, gestendo anche il caso in cui \\(a\\) sia uguale a \\(b\\). Dal punto di vista del diagramma di flusso, l'ELSE IF \u00e8 rappresentabile mediante una \"cascata\" di selezioni:</p> <p></p> <p>Il costrutto SWITCH \u00e8 usato per verificare che una certa variabile assuma un dato valore, chiamato <code>case</code> (da cui il nome SWITCH-CASE con cui il costrutto \u00e8 anche conosciuto), normalmente non relativo ad un intervallo, quanto piuttosto ben specifico. Qualora la variabile di controllo rispetti il valore definito da un case, le istruzioni ivi contenute saranno eseguite fino all'uscita dal costrutto.</p> <p>Lo SWITCH ha inoltre un case di default, indicato con la parola chiave omonima, che sar\u00e0 eseguito qualora la variabile da verificare non rispetti alcuno dei case precedenti. Ad esempio:</p> <pre><code>a = 1;\nswitch (a)\n    case 1:\n        scrivi \"Uguale ad uno!\";\n    case 2:\n        scrivi \"Uguale a due!\"\n    case 3:\n        scrivi \"Uguale a tre!\";\n    default:\n        scrivi \"Non saprei!\";\n</code></pre>"},{"location":"material/02_programming/02_structured/01_intro/lecture/#iterazione","title":"Iterazione","text":"<p>L'ultimo tipo di struttura di controllo \u00e8 l'iterazione, chiamata anche ciclo; in questo caso, un'istruzione verr\u00e0 reiterata fino a che una certa condizione \u00e8 verificata.</p> <p>Nota</p> <p>In un certo senso, l'iterazione \u00e8 una \"summa\" di struttura e selezione.</p> <p>Per comprendere il funzionamento dell'iterazione, proviamo ad utilizzarla, sempre in pseudocodice, per scrivere i numeri che vanno da uno a dieci:</p> <pre><code>i = 1;\nfor (i che va da 1 a 10):\n    scrivi 'i';\nendfor\nscrivi 'fine';\n</code></pre> <p>Schematizziamo il funzionamento dell'iterazione nella figura successiva:</p> <p></p> <p>Risulta particolarmente interessante notare come l'iterazione (espressa in questo caso da un'istruzione FOR) non faccia altro che verificare una condizione su una variabile contatore (ovvero che i sia minore od uguale a 10), modificando la stessa ad ogni iterazione. Una volta che la condizione sul contatore non sar\u00e0 pi\u00f9 verificata, il programma continuer\u00e0 la sua esecuzione.</p> <p>Nota</p> <p>Modificare la variabile contatore ad ogni iterazione \u00e8 estremamente importante. Se il contatore non fosse mai modificato, infatti, il programma non potrebbe mai uscire dal ciclo.</p>"},{"location":"material/02_programming/02_structured/01_intro/lecture/#costrutti-for-e-while-do","title":"Costrutti FOR e WHILE-DO","text":"<p>Tradizionalmente, sono usati due costrutti per implementare una struttura iterativa, ovvero il costrutto FOR (che abbiamo visto in precedenza) ed il costrutto WHILE-DO.</p> <p>La differenza principale tra i due costrutti sta nel fatto che il FOR viene normalmente usato quando il numero di iterazioni \u00e8 conosciuto a priori, mentre il WHILE-DO quando non si conosce il numero di iterazioni, e si vuole semplicemente verificare una condizione. Ad esempio:</p> <pre><code>condizione = vero;\nwhile (condizione diverso da falso):\n    do [...] // istruzioni\n    aggiorna condizione;\nendwhile\n</code></pre> <p>In pratica, il costrutto WHILE-DO verifica ad ogni iterazione che la condizione sia vera; se ci\u00f2 avviene, sono eseguite le istruzioni specificate nel DO, ed \u00e8 aggiornata la condizione (che, prima o dopo, non dovr\u00e0 essere pi\u00f9 verificata).</p> <p>L'importanza di aggiornare la condizione</p> <p>Nel WHILE-DO, l'importanza dell'aggiornamento della condizione \u00e8 ancora pi\u00f9 evidente rispetto al FOR, ed \u00e8 molto spesso delegata al programmatore. Ci\u00f2 comporta maggiore libert\u00e0 nell'aggiornamento della condizione, ma anche maggiori responsabilit\u00e0 (semi-cit.).</p> <p>Il costrutto DO-WHILE</p> <p>Esiste una variante del costrutto WHILE-DO chiamata DO-WHILE, nella quale le istruzioni specificate nel DO vengono effettuate prima della verifica della condizione. Non tutti i linguaggi di programmazione supportano tale costrutto; inoltre, con pochi accorgimenti, \u00e8 possibile usare indifferentemente il WHILE-DO ed il DO-WHILE. Tuttavia, occorre tener presente che il DO-WHILE sar\u00e0 eseguito almeno una volta, dato che la condizione \u00e8 verificata dopo l'esecuzione delle istruzioni, mentre il WHILE-DO potrebbe non essere mai eseguito, dato che la condizione \u00e8 verificata prima dell'esecuzione delle istruzioni.</p>"},{"location":"material/02_programming/02_structured/01_intro/lecture/#esercizi","title":"Esercizi","text":"<ol> <li>Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto WHILE-DO.</li> <li>Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto SWITCH.</li> </ol>"},{"location":"material/02_programming/02_structured/02_flow_charts/lecture/","title":"2.2.2 I diagrammi di flusso","text":"<p>Abbiamo visto come </p> <p>In una delle lezioni precedenti, abbiamo visto come un algoritmo pu\u00f2 essere espresso come una sequenza arbitrariamente complessa di operazioni atomiche.</p> <p>Detta sequenza, ovviamente, deve essere in qualche modo \"fissata\", di modo da indirizzare il funzionamento dell'algoritmo secondo le modalit\u00e0 desiderate. In tal senso, la tentazione potrebbe essere quella di limitarsi a tenere a mente i passi della sequenza di istruzioni, ed implementarle di getto. Tuttavia, questo non \u00e8 il modo migliore per farlo, in quanto risulta essere abbastanza complesso gestire tali informazioni all'aumentare della complessit\u00e0 dell'algoritmo.</p> <p>Un'altra soluzione potrebbe essere quella di scrivere le istruzioni su un qualche tipo di supporto o documento; tuttavia, la soluzione migliore \u00e8 quella di affidarsi a degli strumenti appositamente predisposti in tal senso, ovvero i diagrammi di flusso.</p>"},{"location":"material/02_programming/02_structured/02_flow_charts/lecture/#cosa-sono-i-diagrammi-di-flusso","title":"Cosa sono i diagrammi di flusso?","text":"<p>I diagrammi di flusso (in inglese flow charts) sono uno strumento utile a gestire il flusso delle istruzioni.</p> <p>Un flow chart \u00e8 uno strumento prettamente visivo, atto a schematizzare il flusso delle singole istruzioni di un algoritmo. In tal modo, diventa estremamente pi\u00f9 semplice scrivere l'algoritmo, e valutare come i dati cambiano all'interno dello stesso.</p>"},{"location":"material/02_programming/02_structured/02_flow_charts/lecture/#quali-sono-le-componenti-fondamentali","title":"Quali sono le componenti fondamentali?","text":"<p>Un diagramma di flusso pu\u00f2 avere al suo interno diverse componenti, le pi\u00f9 importanti delle quali sono visualizzate nella tabella successiva.</p> <p></p> <p>In particolare:</p> <ul> <li>una ellisse indica l'inizio o la fine dell'algoritmo, ed andrebbe sempre apposta;</li> <li>un rettangolo indica una singola istruzione (o anche un gruppo di istruzioni) da eseguire nel programma;</li> <li>un parallelogramma indica un input o un output;</li> <li>un rombo indica una ramificazione nel percorso dell'algoritmo, legata prevalentemente alla verifica di una condizione;</li> <li>infine, le frecce sono usate per collegare tra loro diverse parti dello stesso algoritmo.</li> </ul>"},{"location":"material/02_programming/02_structured/02_flow_charts/lecture/#un-esempio","title":"Un esempio","text":"<p>Nella seguente figura mostriamo un esempio di diagramma di flusso.</p> <p></p> <p>Vediamo come il diagramma inizi con un'ellisse, che sar\u00e0 contrassegnata dalla scritta START (inserita arbitrariamente). Immediatamente dopo, vi sar\u00e0 la lettura di due variabili, ovvero \\(c_1\\) e \\(c_2\\); a quel punto, vi sar\u00e0 l'assegnazione di altre tre variabili, con infine la variabile \\(v_3\\) scritta su un dispositivo di output, seguita dal simbolo di fine algoritmo.</p> <p>E' estremamente importante notare come l'assegnazione e la lettura siano, in realt\u00e0, quasi \"ambigue\" dal punto di vista della notazione: occorre quindi in tal senso fare attenzione al fatto che si stia usando un parallelogramma o un rettangolo, seguendo le regole descritte nel paragrafo 5.2.</p>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/","title":"Pseudocodifica","text":"<p>La pseudocodifica \u00e8 un linguaggio per descrivere gli algoritmi strutturati. Per farlo, dobbiamo codificare l'algoritmo in due parti:</p> <ul> <li>la prima \u00e8 quella della dichiarazione delle variabili;</li> <li>la seconda \u00e8 la descrizione delle azioni dell'algoritmo.</li> </ul>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/#tipo-delle-variabili","title":"Tipo delle variabili","text":"<p>Sappiamo che il tipo di una variabile rappresenta l'insieme dei valori che possono essere ad essa assegnati.</p> <p>SOno permessi quattro tipi, ovvero integer, real, boolean e string-q. In particoalre:</p> <ul> <li>gli integer rappresentano i numeri interi;</li> <li>i real rappresentano i numeri decimali, rappresentabili sia in notazione decmiale che in notazione scientifica;</li> <li>i boolean rappresetano un valore booleano che pu\u00f2 assumere valore pari a vero o falso;</li> <li>le string-q sono parole (o stringhe) costituite da q caratteri.</li> </ul>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/#la-dichiaraizone-delle-variabili","title":"La dichiaraizone delle variabili","text":"<p>La dichiarazione elel varaibili \u00e8 un elenco preceduto dalla parola chiave var.</p> <p>La dichiarazione prevede che queste siano suddivise per tipo. La forma \u00e8 del tipo:</p> <p>var nomevariabile1: tipo1;     nomevariabile2: tipo2;     nomevariabile3: tipo_3.</p>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/#la-descrizione-delle-azioni","title":"La descrizione delle azioni","text":"<p>Regole fondamentali: 1. prima della prima azione vi \u00e8 un begin 2. dopo l'ultima vi \u00e8 un  end 3. la lettura \u00e8 read 4. la scrittura \u00e8 write</p>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/#schema-sequenziale","title":"Schema sequenziale","text":"<p>Le istruzioni in una sequenza sono rappresentate secondo uno schema sequenziale. In altre parole, supponendo una sequenza del tipo...</p> <p>le istruzioni sono fatte in modo sequenziale</p>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/#schema-di-selezione","title":"Schema di selezione","text":"<p>Gli schemi di selezione sono rappresentati mediante la struttura if then else, con un endif finale.</p>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/#schemi-di-iterazione","title":"Schemi di iterazione","text":"<p>Gli schemi di iterazione sono rappresentati mediante la struttura while Cond Do S, con S sequenza nel caso di controllo in coda, mentre con contro0llo in testa abbiamo un repeat S until C.</p>"},{"location":"material/02_programming/02_structured/03_pseudocode/lecture/#schema-enumerativo","title":"Schema enumerativo","text":"<p>Esistonod elle situaizoni particolari nei quali ci sono detrerminate schemi linguistici. Ad esempio, nel caso di un for </p> <p><pre><code>for idx from val_in to val_fin step incr do\n    S\nendfor\n</code></pre> Esistono anche delle rappresentazioni</p>"},{"location":"material/02_programming/03_recursion/lecture/","title":"2.3 Ricorsione","text":"<p>Quella della ricorsione \u00e8 una tecnica di programmazione che permette di \"spezzare\" un problema in diverse piccole parti, da trattare una alla volta fino alla risoluzione completa dello stesso. E' quindi in qualche modo assimilabile al paradigma \"divide-et-impera\", tanto caro agli strateghi dell'antica Roma.</p> <p>Nella pratica, si tratta di riapplicare una serie di istruzioni (e, quindi, una funzione) ad istanze sempre pi\u00f9 piccole del problema originario, fino a che non \u00e8 possibile giungere ad una risoluzione diretta; tuttavia, per comprenderne appieno il funzionamento, \u00e8 opportuno procedere con un esempio pratico.</p>"},{"location":"material/02_programming/03_recursion/lecture/#calcolo-del-fattoriale","title":"Calcolo del fattoriale","text":"<p>Il fattoriale di un numero \\(n\\) \u00e8 indicato con \\(n!\\) ed \u00e8 dato dal prodotto di tutti i numeri che vanno da \\(1\\) ad \\(n\\). Formalmente:</p> \\[ n! = 1 \\cdot 2 \\cdot \\ldots \\cdot (n-1) \\cdot (n) \\] <p>Ad esempio, \\(3! = 6\\), mentre \\(4! = 24\\), \\(5! = 120\\), e via dicendo. Il fattoriale \u00e8 definito per ogni numero intero strettamente positivo, oltre che per lo \\(0\\), per il quale vale \\(0!=1\\).</p> <p>Proviamo per prima cosa a calcolare il fattorale usando un ciclo.</p>"},{"location":"material/02_programming/03_recursion/lecture/#calcolo-iterativo-del-fattoriale","title":"Calcolo iterativo del fattoriale","text":"<p>Calcolare il fattoriale mediante un ciclo \u00e8 molto semplice. Infatti, basta usare la formulazione stessa di fattoriale:</p> <pre><code>fatt = 1;\nfor i che varia da 1 ad n:\n    fatt = fatt * i;\nendfor\nreturn fatt;\n</code></pre>"},{"location":"material/02_programming/03_recursion/lecture/#calcolo-ricorsivo-del-fattoriale","title":"Calcolo ricorsivo del fattoriale","text":"<p>\"Complichiamoci\" la vita, e vediamo come \u00e8 possibile calcolare il fattoriale in maniera ricorsiva. Riprendiamo la definizione di fattoriale, applicando la propriet\u00e0 commutativa:</p> \\[ n! = n \\cdot(n-1) \\ldots 2 \\cdot 1 \\] <p>Notiamo che \\((n - 1)! = (n - 1) \\cdot \\ldots \\cdot 2 \\cdot 1\\), per cui possiamo scrivere che:</p> \\[ n! = n \\cdot (n - 1)! \\] <p>Abbiamo quindi scomposto il problema del calcolo del fattoriale di \\(n\\) nel problema della moltiplicazione di \\(n\\) per il fattoriale di \\((n-1)\\); di conseguenza, \\((n-1)!\\) \u00e8 un sottoproblema di \\(n!\\). Se provassimo ad estendere il concetto, avremmo che:</p> \\[ n! = n \\cdot (n-1)! = n \\cdot (n-1) \\cdot (n-2)! = \\ldots = n \\cdot (n-1) \\cdot \\ldots \\cdot 1 \\cdot 0! \\] <p>da cui deriva che:</p> \\[ 0! * 1 = 1 = 1! \\Rightarrow \\\\ \\Rightarrow 1! * 2 = 2 = 2! \\Rightarrow \\\\ \\Rightarrow \\ldots \\Rightarrow \\\\ \\Rightarrow (n-1)! * n = n! \\Rightarrow \\\\ \\]"},{"location":"material/02_programming/03_recursion/lecture/#caso-base-e-ricorsione","title":"Caso base e ricorsione","text":"<p>Risulta quindi che:</p> <ul> <li>nel caso \\(n=0\\), allora \\(n! = 1\\);</li> <li>nel caso \\(n &gt; 0\\), allora dobbiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\).</li> </ul> <p>Il caso \\(n =0\\) assume il nome di caso base, ed \u00e8 la situazione che cerchiamo per \"terminare\" la ricorsione; alternativamente, dovremo procedere a richiamare ricorsivamente la funzione desiderata.</p>"},{"location":"material/02_programming/03_recursion/lecture/#implementazione-della-ricorsione","title":"Implementazione della ricorsione","text":"<p>Proviamo ad implementare la funzione ricorsiva in pseudocodice. Scriviamo:</p> <pre><code>int factorial(int n):\n    if n = 0:\n        return 1;\n    else:\n        return n * factorial(n - 1);\n    endif\n</code></pre> <p>Analizziamo il comportamento della funzione. Se <code>n</code> \u00e8 maggiore di zero, la funzione restituir\u00e0 il prodotto tra <code>n</code> ed il risultato della funzione <code>factorial</code> applicata ad <code>n - 1</code>. La funzione quindi \"chiama s\u00e8 stessa\", usando parametri differenti, fino a che non ci si ritrova nel caso base, e viene restituito <code>1</code>.</p> <p>Ci si potrebbe chiedere come faccia la funzione ricorsiva a restituire il valore complessivo di \\(n!\\). La risposta \u00e8 da ricercarsi nel modo in cui sono memorizzati i dati durante la ricorsione: infatti, questi vengono organizzati secondo un call stack (traducibile in \"stack di chiamate\"), che conserva al suo interno i risultati derivanti dalle precedenti chiamate a funzione. Questo concetto \u00e8 riassunto nella seguente figura, che mostra il call stack per il calcolo ricorsivo del fattoriale di 4.</p> <p></p>"},{"location":"material/02_programming/04_variables/lecture/","title":"2.4 Le variabili","text":"<p>Comprendere il concetto di variabile \u00e8 fondamentale (o, per meglio dire, propedeutico) all'acquisizione dei fondamentali della programmazione.</p> <p>Per capire di cosa si tratta, possiamo analizzare il significato della parola nella lingua italiana: intuitivamente, una variabile rappresenta una quantit\u00e0 (o, in maniera molto pi\u00f9 \"lasca\", un dato) a cui \u00e8 \"concesso\" di variare durante l'esecuzione del programma. Risulta importantissimo sottolineare come una variabile non sia quindi necessariamente un dato di ingresso o un risultato atteso: si tratta piuttosto di una rappresentazione (parziale) dello stato interno del programma ad un dato istante.</p> <p>Una variabile pu\u00f2 essere quindi qualsiasi dato contenuto nel nostro programma: ci sono variabili che contano il numero di operazioni eseguite, ad esempio, oppure ancora variabili di supporto, che ci permettono di memorizzare stati intermedi durante l'esecuzione di iterazioni complesse.</p> <p>Nota</p> <p>Non tutti i dati contenuti in un programma sono delle variabili: esistono anche delle costanti, che si differenziano dalle variabili per la caratteristica di non poter variare durante l'esecuzione del programma. Di solito, le costanti vengono utilizzate per modellare valori ben definiti, come ad esempio il \\(\\pi\\).</p>"},{"location":"material/02_programming/04_variables/lecture/#dichiarare-ed-inizializzare-una-variabile","title":"Dichiarare ed inizializzare una variabile","text":"<p>Per poter utilizzare una variabile all'interno del nostro programma dovremo seguire due step fondamentali, indipendentemente dal linguaggio di programmazione scelto. In particolare:</p> <ul> <li>nel primo step, chiamato dichiarazione della variabile, dovremo \"informare\" il programma dell'esistenza della stessa, associandovi un identificatore (ovvero, un nome) ed il tipo di dato rappresentato dalla stessa;</li> <li>nel secondo step, chiamato inizializzazione, dovremo assegnare un valore iniziale alla nostra variabile, in accordo ovviamente al tipo di dato utilizzato.</li> </ul> <p>Ad esempio, per dichiarare una variabile di tipo <code>type</code> chiamata <code>identifier</code>, dovremo usare una sintassi di questo tipo:</p> <pre><code>type identifier;\n</code></pre> <p>Successivamente, potremo inizializzare la variabile <code>identifier</code> con il valore <code>value</code>:</p> <pre><code>identifier = value;\n</code></pre> <p>Le due operazioni non sono necessariamente separate, e possono essere combinate in un'unica istruzione.</p> <pre><code>type identifier = value;\n</code></pre> <p>Nota</p> <p>Vedremo un gran numero di esempi pratici di dichiarazione ed inizializzazione.</p>"},{"location":"material/02_programming/04_variables/lecture/#identificatore-della-variabile","title":"Identificatore della variabile","text":"<p>In genere, la scelta dell'identificatore da associare ad una variabile lascia vasta libert\u00e0 di scelta al programmatore. Tuttavia, occorre tenere a mente che, indipendentemente dal linguaggio, non sar\u00e0 possibile usare come identificatore una keyword (ad esempio, non \u00e8 possibile chiamare una variabile <code>if</code> o <code>long</code>); inoltre, \u00e8 fortemente consigliato attenersi allo styling code del linguaggio.</p> <p>Facciamo un paio di esempi. Il linguaggio Java, che non tratteremo, adotta per convenzione uno styling code chiamato camel case, che prevede che parole consecutive siano unite tra di loro, con l'iniziale di ogni parola successiva alla prima in maiuscolo. Ad esempio:</p> <pre><code>int integerVariable = 1;\n</code></pre> <p>Python, invece, utilizza per convenzione lo stile snake case, che prevede che parole consecutive siano \"unite\" mediante un simbolo di underscore, lasciando tutte le lettere minuscole:</p> <pre><code>integer_variable = 1\n</code></pre> <p>Sulla scelta del nome</p> <p>La scelta del nome da assegnare ad una variabile non \u00e8 casuale. Il suggerimento \u00e8 quello di assegnare nomi esplicativi, oltre che univoci: ad esempio, un contatore chiamato <code>cnt</code> sar\u00e0 sicuramente pi\u00f9 riconoscibile di un contatore chiamato <code>pippo_joy</code>.</p>"},{"location":"material/02_programming/04_variables/lecture/#tipo-della-variabile","title":"Tipo della variabile","text":"<p>Il tipo della variabile definisce il tipo di dato associato alla stessa; come abbiamo visto nella lezione 4, quindi, ci\u00f2 influenzer\u00e0 il range di valori che questa pu\u00f2 rappresentare. Ponderare adeguatamente il tipo di dato da usare per una variabile \u00e8 quindi estremamente importante, principalmente per due ragioni:</p> <ol> <li>flusso logico;</li> <li>complessit\u00e0 computazionale spaziale.</li> </ol> <p>Partiamo dal flusso logico. Immaginiamo di dover sommare tra loro due numeri reali<code>x</code> ed <code>y</code>, e di voler associare il valore risultante da questa operazione alla variabile <code>z</code>. Al momento della scrittura del codice, decidiamo di assegnare (correttamente) il tipo <code>float</code> ad <code>x</code> ed <code>y</code> ma, per una disattenzione, assegnamo il tipo <code>int</code> alla variabile <code>z</code>:</p> <pre><code>float x = 1.1;\nfloat y = 1.2; \nint z;\nz = x + y;\n</code></pre> <p>Cosa accadr\u00e0? Consideriamo che il valore che ci attendiamo che <code>z</code> assuma \u00e8 pari <code>2.3</code>: tuttavia, avremo come output <code>2</code>, principalmente a causa del tipo di <code>z</code>. Ci\u00f2 comporter\u00e0 quindi un errore di troncamento pari a <code>0.3</code>.</p> <p>Per quello che riguarda invece la complessit\u00e0 computazionale spaziale, ricordiamo, sempre dalla lezione 4, che ogni tipo di dato richiede una quantit\u00e0 di memoria differente, ma al tempo stesso permette di memorizzare un range di valori pi\u00f9 o meno ampio.</p> <p>Questa caratteristica pu\u00f2 e deve essere usata a nostro vantaggio: infatti, qualora fossimo sicuri che le nostre variabili intere assumono sempre valori compresi tra 0 e 100, potremmo utilizzare dati di tipo <code>byte</code>. Tuttavia, se per qualche motivo una variabile si trovasse ad assumere un valore superiore a 256, avremmo un errore di buffer overflow, che porterebbe la variabile a \"ritornare\" a zero, con conseguenze facilmente intuibili.</p> <p>Curiosit\u00e0</p> <p>Errori di questo tipo possono portare ad esiti catastrofici. Ad esempio, nel 1995, il razzo spaziale Ariane 5 esplose 39 secondi dopo il lancio perch\u00e9 nel software di controllo dell'altitudine era stato usato un intero a 16 bit piuttosto che a 64 bit.</p>"},{"location":"material/02_programming/05_functions/01_intro/lecture/","title":"2.5.1 - Le funzioni","text":"<p>Immaginiamo di dover calcolare il nostro voto di accesso all'esame laurea. Supponendo che nel nostro corso di studi ci siano esattamente venti esami, le istruzioni necessarie a calcolarlo sono molto semplici:</p> <pre><code>numero_esami = 20;\nsomma_voti = 0;\nfor i che va da 1 a numero_esami:\n    somma_voti = somma_voti + voto_esame_i;\nendfor\nvoto_medio = somma_voti/numero_esami;\nvoto_accesso = voto_medio / 3 * 11;\n</code></pre> <p>Queste istruzioni accettano un solo \"insieme\" di esami, relativo quindi a noi; come potremmo fare quindi per calcolare la media di un nostro collega? La tentazione potrebbe essere quella di \"sdoppiare\" le istruzioni, cambiando leggermente il nome delle variabili e passando un insieme di esami diverso:</p> <pre><code>numero_esami = 20;\nsomma_voti_a = 0;\nfor i che va da 1 a numero_esami:\n    somma_voti_a = somma_voti_a + voto_esame_i_a;\nendfor\nvoto_medio_a = somma_voti_a / numero_esami;\nvoto_accesso_a = voto_medio_a / 3 * 11;\n\nsomma_voti_b = 0;\nfor i che va da 1 a numero_esami:\n    somma_voti_b = somma_voti_b + voto_esame_i;\nendfor\nvoto_medio_b = somma_voti_b / numero_esami;\nvoto_accesso_b = voto_medio / 3 * 11;\n</code></pre> <p>Cosa accadrebbe se volessimo aggiungere un altro studente? Ovviamente, dovremmo aggiungere altre righe di codice; \u00e8 facile quindi intuire che, in breve tempo, la situazione diventerebbe ingestibile.</p> <p>In nostro aiuto, quindi, giungono le funzioni, ovvero dei costrutti che ci permettono di raggruppare istruzioni eseguite un numero arbitrario di volte all'interno del nostro codice. Le funzioni (chiamate anche metodi) assumono quindi il ruolo di contenitore logico, utilizzabile per effettuare una serie ben definita di operazioni su un certo input, conseguendo un determinato output.</p> <p>Vediamo quindi come sono strutturate.</p>"},{"location":"material/02_programming/05_functions/01_intro/lecture/#struttura-di-una-funzione","title":"Struttura di una funzione","text":"<p>Una funzione consta di due parti: una firma ed un corpo.</p> <p>Nella firma, sono definiti:</p> <ul> <li>il nome della funzione, ovvero un identificativo utile a richiamarla in altre parti del programma (un po' come quello della variabile);</li> <li>il tipo di ritorno, ovvero il tipo del valore restituito (ovvero, mandato in output) dalla funzione;</li> <li>i parametri di ingresso, ovvero il tipo ed i nomi dei valori in ingresso (input) alla funzione.</li> </ul> <p>Nel corpo, invece, saranno indicate le istruzioni vere e proprie, oltre che l'eventuale valore restituito dalla funzione. Schematizzando:</p> <pre><code>tipo_ritorno nome_funzione(tipo_par_1 par_1, tipo_par_2 par_2):         // Questa \u00e8 la firma...\n    istr_1;                                                             // ...questo \u00e8 il corpo...\n    istr_2;\n    tipo_ritorno valore_ritorno = istr_3;\n    return valore_ritorno;                                              // ...e questo \u00e8 il valore restituito!\n</code></pre> <p>Da notare la presenza della parola chiave <code>return</code>, che serve ad indicare il valore (o, per meglio dire, la variabile) che sar\u00e0 \"restituita\" dalla funzione. </p> <p>Nota</p> <p>Quando la funzione trova la parola chiave <code>return</code>, si \"ferma\" immediatamente, e l'esecuzione del programma continua.</p> <p>Facciamo un esempio creando una pseudo-funzione per il calcolo del voto di accesso all'esame di laurea; chiamiamola, in maniera originale, <code>calcolo_voto_accesso_laurea</code>, e supponiamo restituisca un <code>float</code> (il voto di accesso non approssimato) a partire da un insieme di valori <code>interi</code> (i voti dei singoli esami). Allora:</p> <pre><code>numero_esami = 20;\n\nfloat calcolo_voto_accesso_laurea(int[] voti_esami):\n    somma_voti = 0;\n    for i che va da 1 a numero_esami:\n        somma_voti = somma_voti + voto_esame_i;\n    endfor\n    voto_medio = somma_voti / numero_esami;\n    voto_accesso = voto_medio / 3 * 11;\n    return voto_accesso;\n</code></pre> <p>Immaginiamo di voler chiamare la funzione per calcolare i nostri voti, oltre a quelli di un collega. Per farlo, useremo istruzioni simili a queste:</p> <pre><code>mio_voto_accesso = calcolo_voto_accesso_laurea(miei_voti);\nvoto_accesso_collega = calcolo_voto_accesso_laurea(voti_collega);\n</code></pre> <p>Come si pu\u00f2 notare, il numero di righe di codice scritte diminuisce in maniera tanto pi\u00f9 rilevante quanto pi\u00f9 si usa la funzione!</p> <p>Nota sulle parentesi quadre</p> <p>Abbiamo usato in precedenza le parentesi quadre (<code>[]</code>) per indicare un \"insieme\" di valori. In realt\u00e0, questa notazione indica spesso un array, o una lista, a seconda del linguaggio; ne parleremo pi\u00f9 diffusamente nel seguito.</p>"},{"location":"material/02_programming/05_functions/01_intro/lecture/#il-concetto-di-modularita","title":"Il concetto di modularit\u00e0","text":"<p>Abbiamo visto come una funzione serva ad evitare di dover ripetere numerose volte lo stesso insieme di istruzioni. Tuttavia, abbiamo accennato in precedenza anche al fatto che ogni funzione \u00e8 un contenitore logico di una sequena di istruzioni da utilizzare per risolvere un problema: ci\u00f2 ci conduce direttamente al concetto di modularit\u00e0, per il quale una funzione deve contenere esclusivamente le istruzioni necessarie ad eseguire lo scopo per cui \u00e8 stata concepita.</p> <p>Per fare un esempio, immaginiamo adesso di dover calcolare, oltre al voto medio di accesso all'esame di laurea, anche quello finale, tenendo conto della votazione della commissione e dell'eventuale lode. Sottolineamo comunque come sia sempre importante per noi (e, nello specifico, per la segreteria e la commissione) tenere traccia del voto medio, per cui le due cose andranno, in qualche modo, separate.</p> <p>L'approccio da utilizzare \u00e8 quindi quello di creare un'altra funzione che asserva allo scopo di calcolare il voto finale:</p> <p>```linenums=1\" int calcolovotofinalelaurea(float votoaccesso, int votoesame, float soglialode):     votocumulativo = votoaccesso + votoesame;     if (votocumulativo &gt; (110 + soglialode)):         return 110L     else:         return votocumulativo <pre><code>Da notare la presenza di due `return`: questo \u00e8 corretto perch\u00e9, essendo specificati nei due rami di un'istruzione condizionale, saranno mutualmente esclusivi, e quindi la funzione potr\u00e0 \"arrivare\" soltanto ad uno di essi.\n\n## Funzioni, variabili ed ambito\n\nIntroduciamo brevemente il concetto di *ambito* di una variabile. All'interno del nostro programma, infatti, ogni variabile ha una sorta di \"ciclo di vita\", nel quale viene creata, utilizzata, ed infine distrutta.\n\nL'intero programma ha un ambito chiamato *globale*: ci\u00f2 significa che tutte le variabili specificate nel corpo principale del programma, che vedremo in avanti essere chiamato spesso *main*, avranno validit\u00e0 in tutto il nostro codice. Le singole funzioni, invece, definiscono un ambito *locale*, che viene creato alla chiamata della funzione, e distrutto al termine della stessa.\n\nAd esempio:\n\n```linenums=\"1\"\nnumero_esami = 20;\nmiei_voti = lista_miei_voti;\n\nfloat calcolo_voto_accesso_laurea(int[] voti_esami):\n    somma_voti = 0;\n    for i che va da 1 a numero_esami:\n        somma_voti = somma_voti + voto_esame_i;\n    endfor\n    voto_medio = somma_voti / numero_esami;\n    voto_accesso = voto_medio / 3 * 11;\n    return voto_accesso;\n\nvoto_accesso_mio = calcolo_voto_accesso_laurea(miei_voti);\n</code></pre></p> <p>Nel codice precedente, dichiariamo le variabili <code>numero_esami</code> e <code>miei_voti</code> nel corpo principale del programma: ci\u00f2 significa che questa variabili hanno validit\u00e0 nell'intero codice, e sono quindi richiamabili (e potenzialmente modificabili) anche all'interno della funzione <code>calcolo_voto_accesso_laurea</code>. Dal canto suo, quest'ultima crea un ambito locale: ci\u00f2 comporta che le variabili create al suo interno, come <code>somma_voti</code>, <code>voto_medio</code> e <code>voto_accesso</code>, non potranno essere accedute all'esterno della funzione.</p> <p>Da ci\u00f2 seguono alcune considerazioni:</p> <ol> <li>parlando in maniera \"logica\", la parola chiave <code>return</code> serve a \"trasferire\" il valore di una variabile da un ambito locale ad uno globale;</li> <li>la variabile restituita cambia identificatore, ma il valore \u00e8 quello calcolato all'interno della funzione;</li> <li>occorre fare estrema attenzione alla modifica delle variabili globali in ambito locale, ovvero all'interno delle singole funzioni.</li> </ol> <p>Imparare ad utilizzare l'ambito delle variabili \u00e8 propedeutico al corretto utilizzo delle tecniche di programmazione, e tenere a mente queste tre semplici regole ci aiuter\u00e0 enormemente nella scrittura dle nsotro codice.</p>"},{"location":"material/02_programming/05_functions/02_parameters/lecture/","title":"Parametri formali ed attuali","text":"<p>Certamente, cercher\u00f2 di spiegare i parametri formali e attuali in modo chiaro e adatto a studenti del primo anno, usando un esempio in MATLAB.</p> <p>Concetti chiave: Funzioni e Parametri</p> <p>Prima di parlare di parametri formali e attuali, \u00e8 importante capire cosa sono le funzioni e perch\u00e9 usiamo i parametri.</p> <ul> <li>Funzione: Immagina una funzione come una piccola \"macchina\" che prende degli \"ingredienti\" (dati), li elabora e produce un \"risultato\".  Le funzioni ci permettono di organizzare il codice, renderlo pi\u00f9 leggibile e riutilizzabile. Invece di riscrivere lo stesso blocco di codice pi\u00f9 volte, lo mettiamo in una funzione e la chiamiamo quando serve.</li> <li>Parametri:  I parametri sono come gli \"ingredienti\" che passiamo alla \"macchina-funzione\".  Servono per far sapere alla funzione quali dati deve usare per svolgere il suo compito.</li> </ul> <p>Parametri Formali (o Argomenti Formali)</p> <ul> <li>Definizione: I parametri formali sono le variabili che vengono definite all'interno della definizione della funzione.  Sono dei \"segnaposto\" che indicano cosa la funzione si aspetta di ricevere quando viene chiamata.  Immaginali come i nomi degli ingredienti scritti sulla ricetta (es. \"farina\", \"uova\", \"zucchero\").</li> <li>Scopo: Servono a definire come la funzione user\u00e0 i dati che ricever\u00e0.  All'interno del corpo della funzione, usiamo i nomi dei parametri formali per riferirci ai valori che verranno passati.</li> <li> <p>Esempio (MATLAB):</p> <pre><code>function area = calcolaAreaRettangolo(base, altezza)\n    % Questa funzione calcola l'area di un rettangolo.\n    % base e altezza sono i parametri formali.\n\n    area = base * altezza;\nend\n</code></pre> <p>In questo esempio, <code>base</code> e <code>altezza</code> sono i parametri formali della funzione <code>calcolaAreaRettangolo</code>.  La funzione si aspetta di ricevere due valori numerici, che internamente chiamer\u00e0 <code>base</code> e <code>altezza</code>, e li user\u00e0 per calcolare l'area.</p> </li> </ul> <p>Parametri Attuali (o Argomenti Attuali)</p> <ul> <li>Definizione: I parametri attuali sono i valori effettivi che vengono passati alla funzione quando la si chiama (cio\u00e8 quando la si \"usa\"). Sono gli ingredienti veri che mettiamo nella \"macchina-funzione\".</li> <li>Scopo: Forniscono alla funzione i dati specifici su cui deve lavorare.</li> <li> <p>Esempio (MATLAB):</p> <pre><code>lunghezza = 5;\nlarghezza = 3;\n\nareaRettangolo = calcolaAreaRettangolo(lunghezza, larghezza);\n% lunghezza e larghezza sono i parametri attuali.\n\ndisp(['L''area del rettangolo \u00e8: ', num2str(areaRettangolo)]);\n</code></pre> <p>In questo esempio, <code>lunghezza</code> (con valore 5) e <code>larghezza</code> (con valore 3) sono i parametri attuali.  Quando chiamiamo <code>calcolaAreaRettangolo(lunghezza, larghezza)</code>, il valore di <code>lunghezza</code> (5) viene passato al parametro formale <code>base</code>, e il valore di <code>larghezza</code> (3) viene passato al parametro formale <code>altezza</code>.  La funzione esegue i calcoli usando questi valori specifici.</p> </li> </ul> <p>Riassumendo in una Tabella:</p> Caratteristica Parametri Formali Parametri Attuali Dove si trovano Nella definizione della funzione Nella chiamata alla funzione Cosa sono Segnaposto per i valori che la funzione ricever\u00e0 I valori effettivi che vengono passati alla funzione Scopo Definire come la funzione user\u00e0 i dati Fornire alla funzione i dati specifici su cui lavorare Esempio (MATLAB) <code>function miaFunzione(parametro1, parametro2)</code> <code>miaFunzione(valore1, valore2)</code> <p>Analogia con una Ricetta:</p> <ul> <li>Ricetta: La funzione</li> <li>Ingredienti elencati nella ricetta (es. \"farina\", \"uova\"): Parametri Formali</li> <li>Ingredienti che usi effettivamente per cucinare (es. 200g di farina, 3 uova): Parametri Attuali</li> </ul> <p>Punti importanti da ricordare:</p> <ul> <li>Corrispondenza: L'ordine dei parametri attuali deve corrispondere all'ordine dei parametri formali nella definizione della funzione.  Se la funzione si aspetta <code>(base, altezza)</code>, devi passare i valori in quell'ordine: <code>calcolaArea(5, 3)</code> \u00e8 corretto, <code>calcolaArea(3, 5)</code> darebbe un risultato diverso (e potenzialmente inatteso).</li> <li>Nomi diversi: I nomi dei parametri attuali e formali non devono necessariamente essere gli stessi.  Nell'esempio, abbiamo usato <code>lunghezza</code> e <code>larghezza</code> come parametri attuali e <code>base</code> e <code>altezza</code> come parametri formali.  L'importante \u00e8 che i valori vengano passati correttamente.</li> <li>Tipi di dati:  Idealmente, i tipi di dati dei parametri attuali dovrebbero essere compatibili con i tipi di dati che la funzione si aspetta (anche se MATLAB \u00e8 meno rigido di altri linguaggi in questo).  Se la funzione si aspetta un numero, dovresti passare un numero, non una stringa di testo.</li> </ul> <p>Spero che questa spiegazione e l'esempio in MATLAB ti siano utili! Se hai altre domande, non esitare a chiedere.</p>"},{"location":"material/02_programming/05_functions/03_procedures/lecture/","title":"Lecture","text":"<p>Certamente, ecco una spiegazione della differenza tra procedure e funzioni, adatta a uno studente del primo anno senza conoscenze informatiche pregresse, con esempi in MATLAB.</p> <p>L'Idea Chiave: Output o No Output?</p> <p>La differenza fondamentale tra una procedura e una funzione sta nel fatto se ritornano un valore di output o meno.</p> <ul> <li> <p>Funzione:  Come abbiamo detto prima, una funzione \u00e8 come una \"macchina\" che prende degli input (tramite parametri), li elabora e restituisce un output (un risultato).  Pensa a una calcolatrice: inserisci dei numeri, premi il tasto \"+\", e la calcolatrice ti restituisce la somma.</p> </li> <li> <p>Procedura: Una procedura (o \"sottoprogramma\") \u00e8 un blocco di codice che esegue una serie di operazioni, ma non restituisce un valore specifico di output.  Esegue semplicemente un compito, come stampare qualcosa sullo schermo, modificare un file, o disegnare un grafico.  Pensa a un robot aspirapolvere: lo programmi per pulire la stanza, lui esegue l'azione, ma non ti \"restituisce\" un valore specifico (a parte forse la stanza pulita!).</p> </li> </ul> <p>Analogia:</p> <p>Immagina di chiedere a qualcuno di fare qualcosa:</p> <ul> <li>Funzione: \"Per favore, calcola l'area di questo rettangolo e dimmi il risultato.\" (Ricevi un valore di ritorno: l'area).</li> <li>Procedura: \"Per favore, stampa le mie informazioni di contatto su un biglietto.\" (Non ricevi un valore di ritorno, ma un'azione \u00e8 stata compiuta: il biglietto \u00e8 stato stampato).</li> </ul> <p>In Termini di Codice (MATLAB):</p> <ul> <li> <p>Funzione (con output):</p> <pre><code>function area = calcolaAreaCerchio(raggio)\n% Calcola l'area di un cerchio dato il raggio.\n% Restituisce il valore dell'area.\n\n    area = pi * raggio^2;\nend\n\n% Esempio di utilizzo:\nraggio = 4;\nareaCerchio = calcolaAreaCerchio(raggio); % La funzione RITORNA un valore\ndisp(['L''area del cerchio \u00e8: ', num2str(areaCerchio)]);\n</code></pre> <p>In questo caso, <code>calcolaAreaCerchio</code> restituisce (tramite la variabile <code>area</code>) il valore calcolato dell'area del cerchio. Quando chiami la funzione, puoi assegnare il valore restituito a una variabile (<code>areaCerchio</code>).  La parola chiave <code>return</code> (anche se non esplicita in questo esempio, poich\u00e9 l'output \u00e8 assegnato ad <code>area</code>) \u00e8 spesso usata in altri linguaggi (e a volte in MATLAB per interrompere l'esecuzione della funzione) per indicare quale valore deve essere restituito.</p> </li> <li> <p>Procedura (senza output diretto):</p> <pre><code>function stampaSaluto(nome)\n% Stampa un saluto personalizzato sullo schermo.\n% NON restituisce un valore specifico.\n\n    disp(['Ciao, ', nome, '!']);\n    disp('Benvenuto nel programma!');\nend\n\n% Esempio di utilizzo:\nstampaSaluto('Mario'); % La procedura esegue un'azione (stampa)\n</code></pre> <p>In questo caso, <code>stampaSaluto</code> esegue delle azioni (stampare del testo sullo schermo), ma non restituisce un valore che puoi assegnare a una variabile.  Semplicemente la chiami, e lei fa quello che deve fare.</p> </li> </ul> <p>Ulteriori Chiarimenti:</p> <ul> <li><code>return</code>: Nelle funzioni, spesso (ma non sempre in MATLAB, se c'\u00e8 un'assegnazione all'output) si usa la parola chiave <code>return</code> per specificare il valore che la funzione deve restituire.  Nelle procedure, <code>return</code> pu\u00f2 essere usato per uscire anticipatamente dalla procedura, ma non per restituire un valore.</li> <li>Effetti collaterali: Le procedure spesso (ma non sempre) hanno \"effetti collaterali\", cio\u00e8 modificano qualcosa al di fuori del loro stesso scope (es. stampare sullo schermo, modificare un file). Le funzioni, idealmente, dovrebbero essere \"pure\", cio\u00e8 non dovrebbero avere effetti collaterali (dovrebbero solo calcolare un valore basandosi sugli input). Questo rende il codice pi\u00f9 facile da capire e da testare.</li> <li>Terminologia: In alcuni linguaggi di programmazione, non si fa una distinzione formale tra procedure e funzioni.  Ad esempio, in C, tutto \u00e8 una \"funzione\", ma una funzione che non restituisce un valore viene dichiarata con tipo di ritorno <code>void</code>.  In MATLAB, la distinzione \u00e8 implicita: se una funzione ha una variabile a cui viene assegnato un valore di output, allora \u00e8 una funzione; altrimenti, \u00e8 una procedura.</li> </ul> <p>Riassumendo in una tabella:</p> Caratteristica Funzione Procedura Output Restituisce un valore di output (usando <code>return</code> o assegnando il valore ad una variabile di output). Non restituisce un valore di output (a parte, implicitamente, modificando variabili esterne). Scopo Calcolare e restituire un risultato. Eseguire una serie di azioni (es. stampare, modificare dati). Effetti collaterali Idealmente, pochi o nulli (dovrebbe solo calcolare il risultato). Spesso ha effetti collaterali (es. modifica lo stato del programma). Esempio (MATLAB) <code>function area = calcolaArea(raggio)</code> (restituisce <code>area</code>) <code>function stampaSaluto(nome)</code> (stampa un saluto, non restituisce nulla) <p>Spero che questa spiegazione ti sia chiara. Ricorda che questa \u00e8 una semplificazione, e ci sono sfumature pi\u00f9 avanzate, ma per un principiante dovrebbe darti una buona base per capire la differenza.</p>"},{"location":"material/02_programming/06_complexity/lecture/","title":"2.6 La complessit\u00e0 computazionale degli algoritmi","text":"<p>Il concetto di complessit\u00e0 computazionale di un algoritmo \u00e8 direttamente correlato al numero di operazioni che occorre svolgere per portarlo a termine, oppure ancora alla quantit\u00e0 di memoria occupata nel sistema durante l'esecuzione dello stesso.</p> <p>In particolare, avremo due tipi di complessit\u00e0:</p> <ul> <li>la complessit\u00e0 temporale pu\u00f2 essere determinata a partire dal numero di operazioni effettuate dall'algoritmo;</li> <li>la complessit\u00e0 spaziale \u00e8 legata allo spazio massimo richiesto dall'algoritmo in fase di esecuzione nella memoria del calcolatore.</li> </ul> <p>Torneremo pi\u00f9 avanti su questi aspetti; per adesso, limitiamoci a fare un breve esempio a titolo meramente illustrativo.</p>"},{"location":"material/02_programming/06_complexity/lecture/#un-primo-rapido-esempio","title":"Un primo, rapido, esempio","text":"<p>Facciamo un rapido esempio introduttivo (nel prosieguo, formalizzeremo al meglio i concetti espressi).</p> <p>Immaginiamo di dover calcolare la distanza euclidea tra due numeri, cos\u00ec come abbiamo visto nella lezione precedente; per comodit\u00e0, riportiamo di seguito lo stesso pseudo-codice:</p> <pre><code>distanza_x = (x_a - x_b)^2;\ndistanza_y = (y_a - y_b)^2;\ndistanza = (distanza_x + distanza_y)^(1/2);\n</code></pre> <p>La complessit\u00e0 computazionale va valutata a partire dalle operazioni atomiche. Nel caso precedente, notiamo subito che alcune operazioni sono raggruppate, per cui \u00e8 il caso di \"esplodere\" l'algoritmo per quanto possibile.</p> <pre><code>differenza_x = x_a - x_b\ndistanza_x = (differenza_x)^2;\ndifferenza_y = y_a - y_b\ndistanza_y = (differenza_y)^2;\ndistanza_quad = distanza_x + distanza_y\ndistanza = (distanza_quad)^(1/2);\n</code></pre> <p>Nota</p> <p>Per semplicit\u00e0, non teniamo conto dei singoli passaggi che un calcolatore potrebbe impiegare nell'effettuare un'elevazione a potenza, ma consideriamo la stessa un'operazione unitaria.</p> <p>Avremo quindi un totale di \\(N=6\\) operazioni; supponendo che ognuna di queste richieda esattamente un ciclo del nostro processore, e che questo effettui un ciclo al secondo, la complessit\u00e0 computazionale temporale sar\u00e0 proprio pari a 6.</p> <p>Per quello che riguarda la complessit\u00e0 computazionale spaziale, invece, dovremo contare il numero \\(K\\) di variabili create (e, di conseguenza, memorizzate) durante l'esecuzione dell'algoritmo, oltre che il numero \\(b\\) di bit con cui ciascuna variabile \u00e8 rappresentata (per semplicit\u00e0, riterremo costante questo valore). In particolare, notiamo che vengono create 6 variabili, a cui sono da aggiungere gli input <code>x_a</code> ed <code>x_b</code>; supponendo che \\(b\\) sia pari ad 8 bit, avremo:</p> \\[ K = 6 + 2 = 8, b = 8 \\Rightarrow \\\\ \\Rightarrow C_s = K \\cdot b = 8 \\cdot 8 = 64 \\] <p>La complessit\u00e0 computazionale spaziale sar\u00e0 quindi pari a 64 bit.</p> <p>Importantissimo comunque sottolineare come questo esempio sia puramente introduttivo. Nel seguito, forniremo una definizione formale di complessit\u00e0 spaziale e temporale; per adesso, concentriamoci brevemente su due tipi di analisi che \u00e8 possibile effettuare, ovvero quelle a priori ed a posteriori.</p>"},{"location":"material/02_programming/06_complexity/lecture/#tipi-di-analisi-computazionale","title":"Tipi di analisi computazionale","text":""},{"location":"material/02_programming/06_complexity/lecture/#analisi-a-priori","title":"Analisi a priori","text":"<p>L'analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato e la quantit\u00e0 di memoria disponibile siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso.</p>"},{"location":"material/02_programming/06_complexity/lecture/#analisi-a-posteriori","title":"Analisi a posteriori","text":"<p>L'analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata.</p> <p>Importanza del contesto</p> <p>Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore. E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti.</p> <p>Vediamo adesso come \u00e8 possibile formalizzare i due diversi tipi di analisi computazionale per la complessit\u00e0 spaziale e per quella temporale.</p>"},{"location":"material/02_programming/06_complexity/lecture/#complessita-spaziale-e-temporale","title":"Complessit\u00e0 spaziale e temporale","text":""},{"location":"material/02_programming/06_complexity/lecture/#complessita-spaziale","title":"Complessit\u00e0 spaziale","text":"<p>La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria durante la sua esecuzione. Formalmente, questo \u00e8 pari alla somma di due componenti:</p> <ul> <li>una parte fissa, pari allo spazio richiesto per la memorizzazione di dati che non variano (in pratica, funzioni e costanti, che saranno trattati nel seguito);</li> <li>una parte variabile, data dallo spazio richiesto per la memorizzazione delle variabili.</li> </ul> <p>Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(C_s(X)\\) di un algoritmo \\(X\\) come:</p> \\[ C_s(X) = C_{S_F}(C) + C_{S_V}(C) \\] <p>con \\(C_{S_F}\\) parte fissa e \\(C_{S_V}\\) parte variabile; entrambe possono essere influenzate dalle caratteristiche \\(C\\) come linguaggio di programmazione ed hardware sottostante.</p>"},{"location":"material/02_programming/06_complexity/lecture/#un-esempio-piu-strutturato-parte-1","title":"Un esempio pi\u00f9 strutturato - Parte 1","text":"<p>Consideriamo il seguente algoritmo (in pseudocodice):</p> <pre><code>leggi p, q\nr = p + q + 1\nscrivi r\n</code></pre> <p>Partiamo dall'analisi a priori. Vediamo subito come questo algoritmo consti di tre variabili, ovvero <code>p</code> e <code>q</code> (variabili di input) ed <code>r</code> (variabile di output). Abbiamo inoltre una costante (il valore <code>1</code>). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a:</p> \\[ C_S(X) = C_{S_F} + C_{S_V} = 1 + 3 \\] <p>Notiamo che abbiamo omesso le caratteristiche \\(C\\), in quanto, come gi\u00e0 detto, non ne teniamo conto nell'analisi a priori. Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria.</p> <p>Per quello che riguarda l'analisi a posteriori, immaginiamo che il tipo di dato associato a ciascuna variabile sia un intero ad 8 bit. La complessit\u00e0 analizzata a posteriori sar\u00e0:</p> \\[ b = 8 bit \\Rightarrow \\\\ \\Rightarrow C_S(X) = C_{S_F}(C) + C_{S_V}(C) = (1 + 3) \\cdot 8 = 32 bit \\]"},{"location":"material/02_programming/06_complexity/lecture/#complessita-temporale","title":"Complessit\u00e0 temporale","text":"<p>Abbiamo gi\u00e0 visto come la complessit\u00e0 temporale di un algoritmo risulti essere associata alla quantit\u00e0 di tempo richiesto ad una completa esecuzione dello stesso. Anche questa complessit\u00e0 pu\u00f2 essere espressa da una funzione numerica del tipo:</p> \\[ C_T = \\sum_{i=1}^n t_i(C) \\] <p>con \\(t_i\\) tempo necessario all'esecuzione di uno step atomico dell'algoritmo, e \\(C\\) dipendendente anche stavolta dalle caratteristiche hardware del nostro dispositivo.</p>"},{"location":"material/02_programming/06_complexity/lecture/#un-esempio-piu-strutturato-parte-2","title":"Un esempio pi\u00f9 strutturato - Parte 2","text":"<p>Torniamo all'algoritmo precedente, ed effettuiamone una valutazione a priori.</p> <p>Abbiamo elencato tre step, anche se, nei fatti, ci saranno soltanto due addizioni della cui esecuzione dovremo tenere conto. Di conseguenza, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(C_T = 2\\).</p> <p>Per quello che riguarda l'analisi a posteriori, invece, sar\u00e0 necessario anche stavolta fissare una condizione al contorno, ovvero la velocit\u00e0 con cui il nostro processore riesce ad eseguire una singola istruzione. Supponendo che questa sia pari ad un microsecondo, l'analisi a posteriori ci porter\u00e0 a stabilire che la complessit\u00e0 computazionale sar\u00e0 pari a 2 microsecondi.</p>"},{"location":"material/02_programming/06_complexity/lecture/#complessita-di-caso-peggiore","title":"Complessit\u00e0 di caso peggiore","text":"<p>Nelle applicazioni reali, \u00e8 abbastanza difficile che si riesca a calcolare esattamente la complessit\u00e0 computazionale di un programma, in quanto il numero di ramificazioni e le variabili da tenere in considerazione sono tali da rendere un approccio deterministico realisticamente non percorribile. Di conseguenza, si ricorre ad approcci che ci permettano di avere un'idea veritiera della complessit\u00e0 dell'algoritmo, stimata assumendo la casistica peggiore, ovvero calcolando la quantit\u00e0 massima di tempo e memoria che, nel peggiore dei casi, il nostro algoritmo richieder\u00e0 per essere eseguito.</p> <p>Per far questo, si utilizza la cosiddetta O-big notation, che in matematica ci permette di descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. In parole povere, un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(C_T(n) = \\mathbb{O}(n^2)\\) richieder\u00e0 un tempo di esecuzione pari al massimo ad \\(n^2\\), mentre un algoritmo con una complessit\u00e0 \\(C_S(n) = O(n * log(n))\\) occuper\u00e0 al massimo \\(n*log(n)\\) unit\u00e0 di memoria.</p> <p>Nota</p> <p>Nella notazione precedente, <code>n</code> indica una variabile che pu\u00f2 influenzare il numero di operazioni eseguite dall'algoritmo. Il perch\u00e9 occorra specificarla sar\u00e0 pi\u00f9 chiaro grazie ai prossimi esempi.</p>"},{"location":"material/02_programming/06_complexity/lecture/#alcuni-esempi","title":"Alcuni esempi","text":""},{"location":"material/02_programming/06_complexity/lecture/#ciclo-for-semplice","title":"Ciclo for (semplice)","text":"<p>Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo <code>for</code>:</p> <pre><code>n = 10;\nfor i da 1 a n:\n    scrivi i;\n    incrementa i;\nendfor\n</code></pre> <p>Notiamo innanzitutto che il valore del contatore <code>i</code> varia da 1 ad \\(n=10\\). Ci\u00f2 significa che, al pi\u00f9, saranno eseguite \\(n-1\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale (nel tempo) sar\u00e0 nell'ordine di \\(O(n)\\).</p> <p>Per quello che riguarda quella nello spazio, supponendo che ad ogni iterazione le variabili create all'interno del corpo del ciclo (righe 3-4) siano anche cancellate, l'algoritmo avr\u00e0 una complessit\u00e0 spaziale di caso peggiore pari a 2; in questi casi, ovvero quando la complessit\u00e0 di caso peggiore \u00e8 costante, si dice che \\(C_S = O(1)\\)</p>"},{"location":"material/02_programming/06_complexity/lecture/#cicli-for-annidati","title":"Cicli for annidati","text":"<p>Vediamo cosa accade nel caso si considerino due cicli <code>for</code> l'uno annidato all'interno dell'altro.</p> <pre><code>n = 10;\nfor i da 1 a n:\n    for j da 1 a n:\n        scrivi i;\n        scrivi j;\n    endfor\nendfor\n</code></pre> <p>Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile <code>i</code>) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile <code>j</code>). La complessit\u00e0 temporale di caso peggiore sar\u00e0 quindi \\(O(n^2)\\); per quello che riguarda invece la complessit\u00e0 spaziale, invece, assumendo un meccanismo analogo al precedente, avremo sempre \\(O(1)\\).V</p>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/","title":"2.7.1 Strutture dati base","text":"<p>Nelle lezioni precedenti abbiamo ad un certo punto parlato di \"insieme\" dei voti relativi ai nostri esami, senza per\u00f2 ben specificare come rappresentarlo con i concetti a nostra disposizione. Se ci pensiamo, infatti, non abbiamo (apparentemente) strumenti per rappresentare degli insiemi: non possiamo certamente utilizzare un singolo dato numerico, cos\u00ec come neanche un dato booleano o un carattere.</p> <p>Per risolvere questo problema (e, in realt\u00e0, mille altri) dobbiamo utilizzare una serie di concetti che vanno sotto il nome collettivo di strutture dati, ovvero dei costrutti progettati per organizzare e gestire un insieme di valori nella maniera pi\u00f9 efficiente possibile.</p> <p>Esistono diversi tipi di struttura dati, ognuno dei quali adatto ad un determinato scopo. Vediamo quelli pi\u00f9 diffusi.</p>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/#array","title":"Array","text":"<p>La maniera pi\u00f9 rapida di rappresentare i nostri voti \u00e8 quella di immaginarli come un vettore di numeri interi; per far questo esiste una struttura dati apposita chiamata array.</p> <p>Un array contiene quindi una sequenza di elementi, tipicamente dello stesso tipo (anche se, come vedremo, ci\u00f2 dipende dal linguaggio di programmazione), ed organizzati seguendo un ordine specifico, \"esplorabile\" mediante il concetto di indice.</p> <p>La presenza dell'indice permette di definire la modalit\u00e0 di accesso ai dati dell'array, indicata come accesso diretto. Nella pratica, possiamo estrarre qualsiasi elemento nell'array mediante l'indice stesso, in maniera diretta, senza dover \"scorrere\" l'intero vettore; questo fa s\u00ec che l'accesso abbia sempre una complessit\u00e0 \\(O(1)\\), dato che \u00e8 richiesta un'unica operazione.</p> <p>Nota</p> <p>A far da contraltare all'efficienza in termini di accesso vi \u00e8 una certa laboriosit\u00e0 legata all'inserimento o rimozione di un elemento dall'array.</p> <p>Tipicamente, un array viene rappresentato come una serie di singole variabili racchiuse tra due parentesi quadre. Ad esempio:</p> <pre><code>array = [8, 5, 12, 7, 4]\n</code></pre> <p>In particolare, il precedente array \u00e8 composto da elementi di tipo intero, ed ha una lunghezza pari a cinque elementi. Da notare che nella maggior parte dei linguaggi di programmazione l'indice del primo elemento non \u00e8 pari ad uno, ma a zero. La figura successiva esplicita adeguatamente questo concetto.</p> <p></p>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/#liste","title":"Liste","text":"<p>Una lista, conosciuta anche con il nome di linked list, \u00e8 una struttura dati simile all'array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento esplicito a quello successivo. Questo concetto \u00e8 esplicitato nella seguente figura:</p> <p></p> <p>In particolare, osserviamo che:</p> <ul> <li>il primo elemento nella lista, il cui valore \u00e8 <code>5</code>, ha un riferimento all'elemento successivo <code>R3</code>;</li> <li>il secondo elemento nella lista ha valore <code>3</code>, e conserva un riferimento all'elemento successivo <code>R2</code>;</li> <li>ci\u00f2 prosegue sino all'elemento <code>7</code>, che conserva un riferimento all'ultimo elemento <code>R12</code>.</li> </ul> <p>Il fatto che ogni elemento della lista contenga un riferimento al successivo ha due conseguenze:</p> <ol> <li>la prima consiste nel fatto che la lista \u00e8 una struttura dati ad accesso sequenziale, il che significa che occorrer\u00e0 \"scorrere\" tutti gli elementi della stessa fino ad arrivare a quello desiderato;</li> <li>la seconda sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o rimuovere un elemento da una lista che da un array: infatti, baster\u00e0 semplicemente modificare i riferimenti dagli elementi contigui a quello che si sta aggiungendo o rimuovendo.</li> </ol>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/#struct","title":"Struct","text":"<p>Una struct contiene un insieme di valori tipicamente chiamati membri o campi, il cui numero, sequenza e tipo sono tipicamente prefissati. Le struct trovano ampia applicazione in linguaggi come il C, ed hanno una sintassi di questo tipo:</p> <pre><code>struct nome_struct {\n    tipo_campo_uno id_campo_uno;\n    tipo_campo_due id_campo_due;\n};\n</code></pre> <p>Questa sintassi ci permette di definire quindi un tipo di struct chiamato <code>nome_struct</code> ed avente, in questo caso, due campi, ovvero un primo campo di tipo <code>tipo_campo_uno</code> ed identificatore <code>id_campo_uno</code>, ed un secondo campo di tipo <code>tipo_campo_due</code> ed identificatore <code>id_campo_due</code>.</p>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/#union","title":"Union","text":"<p>Una union \u00e8 un tipo di struttura dati che permette di specificare il tipo del valore che pu\u00f2 essere memorizzato al suo interno tra un certo numero di tipi primitivi. Nonostante sia sintatticamente affine alla struct, ne differisce quindi dal punto di vista funzionale: non \u00e8 una \"struttura\", ma piuttosto un \"ventaglio di possibili tipi\" da cui selezionare. La sintassi di una union \u00e8 simile alla seguente:</p> <pre><code>union nome_union {\n    tipo_union_uno id_union_tipo_uno;\n    tipo_union_due id_union_tipo_due;\n};\n</code></pre> <p>In questo caso, la union di nome <code>nome_union</code> potr\u00e0 assumere uno tra due possibili valori, ovvero <code>id_union_tipo_uno</code> di tipo <code>tipo_union_uno</code> o <code>id_union_tipo_due</code> di tipo <code>id_union_tipo_due</code>.</p> <p>Nota</p> <p>Per adesso, non facciamo un esempio \"concreto\" di union; lo vedremo pi\u00f9 avanti, quando ritorneremo su queste due strutture dati in C.</p>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/#pile-e-code","title":"Pile e code","text":"<p>Abbiamo visto in precedenza due tipi di accesso ai dati, ovvero quello casuale, proprio degli array, e quello sequenziale, proprio dell eliste. Esiste un altro tipo di accesso ai dati, chiamato accesso limitato, usato da specifiche strutture dati come pile e code. Vediamo brevemente entrambi questi tipi di struttura dati.</p>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/#pile","title":"Pile","text":"<p>Una pila (in inglese, stack) \u00e8 una struttura dati che contiene al suo interno variabili inserite e/o rimosse seguendo il principio Last-In, First-Out (LIFO). In altre parole, ci\u00f2 significa che l'ultimo elemento che accede ad una pila \u00e8 anche il primo ad uscirne.</p> <p>Una pila ha a disposizione quindi due diverse operazioni, ovvero quella di <code>push</code>, mediante la quale un oggetto viene inserito in cima allo stack, e quella di <code>pop</code>, che permette di estrarre l'oggetto dalla cima dello stesso.</p> <p>Il funzionamento della pila \u00e8 schematizzato all'interno della seguente figura.</p> <p></p> <p>Nota</p> <p>Il motivo alla base dell'aggettivo \"limitato\" \u00e8 da ricercarsi proprio nel fatto che sia il push sia il pop possono essere effettuati soltanto sugli elementi in cima alla pila.</p>"},{"location":"material/02_programming/07_data_structures/01_intro/lecture/#code","title":"Code","text":"<p>Una coda (in inglese, queue) \u00e8 una struttura dati concettualmente simile alla pila, ma che segue il principio (First-In, First-Out) (FIFO); in questo caso, il primo ad uscire dalla coda sar\u00e0 il primo ad esservi entrato.</p> <p>Le operazioni definite sulla coda sono concettualmente simili a quelle definite sulla pila, e vengono chiamate <code>enqueue</code> (per mettere in coda un nuovo elemento) e <code>dequeue</code> (per togliere dalla coda l'elemento presente da pi\u00f9 tempo).</p> <p>Il funzionamento della coda \u00e8 schematizzato all'interno della seguente figura.</p> <p></p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/","title":"2.7.2 Strutture dati avanzate","text":"<p>In questa lezione, vedremo prima come progettare una pila ed una coda come degli array, per poi passare a presentare un altro tipo di strutture dati estremamente utilizzate, ovvero grafi ed alberi.</p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#pila-come-array","title":"Pila come array","text":""},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#variabili-da-utilizzare","title":"Variabili da utilizzare","text":"<p>Proviamo adesso ad implementare una pila utilizzando un array. Per farlo, avremo bisogno di tre elementi:</p> <ol> <li>un array, che chiameremo <code>stack</code>;</li> <li>una variabile che indica l'elemento in cima allo <code>stack</code>, che chiameremo <code>top</code>;</li> <li>una variabile che indica la lunghezza dello <code>stack</code>, che chiameremo <code>capacity</code>.</li> </ol> <p>Da qui consegue che:</p> <ul> <li>lo <code>stack</code> \u00e8 pieno quando <code>top</code> \u00e8 pari a <code>capacity</code>;</li> <li>lo <code>stack</code> \u00e8 vuoto quando <code>top</code> \u00e8 pari a <code>0</code>.</li> </ul>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#operazioni-di-push-e-pop","title":"Operazioni di <code>push</code> e <code>pop</code>","text":"<p>Ricordiamo che lo stack segue una strategia LIFO, per cui una <code>push</code> prevede che sia inserito un nuovo elemento nella parte superiore dell'array (ovvero, all'indice <code>top</code>). Quindi:</p> <pre><code>push(stack, top, capacity, element):\n\nSTEP 1 -&gt; top = top + 1;\nSTEP 2 -&gt; if (top &gt;= capacity)\n              return ERROR;\nSTEP 3 -&gt; top = element;\n</code></pre> <p>Ci\u00f2 implica che:</p> <ul> <li>allo <code>STEP 1</code> viene aumentato il valore attuale di <code>top</code>;</li> <li>allo <code>STEP 2</code> viene verificato che <code>top</code> non sia superiore a <code>capacity</code>, e che quindi la pila non sia gi\u00e0 piena;</li> <li>allo <code>STEP 3</code> l'elemento <code>element</code> viene inserito al posto <code>top</code> dello della pila.</li> </ul> <p>L'operazione di <code>pop</code> invece prevede che l'elemento al vertice dello stack sia rimosso:</p> <pre><code>pop(stack, top)\n\nSTEP 1 -&gt; if (top &lt;= 0):\n              return ERROR;\nSTEP 2 -&gt; element = top;\nSTEP 3 -&gt; top = top - 1;\nSTEP 4 -&gt; return element;\n</code></pre> <p>Ci\u00f2 implica che:</p> <ul> <li>allo <code>STEP 1</code> si verifica che lo <code>stack</code> non sia vuoto;</li> <li>allo <code>STEP 2</code> viene assegnato ad <code>element</code> il valore presente al <code>top</code> dello <code>stack</code>;</li> <li>allo <code>STEP 3</code> il valore di <code>top</code> viene ridotto di uno;</li> <li>allo <code>STEP 4</code> viene restituito il valore estratto dallo <code>stack</code>.</li> </ul>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#coda-come-array","title":"Coda come array","text":""},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#variabili-da-utilizzare_1","title":"Variabili da utilizzare","text":"<p>Anche in questo caso dovremo usare tre diversi elementi:</p> <ol> <li>un array, che chiameremo <code>queue</code>;</li> <li>una variabile che indica l'elemento da pi\u00f9 tempo in coda, chiamata <code>first</code>;</li> <li>una variabile che indica la lunghezza della <code>queue</code>, che chiameremo <code>capacity</code>.</li> </ol> <p>Ovviamente, come nel caso precedente, se <code>first</code> \u00e8 uguale a <code>capacity</code> allora la coda \u00e8 piena.</p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#operazioni-di-enqueue-e-dequeue","title":"Operazioni di enqueue e dequeue","text":"<p>Ricordiamo che la strategia seguita da una coda \u00e8 di tipo FIFO, per cui dovremo definire i metodi <code>enqueue</code> e <code>dequeue</code>.</p> <p>In particolare, il metodo <code>enqueue</code> prevede che al primo posto nell'array sia inserito l'elemento che si vuole aggiungere.</p> <pre><code>enqueue(array, element)\n\nSTEP 1 -&gt; if (first &gt;= capacity):\n              return ERROR;\nSTEP 2 -&gt; for element in queue:\n              element = prev_element;\nSTEP 3 -&gt; last = new_element;\n</code></pre> <p>In pratica:</p> <ul> <li>allo <code>STEP 1</code>, controlliamo che la coda non sia gi\u00e0 satura;</li> <li>allo <code>STEP 2</code>, spostiamo ogni elemento della coda in avanti (in pratica, assegnamo a ciascun elemento il valore dell'elemento precedente nella coda);</li> <li>allo <code>STEP 3</code>, aggiungiamo il nuovo elemento in ultima posizione.</li> </ul> <p>La procedura di <code>dequeue</code>, di converso, comporta la semplice rimozione dell'ultimo elemento nell'array.</p> <pre><code>dequeue(array)\n\nSTEP 1 -&gt; remove first from queue;\nSTEP 2 -&gt; first = prev_element;\n</code></pre> <p>In altre parole:</p> <ul> <li>allo <code>STEP 1</code> viene rimosso il primo elemento dalla coda;</li> <li>allo <code>STEP 2</code> il valore di first viene aggiornato, assegnandovi quello associato all'elemento immediatamente precedente.</li> </ul>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#grafi","title":"Grafi","text":"<p>Il concetto di grafo pu\u00f2 essere compreso in maniera intuitiva partendo da quelli che sono i nostri contatti sulle reti sociali (possiamo tranquillamente pensare a Facebook).</p> <p>Chiunque abbia un account su Facebook, infatti, ha una serie pi\u00f9 o meno estesa di \"collegamenti\", i quali a loro volta possono essere collegati tra loro, andando a creare una sorta di \"intreccio\" di relazioni. Rappresentando ciascun account con un punto, e tutti i collegamenti mediante delle linee, avremmo una situazione pi\u00f9 o meno simile a quella che vediamo nella figura seguente.</p> <p></p> <p>Notiamo anche che, nella maggior parte dei casi, la conoscenza tra due persone \u00e8 bidirezionale: ovvero, dato che noi conosciamo una certa persona, questa persona ci conoscer\u00e0 a sua volta.</p> <p>Questo modo di schematizzare una rete sociale avviene mediante una struttura nota come grafo.</p> <p>Formalmente, un grafo \u00e8 definito come una coppia \\(G=(V, E)\\), dove \\(V\\) \u00e8 l'insieme dei vertici, o nodi (quelli che abbiamo prima chiamato \"punti\"), mentre \\(E\\) \u00e8 l'insieme degli archi, o lati che connette detti vertici (le \"linee\"). Interessante notare come un arco possa essere rappresentato mediante i nodi che connette: infatti, si pu\u00f2 dire che l'arco che connette i vertici \\(u\\) e \\(v\\) \u00e8 descrivibile mediante la coppia \\((u, v)\\).</p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#grafi-diretti-e-non-diretti","title":"Grafi diretti e non diretti","text":"<p>Nell'esempio precedente, abbiamo visto come le relazioni all'interno di un social network siano perlopi\u00f9 bidirezionali. Non \u00e8 quindi possibile individuare una direzione \"specifica\" nell'arco che collega due nodi: l'arco che collega i nodi \\(u\\) e \\(v\\) pu\u00f2 essere inteso sia come un collegamento che da \\(u\\) va verso \\(v\\), sia, al contrario, come un collegamento che va da \\(v\\) verso \\(u\\). Una situazione di questo tipo implica la presenza di un grafo non diretto. In un grafo non diretto l'arco \\((u, v)\\) coincide quindi con l'arco \\((v, u)\\).</p> <p>Per un grafo non diretto possiamo definire la condizione di adiacenza per due vertici \\(u\\) e \\(v\\):</p> <p>Vertici adiacenti</p> <p>Due vertici \\(u\\) e \\(v\\) sono definiti adiacenti o vicini quando vi \u00e8 un arco che li connette.</p> <p>Contestualmente, possiamo definire il concetto di grado di un vertice:</p> <p>Grado di un vertice</p> <p>Si definisce grado di un vertice \\(u\\) il numero di archi che vi incidono.</p> <p>Ad esempio, se abbiamo cento contatti su Facebook, il nostro \"grado\" all'interno del social network sar\u00e0 proprio pari a 100.</p> <p>Viceversa, se ad ogni arco \u00e8 associata una direzione, otterremo un grafo diretto, nel quale non sar\u00e0 sempre possibile andare indifferentemnete da \\(u\\) a \\(v\\), e viceversa. Per fare un esempio di grafo indiretto, immaginiamo che i nodi del nostro grafo siano gli incroci di una citt\u00e0, mentre i lati le vie che li connettono; in tal senso, ogni via a senso unico sar\u00e0 un esempio di arco diretto, e percorrobile (teoricamente) in un'unica direzione.</p> <p>Per un grafo diretto dovremo ridefinire il concetto di grado, separandolo in due concetti distinti.</p> <p>Grado esterno</p> <p>Si definisce grado esterno, o out-degree, di un vertice \\(u\\) il numero di archi in uscita da \\(u\\).</p> <p>Grado interno</p> <p>Si definisce grado interno, o in-degree, di un vertice \\(u\\) il numero di archi in ingresso su \\(u\\).</p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#cammini-e-cicli","title":"Cammini e cicli","text":"<p>Prendendo una licenza ed usando un \"gioco di parole\", immaginiamo di voler contattare il contatto di un nostro contatto. Per farlo, potremmo semplicemente chiedere al nostro amico di presentarci il suo amico il quale, ovviamente, non ha un collegamento diretto con noi, ma che risulta essere in qualche modo \"raggiungibile\": esiste, quindi, un percorso o, pi\u00f9 propriamente, un cammino, che mette in relazione noi con la nostra conoscenza futura.</p> <p>Ovviamente, il numero di cammini esistenti tra due nodi \\(u\\) e \\(v\\) \u00e8 potenzialmente molto elevato, se non addirittura infinito: ad esempio, nel caso precedente, potremmo sicuramente costruire una rete di contatti indiretti con la quale arrivare al nostro obiettivo in maniera pi\u00f9 \"larga\". Tuttavia, \u00e8 opportuno sempre cercare il cammino minimo (shortest path), che rappresenta il modo pi\u00f9 diretto per arrivare al nostro obiettivo.</p> <p>Definiamo inoltre altre due condizioni.</p> <p>Cicli</p> <p>Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo.</p> <p>Connessione del grafo</p> <p>Un grafo si dice connesso quando esiste almeno un percorso che colleghi due nodi \\((u, v)\\), \\(\\forall (u, v) \\in V\\).</p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#un-esempio","title":"Un esempio","text":"<p>Facciamo un esempio pratico. Immaginiamo che Bob voglia conoscere Eric; come \u00e8 possibile notare, non esiste alcun grafo che li collega. Tuttavia, Bob ha due strade: la prima \u00e8 quella di chiedere ad Alice di presentargli Charlie, che potrebbe a sua volta introdurgli Eric. La seconda, invece, prevede che Bob si metta in contatto con David, che potr\u00e0 direttamente introdurgli Eric.</p> <p></p> <p>Abbiamo quindi individuato due cammini tra Bob ed Eric, di cui uno (quello che passa per David) \u00e8 da considerarsi minimo, in quanto tiene conto del numero minimo di vertici e lati intercorrenti tra il nodo di partenza e quello di arrivo.</p> <p>Per quello che riguarda i cicli, quello che va da Alice verso Bob verso David e torna poi ad Alice \u00e8 da considerarsi appunto come tale.</p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#grafo-pesato","title":"Grafo pesato","text":"<p>E' possibile che a tutti gli archi di un grafo sia associato un peso, ovvero un valore numerico. In uno degli esempi precedenti, ovvero quello delle vie e degli incroci, potremmo associare ad ogni strada un numero indicativo della sua lunghezza in metri:</p> <p></p> <p>Un grafo i cui archi hanno dei pesi \u00e8 chiamato grafo pesato. Ovviamente, per trovare il cammino minimo in un grafo di questo tipo, dovremo tenere conto del valore dei pesi: nella figura precedente, infatti, TODO: esempio</p>"},{"location":"material/02_programming/07_data_structures/02_advanced/lecture/#alberi","title":"Alberi","text":"<p>Un concetto cugino di quello di grafo \u00e8 quello di albero, struttura dati particolarmente usata soprattutto in ambito informatico, che permette di modellare una struttura gerarchica fatta di un nodo radice e di una serie di nodi figli, fino ai nodi foglia, ovvero quelli che non hanno ulteriori successori.</p> <p>Per comprendere al meglio la struttura di un albero, vediamo quella che \u00e8 la \"geneaologia\" della razza umana (in versione volutamente semplificata):</p> <p></p> <p>In particolare, notiamo come a partire da un \"antenato comune\" (il famoso \"anello mancante\") si siano evoluti diversi rami dell'albero, ognuno afferente ad un diverso genere, di cui gli ultimi esemplari rappresentano i nodi foglia; nel nostro caso, l'Homo sapiens \u00e8 la foglia del ramo rappresentativo del genere Homo.</p> <p>Nota</p> <p>L'albero \u00e8 un grafo, con delle particolari caratteristiche: infatti, \u00e8 non diretto, connesso ed aciclico (ovvero, non presenta alcun ciclo al suo interno).</p> <p>Concludiamo questo excursus citando infine gli alberi binari, caratterizzati dal fatto che ciascun nodo ha (al pi\u00f9) due figli.</p>"},{"location":"material/02_programming/08_paradigms/lecture/","title":"2.8 I paradigmi di programmazione","text":"<p>Nella lezione 6 abbiamo parlato del paradigma della programmazione strutturata riferendoci a tutte quelle tecniche volte ad imprimere una certa struttura nel nostro codice. Abbiamo per\u00f2 anche sottolineato come quello della programmazione strutturata non sia l'unico paradigma di programmazione presente al giorno d'oggi; esistono infatti diversi altri approcci, tutti per\u00f2 riconducibili a due macro-aree, ovvero quelle della programmazione imperativa da un lato, e della programmazione dichiarativa dall'altro.</p>"},{"location":"material/02_programming/08_paradigms/lecture/#la-programmazione-imperativa","title":"La programmazione imperativa","text":"<p>Come suggerito dal termine stesso, il paradigma della programmazione imperativa prevede che il nostro programma espliciti una sequenza ben definita di istruzioni da seguire, integrate secondo le strutture che abbiamo visto quando abbiamo parlato della programmazione strutturata.</p> <p>In generale, questo approccio risulta essere decisamente comprensibile dal programmatore, che si limita ad indicare una sequenza pi\u00f9 o meno articolata di \"ordini\"; tuttavia, \u00e8 importante sottolineare come la maggior chiarezza del paradigma imperativo rispetto a quello dichiarativo comporti contestualmente una maggior verbosit\u00e0 del primo rispetto al secondo.</p> <p>Esempi di linguaggi di programmazione che adottano il paradigma imperativo sono C, C++, Java e Python.</p> <p>Tra i linguaggi di programmazione imperativa si annoverano tre distinti \"stili\" di programmazione, ovvero quello strutturato (che abbiamo gi\u00e0 trattato), quello procedurale e quello modulare.</p> <p>In particolare, nell'approccio procedurale il programma viene suddiviso in piccole task, ciascuna delle quali \u00e8 descritta nel codice mediante una procedura, concetto assimilabile al moderno \"metodo\" o \"funzione\". Il paradigma modulare fa un ulteriore passo in avanti in tal senso, e struttura il programma in una serie di moduli indipendenti combinati tra loro a formare il software definitivo.</p>"},{"location":"material/02_programming/08_paradigms/lecture/#la-programmazione-dichiarativa","title":"La programmazione dichiarativa","text":"<p>Il paradigma di programmazione dichiarativa prevede che il risultato richiesto sia descritto, e che non siano invece specificate le singole istruzioni da parte dello sviluppatore.</p> <p>In pratica, a differenza del paradigma imperativo, che definisce come arrivare ad un risultato, il paradigma dichiarativo si limita a descrivere ci\u00e0 che si vuole ottenere, posizionandosi di conseguenza pi\u00f9 vicino all'essere umano che al calcolatore (ovvero ad un livello di astrazione pi\u00f9 elevato). Esempi di linguaggi di programmazione che seguono il paradigma imperativo sono Prolog, Lisp o SQL.</p> <p>In analogia al paradigma imperativo, anche quello dichiarativo vede due possibili stili di programmazione, ovvero quello funzionale e quello logico. In ogni caso, i paradigmi dichiarativi sono generalmente pi\u00f9 complessi da utilizzare rispetto a quelli imperativi, in quanto richiedono un elevato apporto logico da parte del programmatore, che invece nel paradigma imperativo deve \"limitarsi\" ad implementare correttamente una sequenza di istruzioni.</p>"},{"location":"material/03_algorithms/01_sorting/01_selection/lecture/","title":"3.1.1 Selection sort","text":"<p>Uno dei problemi pi\u00f9 \"classici\" nello studio degli algoritmi \u00e8 quello di ordinare una lista di elementi affini (ovvero dello stesso tipo). Questo problema, soltanto apparentemnete banale, ha in realt\u00e0 numerosi riscontri pratici, in quanto capita molto spesso di dover ordinare una lista secondo un certo criterio (ad esempio, un elenco di nomi in ordine alfabetico, oppure i prezzi di diversi beni in ordine ascendente). Per far questo, nel tempo sono stati definiti diversi algoritmi detti di ordinamento o, in inglese, sorting algorithms.</p> <p>Il primo algoritmo che vedremo \u00e8 chiamato selection sort. Questo \u00e8 un algoritmo di tipo iterativo, che analizza quindi un elemento della lista alla volta alla ricerca dell'elemento minore; per comprendere appieno il funzionamento dell'algoritmo, \u00e8 opportuno utilizzare un esempio concreto.</p>"},{"location":"material/03_algorithms/01_sorting/01_selection/lecture/#esempio-e-formalizzazione","title":"Esempio e formalizzazione","text":"<p>Immaginiamo quindi di voler ordinare un mazzo di dieci carte dalla pi\u00f9 piccola alla pi\u00f9 grande. Per farlo, seguiamo questi passi:</p> <ol> <li>disponiamo tutte le carte presenti nel mazzo in un'unica fila;</li> <li>cerchiamo la carta pi\u00f9 piccola, e posizioniamola all'estrema sinistra del mazzo;</li> <li>dividiamo la fila in due parti: nella parte pi\u00f9 a sinistra inseriamo le carte gi\u00e0 ordinate, mentre in quella destra quelle da ordinare;</li> <li>prendiamo dalla fila di destra la carta pi\u00f9 piccola, posizionandola a destra dell'ultimo elemento della fila di sinistra;</li> <li>reiteriamo il passo 4 fino a che non vi sono pi\u00f9 carte nella fila di destra.</li> </ol> <p>Volendo, \u00e8 possibile formalizzare i passi precedenti come segue. Dato un vettore \\(x\\) fatto da \\(n\\) numeri interi:</p> <ol> <li>Associare ad \\(i\\) il primo indice dell'array, ovvero \\(i = 0\\), ed a \\(j\\) l'ultimo, ovvero \\(j = n-1\\).</li> <li>Associare alla variabile \\(m\\) il valore di \\(x(0)\\), supponendo che \\(m\\) sia il valore pi\u00f9 piccolo attualmente presente all'interno dell'array.</li> <li>Confrontare \\(m\\) con tutti gli elementi \\(x(k), k \\in (0, n-1]\\). Se \\(x(k) &lt; m\\) per qualche \\(k\\), allora \\(m = x(k)\\).</li> <li>Aumentare il valore di \\(i\\) di un'unit\u00e0.</li> <li>Reiterare le istruzioni 3-4 fino a che \\(i = x(n-1)\\).</li> </ol>"},{"location":"material/03_algorithms/01_sorting/01_selection/lecture/#esempio-pratico","title":"Esempio pratico","text":"<p>Immaginiamo di avere un array di numeri interi, i cui elementi assumono valore <code>[12, 4, 8, 7, 2]</code>. Seguiamo i passi evidenziati in precedenza per l'algoritmo.</p> <ul> <li>Step 1: imponiamo \\(i = 0, j = 4\\).</li> <li>Step 2: imponiamo \\(m = x(0) = 12\\).</li> <li>Step 3: dal confronto, emerge che \\(x(1) = 4 &lt; m \\Rightarrow m = x(1)\\). Continuando per\u00f2 ad incrementare \\(i\\), notiamo che \\(x(4) = 2 &lt; m \\Rightarrow m = x(4)\\).</li> <li>Step 4: poniamo \\(i = i + 1 = 2\\).</li> <li>Step 5: reiteriamo le istruzioni 3-4 fino a che \\(i = 4\\), ottenendo l'array finale.</li> </ul> <p>In altre parole:</p> <pre><code>START\n\nCICLO 0\nx = [12, 4, 8, 7, 2];\ni = 0; j = 4; min = x(0) = 12;\n\nCICLO 1\nx = [2, 12, 4, 8, 7];\ni = 1; j = 4; min = x(1) = 12;\n\nCICLO 2\nx = [2, 4, 12, 8, 7];\ni = 2; j = 4; min = x(2) = 12;\n\nCICLO 3\nx = [2, 4, 7, 12, 8];\ni = 3; j = 4; min = x(3) = 12;\n\nCICLO 4\nx = [2, 4, 7, 8, 12];\ni = 4; j = 4; min = x(4) = 12;\n\nSTOP\n</code></pre>"},{"location":"material/03_algorithms/01_sorting/01_selection/lecture/#analisi-della-complessita-computazionale-dellalgoritmo","title":"Analisi della complessit\u00e0 computazionale dell'algoritmo","text":"<p>L'algoritmo di selection sort cicla su tutti gli \\(n\\) indici di un array. Per comprendere quante operazioni sono necessarie a completare l'ordinamento, dovremo contare il numero di comparazioni necessarie ad individuare l'elemento \"minore\" attualmente presente all'interno dell'array.</p> <p>In particolare, alla prima iterazione (con \\(i = 0\\)), avremo la necessit\u00e0 di effettuare \\(n\\) operazioni di comparazione, una per ogni elemento dell'array; alla seconda, con \\(i = 1\\), dovremo fare \\(n - 1\\) confronti, alla terza \\(n - 2\\), e cos\u00ec via. Ci\u00f2 implica che avremo bisogno di un numero di operazioni pari a:</p> \\[ C_T = n + (n - 1) + \\ldots + 2 + 1 = \\frac{n^2}{2} + \\frac{n}{2} \\] <p>La complessit\u00e0 di caso peggiore tiene conto del limite asintotico del valore precedente, ed \u00e8 chiaramente pari ad un \\(O(n^2)\\).</p>"},{"location":"material/03_algorithms/01_sorting/02_bubble/lecture/","title":"3.1.2 Bubble sort","text":""},{"location":"material/03_algorithms/01_sorting/02_bubble/lecture/#idea-di-base","title":"Idea di base","text":"<p>L'algoritmo di ordinamento a bolle (bubble sort) ordina un array confrontando e scambiando gli elementi adiacenti di un vettore. In particolare, l'algoritmo sposta, in maniera rigorosamente iterativa, i valori pi\u00f9 alti verso la fine dell'array, mentre i valori pi\u00f9 piccoli vengono spostati verso l'inizio. Questo processo (che ricorda un po' delle \"bolle\" che \"risalgono\" in un bicchiere di champagne) viene ripetuto fino a che l'array non \u00e8 completamente ordinato.</p> <p>L'algoritmo si articola in due step reiterati per un certo numero di volte.</p> <ol> <li><code>compare</code>: nel primo step, compariamo (coppia a coppia) tutti gli elementi adiacenti all'interno dell'array.</li> <li><code>swap</code>: se dallo step precedente risulta che l'ordinamento \u00e8 sbagliato, invertiamo la coppia di elementi nell'array.</li> </ol>"},{"location":"material/03_algorithms/01_sorting/02_bubble/lecture/#esempio-pratico","title":"Esempio pratico","text":"<pre><code>START\n\nINIZIALIZZAZIONE\nx = [12, 4, 8, 7, 2]\ni = 1; j = 4;\n\nITERAZIONE 1\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 2 &lt; 7 ==&gt; TRUE\nSOSTITUZIONE:   [12, 4, 8, 2, 7]\nAGGIORNAMENTO:  j ==&gt; 3\n\nITERAZIONE 2\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 2 &lt; 8 ==&gt; TRUE\nSOSTITUZIONE:   [12, 4, 2, 8, 7]\nAGGIORNAMENTO:  j ==&gt; 2\n\nITERAZIONE 3\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 2 &lt; 4 ==&gt; TRUE\nSOSTITUZIONE:   [12, 2, 4, 8, 7]\nAGGIORNAMENTO:  j ==&gt; 1\n\nITERAZIONE 4\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 2 &lt; 12 ==&gt; TRUE\nSOSTITUZIONE:   [2, 12, 4, 8, 7]\nAGGIORNAMENTO:  i ==&gt; 2, j ==&gt; 4\n\nITERAZIONE 5\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 7 &lt; 8 ==&gt; TRUE\nSOSTITUZIONE:   [2, 12, 4, 7, 8]\nAGGIORNAMENTO:  j ==&gt; 3\n\nITERAZIONE 6\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 7 &lt; 8 ==&gt; FALSE\nSOSTITUZIONE:   [2, 12, 4, 7, 8]\nAGGIORNAMENTO:  j ==&gt; 2\n\nITERAZIONE 7\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 4 &lt; 12 ==&gt; TRUE\nSOSTITUZIONE:   [2, 4, 12, 7, 8]\nAGGIORNAMENTO:  j ==&gt; 1\n\nITERAZIONE 8\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 8 &lt; 7 ==&gt; FALSE\nSOSTITUZIONE:   [2, 4, 12, 7, 8]\nAGGIORNAMENTO:  i ==&gt; 3, j ==&gt; 4\n\nITERAZIONE 9\nCONFRONTO:      V(j) &lt; V(j-1) &lt;==&gt; 7 &lt; 12 ==&gt; FALSE\nSOSTITUZIONE:   [2, 4, 7, 12, 8]\nAGGIORNAMENTO:  j ==&gt; 2\n</code></pre>"},{"location":"material/03_algorithms/01_sorting/02_bubble/lecture/#pseudocodice","title":"Pseudocodice","text":""},{"location":"material/03_algorithms/01_sorting/02_bubble/lecture/#complessita-numerica","title":"Complessit\u00e0 numerica","text":""},{"location":"material/03_algorithms/01_sorting/02_bubble/lecture/#codice","title":"Codice","text":"<pre><code>function sortedArray = bubbleSort(array)\n    n = length(array); % Lunghezza dell'array\n    for i = 1:n-1\n        for j = 1:n-i\n            if array(j) &gt; array(j+1)\n                % Scambia gli elementi\n                temp = array(j);\n                array(j) = array(j+1);\n                array(j+1) = temp;\n            end\n        end\n    end\n    sortedArray = array; % Restituisce l'array ordinato\nend\n\n% Esempio di array\narray = [64, 34, 25, 12, 22, 11, 90];\n\n% Ordinamento con Bubble Sort\nsortedArray = bubbleSort(array);\n\n% Visualizza il risultato\ndisp('Array ordinato:');\ndisp(sortedArray);\n</code></pre>"},{"location":"material/03_algorithms/01_sorting/03_insertion/lecture/","title":"Insertion sort","text":"<pre><code>function sortedArray = insertionSort(array)\n    n = length(array); % Lunghezza dell'array\n    for i = 2:n\n        key = array(i); % Elemento da inserire nella posizione corretta\n        j = i - 1;\n        % Sposta gli elementi maggiori di 'key' verso destra\n        while j &gt; 0 &amp;&amp; array(j) &gt; key\n            array(j + 1) = array(j);\n            j = j - 1;\n        end\n        % Inserisce il valore 'key' nella posizione corretta\n        array(j + 1) = key;\n    end\n    sortedArray = array; % Restituisce l'array ordinato\nend\n</code></pre> <p>Spiegazione del funzionamento: Suddivisione dell'array:</p> <p>L'algoritmo considera due parti dell'array: una parte ordinata (inizialmente il primo elemento) e una parte non ordinata (gli altri elementi). Iterazione:</p> <p>Si parte dal secondo elemento e si confronta con gli elementi della parte ordinata. Se il valore \u00e8 pi\u00f9 piccolo, gli elementi maggiori vengono spostati a destra. Inserimento:</p> <p>L'elemento corrente viene posizionato nella sua posizione corretta nella parte ordinata. Ripetizione:</p> <p>Si ripete il processo per tutti gli elementi dell'array. Complessit\u00e0: Tempo: Caso migliore (array gi\u00e0 ordinato):  O ( n ) O(n). Caso peggiore (array in ordine inverso):  O ( n 2 ) O(n  2  ). Spazio: In-place, quindi  O ( 1 ) O(1) memoria aggiuntiva. Se hai bisogno di una spiegazione pi\u00f9 dettagliata o ulteriori modifiche, fammi sapere! \ud83d\ude0a</p> <p>Che cos\u2019\u00e8 Insertion Sort? Insertion Sort \u00e8 un algoritmo di ordinamento semplice ed efficiente per piccoli array. Funziona come farebbe una persona quando ordina manualmente delle carte da gioco: seleziona una carta (elemento), la confronta con quelle gi\u00e0 ordinate e la inserisce nella posizione corretta.</p> <p>Passaggi dell'algoritmo Considerare il primo elemento come gi\u00e0 ordinato:</p> <p>L'algoritmo inizia con l'assunto che il primo elemento dell'array sia ordinato. La parte rimanente \u00e8 considerata non ordinata. Iterare sugli elementi non ordinati:</p> <p>Per ogni elemento nella parte non ordinata (dal secondo elemento in poi), determina la sua posizione corretta nella parte ordinata. Inserimento nella posizione corretta:</p> <p>Scorri gli elementi ordinati all'indietro per trovare dove inserire l'elemento corrente. Sposta gli elementi maggiori verso destra per fare spazio all'elemento. Inserisci l'elemento nella posizione trovata. Ripetere per ogni elemento:</p> <p>Il processo si ripete per ogni elemento fino a che tutta la lista \u00e8 ordinata. Esempio passo-passo Consideriamo l'array: [64, 34, 25, 12].</p> <p>Iterazione 1 (i=2): Elemento da inserire (key): 34. Parte ordinata: [64]. Confronta 34 con 64: Sposta 64 a destra \u2192 [64, 64, 25, 12]. Inserisci 34 al posto corretto \u2192 [34, 64, 25, 12]. Iterazione 2 (i=3): Elemento da inserire (key): 25. Parte ordinata: [34, 64]. Confronta 25 con 64: Sposta 64 a destra \u2192 [34, 64, 64, 12]. Confronta 25 con 34: Sposta 34 a destra \u2192 [34, 34, 64, 12]. Inserisci 25 al posto corretto \u2192 [25, 34, 64, 12]. Iterazione 3 (i=4): Elemento da inserire (key): 12. Parte ordinata: [25, 34, 64]. Confronta 12 con 64: Sposta 64 a destra \u2192 [25, 34, 64, 64]. Confronta 12 con 34: Sposta 34 a destra \u2192 [25, 34, 34, 64]. Confronta 12 con 25: Sposta 25 a destra \u2192 [25, 25, 34, 64]. Inserisci 12 al posto corretto \u2192 [12, 25, 34, 64]. Propriet\u00e0 dell'algoritmo Stabile: Mantiene l'ordine relativo degli elementi uguali. In-place: Non richiede memoria aggiuntiva significativa. Prestazioni: O ( n 2 ) O(n  2  ) nel caso peggiore (array in ordine inverso). O ( n ) O(n) nel caso migliore (array gi\u00e0 ordinato). Applicazioni: Ottimo per piccoli array o quando l'array \u00e8 quasi ordinato. Se hai altri dubbi o vuoi un esempio pi\u00f9 complesso, fammi sapere! \ud83d\ude0a</p>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/","title":"15 - Algoritmi di ricerca","text":"<p>Vediamo in ultimo gli algoritmi di ricerca.</p>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/#151-ricerca-binaria","title":"15.1 - Ricerca binaria","text":""},{"location":"material/03_algorithms/02_search/01_linear/lecture/#introduzione-al-problema","title":"Introduzione al problema","text":"<p>Supponiamo di voler trovare un determinato elemento all'interno di una lista di valori, come ad esempio il numero di un nostro contatto all'interno della nostra rubrica (ovviamente, supponiamo di non voler utilizzare la funzionalit\u00e0 di ricerca integrata nella rubrica stessa).</p> <p>Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica.</p> <p>Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare (linear search). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto?</p> <p>Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2, che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice.</p> <p>Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search. </p> <p>Definizione del problema</p> <p>Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata.</p>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/#descrizione-dellalgoritmo","title":"Descrizione dell'algoritmo","text":"<p>L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli. Facciamo un rapido esempio per capire al meglio di cosa si tratta.</p> <p>Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento. Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore.</p> <p>Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra.</p> <p>La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false, ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore. Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta.</p> <p>La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore. Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0.</p> <p>Il gioco prosegue come segue.</p> <pre><code>ROUND 3\n--------------------------------\nALICE -&gt; 62 --- BOB -&gt; INFERIORE\n--------------------------------\nROUND 4\n--------------------------------\nALICE -&gt; 56 --- BOB -&gt; SUPERIORE\n--------------------------------\nROUND 5\n--------------------------------\nALICE -&gt; 59 --- BOB -&gt; SUPERIORE\n--------------------------------\nROUND 6 (BOB IMPALLIDISCE)\n--------------------------------\nALICE -&gt; 61 --- BOB -&gt; INFERIORE\n--------------------------------\nROUND 7 (BOB TREMANTE...)\n--------------------------------\nALICE -&gt; 60 --- BOB -&gt; PAGARE\n</code></pre> <p>In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato.</p>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/#fase-di-progettazione","title":"Fase di progettazione.","text":"<p>Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc.</p> <p>Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice, e poi definirne il flow chart.</p> <p>TODO: da qui</p> <p>Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole.</p> <p>Ecco un'implementazione step-by-step:</p> <ol> <li>sia min = 1 e max = n</li> <li>troviamo il valore medio tra min e max, arrotondato ad un intero</li> <li>se abbiamo trovato il numero, fermiamoci. altrimenti</li> <li>se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1</li> <li>se l'ipotesi era troppo altra, impostiamo max a n/2 - 1</li> <li>torniamo al passo 2</li> </ol>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/#todo-flow-chart","title":"TODO: flow chart","text":""},{"location":"material/03_algorithms/02_search/01_linear/lecture/#complessita-computazionale","title":"Complessit\u00e0 computazionale","text":"<p>Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi.</p> <p>Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica.</p> <p>L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta.</p> <p>Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni.</p> <p>Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni.</p> <p>Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\). Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\).</p> <p>Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\), fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22.</p> <p>Nota</p> <p>I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22.</p> <p>Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente.</p>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/#152-ricerca-in-ampiezza","title":"15.2 - Ricerca in ampiezza","text":""},{"location":"material/03_algorithms/02_search/01_linear/lecture/#descrizione-dellalgoritmo_1","title":"Descrizione dell'algoritmo","text":"<p>La ricerca in ampiezza, o, in inglese, breath-first search (BFS), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi.</p> <p>Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\), oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi.</p> <p>Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda.</p> <p>Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi.</p>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/#bfs-sugli-alberi","title":"BFS sugli alberi","text":"<p>Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero.</p> <p>La BFS opera considerando due parametri:</p> <ol> <li>il nodo attualmente ispezionato;</li> <li>i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato.</li> </ol> <p>In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i</p> <ol> <li>il nodo radice, ovvero quello da cui parte la ricerca;</li> <li>la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice;</li> <li>il predecessore del nodo</li> </ol> <p>Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\).</p> <p>Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\).</p> <p>Il primo valore \u00e8 la distanza, che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\).</p> <p>Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8.</p> <p>Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\), la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste.</p> <p>TODO: esempio vertice isolato</p> <p>Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\).</p> <p>TODO: ESEMPIO SU ALBERO</p> <p>Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null.</p> <p>L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda.</p> <p>In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue().</p> <p>TODO: esempio su albero</p> <p>Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\). In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\).</p>"},{"location":"material/03_algorithms/02_search/01_linear/lecture/#analisi-della-bfs","title":"Analisi della BFS","text":"<p>Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\)? La risposta \u00e8 un tempo pari a \\(O(V + E)\\).</p> <p>Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\), che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi:</p> \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] <p>Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\), allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\). Se, per\u00f2, abbiamo \\(|E| &lt; |V|\\), allora:</p> \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] <p>per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\). Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\).</p> <p>In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\), \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\).</p> <p>Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\)? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a <code>null</code>, per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.</p>"},{"location":"material/05_os/02_kernel/lecture/","title":"5.1 - Il kernel","text":"<p>Per kernel si intende il \"nucleo\" del sistema operativo, ovvero quell'insieme di funzionalit\u00e0 che agiscono da \"ponte\" tra gli applicativi software ad alto livello e l'hardware del computer. In particolare:</p> <ul> <li>gestisce le risorse di sistema, come processore, memoria, dispoositivi, assicurandosi che tutto funzioni in maniera efficiente ed armoniosa;</li> <li>gestisce tasak comem esecuzione dei programmmi, accesso ai file, e connessione ai dispositivi come stampanti, mouse o tastiere.</li> </ul> <p>Il kernel \u00e8 la base del sistema operativo, ma fornisce anche un'interfaccia utente, un sistema di gestioe file, servizi di rete, e varie applicazioni che permettono agli utenti di interagire con il sistema.</p> <p>Inoltre, facilita al comunicazione tra le applicazioni utente e l'hardware, assicura il multitasking efficiente e sicuro, gestisce la stabilit\u00e0 del sistema e previene un accesso non autorizzato alle risorse.</p> <p> </p> Figura 1 - La funzionalit\u00e0 del kernel"},{"location":"material/05_os/02_kernel/lecture/#511-tipi-di-kernel","title":"5.1.1 - Tipi di Kernel","text":"<p>Il kenrel gestisce le risorse del sistemma quindi e facilita la comuncaizione tra le componenti hardware e software. Questi kernel sono di diversi tipi, vediamoli nel dettaglio.</p>"},{"location":"material/05_os/02_kernel/lecture/#kernel-monolitico","title":"Kernel monolitico","text":"<p>Il kernel momnolitico \u00e8 uno dei tipi di kernel dove tutti i servizi dei sistemi operativi operano nello spazio del kernel. Ha delle dipendenze tra le componenti dei sistemi. Ha molte linee di codice, ed \u00e8 complesso. Esempi sono Unix, Linux.</p> <p>I vantaggi del kernel monolitico sono:</p> <ul> <li>efficienza, in quanto sono spesso pi\u00f9 veloci di altir tipi di kernel in quanto non devono cammbaire tra due modalit\u00e0, chiamate user mode e kernel mode, per ogni chiamata di sisetema, il che riduce l'overhead complessivo.</li> <li>integrazione stretta, dal momento in cui tutti i servizi del sistema operativo sopno eseguiti nel kernel space, possono comunicare in modo pi\u00f9 efficienti tra loro, rendendo pi\u00f9 semplice implenmetare funzionalit\u00e0 complesse ed ottimizzazioni.</li> <li>semplicit\u00e0, i kernel monolitici sono pi\u00f9 semplici da progettare, implementare, ed effettuare il debug di altri tipi di kernel perch\u00e9 hanno una struttura unificata che rende pi\u00f9 semplice gestire il codice.</li> <li>latenza bassa: i kernel monolitici hanno una latenza pi\u00f9 basa di altri tipi di kernel a causa delle chiamate a sistemma e degli interrupt che possono essere gfestiti direttamente dal kernel.</li> </ul> <p>Gli svantaggi invece sono:</p> <ul> <li>problemi di stabilit\u00e0: i kernel monolitici possono essere menos tabili di altri tipi di kernel perch\u00e9 una qualsiasi bug o problema di sicurezza nel kernel influenza l'interno sistema.</li> <li>vulnerabilit\u00e0 di sicurezza: dal momento che tutti i sistemi operativi sono eseguiti nello spazio kernel, ogni vulnerabilit\u00e0 di sicurezza in uno dei servizi pu\u00f2 compromettere l'intero sistema</li> <li>difficolt\u00e0 di manutenzione: i kernel monolitici possono essere pi\u00f9 difficili da manutenere rispetto ad altri tipi di kernel perch\u00e9 un qualsiasi cambio in uno o pi\u00f9 servizi possono influenzare l'intero sistema</li> <li>modularit\u00e0 limitata: i kernel monolitici sono meno modulare degli altri tipi di kernel perch\u00e9 tutti i sistemi operativi sono strettamente integrati nel kernel. Questo rende pi\u00f9 difficile aggiungere o rimuovere funzionalit\u00e0 senza influenzare l'intero sistema</li> </ul>"},{"location":"material/05_os/02_kernel/lecture/#micro-kernel","title":"Micro kernel","text":"<p>Il micro kernel ha un approccio minimalista. Ha della memoria virtuale e del thread scheduling. E' pi\u00f9 stabile con meno servizi nel kernel space, e si basa su un sistema operativo pi\u00f9 snello. Esempi sono AmigaOS, ma sono poco diffusi.</p> <p>I vantaggi del microkernel stanno nella sua affidabilit\u00e0, in quanto \u00e8 progettato per essere pi\u00f9 affidabile dei kernel monolitici, perch\u00e9 la maggior parte del sistema operativo viene eseguito al di fuori del kernel space, e i bug o le vulnerabilit\u00e0 di ssicurezza in un servizio non ifnluenzano l'iuntero sistema.</p> <p>E' inoltre pi\u00f9\u00e0 flessibile, in quanto permette a diversi servizi del sistema oeperativo di essere aggiunti o rimossi senza influenzare l'intero sistrema.</p> <p>Offre maggiore modularit\u00e0, in quanto ogni servizio viene eseguito indipendentemente dagli altri, e rende il sistema pi\u00f9 semplice da manutenere e debuggare.</p> <p>Infine, offre migliori perofmrance in termini di portabilit\u00e0, in quanto la maggior parte dei seriviz del sistema operativo operano al di fuori dello spazio klernel. Questo rende pi\u00f9 semplcie effettuare il porting del sistema operativo verso architetture hardware differenti.</p> <p>In termini di svantaggi, abbiamo svantaggi di performance, perch\u00e9 l'architettura pu\u00f2 essere pi\u00f9\u00e0 lenta di quelli monolitici in quanto richiede pio\u00f9 context switch tra lo user space ed il kernel space.</p> <p>Inoltre l'architettura \u00e8 pi\u00f9 complessa, perch\u00e9 richiede pi+\u00f9 comunicazione e meccanismi di sincronizzazione tra i diversi servizi del sistema operativo</p> <p>E' anche pi\u00f9 compelsso sviluppare questo tipo di sistemi operativi, perch\u00e9 richiede pi\u00f9 attenzione al dettaglio nello sviluppo dei meccanismi di comunciazione e sincronizzazione tra i diversi servizi.</p> <p>Inoltre, vi \u00e8 un pi\u00f9 elevato uso delle risorse di sistema come memoria e CPU rispetto ai kenrel monolitici, perch\u00e9 richiede pi\u00f9 comunicazione e sincronizzazione tra i diversi servizi del sistema operativo.</p>"},{"location":"material/05_os/02_kernel/lecture/#kernel-ibridi","title":"Kernel ibridi","text":"<p>Questo tipo di kernel \u00e8 una combinazione di kernel monolitico e microkernel. Riesce ad avere la velocit\u00e0 ed il design del kernel monolitico, cos\u00ec come la modularit\u00e0 e stabilit\u00e0 del microkernel.</p> <p>I vantaggi stanno nelle performance, perch\u00e9 riducono rispetto ai microkernel il numero di context switch richiesto tra lo user space ed il kernel space. Poi vi \u00e8 l'affidabilit\u00e0, in quanto \u00e8 pi\u00f9 affidabile perch\u00e9 isola i driver ed altre componenti del kernel in sdomini separati. I kernel ibridi sono anche pi\u00f9 flessibili di quelli monolitici, anche perch\u00e9 permettono a diversi servizi dei sistemi operativi di essere aggiunti o rimossi senza influenzare l'intero sistema. La compatibilit\u00e0 dei kernel ibridi pu\u00f2 essere superiore ai microkernel perch\u00e9 possono suporater eun range pi\u00f9 ampio dei driver del dispositivo.</p> <p>PEr quello che riguarda invece gli svantaggi, questi sono in termini di complessit\u00e0, in quanto i kernel ibridi sono pi\u00f9 complessi perch\u00e9 incluudono sia componenti mmonolitiche sia microkernel, il che pu\u00f2 rendere il desgin e l'implementazione pi\u00f9 difficile. I kernel ibridi possono essere meno sicure dei mircokernel perch\u00e9 hanno una superficie di \"attacco\" meno grande a causa dell'inclusione dei componenti monolitici. Anche in termini di manutenibilit\u00e0, i kernel ibrdii possono essere pi\u00f9 difficil da mantener edei mircokernel perch\u00e9 hanno un design ed un'implementazione pi\u00f9 complesse. Alla fine, l'utilizzo di risorse nei kernel ibridi sono pi\u00f9 intensi dei microkernel, perch\u00e9 includono sia i componenti monolitici sia i microkernel.</p>"},{"location":"material/05_os/02_kernel/lecture/#exo-kernel","title":"Exo kernel","text":"<p>E' il tipo di kernel che segue dei principi end-to-end. Ha il minor numero di astrazioni hardware possibile. Alloca risorse fisiche alle applicazioni.</p> <p>I vantaggi sono in termini di flessibilit\u00e0 (offrono il livello pi\u00f9 alto possibile di flessibilit\u00e0, permettendo agli sviluppatopi di customizzare e dottimizzare il sistema operativo per gli specifici obiettivi dell'applcazione). In termini di performanfe, gli exokernel sono progettati per fornire performance migliori ai kenrel traidzionali perc\u00e9 eliminano astrazioni non necessari e permettono alle applicazioni di accedere direttamente alle risorse hardware. In termini di sicurezza, gli exokernel forniscono una migliore sicurezza rispetto ai kernel tradizionali perch\u00e9 opermettono un controllo pi\u00f9 fine sull'allocazione delle risorse di sistema, come memoria e tempo CPU. INfine gli exokernel sono estremamente modulari, poeremttendo l'aggiunta o rimozione facile di servizi dei sistemi operativi.</p> <p>In termini di complessit\u00e0, invece, gli exokernel risultano pi\u00f9 complessi da sviluppare dei kernele tradizionali in quanot rihicedono una maggiore attenzione ai dettagli e considerazioni attente sull'allocazione delle risorse. Inoltre sviluppare applicazioni per gli exokernel \u00e8 pi\u00f9 difficile perch\u00e9 queste devono essere scritte in modo da accdere direttamente alle risorse harware. vi \u00e8 anche un supporto limitato agli exokernel, in quanto sono ancora una tecnologia emergente e potrebbero nona vere lo stesso livello di supporto e risorse dei kernel tradizionali. Infine, effettuare il debuig di applicazioni e servizi del sistema operativo sugli exokernel potrebbe essere pi\u00e0 difficile a causa dell'accesso diretto alle risorse hardware.</p>"},{"location":"material/05_os/02_kernel/lecture/#nano-kernel","title":"Nano kernel","text":"<p>E' il tipo di kernel che offre l'astrazione dell'hardware ma senza servizi di sistema, un po' come i micro kernel, per cui sono diventati sinonimi.</p>"},{"location":"material/05_os/02_kernel/lecture/#funzzioni-del-kernel","title":"Funzzioni del kernel","text":"<p>Il kernel \u00e8 responsabile di diverse funzioni critiche che assicurano il funzionamento del sistema. Queste includono:</p> <ol> <li>gestione dei processi, ovvero scheduling ed esecuzione dei processi, context switching tra processi, creazione e terminazione dei processi</li> <li>gestione della memoria, ovvero allocazione e deallocazione dello spazio in memoria, gestione della memoria virtuale, gestione della protezione della memoria e condivisione</li> <li>gestione del dispositivo, gestendo i dispositivi di input/outp\u00e8ut, fornire un'interfaccia unificata ai dispositivi hardware, e gestiere la comunciazione dei driver di dispositivo</li> <li>gestione del file system: gestire le operazioni sui file e in memoria, gestire il mounting e l'unmounting del file system,. fornire l'interfaccai del file system alle applcaizion.</li> <li>gestione risorse;: gestire le risorse di sistema come temmpo CPU, spazio su disco e banda, allocare e deallocare le risorse quanbdo ncecessario, monitorare l'utilizzo delle risorse se forzare dei limiti</li> <li>sicurezza e controllo degli accessi: forzare delle policy di controlloa ccessi, gestire l'autenticazione e i permessi utente, assicurare la sicurezza e l'integrit\u00e0 del sistema</li> <li>inter-processo communication, facilitando la comunciazione tra processi, e fornendo i meccanismi come il message passing e la memorai condivisa</li> </ol>"},{"location":"material/05_os/02_kernel/lecture/#fuznioanmento-del-kernel","title":"Fuznioanmento del kernel","text":"<p>Un kernel \u00e8 caricato in memoria immedaitamente quanod viene caricato un sistema operativo, e vi rimane fino a che questo non viene spento. E' responsabile per diversi trask come la gestione del disco e quella della memoria.</p>"},{"location":"material/06_isw/01_intro/01_intro/","title":"2.1 - L'Ingegneria del Software","text":"<p>Avete mai scritto un programma? Se state leggendo questo documento, la risposta \u00e8, presumibilmente, s\u00ec. Adesso, possiamo avere diverse situazioni, sinteticamente raggruppabili in due diverse casistiche. </p> <ol> <li>Avete scritto software abbastanza basilare, contenuto in una manciata di file sorgenti.</li> <li>Avete scritto anche software complesso, con dipendenze multiple, magari stipulando contratti specifici con committenti, o lavorando in un team.</li> </ol> <p>Nel primo caso, \u00e8 probabile che siate riusciti ad organizzare il tutto semplicemente \"tenendo a mente\" i requisiti base del software e le relazioni che intercorrono tra funzioni, script, e via discorrendo. Nel secondo caso, invece, \u00e8 plausibile che abbiate dovuto in qualche modo utilizzare tecniche e strumenti per strutturare al meglio il vostro lavoro, utilizzando magari dei processi agili, interagendo con i clienti alla scoperta dei requisiti, oppure ancora testando e manutenendo il software.</p> <p>E' quindi chiaro come progetti software pi\u00f9 complessi implichino una gestione necessariamente pi\u00f9 strutturata: in tal senso, la disciplina dell'Ingegneria del Software si occupa proprio di fornire gli strumenti e le tecniche necessarie a produrre software di qualit\u00e0 e che rispecchino i requisiti posti dall'utente. Per approfondire il concetto, dobbiamo partire da due definizioni. In primis, abbiamo il concetto di software:</p> <p>Il software</p> <p>Per software si intende un programma, o un insieme di programma, che soddisfano uno o pi\u00f9 requisiti dell'utente.</p> <p>Abbiamo poi il concetto di ingegneria o, per meglio dire, ingegnerizzazione:</p> <p>Ingegnerizzazione</p> <p>L'ingegnerizzazione \u00e8 un processo che prevede la progettazione e realizzazione di un manufatto, bene, o servizio atto a soddisfare un particolare scopo, trovando una soluzione efficace in termini di costi ad un determinato problema.</p> <p>L'Ingegneria del Software (ISW) \u00e8 quindi il processo di progettazione, sviluppo, test e manutenzione di  un software. L'ISW \u00e8 quindi un approccio sistematico e disciplinato allo sviluppo software, mirato alla creazione di software di alta qualit\u00e0, affidabile e manutenibile.</p> <p>L'ISW \u00e8 un campo in rapida evoluzione, nel quale vengono costantemente sviluppati e proposti nuovi tool e tecnologie per migliorare lo sviluppo software, utilizzando i quali \u00e8 possibile creare software di alta qualit\u00e0, affidabile e manutenibile, rispettando contestualmente i requisiti posti dagli utenti, creando programmi consistenti, funzionali e, soprattutto, rispettosi dei vincoli di sviluppo.</p> <p>Le dimensioni contano</p> <p>Ricollegandoci a quanto abbiamo detto prima, l'ISW \"mostrano i muscoli\" soprattutto nel caso di progetti di grandi dimensioni, perdendo senso nel caso siano applicati a programmi \"limitati\".</p>"},{"location":"material/06_isw/01_intro/01_intro/#principi-chiave-dellisw","title":"Principi chiave dell'ISW","text":"<p>Riassumiamo in breve alcuni dei principi alla base dei concetti dell'ISW.</p> Principio Breve descrizione Modularit\u00e0 Suddividere il software in componenti di piccola dimensione, sviluppabili, testabili e, soprattutto, riutilizzabili in maniera indipendente. Astrazione Nascondere i dettagli implementativi di ciascun componente software, esponendo agli altri componenti soltanto le funzionalit\u00e0 necessarie. Incapsulamento Racchiudere i dati e le funzioni di un oggetto in una singola unit\u00e0, proteggendone lo stato interno da interferenze esterne. Riutilizzabilit\u00e0 Creare componenti che possano essere utilizzati in pi\u00f9 progetti, risparmiando di conseguenza tempo e risorse. Manutenibilit\u00e0 Aggiornare e migliorare il software in maniera regolare, allo scopo di risolvere bug, aggiungere nuove feature, e risolvere eventuali vulnerabilit\u00e0. Test Verificare che il software rispetti i requisiti indicati, e risulti essere scevro da bug. Design pattern Proporre dei pattern per la soluzione di problemi ricorrenti della progettazione del software. Sviluppo Agile Usare processi di sviluppo iterativi ed incrementali, focalizzandosi su soddisfazione dell'utente, rilascio rapido di nuove versioni e flessibilit\u00e0. Integrazione continua Integrare in maniera rapida e continua i cambiamenti nel sorgente, rilasciandoli il prima possibile in ambiente di produzione."},{"location":"material/06_isw/01_intro/01_intro/#obiettivi-dellisw","title":"Obiettivi dell'ISW","text":"<p>Possiamo anche definire una serie di obiettivi che l'ISW vuole peseguire.</p> Obiettivo Breve descrizione Manutenibilit\u00e0 Il software dovrebbe poter evolvere rispettando requisiti mutevoli nel tempo. Efficienza Il software non dovrebbe usare in maniera inefficace le capacit\u00e0 di calcolo dei dispositivi utilizzati. Correttezza Il software dovrebbe rispettare i requisiti specificati dai suoi utilizzatori. Riusabilit\u00e0 Il software dovrebbe essere suddiviso in moduli, i quali dovrebbero essere facilmente riutilizzati allo scopo di sviluppare nuovi prodotti software. Testabilit\u00e0 Il software dovrebbe essere progettato per facilitare cicli di test per valutare il rispetto dei requisiti e delle funzionalit\u00e0. Affidabilit\u00e0 Il software dovrebbe essere in grado di svolgere i suoi compiti prefissati in un certo periodo di tempo. Portabilit\u00e0 Il software dovrebbe poter essere trasferito in maniera semplice da un sistema ad un altro. Adattabilit\u00e0 Il software dovrebbe garantire il rispetto di vincoli di sistema ed utente anche nel caso di modifiche sostanziali. Interoperabilit\u00e0 Diverse unit\u00e0 funzionali del software dovrebbero essere in grado di elaborare i dati in maniera cooperativa e non concorrente."},{"location":"material/06_isw/01_intro/01_intro/#programmi-e-software","title":"Programmi e software","text":"<p>Quando parliamo di programma non parliamo necessariamente di (prodotto) software. Infatti, possiamo definire il programma come un insieme di istruzioni date ad un computer per svolgere un compito specifico; invece, il software \u00e8 un programma reso disponibile per scopi solitamente commerciali, documentato, e fornito di un'apposita licenza. Di conseguenza, possiamo affermare che il programma \u00e8 uno degli step nello sviluppo del software.</p>"},{"location":"material/06_isw/01_intro/01_intro/#vantaggi-e-svantaggi-dellisw","title":"Vantaggi e svantaggi dell'ISW","text":"<p>I vantaggi nell'uso di un approccio sistematico e disciplinato allo sviluppo del software sono:</p> Vantaggio Breve descrizione Qualit\u00e0 Seguire i principi dell'ISW permette di ottenere software con un numero limitato di bug ed un'affidabilit\u00e0 pi\u00f9 elevata. Produttivit\u00e0 L'utilizzo di strumenti e metodologie moderne pu\u00f2 rendere pi\u00f9 lineare il processo di sviluppo, aumentando quindi la produttivit\u00e0 degli sviluppatori. Manutenibilit\u00e0 Il software progettato e sviluppato usando le pratiche dell'ISW \u00e8 pi\u00f9 facile da manutenere ed aggiornare nel tempo. Riduzione dei costi Identificando e risolvendo i potenziali problemi nei primi stage del processo di sviluppo, l'ISW pu\u00f2 aiutare a ridurre il costo nel tempo legato all'introdurre nuove feature e risolvere bug. Soddisfazione utente Coinvolgendo gli utenti nel processo di sviluppo, e creando del software che rispetta le loro necessit\u00e0, l'ISW pu\u00f2 aumentare la soddisfazione utente. Collaborazione L'uso dell'approccio agile e dell'integrazione continua permette ai team di collaborare al meglio. Scalabilit\u00e0 Un software progettato per essere scalabile pu\u00f2 gestire un numero variabile di utenti e transazioni. Sicurezza Un software opportunamente testato secondo i principi definiti dall'ISW \u00e8 spesso meno vulnerabile e pi\u00f9 sicuro. <p>Per ci\u00f2 che riguarda gli svantaggi invece:</p> Svantaggio Breve descrizione Costi iniziali Implementare un approccio sistematico e disciplinato allo sviluppo pu\u00f2 richiedere parecchie risorse, oltre che un investimento significativo in termini di strumentazione e training. Flessibilit\u00e0 Seguire dei principi prestabiliti pu\u00f2 comportare delle rigidit\u00e0, limitando in alcune situazioni il rapido adattamento a requisiti mutevoli. Burocrazia Usare l'ISW pu\u00f2 creare un ambiente burocratizzato, in cui \u00e8 necessario redigere un gran numero di documenti, il che pu\u00f2 rallentare lo sviluppo. Complessit\u00e0 Con l'aumento del numero di strumenti e meotodologie, i principi dell'ISW pu\u00f2 diventare complessa e difficile da gestire. Creativit\u00e0 Il focus sul processo di sviluppo pu\u00f2 limitare la creativit\u00e0 e l'innovazione. Curva di apprendimento Il processo di sviluppo pu\u00f2 essere complesso e richiede l'apprendimento di numerosi strumenti. Dipendenza dai tool L'ISW fa largo affidamento a degli strumenti che, se non propriamente  configurati o incompatibili con il software in uso, possono causare diversi problemi. Manutenzione I processi alla base dell'ISW richiedono una manutenzione regolare per assicurarsi che il software venga eseguito in maniera efficiente."},{"location":"material/06_isw/01_intro/01_intro_bis/","title":"01 intro bis","text":"<p>Ok, immagina di voler fare un panino. Se hai solo due fette di pane e del formaggio, lo fai in fretta e senza pensarci troppo. Ma se devi preparare un buffet per 100 persone, con panini diversi, esigenze alimentari particolari, decorazioni e tempi precisi, hai bisogno di un piano, di organizzazione e di un metodo, giusto?</p> <p>Ecco, lo sviluppo di un videogioco \u00e8 molto pi\u00f9 simile al buffet per 100 persone che al panino veloce. L'ingegneria del software \u00e8 necessaria perch\u00e9 i videogiochi moderni sono progetti incredibilmente complessi, che richiedono organizzazione, pianificazione e un approccio sistematico per essere realizzati con successo.</p> <p>Pensa a questo:</p> <ul> <li>Milioni di righe di codice: I videogiochi moderni hanno milioni di righe di codice. Se non c'\u00e8 un modo per gestire e organizzare questo codice, diventa un casino ingestibile. L'ingegneria del software fornisce gli strumenti e le tecniche per scrivere codice pulito, modulare e facile da mantenere.</li> <li>Team enormi: Per fare un gioco come Cyberpunk 2077 o Grand Theft Auto V, lavorano centinaia di persone, tra programmatori, artisti, designer, musicisti, sound designer, tester, project manager e molti altri. L'ingegneria del software fornisce le metodologie per far lavorare queste persone in modo coordinato ed efficiente. Immagina cosa succederebbe se tutti facessero quello che vogliono senza un piano condiviso.</li> <li>Tecnologie complesse: I videogiochi usano tecnologie all'avanguardia come motori grafici (Unreal Engine, Unity), intelligenza artificiale, fisica simulata, reti multiplayer, realt\u00e0 virtuale, realt\u00e0 aumentata e molto altro. L'ingegneria del software aiuta a gestire questa complessit\u00e0 e a integrare queste tecnologie in modo efficace.</li> <li>Budget elevati: Lo sviluppo di un videogioco tripla A pu\u00f2 costare decine o addirittura centinaia di milioni di dollari. Se il progetto viene gestito male, si rischia di sforare il budget, di ritardare i tempi di rilascio o, peggio ancora, di fallire. L'ingegneria del software fornisce le tecniche di gestione del progetto per tenere sotto controllo i costi e i tempi.</li> <li>Aspettative elevate: I giocatori si aspettano giochi di alta qualit\u00e0, con grafica spettacolare, gameplay coinvolgente, storia avvincente e zero bug. L'ingegneria del software aiuta a garantire la qualit\u00e0 del software, attraverso test rigorosi, revisioni del codice e processi di sviluppo ben definiti.</li> </ul> <p>Senza ingegneria del software, i videogiochi sarebbero:</p> <ul> <li>Pieni di bug: Immagina un gioco pieno di glitch, crash e problemi di performance. Nessuno vorrebbe giocarci.</li> <li>Incompiuti: Molte funzionalit\u00e0 sarebbero tagliate o non implementate correttamente.</li> <li>Estremamente costosi: I tempi di sviluppo si allungherebbero a dismisura e i costi salirebbero alle stelle.</li> <li>Impossibili da aggiornare: Correggere bug e aggiungere nuove funzionalit\u00e0 sarebbe un incubo.</li> <li>In sostanza, sarebbero un disastro.</li> </ul> <p>Esempi concreti:</p> <ul> <li>Gestione della complessit\u00e0: Immagina di dover implementare un sistema di intelligenza artificiale per gestire il comportamento di centinaia di personaggi non giocanti (NPC) in un open world come Red Dead Redemption 2. Senza un'architettura software ben definita, il sistema diventerebbe ingestibile e inefficiente.</li> <li>Collaborazione: Pensa a un team di artisti che lavorano alla creazione degli asset grafici per un gioco. Senza un sistema di controllo della versione (come Git), sarebbe impossibile tenere traccia delle modifiche e risolvere i conflitti.</li> <li>Qualit\u00e0 del software: Immagina di dover testare un gioco multiplayer online che supporta migliaia di giocatori contemporaneamente. Senza un piano di test ben definito, sarebbe impossibile individuare e correggere tutti i bug e i problemi di performance.</li> </ul> <p>Quindi, l'ingegneria del software non \u00e8 solo una teoria astratta, ma un insieme di pratiche e tecniche che sono assolutamente essenziali per lo sviluppo di videogiochi di successo. \u00c8 quello che permette di trasformare un'idea brillante in un prodotto reale, giocabile e divertente. Pensa ai team che sviluppano i giochi di Naughty Dog (The Last of Us, Uncharted): la loro capacit\u00e0 di creare esperienze di gioco complesse e raffinate \u00e8 frutto di una solida base di ingegneria del software. Senza di essa, avremmo solo idee, ma non giochi concreti.</p>"},{"location":"material/06_isw/01_intro/02_classification/","title":"2.2 Classificazione del software","text":"<p>Il software pu\u00f2 essere classificato in base a diversi criteri. Vediamone alcuni.</p>"},{"location":"material/06_isw/01_intro/02_classification/#il-software-sulla-base-dellambito-applicativo","title":"Il software sulla base dell'ambito applicativo","text":"<p>Per ambito del software intendiamo quello che \u00e8 lo \"scopo finale\" del software, ovvero l'area in cui andr\u00e0 ad operare sulla base dgli scopi per il quale \u00e8 stato creato. Esistono numerosi ambiti; ne elenchiamo di seguito alcuni.</p>"},{"location":"material/06_isw/01_intro/02_classification/#software-di-sistema","title":"Software di sistema","text":"<p>Un software di sistema \u00e8 delegato alla gestione delle risorse della macchina, oltre che al supporto all'esecuzione di programmi applicativi. Software come sistemi operativi, compilatori, editor, o driver, rientrano in qusta categoria. Un computer non pu\u00f2 funzionare senza i software di sistema: il sistema operativo, ad esempio, \u00e8 necessario per gestire correttamente le diverse componenti della macchina, mentre senza i driver i dispositivi di sistema non possono comunicare con il cuore della macchina.</p> <ol> <li>Software applicativo</li> </ol> <p>Il software applicativo \u00e8 progettato per soddisfare i requisiti dell'utente interagendovi direttamente. Pu\u00f2 essere classificato in due categorie: generico o personalizzato. Il software generico \u00e8 aperto a tutti e si comporta allo stesso modo per tutti i suoi utenti. Le sue funzioni sono limitate e non personalizzate in seguito a requisiti cangianti dell'utente. Tuttavia, d'altro canto, il software customizzato \u00e8 il prodotto software progettato per i requisiti del cliente, e non \u00e8 disponibile per tutti.</p> <ol> <li>Software di rete ed applicazioni web</li> </ol> <p>Il software di rete fornisce il supporto necessario per i computer ad interagire tra loro e con le facility di data storage. Il software di rete \u00e8 anche usato per interfacciare reti di computer, come il World Wide Web. Include tutto il software di gestione della rete, il software dei server, il software di sicurezza e cifratura, ed il software per sviluppare applicazioni web based.</p> <ol> <li>Software embedded</li> </ol> <p>Questo tipo di software viene integrato normalmente nella memoria ROM come parte di un sistema pi\u00f9 ampio ed \u00e8 usato per supportare alcune funzionalit\u00e0 in determinate condizioni. Esempi sono i software usati nelle applicazioni di controllo e strumentazione come lavatrici, satelliti, microonde, e via dicendo.</p> <ol> <li>Reservation software</li> </ol> <p>Un sistema di prenotazione \u00e8 usato in primis per memorizzare e recuperare informazioni ed effettuare transazioni correlate ad esempio a viaggi aerei, prenotazioni di automobili, alberghi, ed altre attivit\u00e0. Questi forniscono anche accesso alle prenotazioni di autobus e treni, anche se non sono sempre integrati con il sistema principale. Questi sono anche usati per trasmettere informazioni computerizzate per utenti nell'industria alberghiera, che possono prenotare ed assicurarsi che l'albergo non sia pieno.</p> <ol> <li>Business software</li> </ol> <p>Questa categoria di software fornisce supporto ad aziende ed \u00e8 una delle categorie pi\u00f9 usate di software. Esempi sono software per gestione degli inventari, account, banca, ospedali, scuole, mercati azionari, ecc.</p> <ol> <li>Software di intelligenza artificiale</li> </ol> <p>Software come sistemi esperti, decision support systems, pattern recognition software, reti neurali, e via discorrendo ricadono in questa categoria. Questi software prevedono la risoluzione di problemi complessi mediante algoritmi di intelligenza artificiale.</p> <ol> <li>Software scientifici</li> </ol> <p>I software scientifici e di ingegneria soddisfano la necessit\u00e0 di utenti di tipo scientifico di effettuare dei task specifici per l'impresa. Questi software sono scritti per applicazioni specifiche usando principi, tecniche e formule specifiche per quel campo, come MATLAB.</p> <ol> <li>Utility software</li> </ol> <p>I programmi che ricadono in questa categoria effettuano task specifici e sono differenti da altri software in termini di dimensioni, costo e complessit\u00e0. Esempi sono i software antivirus, i software di riconoscimento vocale, quelli di compressione, e via dicendo.</p> <ol> <li> <p>Software di gestione documentale</p> <p>I software di gestione documentale sono usati per tracciare, gestire e memorizzare documenti per ridurre il numero di documenti utilizzati. Questi sistemi sono in grado di mantenere traccia delle diverse versioni create e modificate da diversi utenti. Di solito forniscono funzionalit\u00e0 di memorizzazione, versioning, metadata, sicurezza, cos\u00ec come indicizzazione e recupero.</p> </li> </ol>"},{"location":"material/06_isw/01_intro/02_classification/#ambito","title":"Ambito","text":"<p>In tal senso, individuiamo due tipologie di software, ovvero:</p> <ul> <li>software di sistema, ovvero un tipo di software che permette al sistema di funzionare. Esempi sono i driver di dispositivo, come ad esempio quelli della scheda grafica, o anche il sistema operativo stesso;</li> <li>software applicativo, ovvero un tipo di software che non \u00e8 essenziale al funzionamento del sistema, ma che offre potenzialit\u00e0 e applicazioni aggiuntive all'utente. Esempi classici sono gli elaboratori di testo, le suite per l'ufficio, oppure anche gli stessi videogame.</li> </ul>"},{"location":"material/06_isw/01_intro/02_classification/#piattaforma","title":"Piattaforma","text":"<p>Per piattaforma si intende l'ecosistema sul quale un software pu\u00f2 essere eseguito. In particolare, qualora il software possa essere utilizzato soltanto su uno specifico sistema operativo viene chiamato nativo, mentre nel caso possa essere eseguito su diversi sistemi operativi \u00e8 detto cross-platform.</p> <p>Un tipico esempio \u00e8 quello legato allo sviluppo di applicazioni per smartphone: queste possono essere sviluppate utilizzando le librerie specifiche per Android ed iOS (e, quindi, usando un approccio nativo), oppure usando dei framework cross-platform che richiamano le funzionalit\u00e0 comuni del dispositivo (e, quindi, usando un approccio cross-platform). Ognuno dei due approcci ha diversi vantaggi e svantaggi: ad esempio, il software nativo ha performance normalmente superiori, ma richiede uno sviluppo pi\u00f9 lungo e complesso, mentre il software cross-platform ha generalmente performance peggiori, ma permette di prototipare in maniera pi\u00f9 rapida e diffondere il software in maniera pi\u00f9 capillare su diverse piattaforme.</p>"},{"location":"material/06_isw/01_intro/02_classification/#deployment","title":"Deployment","text":"<p>Per deployment si intende la modalit\u00e0 con cui il sistema pu\u00f2 essere usufruito dall'utente. In particolare, il software pu\u00f2 essere definito come installabile, se pu\u00f2 essere effettivamente installato sul dispositivo dell'utente, mentre cloud-based se non deve essere installato e pu\u00f2 essere usufruito da server remoti collocati su Internet.</p> <p>Un esempio di software installabile \u00e8 ad esempio un'app per cellulare; di contro, tutte le web app che utilizziamo via Internet, come ad esempio la suite Google Docs, \u00e8 un esempio di software cloud-based.</p>"},{"location":"material/06_isw/01_intro/02_classification/#licenza","title":"Licenza","text":"<p>Per licenza si intende la modalit\u00e0 con cui il software pu\u00f2 essere usufruito dall'utente. Esistono diversi tipi di licenze ma, in linea generale, il software \u00e8 di tipo proprietario, ovvero posseduto da una singola entit\u00e0 ed il cui utilizzo \u00e8 concesso in licenza, o open source, ovvero software disponibile liberamente, assieme al suo codice sorgente, che \u00e8 pubblicamente accessibile.</p>"},{"location":"material/06_isw/01_intro/02_classification/#modello-di-sviluppo","title":"Modello di sviluppo","text":"<p>E' possibile utilizzare diversi modelli di sviluppo per un software. In linea generale, per\u00f2, i software possono essere sviluppati utilizzando un approccio tradizionale, normalmente a cascata, o un approccio pi\u00f9 moderno e basato su metodologie iterative ed adattative.</p>"},{"location":"material/06_isw/01_intro/02_classification/#dimensione","title":"Dimensione","text":"<p>Il software pu\u00f2 anche essere classificato in base alla dimensione che assume. In particolare, esistono progetti a piccola scala, che sono specificamente pensati per esere utilizzati da singoli o da piccoli gruppi, o a larga scala, progettati prevalentemente per grosse organizzazioni.</p>"},{"location":"material/06_isw/01_intro/02_classification/#interfaccia-utente","title":"Interfaccia utente","text":"<p>Un'ulteriore possibile classificazione \u00e8 quella basata sull'interfaccia utente usata dal software. La maggior parte dei software che si rivolge al grande pubblico offre infatti una Graphical User Interface, ovvero un'interfaccia di tipo visivo, con la quale l'utente pu\u00f2 interagire per sfruttare le funzionalit\u00e0 richieste. Altri software, generalmente rivolti ad un pubblico pi\u00f9 specializzato, utilizzano invece un'interfaccia a riga di comando (Command Line Interface, o CLI).</p>"},{"location":"material/06_isw/01_intro/02_classification/#_1","title":"2.2 Classificazione del software","text":""},{"location":"material/06_isw/01_intro/02_classification/#tipi-di-software","title":"Tipi di software","text":"<p>Il software viene usato estensivamente in diversi domini, inclusi healthcare, banche, scuole, difesa, finanza, e via dicendo. Pu\u00f2 essere categorizzato in diversi tipi:</p> <ol> <li>Basato sull'applicazione</li> <li>Basato sul copyright</li> </ol>"},{"location":"material/06_isw/01_intro/02_classification/#basato-sullapplicazione","title":"Basato sull'applicazione","text":"<p>Il software pu\u00f2 essere classificato in base all'applicazione. Questo deve essere fatto su questa base.</p>"},{"location":"material/06_isw/01_intro/02_classification/#basato-sul-copyright","title":"Basato sul copyright","text":"<p>I software possono essere classificati sulla base del copyright nei seguenti modi:</p> <ol> <li>Software commerciali: rappresentano la maggioranza del software che acquistiamo da compagnie software, negozi commerciali, e via dicendo. In questo caso, quando un utente acquista un software, acquista una licenza per utilizzarlo. Gli utenti non possono fare copie del software, e la compagnia ha i diritti di copyright del programma.</li> <li>Shareware: lo shareware \u00e8 protetto da copyright, ma i compratori possono fare e distribuire copie alle condizioni che, dopo aver testato il software, se il compratore lo inizia ad usare, deve anche pagarlo. In entrambi i tipi di software precedenti, cambi al software non sono permessi.</li> <li>Freeware: in accordo alle licenze freeware, le copie del software possono essere fatte per scopo di archiviazione e distribuzione, ma la distribuzione non pu\u00f2 essere fatta a scopo di lucro. I lavori derivativi e le modifiche al software sono permesse ed incoraggiate. Decompilare il codice del programma \u00e8 anche permesso senza il permesso esplicito dei detentori del copyright.</li> <li>Software di pubblico dominio: nel caso del software di pubblico dominio, il detentore originale del software rinuncia esplicitamente a tutti i diritti sul software, per cui le copie software possono essere fatte per motivi di archiviazione e distribuzione senza restrizione alcuna. Modifiche al software e reverse engineering sono anche permesse.</li> </ol>"},{"location":"material/06_isw/01_intro/02_classification_integration/","title":"02 classification integration","text":"<p>Ok, continuiamo con il nostro amico ventenne. Immagina di essere al supermercato e di dover scegliere un tipo di pasta. C'\u00e8 quella corta, quella lunga, quella integrale, quella senza glutine, quella artigianale... la pasta si pu\u00f2 classificare in tanti modi diversi, giusto?</p> <p>Anche il software, compresi i videogiochi, pu\u00f2 essere classificato in diversi modi, a seconda delle sue caratteristiche. Vediamo alcuni dei modi pi\u00f9 comuni, con esempi dal mondo dei videogame:</p> <p>1. Ambito (Software di Sistema vs. Applicativo):</p> <ul> <li>Software di Sistema: Software che gestisce l'hardware e le risorse del computer. In pratica, fa funzionare tutto. Esempi sono i sistemi operativi (Windows, macOS, Linux) o i driver delle schede video.<ul> <li>Nel mondo dei videogame: Direct X o Vulkan (librerie grafiche che permettono ai giochi di comunicare con la scheda video), i sistemi operativi delle console (il sistema operativo della PlayStation o Xbox).</li> </ul> </li> <li>Software Applicativo: Software che esegue compiti specifici per l'utente. Sono le applicazioni che usiamo tutti i giorni, come i browser, i word processor e, ovviamente, i videogiochi.<ul> <li>Nel mondo dei videogame: Tutti i videogiochi sono software applicativo (Fortnite, Elden Ring, The Sims, ecc.).</li> </ul> </li> </ul> <p>2. Piattaforma:</p> <ul> <li>Desktop: Software che gira su computer fissi (PC, Mac).<ul> <li>Nel mondo dei videogame: La maggior parte dei videogiochi tripla A sono sviluppati per PC (Cyberpunk 2077, Assassin's Creed Valhalla).</li> </ul> </li> <li>Console: Software che gira su console dedicate (PlayStation, Xbox, Nintendo Switch).<ul> <li>Nel mondo dei videogame: God of War (PlayStation), Halo (Xbox), Mario Odyssey (Nintendo Switch).</li> </ul> </li> <li>Mobile: Software che gira su smartphone e tablet (Android, iOS).<ul> <li>Nel mondo dei videogame: Mobile Legends, Candy Crush, PUBG Mobile.</li> </ul> </li> <li>Web: Software che gira all'interno di un browser web.<ul> <li>Nel mondo dei videogame: Giochi in Flash (ormai obsoleti), giochi in HTML5 (Agar.io), giochi che usano tecnologie web come Unity WebGL.</li> </ul> </li> </ul> <p>3. Deployment (Installabile vs. Cloud-Based):</p> <ul> <li>Installabile (On-Premise): Il software viene installato direttamente sul dispositivo dell'utente.<ul> <li>Nel mondo dei videogame: La maggior parte dei videogiochi che compri su Steam o in formato fisico sono installabili.</li> </ul> </li> <li>Cloud-Based (SaaS - Software as a Service): Il software gira su server remoti e l'utente vi accede tramite internet.<ul> <li>Nel mondo dei videogame: Giochi in streaming come Google Stadia (ormai defunto), NVIDIA GeForce Now o Xbox Cloud Gaming. Anche molti giochi online, pur essendo installati sul dispositivo, usano server cloud per gestire il multiplayer e i dati.</li> </ul> </li> </ul> <p>4. Licenza:</p> <ul> <li>Proprietario (Closed Source): Il codice sorgente del software non \u00e8 pubblico e l'utente ha solo il diritto di usare il software secondo i termini della licenza.<ul> <li>Nel mondo dei videogame: La maggior parte dei videogiochi commerciali ha licenza proprietaria (Call of Duty, FIFA, ecc.).</li> </ul> </li> <li>Open Source: Il codice sorgente del software \u00e8 pubblico e l'utente ha il diritto di usarlo, modificarlo e distribuirlo liberamente (spesso con alcune restrizioni).<ul> <li>Nel mondo dei videogame: Alcuni motori di gioco come Godot Engine sono open source. Ci sono anche alcuni giochi indie open source.</li> </ul> </li> </ul> <p>5. Sviluppo (Agile vs. a Cascata - Waterfall):</p> <ul> <li>A Cascata (Waterfall): Un approccio sequenziale allo sviluppo software, in cui ogni fase (analisi dei requisiti, progettazione, implementazione, test, deployment) viene completata prima di passare alla successiva.<ul> <li>Nel mondo dei videogame: Un tempo era l'approccio pi\u00f9 comune, ma oggi \u00e8 meno diffuso a causa della sua rigidit\u00e0.</li> </ul> </li> <li>Agile: Un approccio iterativo e incrementale allo sviluppo software, in cui il progetto viene suddiviso in brevi cicli di sviluppo (sprint) e il feedback degli utenti viene incorporato continuamente.<ul> <li>Nel mondo dei videogame: L'approccio agile \u00e8 diventato sempre pi\u00f9 popolare, soprattutto per i giochi online e i giochi \"live service\" che vengono aggiornati frequentemente (Fortnite, Apex Legends).</li> </ul> </li> </ul> <p>6. Interfaccia Utente (GUI vs. CLI):</p> <ul> <li>GUI (Graphical User Interface): L'utente interagisce con il software tramite elementi grafici come finestre, menu, icone e pulsanti.<ul> <li>Nel mondo dei videogame: La stragrande maggioranza dei videogiochi usa una GUI (tutti i giochi che hai giocato probabilmente usano una GUI).</li> </ul> </li> <li>CLI (Command Line Interface): L'utente interagisce con il software tramite comandi testuali inseriti nella riga di comando.<ul> <li>Nel mondo dei videogame: Meno comune, ma a volte usata per strumenti di sviluppo, server di gioco o per giochi testuali (MUD).</li> </ul> </li> </ul> <p>Esempio pratico:</p> <p>Prendiamo Fortnite:</p> <ul> <li>Ambito: Software applicativo.</li> <li>Piattaforma: Disponibile su PC, console (PlayStation, Xbox, Nintendo Switch), mobile (Android, iOS) e cloud (Xbox Cloud Gaming).</li> <li>Deployment: Installabile (sul dispositivo) e cloud-based (tramite Xbox Cloud Gaming).</li> <li>Licenza: Proprietaria.</li> <li>Sviluppo: Agile (con aggiornamenti frequenti e feedback degli utenti).</li> <li>Interfaccia Utente: GUI.</li> </ul> <p>Spero che questa spiegazione ti sia chiara! La prossima volta che giochi a un videogioco, prova a pensare a come potrebbe essere classificato secondo questi criteri. Ti aiuter\u00e0 a capire meglio la complessit\u00e0 del mondo del software e come i videogiochi si inseriscono in questo contesto.</p>"},{"location":"material/06_isw/01_intro/03_characteristics/","title":"03 characteristics","text":"<p>Ok, eccoci qui. Immagina che il tuo videogioco sia una macchina sportiva di lusso. Non basta che sia bella e veloce, deve anche essere comoda, affidabile e facile da guidare, giusto? Le caratteristiche del software sono un po' come le caratteristiche di una macchina: definiscono le qualit\u00e0 che rendono un software (in questo caso, un videogioco) buono e adatto al suo scopo.</p> <p>Diamo un'occhiata a queste caratteristiche, usando esempi dal mondo dei videogame:</p> <p>1. Funzionalit\u00e0:</p> <ul> <li>Definizione: Cosa fa il software? Quali compiti \u00e8 in grado di svolgere? Sono le caratteristiche che permettono al giocatore di interagire con il gioco e raggiungere i suoi obiettivi.</li> <li>Esempio:<ul> <li>The Legend of Zelda: Breath of the Wild: La possibilit\u00e0 di scalare quasi tutte le superfici, cucinare cibo per ottenere bonus, usare la \"Tavoletta di Sheikah\" per sbloccare abilit\u00e0.</li> <li>Minecraft: La possibilit\u00e0 di scavare, costruire, craftare oggetti, esplorare un mondo generato proceduralmente.</li> <li>Un FPS generico la funzionalit\u00e0 di sparare, mirare, ricaricare.</li> </ul> </li> <li>Importanza: Se un gioco non ha le funzionalit\u00e0 che promette, \u00e8 come comprare una macchina sportiva senza motore. \u00c8 inutile.</li> </ul> <p>2. Efficienza:</p> <ul> <li>Definizione: Quanto bene il software utilizza le risorse del sistema (CPU, memoria, batteria)? \u00c8 veloce, reattivo e non spreca risorse? Un gioco efficiente gira bene anche su hardware meno potente e non consuma troppa batteria su dispositivi mobili.</li> <li>Esempio:<ul> <li>God of War (2018) su PS4: Nonostante la grafica spettacolare, il gioco \u00e8 ottimizzato per girare fluidamente su una PS4 standard (anche se non a 60 FPS costanti).</li> <li>Fortnite su mobile: Pur essendo un gioco graficamente complesso, \u00e8 stato ottimizzato per girare su una vasta gamma di smartphone e tablet.</li> <li>Giochi male ottimizzati: Cyberpunk 2077 al lancio \u00e8 un esempio di gioco con scarsa efficienza, soprattutto su console di vecchia generazione.</li> </ul> </li> <li>Importanza: Un gioco inefficiente pu\u00f2 causare lag, crash, surriscaldamento del dispositivo e un'esperienza di gioco frustrante.</li> </ul> <p>3. Affidabilit\u00e0:</p> <ul> <li>Definizione: Quanto \u00e8 affidabile il software? Funziona senza errori, crash o comportamenti inaspettati? Un gioco affidabile non perde i salvataggi, non ha bug che bloccano il gameplay e non ti fa imprecare contro lo schermo.</li> <li>Esempio:<ul> <li>Super Mario Odyssey: Un gioco con pochissimi bug e un gameplay solido come una roccia.</li> <li>Un gioco indie ben testato: Anche i giochi indie possono essere molto affidabili se gli sviluppatori si prendono il tempo di testarli a fondo.</li> <li>No Man's Sky al lancio: Un esempio di gioco con problemi di affidabilit\u00e0 al lancio, con molti bug, crash e funzionalit\u00e0 promesse non presenti.</li> </ul> </li> <li>Importanza: Un gioco inaffidabile pu\u00f2 rovinare l'esperienza di gioco e farti perdere ore di progressi.</li> </ul> <p>4. Manutenibilit\u00e0:</p> <ul> <li>Definizione: Quanto \u00e8 facile per gli sviluppatori correggere bug, aggiungere nuove funzionalit\u00e0 e aggiornare il software? Un gioco manutenibile ha un codice ben scritto, modulare e facile da capire.</li> <li>Esempio:<ul> <li>World of Warcraft: Un gioco che \u00e8 stato aggiornato e ampliato per oltre 15 anni, grazie a un'architettura software ben progettata.</li> <li>I giochi con mod: Giochi come Skyrim o Minecraft, con un'architettura aperta che permette ai modder di creare nuove funzionalit\u00e0 e contenuti.</li> <li>Un gioco con codice \"spaghetti\": Se il codice \u00e8 disorganizzato e difficile da capire, anche correggere un piccolo bug pu\u00f2 diventare un incubo.</li> </ul> </li> <li>Importanza: Un gioco non manutenibile diventa obsoleto rapidamente e non pu\u00f2 essere aggiornato o migliorato nel tempo.</li> </ul> <p>5. Portabilit\u00e0:</p> <ul> <li>Definizione: Quanto \u00e8 facile adattare il software per farlo funzionare su diverse piattaforme (PC, console, smartphone, browser)? Un gioco portabile pu\u00f2 raggiungere un pubblico pi\u00f9 ampio e massimizzare le vendite.</li> <li>Esempio:<ul> <li>Genshin Impact: Un gioco disponibile su PC, Playstation, Android e iOS.</li> <li>I giochi che usano motori grafici multipiattaforma: Unreal Engine e Unity facilitano la portabilit\u00e0 dei giochi su diverse piattaforme.</li> <li>Un gioco scritto in un linguaggio specifico per una piattaforma: Potrebbe essere difficile o impossibile portarlo su altre piattaforme.</li> </ul> </li> <li>Importanza: Un gioco non portabile \u00e8 limitato a una sola piattaforma e perde l'opportunit\u00e0 di raggiungere un pubblico pi\u00f9 ampio.</li> </ul> <p>6. Usabilit\u00e0:</p> <ul> <li>Definizione: Quanto \u00e8 facile da usare il software? L'interfaccia utente \u00e8 intuitiva? I comandi sono facili da imparare? C'\u00e8 un tutorial chiaro? Un gioco usabile \u00e8 facile da imparare e da giocare, anche per i nuovi giocatori.</li> <li>Esempio:<ul> <li>The Last of Us Part II: Nonostante la complessit\u00e0 del gameplay, il gioco ha un'interfaccia utente chiara e intuitiva, con opzioni di accessibilit\u00e0 per i giocatori con disabilit\u00e0.</li> <li>Un gioco con un tutorial ben fatto: Aiuta i nuovi giocatori a imparare le meccaniche di gioco in modo graduale.</li> <li>Un gioco con un'interfaccia utente confusa: Pu\u00f2 scoraggiare i giocatori e rendere difficile godersi il gioco.</li> </ul> </li> <li>Importanza: Un gioco non usabile pu\u00f2 essere frustrante e difficile da imparare, anche se ha un gameplay interessante.</li> </ul> <p>In sintesi: Tutte queste caratteristiche sono importanti e interconnesse. Un buon videogioco deve trovare un equilibrio tra tutte queste caratteristiche per offrire un'esperienza di gioco ottimale. Non basta avere una grafica spettacolare se il gioco \u00e8 pieno di bug o difficile da usare. Pensa a un gioco come \"Disco Elysium\": non ha una grafica all'avanguardia, ma compensa con una trama avvincente, un'ottima usabilit\u00e0 e un gameplay innovativo. Quindi, la prossima volta che giochi a un videogioco, prova a pensare a quali caratteristiche lo rendono buono (o cattivo) e come potrebbero essere migliorate. Questo ti aiuter\u00e0 a capire meglio il ruolo dell'ingegneria del software nello sviluppo dei videogame.</p>"},{"location":"material/06_isw/01_intro/04_quality/","title":"6.1.4 - Qualit\u00e0 del software","text":"<p>Per parlare di qualit\u00e0 del software, possiamo immaginare uno scenario in cui abbiamo racimolato un po' di vil danaro per acquistare un videogioco. Dato che i soldi sono limitati, dobbiamo cercare di fare la scelta migliore possibile: cerchiamo quindi un gioco divertente, senza bug, con una buona interfaccia utente e che, in sintesi, valga i soldi spesi. Con la dicitura qualit\u00e0 del software indichiamo, quindi, l'insieme di tutte queste caratteristiche che, se esistono, rendono un videogioco di qualit\u00e0.</p> <p>Non solo videogiochi</p> <p>Valutazioni simili possono essere effettuate per software di ogni tipo!</p> <p>In parole povere, possiamo dire che la qualit\u00e0 del software indica il grado in cui un software soddisfa le esigenze e le aspettative degli utenti. Per valutarla al meglio, possiamo utilizzare una serie di parametri, che approfondiamo di seguito.</p> <p>Quindi, la qualit\u00e0 del software \u00e8 un compromesso tra tutti questi fattori. A volte, per avere una grafica spettacolare (efficienza compromessa), si sacrificano l'affidabilit\u00e0 (bug) o la manutenibilit\u00e0 (codice difficile da aggiornare). Il bravo ingegnere del software deve trovare il giusto equilibrio.</p>"},{"location":"material/06_isw/01_intro/04_quality/#funzionalita","title":"Funzionalit\u00e0","text":"<p>Torniamo al nostro videogame: le meccaniche di gioco funzionano come previsto? Se il nostro personaggio deve saltare a seguito della pressione di un pulsante, \u00e8 in grado di farlo? Se alla raccolta del centesimo anello (o moneta) \u00e8 previsto che si abbia un'ulteriore vita, ci\u00f2 avviene davvero? Se il gioco \u00e8 di corse, una Ferrari va effettivamente pi\u00f9 veloce di una Twingo? Se invece il nostro software fosse un editor video, siamo in grado di importare sorgenti di diverso tipo? Siamo in grado di tagliare, incollare, applicare effetti, e via discorrendo? In linea generale, quindi, un software \u00e8 funzionale se \u00e8 in grado di fare tutto ci\u00f2 per il quale \u00e8 stato inteso e progettato.</p>"},{"location":"material/06_isw/01_intro/04_quality/#affidabilita","title":"Affidabilit\u00e0","text":"<p>Affidabilit\u00e0: Il gioco funziona senza crash? Ci sono bug fastidiosi che impediscono di giocare? Si blocca spesso? Perde i salvataggi? Esempio: Immagina di essere al boss finale di Elden Ring, e il gioco crasha proprio mentre stai per vincere. La tua affidabilit\u00e0 nel gioco (e nella software house) crollerebbe drasticamente!</p>"},{"location":"material/06_isw/01_intro/04_quality/#usabilita","title":"Usabilit\u00e0","text":"<p>Usabilit\u00e0: \u00c8 facile da usare? I menu sono intuitivi? I comandi sono facili da imparare? C'\u00e8 un tutorial chiaro? Esempio: Un gioco con un'interfaccia utente confusa, menu nascosti e comandi impossibili da ricordare \u00e8 un incubo. Pensa a un simulatore di volo: deve essere complesso, ma non cos\u00ec tanto da scoraggiare un nuovo giocatore.</p>"},{"location":"material/06_isw/01_intro/04_quality/#efficienza","title":"Efficienza","text":"<p>Efficienza: Il gioco \u00e8 veloce e reattivo? Non consuma troppe risorse del computer/console? Gira bene anche su hardware meno potente? Esempio: Un gioco open world che richiede una scheda grafica da 2000 euro per girare decentemente non \u00e8 molto efficiente. Un gioco ben ottimizzato, invece, gira fluido anche su un PC di fascia media.</p>"},{"location":"material/06_isw/01_intro/04_quality/#manutenibilita","title":"Manutenibilit\u00e0","text":"<p>Manutenibilit\u00e0: \u00c8 facile per gli sviluppatori correggere bug, aggiungere nuove funzionalit\u00e0 e aggiornare il gioco? Il codice \u00e8 ben scritto e facile da capire? Esempio: Se uno sviluppatore lascia la software house e nessuno capisce come funziona il codice del gioco, diventa difficile aggiungere nuove espansioni o correggere problemi.</p>"},{"location":"material/06_isw/01_intro/04_quality/#portabilita","title":"Portabilit\u00e0","text":"<p>Portabilit\u00e0: Il gioco funziona su diverse piattaforme (PC, console, smartphone)? \u00c8 facile adattarlo ad altre piattaforme in futuro? Esempio: Cyberpunk 2077 \u00e8 uscito con grossi problemi di performance su console, dimostrando una scarsa portabilit\u00e0.</p>"},{"location":"material/06_isw/01_intro/04_quality/#sicurezza","title":"Sicurezza","text":"<p>Sicurezza: Il gioco protegge i dati degli utenti? \u00c8 resistente agli attacchi degli hacker? Esempio: Se un gioco online ha falle di sicurezza, gli hacker possono rubare gli account degli utenti, i loro oggetti virtuali o addirittura le loro informazioni personali.</p>"},{"location":"material/06_isw/01_intro/04_quality/#perche-la-qualita-e-importante","title":"Perch\u00e9 la qualit\u00e0 \u00e8 importante?","text":"<ul> <li> <p>Soddisfazione del cliente: Ovvio, no? Un gioco di qualit\u00e0 rende felici i giocatori.</p> </li> <li> <p>Reputazione: Un'azienda che produce software di qualit\u00e0 si costruisce una buona reputazione.</p> </li> <li> <p>Risparmio di costi: Correggere bug dopo il rilascio di un gioco costa molto di pi\u00f9 che prevenirli durante lo sviluppo.</p> </li> <li> <p>Vantaggio competitivo: Un gioco di alta qualit\u00e0 ha pi\u00f9 probabilit\u00e0 di vendere bene e battere la concorrenza.</p> </li> </ul> <p>In conclusione, la qualit\u00e0 del software \u00e8 come la \"ricetta segreta\" che rende un gioco (o qualsiasi altro software) un successo. \u00c8 un insieme di attributi che contribuiscono a creare un prodotto che sia non solo funzionale, ma anche piacevole, affidabile e che soddisfi le aspettative di tutti. E, soprattutto, che valga i soldi spesi!</p>"},{"location":"material/06_isw/01_intro/05_requirements/","title":"6.1.5 - Requisiti del software","text":"<p>Immaginimo di voler tornare a costruire il nostro videogame. Prima di iniziare a programmare, \u00e8 importantissimo capire cosa costruire.</p> <p>Il game design</p> <p>Ignoreremo volontariamente l'intera tematica legata al game design. Sappiate per\u00f2 che esiste, ed \u00e8 un aspetto fondamentale della progettazione di un videogioco.</p> <p>Ok, immagina di voler costruire un videogioco. Prima di iniziare a programmare come un pazzo, devi capire COSA devi costruire. I requisiti del software sono proprio questo: una descrizione dettagliata di quello che il tuo videogioco (o qualsiasi altro software) deve fare. Sono un po' come le istruzioni di montaggio di un mobile IKEA, ma molto pi\u00f9 precise e complete.</p> <p>Pensa a un videogioco come un edificio. I requisiti sono i progetti architettonici, le specifiche dei materiali, le normative di sicurezza... tutto quello che serve per costruire l'edificio correttamente.</p> <p>Perch\u00e9 sono importanti?</p> <p>Definiscono il \"cosa\": Senza requisiti chiari, rischi di costruire qualcosa di diverso da quello che volevi. Immagina di costruire un gioco di corse e scoprire a met\u00e0 sviluppo che il cliente voleva un simulatore di Formula 1 iper-realistico, mentre tu stavi facendo un racing arcade alla Mario Kart.</p> <p>Evitano fraintendimenti: Clienti (o team di design) e sviluppatori devono essere sulla stessa pagina. I requisiti servono a chiarire ogni dubbio fin dall'inizio.</p> <p>Forniscono una base per il test: Come fai a sapere se il tuo videogioco funziona correttamente se non hai un elenco chiaro di cosa deve fare? I requisiti sono la base per creare i test che verificano che tutto funzioni come previsto.</p> <p>Aiutano a gestire i costi e i tempi: Definire i requisiti aiuta a stimare il lavoro necessario e a evitare sorprese costose durante lo sviluppo. Se a met\u00e0 sviluppo ti accorgi che devi aggiungere una funzionalit\u00e0 enorme che non era prevista, i tempi e i costi esplodono.</p> <p>Tipi di Requisiti</p> <p>I requisiti si dividono principalmente in due categorie:</p> <p>Requisiti Funzionali: Definiscono cosa il software deve fare. Sono le funzionalit\u00e0, le azioni, i comportamenti che il gioco deve avere.</p> <p>Esempio (Call of Duty):</p> <p>Il gioco deve permettere al giocatore di muovere il personaggio usando i tasti WASD (o il joystick).</p> <p>Il gioco deve permettere al giocatore di sparare con diverse armi.</p> <p>Il gioco deve avere una modalit\u00e0 multiplayer online.</p> <p>Il gioco deve salvare i progressi del giocatore.</p> <p>Il gioco deve permettere al giocatore di personalizzare l'equipaggiamento del personaggio.</p> <p>Se il giocatore completa una missione, deve ricevere una ricompensa.</p> <p>Requisiti Non Funzionali: Definiscono come il software deve funzionare. Sono le caratteristiche di qualit\u00e0, le performance, i vincoli che il gioco deve rispettare.</p> <p>Esempio (The Witcher 3):</p> <p>Performance: Il gioco deve girare a 30 FPS (frame per secondo) su una Playstation 4 standard.</p> <p>Usabilit\u00e0: L'interfaccia utente deve essere intuitiva e facile da usare.</p> <p>Sicurezza: Il gioco deve proteggere i dati dell'utente (password, progressi) da accessi non autorizzati.</p> <p>Affidabilit\u00e0: Il gioco non deve crashare pi\u00f9 di una volta ogni 10 ore di gioco.</p> <p>Portabilit\u00e0: Il gioco deve essere compatibile con Windows, Playstation e Xbox.</p> <p>Scalabilit\u00e0: Il gioco deve poter supportare fino a 64 giocatori in modalit\u00e0 multiplayer contemporaneamente.</p> <p>Come si scrivono i requisiti?</p> <p>Non c'\u00e8 una formula magica, ma ecco alcuni consigli:</p> <p>Sii specifico: Evita frasi vaghe come \"il gioco deve essere divertente\". Definisci cosa rende il gioco divertente in termini di funzionalit\u00e0 e meccaniche di gioco.</p> <p>Sii misurabile: I requisiti non funzionali, in particolare, devono essere misurabili. Invece di dire \"il gioco deve essere veloce\", specifica \"il gioco deve caricare le texture in meno di 2 secondi\".</p> <p>Sii realistico: Non chiedere l'impossibile. Tieni conto delle risorse disponibili, dei tempi di sviluppo e delle limitazioni tecnologiche.</p> <p>Coinvolgi tutti: I requisiti devono essere definiti in collaborazione con il team di design, gli sviluppatori, i tester e, se possibile, anche con i potenziali giocatori (tramite sondaggi o focus group).</p> <p>Esempio concreto:</p> <p>Immagina di dover definire i requisiti per un nuovo gioco di Pok\u00e9mon.</p> <p>Requisito Funzionale: \"Il giocatore deve poter catturare i Pok\u00e9mon selvatici lanciando delle Pok\u00e9ball.\"</p> <p>Requisito Non Funzionale: \"La probabilit\u00e0 di catturare un Pok\u00e9mon con una Pok\u00e9ball standard deve essere del 50% se la sua salute \u00e8 inferiore al 25%.\"</p> <p>In sintesi: i requisiti sono il fondamento di qualsiasi progetto software di successo. Senza requisiti chiari, rischi di costruire un videogioco che nessuno vuole giocare, che non funziona correttamente o che costa troppo. Prenditi il tempo necessario per definire i requisiti in modo accurato e vedrai che il tuo progetto ne trarr\u00e0 enormi benefici. Pensa a un gioco come Among Us che ha un requisito non funzionale di matchmaking veloce per mantenere l'engagement dei giocatori. Un matchmaking lento distruggerebbe l'esperienza di gioco, anche se le meccaniche di gioco rimanessero identiche.</p>"},{"location":"material/06_isw/01_intro/06_problems/","title":"06 problems","text":"<p>Ok, immagina di essere un detective. Ogni caso \u00e8 un problema diverso da risolvere: un furto, un omicidio, una truffa... Ognuno ha le sue difficolt\u00e0 e richiede un approccio specifico.</p> <p>Anche l'ingegneria del software ha i suoi \"casi\" da risolvere, i suoi problemi specifici che rendono lo sviluppo di software un'attivit\u00e0 complessa e impegnativa. Ecco alcuni dei principali:</p> <p>1. Complessit\u00e0:</p> <ul> <li>Descrizione: I sistemi software moderni sono incredibilmente complessi, con milioni di righe di codice, interazioni intricate tra componenti e dipendenze da librerie esterne.</li> <li>Problema: Gestire questa complessit\u00e0 \u00e8 difficile e pu\u00f2 portare a bug, errori di progettazione e difficolt\u00e0 nella manutenzione.</li> <li>Esempio (Videogame): Creare un mondo aperto vasto e dettagliato come quello di Red Dead Redemption 2 richiede una quantit\u00e0 enorme di codice e una gestione complessa delle risorse.</li> </ul> <p>2. Gestione dei Requisiti:</p> <ul> <li>Descrizione: Definire e gestire i requisiti del software (cosa deve fare, come deve funzionare) \u00e8 un processo complesso e cruciale.</li> <li>Problema: I requisiti possono essere incompleti, ambigui, contraddittori o cambiare nel tempo, portando a malintesi, ritardi e software che non soddisfa le esigenze degli utenti.</li> <li>Esempio (Videogame): Se i designer di un gioco non comunicano chiaramente agli sviluppatori come deve funzionare una certa meccanica di gioco, il risultato finale potrebbe essere diverso da quello desiderato. Pensa ai numerosi problemi di Cyberpunk 2077 legati alla gestione delle aspettative e alla comunicazione dei requisiti.</li> </ul> <p>3. Cambiamento:</p> <ul> <li>Descrizione: Il software \u00e8 in continua evoluzione, con nuove tecnologie, nuove esigenze degli utenti e nuove minacce alla sicurezza che richiedono modifiche e aggiornamenti costanti.</li> <li>Problema: Gestire il cambiamento in modo efficiente e senza introdurre nuovi bug \u00e8 difficile e richiede una progettazione flessibile e processi di sviluppo agili.</li> <li>Esempio (Videogame): I giochi \"live service\" come Fortnite o Apex Legends devono essere aggiornati regolarmente con nuovi contenuti, nuove funzionalit\u00e0 e correzioni di bug per mantenere l'interesse dei giocatori.</li> </ul> <p>4. Scalabilit\u00e0:</p> <ul> <li>Descrizione: La capacit\u00e0 di un software di gestire un numero crescente di utenti, dati o transazioni senza compromettere le prestazioni.</li> <li>Problema: Progettare un software scalabile \u00e8 difficile e richiede una pianificazione accurata dell'architettura, l'utilizzo di tecnologie adeguate e test rigorosi.</li> <li>Esempio (Videogame): Un gioco multiplayer online deve essere in grado di gestire migliaia o addirittura milioni di giocatori contemporaneamente senza causare lag o crash.</li> </ul> <p>5. Affidabilit\u00e0:</p> <ul> <li>Descrizione: La capacit\u00e0 di un software di funzionare correttamente e senza errori per un periodo di tempo prolungato.</li> <li>Problema: Garantire l'affidabilit\u00e0 \u00e8 difficile e richiede test rigorosi, una progettazione robusta e una gestione attenta degli errori.</li> <li>Esempio (Videogame): Un gioco che crasha frequentemente o che perde i salvataggi dei giocatori \u00e8 considerato inaffidabile e pu\u00f2 rovinare l'esperienza di gioco.</li> </ul> <p>6. Sicurezza:</p> <ul> <li>Descrizione: La capacit\u00e0 di un software di proteggere i dati degli utenti da accessi non autorizzati, attacchi informatici e vulnerabilit\u00e0.</li> <li>Problema: Garantire la sicurezza \u00e8 difficile e richiede una conoscenza approfondita delle minacce alla sicurezza, l'implementazione di misure di protezione adeguate e aggiornamenti regolari per correggere le vulnerabilit\u00e0.</li> <li>Esempio (Videogame): I giochi online devono proteggere gli account degli utenti, i loro dati personali e le loro transazioni finanziarie da hacker e truffatori.</li> </ul> <p>7. Costi e Tempi:</p> <ul> <li>Descrizione: Lo sviluppo di software pu\u00f2 essere costoso e richiedere molto tempo.</li> <li>Problema: Stimare i costi e i tempi con precisione \u00e8 difficile e spesso i progetti software sforano il budget e i tempi previsti.</li> <li>Esempio (Videogame): Lo sviluppo di un gioco tripla A pu\u00f2 costare decine o addirittura centinaia di milioni di dollari e richiedere anni di lavoro.</li> </ul> <p>8. Gestione del Team:</p> <ul> <li>Descrizione: Lo sviluppo di software richiede spesso la collaborazione di un team di persone con competenze diverse.</li> <li>Problema: Gestire un team in modo efficiente e garantire una comunicazione efficace \u00e8 difficile e richiede leadership, capacit\u00e0 di organizzazione e gestione dei conflitti.</li> <li>Esempio (Videogame): Un team di sviluppo di videogiochi pu\u00f2 essere composto da programmatori, artisti, designer, musicisti, sound designer, tester e project manager. Far lavorare tutte queste persone in modo coordinato \u00e8 una sfida.</li> </ul> <p>9. Debito Tecnico:</p> <ul> <li>Descrizione: Il debito tecnico \u00e8 il costo implicito di soluzioni di sviluppo frettolose che possono sembrare efficienti nel breve termine, ma che creano problemi nel lungo termine.</li> <li>Problema: Ignorare il debito tecnico porta a codice disordinato, difficile da mantenere e da estendere, aumentando i costi e i tempi di sviluppo futuri.</li> <li>Esempio (Videogame): Aggiungere una funzionalit\u00e0 \"al volo\" senza una progettazione adeguata per rispettare una scadenza pu\u00f2 portare a codice \"spaghetti\" difficile da modificare in futuro.</li> </ul> <p>In conclusione, l'ingegneria del software \u00e8 una disciplina complessa che affronta una serie di problemi difficili. Superare questi problemi richiede una combinazione di competenze tecniche, capacit\u00e0 di gestione del progetto, comunicazione efficace e una solida comprensione delle esigenze degli utenti. Pensa allo sviluppo di Star Citizen, un progetto ambizioso che ha affrontato (e sta ancora affrontando) molti di questi problemi, dimostrando quanto possa essere difficile e costoso sviluppare un software complesso.</p>"},{"location":"material/06_isw/01_intro/xx_evaluation/","title":"Xx evaluation","text":"<p>Ok, capito. Niente prototipo completo, focus sulle pratiche dell'ingegneria del software. Ecco un esercizio di gruppo che si concentra sulla pianificazione, l'architettura e la gestione del processo di sviluppo di un videogioco, senza la necessit\u00e0 di creare un prototipo giocabile.</p> <p>Esercizio: Progettazione Ingegneristica di un Videogioco Modulare</p> <p>Obiettivo: Progettare l'architettura software e definire il processo di sviluppo di un videogioco, applicando principi di ingegneria del software.</p> <p>Vincoli:</p> <ul> <li>Tempo: 6 settimane (adattabile)</li> <li>Team: Gruppi di 4-5 studenti.</li> <li>Genere: A scelta (e.g., RPG, platformer, strategico).</li> <li>Target: Definire a chi \u00e8 diretto il gioco (es: bambini, hardcore gamers, casual players).</li> <li>Budget Ipotetico: Definire un budget realistico per il gioco (es: indie, AA, AAA).</li> </ul> <p>Fasi del Progetto:</p> <ol> <li> <p>Settimana 1: Analisi dei Requisiti e Definizione Ambito (Focus Ingegneristico)</p> <ul> <li>Definire il concetto del gioco (genere, ambientazione, storia, personaggi).</li> <li>Analizzare il target di riferimento (gusti, aspettative, piattaforme preferite).</li> <li>Identificare i requisiti funzionali (cosa dovr\u00e0 fare il gioco) e non funzionali (performance, usabilit\u00e0, affidabilit\u00e0, portabilit\u00e0, sicurezza - se applicabile).</li> <li>Stimare i costi e i tempi di sviluppo (ipotesi basata sul budget).</li> <li>Documento da Produrre: Documento dei requisiti, analisi di mercato (target e budget).</li> </ul> </li> <li> <p>Settimana 2: Architettura Software e Design Modulare</p> <ul> <li>Progettare l'architettura software del gioco utilizzando diagrammi UML (o altri strumenti di modellazione).</li> <li>Identificare i principali moduli (es: modulo di rendering, modulo di fisica, modulo di AI, modulo audio, modulo di networking).</li> <li>Definire le interfacce tra i moduli (come comunicheranno i moduli tra loro).</li> <li>Scegliere le tecnologie e i linguaggi di programmazione pi\u00f9 appropriati per ogni modulo.</li> <li>Documento da Produrre: Diagrammi UML (classi, componenti, sequenze), descrizione delle API tra moduli, scelta delle tecnologie.</li> </ul> </li> <li> <p>Settimana 3: Progettazione del Database e Persistenza dei Dati (Se Applicabile)</p> <ul> <li>Se il gioco richiede persistenza dei dati (es: salvataggi, progressi del giocatore, inventario), progettare lo schema del database.</li> <li>Scegliere il tipo di database pi\u00f9 adatto (es: relazionale, NoSQL).</li> <li>Definire le strategie di backup e recovery dei dati.</li> <li>Documento da Produrre: Schema del database, descrizione delle strategie di persistenza.</li> </ul> </li> <li> <p>Settimana 4: Pianificazione del Processo di Sviluppo e Gestione del Team (Focus Ingegneristico)</p> <ul> <li>Definire il processo di sviluppo (es: agile, waterfall, ibrido).</li> <li>Suddividere il progetto in task e milestones.</li> <li>Assegnare i ruoli e le responsabilit\u00e0 ai membri del team.</li> <li>Scegliere gli strumenti di project management (es: Jira, Trello).</li> <li>Definire le strategie di testing (es: unit testing, integration testing, system testing).</li> <li>Documento da Produrre: Piano di progetto (WBS, Gantt chart), matrice dei ruoli e delle responsabilit\u00e0, piano di testing.</li> </ul> </li> <li> <p>Settimana 5: Strategie di Test e Controllo Qualit\u00e0</p> <ul> <li>Definire i tipi di test necessari (unit test, integration test, system test, acceptance test).</li> <li>Scrivere casi di test per i moduli principali del gioco.</li> <li>Pianificare l'integrazione continua e l'automazione dei test (se possibile).</li> <li>Definire le metriche per misurare la qualit\u00e0 del software (es: numero di bug, copertura del codice).</li> <li>Documento da Produrre: Piano di test, casi di test, metriche di qualit\u00e0.</li> </ul> </li> <li> <p>Settimana 6: Presentazione Finale e Analisi del Rischio</p> <ul> <li>Presentare l'intero progetto al resto del corso.</li> <li>Spiegare le scelte di design, le decisioni tecniche e il piano di sviluppo.</li> <li>Identificare i principali rischi del progetto (es: problemi tecnici, ritardi, mancanza di risorse).</li> <li>Proporre strategie per mitigare i rischi.</li> <li>Documento da Produrre: Presentazione finale, analisi dei rischi.</li> </ul> </li> </ol> <p>Valutazione:</p> <ul> <li>Completezza della Progettazione: Quanto \u00e8 dettagliata e completa l'architettura software, il piano di sviluppo e il piano di test?</li> <li>Applicazione dei Principi di Ingegneria del Software: Quanto sono ben applicati i principi di modularit\u00e0, astrazione, incapsulamento e separazione delle responsabilit\u00e0?</li> <li>Realismo del Piano: Quanto \u00e8 realistico il piano di sviluppo, considerando il budget, i tempi e le risorse disponibili?</li> <li>Gestione del Rischio: Quanto sono ben identificati e gestiti i rischi del progetto?</li> <li>Presentazione: Chiarezza, completezza, capacit\u00e0 di rispondere alle domande.</li> <li>Qualit\u00e0 dei Documenti: Chiarezza, completezza e organizzazione dei documenti prodotti.</li> </ul> <p>Suggerimenti Aggiuntivi:</p> <ul> <li>Incoraggiare l'uso di strumenti di modellazione UML (o equivalenti) per progettare l'architettura software.</li> <li>Fornire feedback regolare durante il processo di progettazione.</li> <li>Organizzare sessioni di \"design review\" tra i gruppi per condividere idee e best practice.</li> <li>Invitare un professionista del settore a fare da giudice per la presentazione finale.</li> <li>Enfatizzare l'importanza della comunicazione e della collaborazione nel team.</li> </ul> <p>Questo esercizio permette agli studenti di concentrarsi sugli aspetti fondamentali dell'ingegneria del software, come la pianificazione, la progettazione dell'architettura, la gestione del progetto e la garanzia della qualit\u00e0, senza la necessit\u00e0 di implementare effettivamente il gioco. Il focus \u00e8 sul \"come\" costruire il software, piuttosto che sul \"cosa\". Pensa a questo come alla costruzione di un ponte: prima di posare una singola pietra, devi avere un progetto dettagliato che tenga conto di ogni aspetto, dalla resistenza dei materiali alla gestione del traffico. Questo esercizio simula proprio quella fase di progettazione.</p> <p>Certo, ecco degli esempi di come i gruppi potrebbero affrontare alcune delle fasi chiave dell'esercizio \"Progettazione Ingegneristica di un Videogioco Modulare\", per darti un'idea pi\u00f9 concreta di cosa ci si aspetta.</p> <p>Esempio: Gruppo A - Gioco Strategico a Turni con Microgestione di Risorse (Target: Hardcore Gamers su PC)</p> <ul> <li>Genere: Strategico a turni con elementi di gestione di risorse.</li> <li>Target: Giocatori esperti di giochi strategici su PC, abituati a meccaniche complesse e a lunghe sessioni di gioco.</li> <li>Budget Ipotetico: AA (circa 5-10 milioni di dollari).</li> </ul> <p>1. Analisi dei Requisiti e Definizione Ambito:</p> <ul> <li>Requisiti Funzionali:<ul> <li>Il gioco deve avere una mappa del mondo generata proceduralmente.</li> <li>Il giocatore deve poter costruire basi, raccogliere risorse e addestrare unit\u00e0.</li> <li>Il giocatore deve poter attaccare e difendere territori.</li> <li>Il gioco deve avere un sistema di ricerca tecnologica.</li> <li>Il gioco deve supportare il multiplayer online fino a 8 giocatori.</li> <li>Il gioco deve avere una campagna single-player con una trama complessa.</li> </ul> </li> <li>Requisiti Non Funzionali:<ul> <li>Il gioco deve girare a 60 FPS su PC di fascia media.</li> <li>L'interfaccia utente deve essere intuitiva e personalizzabile.</li> <li>Il gioco deve essere stabile e affidabile (pochi crash).</li> <li>Il gioco deve essere facile da moddare (supporto per modding community).</li> </ul> </li> </ul> <p>2. Architettura Software e Design Modulare:</p> <ul> <li>Moduli Principali:<ul> <li>Modulo di Rendering: Gestisce la grafica del gioco.<ul> <li>Tecnologia: Unreal Engine o Unity.</li> </ul> </li> <li>Modulo di Gameplay: Gestisce le meccaniche di gioco, le regole e l'IA.<ul> <li>Tecnologia: C++ o C#.</li> </ul> </li> <li>Modulo di AI: Gestisce il comportamento dei nemici e delle unit\u00e0 alleate.<ul> <li>Tecnologia: C++ o C# con librerie di AI (es: TensorFlow).</li> </ul> </li> <li>Modulo di Risorse: Gestisce la raccolta, la produzione e la distribuzione delle risorse.<ul> <li>Tecnologia: C++.</li> </ul> </li> <li>Modulo di Rete: Gestisce il multiplayer online.<ul> <li>Tecnologia: C++ con librerie di networking (es: Photon Engine).</li> </ul> </li> <li>Modulo di Interfaccia Utente: Gestisce l'interfaccia utente del gioco.<ul> <li>Tecnologia: UMG (Unreal Motion Graphics) o Unity UI.</li> </ul> </li> <li>Modulo di Audio: Gestisce gli effetti sonori e la musica.<ul> <li>Tecnologia: Wwise o FMOD.</li> </ul> </li> </ul> </li> <li>Interfacce:<ul> <li>Il Modulo di Gameplay comunica con il Modulo di Rendering per visualizzare gli effetti delle azioni del giocatore.</li> <li>Il Modulo di AI comunica con il Modulo di Gameplay per controllare il comportamento delle unit\u00e0.</li> <li>Il Modulo di Rete comunica con il Modulo di Gameplay per sincronizzare lo stato del gioco tra i giocatori.</li> </ul> </li> </ul> <p>3. Progettazione del Database e Persistenza dei Dati:</p> <ul> <li>Database: Relazionale (PostgreSQL) per gestire i dati del mondo di gioco, le statistiche dei giocatori e le transazioni.</li> <li>Schema: Tabelle per giocatori, unit\u00e0, edifici, risorse, tecnologie, missioni, ecc.</li> <li>Strategie di Persistenza: Salvataggi automatici regolari, backup giornalieri del database.</li> </ul> <p>4. Pianificazione del Processo di Sviluppo e Gestione del Team:</p> <ul> <li>Processo di Sviluppo: Agile (Scrum).</li> <li>Team:<ul> <li>Project Manager (1): Gestisce il progetto, comunica con il team e coordina le attivit\u00e0.</li> <li>Lead Programmer (1): Definisce l'architettura software e supervisiona lo sviluppo del codice.</li> <li>Game Designer (1): Progetta le meccaniche di gioco, le regole e l'IA.</li> <li>Artist (1): Crea gli asset grafici del gioco.</li> <li>Sound Designer (1): Crea gli effetti sonori e la musica.</li> </ul> </li> <li>Strumenti: Jira per il task management, Git per il version control, Slack per la comunicazione.</li> </ul> <p>5. Strategie di Test e Controllo Qualit\u00e0:</p> <ul> <li>Tipi di Test: Unit test (per testare singoli componenti), integration test (per testare l'interazione tra i componenti), system test (per testare l'intero gioco).</li> <li>Casi di Test:<ul> <li>Verificare che le unit\u00e0 si muovano correttamente sulla mappa.</li> <li>Verificare che le risorse vengano raccolte e distribuite correttamente.</li> <li>Verificare che gli attacchi e le difese funzionino correttamente.</li> <li>Verificare che il multiplayer online sia stabile e sincronizzato.</li> </ul> </li> </ul> <p>Esempio: Gruppo B - Platformer 2D con Meccaniche di Puzzle (Target: Casual Players su Mobile)</p> <ul> <li>Genere: Platformer 2D con puzzle.</li> <li>Target: Giocatori occasionali su mobile, che cercano un gioco facile da imparare ma stimolante.</li> <li>Budget Ipotetico: Indie (circa 100.000 - 500.000 dollari).</li> </ul> <p>1. Analisi dei Requisiti e Definizione Ambito:</p> <ul> <li>Requisiti Funzionali:<ul> <li>Il giocatore deve poter saltare, correre e interagire con l'ambiente.</li> <li>Il gioco deve avere livelli con puzzle da risolvere.</li> <li>Il gioco deve avere un sistema di punteggio e di ricompense.</li> <li>Il gioco deve supportare controlli touch intuitivi.</li> <li>Il gioco deve avere una grafica colorata e accattivante.</li> </ul> </li> <li>Requisiti Non Funzionali:<ul> <li>Il gioco deve girare a 30 FPS su smartphone di fascia bassa.</li> <li>Il gioco deve consumare poca batteria.</li> <li>Il gioco deve essere facile da imparare e da giocare.</li> <li>Il gioco deve essere disponibile su Android e iOS.</li> </ul> </li> </ul> <p>2. Architettura Software e Design Modulare:</p> <ul> <li>Moduli Principali:<ul> <li>Modulo di Movimento: Gestisce il movimento del personaggio.<ul> <li>Tecnologia: C# (Unity).</li> </ul> </li> <li>Modulo di Collisione: Gestisce le collisioni tra il personaggio e l'ambiente.<ul> <li>Tecnologia: C# (Unity).</li> </ul> </li> <li>Modulo di Puzzle: Gestisce la logica dei puzzle.<ul> <li>Tecnologia: C# (Unity).</li> </ul> </li> <li>Modulo di Interfaccia Utente: Gestisce l'interfaccia utente del gioco.<ul> <li>Tecnologia: Unity UI.</li> </ul> </li> <li>Modulo di Audio: Gestisce gli effetti sonori e la musica.<ul> <li>Tecnologia: Unity Audio.</li> </ul> </li> </ul> </li> </ul> <p>3. Progettazione del Database e Persistenza dei Dati:</p> <ul> <li>Database: Semplice sistema di salvataggio basato su file (PlayerPrefs in Unity) per salvare il progresso del giocatore e i punteggi.</li> </ul> <p>4. Pianificazione del Processo di Sviluppo e Gestione del Team:</p> <ul> <li>Processo di Sviluppo: Agile (Kanban).</li> <li>Team:<ul> <li>Lead Developer (1): Sviluppa il codice e gestisce il progetto.</li> <li>Game Designer (1): Progetta i livelli e i puzzle.</li> <li>Artist (1): Crea gli asset grafici del gioco.</li> <li>Sound Designer (1): Crea gli effetti sonori e la musica.</li> </ul> </li> <li>Strumenti: Trello per il task management, Git per il version control.</li> </ul> <p>5. Strategie di Test e Controllo Qualit\u00e0:</p> <ul> <li>Tipi di Test: Unit test (per testare singoli componenti), playtesting (per testare l'esperienza di gioco).</li> <li>Casi di Test:<ul> <li>Verificare che il personaggio si muova correttamente.</li> <li>Verificare che i puzzle siano risolvibili.</li> <li>Verificare che l'interfaccia utente sia intuitiva.</li> </ul> </li> </ul> <p>Analisi del Rischio (Esempio per entrambi i gruppi):</p> <ul> <li>Rischio: Ritardo nella consegna degli asset grafici.<ul> <li>Mitigazione: Stabilire scadenze chiare, comunicare regolarmente con l'artista, utilizzare asset provvisori in attesa degli asset definitivi.</li> </ul> </li> <li>Rischio: Problemi tecnici imprevisti.<ul> <li>Mitigazione: Prevedere un margine di tempo per la risoluzione dei problemi, avere a disposizione un programmatore esperto, consultare la documentazione e i forum online.</li> </ul> </li> <li>Rischio: Mancanza di feedback da parte dei tester.<ul> <li>Mitigazione: Organizzare sessioni di playtesting regolari, incentivare i tester a fornire feedback dettagliato, utilizzare strumenti di analisi per monitorare il comportamento dei giocatori.</li> </ul> </li> </ul> <p>Questi sono solo esempi, ovviamente. L'obiettivo \u00e8 che i gruppi dimostrino di aver compreso i principi di ingegneria del software e di saperli applicare alla progettazione di un videogioco, anche senza implementarlo completamente. L'attenzione \u00e8 sulla pianificazione, l'organizzazione e la gestione del processo di sviluppo, piuttosto che sul risultato finale.</p>"},{"location":"material/06_isw/03_agile/03_sdlc/","title":"Il ciclo di vita agile","text":"<p>Il processo </p>"},{"location":"material/06_isw/03_agile/01_intro/lecture/","title":"Processi agili","text":"<p>L'approccio agile \u00e8 un approccio alla gestione del progetto ed allo sviluppo software. L'agile si focalizza sul delivery di parti piccole di lavoro in maniera regolare e fornire all'utente del valore in maniera pi\u00f9 rapida, permettenddo al team di sviluppo di adattarsi ai cambi pi\u00f9 rapidmente e fornire pi\u00f9 valore al cliente.</p>"},{"location":"material/06_isw/03_agile/01_intro/lecture/#cosa-e-la-metodologia-agile","title":"Cosa \u00e8 la metodologia Agile?","text":"<p>Le metodologie agili sono di tipo iterativo ed incrementale, il che significa che sono conosciute per suddividere un progetto in piccole parti ed adattarsi a requisiti mutevoli, dando priorit\u00e0 a flessibilit\u00e0, collaborazione, e soddisfazione del cliente.</p>"},{"location":"material/06_isw/03_agile/01_intro/lecture/#storia-della-metodologia","title":"Storia della metodologia","text":"<p>Nel 1957, si inizi\u00f2 a progettare un nuovo modo di costruire programmi per il computer. Si voleva infatti rendere il processo migliore nel tempo, per cui si teorizzarono i metodi iterativi ed incrementali.</p> <p>Negli anni 70, si inizi\u00f2 ad usare lo sviluppo software adattativo, e si parlava di gestione dei progettie volutiva. In altri termini, si stava modfiicando ed evolvendo il modo in cui si costruiva il sofwtare.</p> <p>NEgli anni 90, ci fu il primo grosso cambiamento. Alcuni infatti non amavano il modo rigido ed estremamente pianificato di sviluppare software secondo la metodologia a cascata per cui, in risposta, metodi pi\u00f9 efficaci e flessibili iniziarono a farsi strada, inclusi il RAD (Rapid Application Development) nel 1991 e la metodologia SCRUM, nata nel 1995, che rappresentano dei veri e propri antesignani della metodologia agile.</p> <p>Nel 2001, infine, diciasettes viluppatori si riunirono in un resort in Utah, a Snowbird, per elaboprare quesllo che venne poi chiamato il Manifesto for Agile Softwrare Development.</p> <p>Nel 2005, a partire da questo, si svilupp\u00f2 la PM Declaration of INtterependence, e nel 2009 si cre\u00f2 il Software Craftmanship Manifesto. Infine, nel 20211, l'Agiel Alliance cre\u00f2 la cosiddetta Guide to Agile Practices, o Agile GLossary, un documento condiviso dove gli sviluppatori agile da tutto il mondo buttarono gi\u00e0 le loro idee, termini, e linee guida.</p>"},{"location":"material/06_isw/03_agile/01_intro/lecture/#lifecycle-agile","title":"Lifecycle agile","text":""},{"location":"material/06_isw/03_agile/02_manifesto/lecture/","title":"Lecture","text":""},{"location":"material/06_isw/03_agile/02_manifesto/lecture/#il-manifesto-agile","title":"Il manifesto Agile","text":"<p>Alla fine degli anni '90, le metodologie di sviluppo software tradizionali non riuscivano ad adattarsi ai requisiti cangianti di progetto. Un gruppo di sviluppatori visionari, tra cui Kent Beck, Martin Fowler ed Alistair Cockburn, decisero quindi di riunirsi ed elaborare quello che sarebbe stato conosciuto come Agile Manifesto.</p> <p>Il manifesto \u00e8 un documento che delinea una serie di principi guida per lo sviluppo adattativo e customer-centric del software. Questo manifesto venne ufficialmente rilasciato il 13 febbraio del 2001, ed ha rappresentato un punto di svolta nell'industria, con le metodologie Agile che hanno guadagnato trazione globalmente. Dopo il 2001, pratiche come lo SCRUM e l'Extreme Programming divennero popolari. Questo estende l'influenza dello sviluppo Agile oltre lo sviluppo software in diversi settori. Questa eredit\u00e0 continua quindi a modellare come i team approcciano i progetti, migliorando adattabilit\u00e0, collaborazione e focus dell'utente nel panorama dinamico delle tecnologie e del business.</p> <p>Lo scopo principale dell'Agile Manifesto \u00e8 stato quindi quello di fornire un fondamento per lo sviluppo software in modo che risponda in maniera efficace ai requisiti mutanti continuando a fornire valore ai clienti. L'obiettivo \u00e8 quindi quello di cambiare il focus dai processi rigidi e dalla documentazione estesa agli individui e alle interazioni tra software e collaborare con il cliente.</p> <p>In pratica, l'Agile Manifesto \u00e8 un insieme di principi fondamentali per lo sviluppo agile del software che enfatizza la flessibilit\u00e0, collaborazione e soddisfazione del cliente. Elenca 4 valori principali e 12 principi.</p>"},{"location":"material/06_isw/03_agile/02_manifesto/lecture/#valori-principali","title":"Valori principali","text":"<ol> <li>Individui ed Interazioni su Processi e Strumenti: si focalizza sull'importanza della comunicazione e collaborazione efficace tra i membri del team.</li> <li>Software funzionante rispetto a documentazione completa: prioritizza la consegna di software funzionale come misura primaria di progresso.</li> <li>Collaborazione col cliente rispetto a negoziazione contrattuale: incoraggia i clienti e gli stakeholder ad essere attivi nel processo di sviluppo.</li> <li>Rispondere ai cambi rispetto a seguire un piano: su requisiti cambianti, abbracciare la flessibilit\u00e0 e l'abilit\u00e0 di adattarsi anche tardi nel processo di sviluppo.</li> </ol> <p>FIGURA VALUES</p>"},{"location":"material/06_isw/03_agile/02_manifesto/lecture/#principi","title":"Principi","text":"<p>FIGURA PRINCIPI</p> <ol> <li>Soddisfazione del cliente attraverso la continuous delivery: questo principio si concentra sull'importanza della soddisfazione del cliente fornendo informazioni ai clienti il prima possibile e in maniera consistente durante il processo di sviluppo.</li> <li>Accogliere i cambiamenti nei requisiti, anche in fase avanzata di sviluppo: i processi agili gestiscono i cambiamenti per dare un vantaggio competitivo al cliente. Anche in stadi avanzati di sviluppo, i cambi nei requisiti sono benvenuti per assicurare che il software rispetti i requisiti in evoluzione del cliente.</li> <li>Rilasciare software funzionante frequentemente: questo principio incoraggia il rilascio regolare di incrementi software funzionali in brevi iterazioni. Questo permette un feedback pi\u00f9 veloce, adattandosi ai requisiti cambianti.</li> <li>Collaborazione tra business stakeholders e sviluppatori: questo principio afferma che gli addetti al business e gli sviluppatori devono lavorare insieme giornalmente nel progetto. Ci dovrebbe essere comunicazione e collaborazione tra le parti coinvolte e il team di sviluppo. Questo \u00e8 cruciale per comprendere e prioritizzare in modo efficace i requisiti.</li> <li>Costruire i progetti attorno a individui motivati: questo principio promuove il dare agli sviluppatori l'ambiente e il supporto di cui hanno bisogno e la fiducia necessaria per completare il lavoro con successo. Individui motivati e responsabilizzati possono produrre lavoro di qualit\u00e0 e dare contributi di valore al progetto.</li> <li>La comunicazione faccia a faccia \u00e8 pi\u00f9 efficace: la comunicazione personale \u00e8 il metodo pi\u00f9 efficace per discutere e convogliare informazioni. Questo principio mostra l'importanza dell'interazione diretta che aiuta a minimizzare le incomprensioni e quindi ottenere una comunicazione efficace.</li> <li>Il software funzionante \u00e8 la prima misura del progresso: questo principio enfatizza la consegna di software funzionale e funzionante come metrica principale per l'avanzamento del progetto. Incoraggia i team a prioritizzare la consegna continua di feature di valore, assicurandosi che buoni progressi vengano ottenuti in maniera consistente nel processo. L'obiettivo principale \u00e8 fornire ai clienti valore incrementale e ottenere feedback rapidamente nel ciclo di vita del progetto.</li> <li>Mantenere un tasso di lavoro sostenibile: l'agile promuove lo sviluppo sostenibile. Tutte le persone coinvolte, tra cui sponsor, sviluppatori, ed utenti devono essere in grado di mantenere un passo costante in m aniera indefinita.- Questo principio illusta la necessit\u00e0 diu un tasso di sviluppo sostenibile e consistente. Questo aitua ad evitare dei burnout ed assicura il successo del progetto a lungo termine.</li> <li></li> </ol>"}]}