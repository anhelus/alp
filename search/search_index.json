{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Corso di Informatica \u00b6 Benvenuti! In questa pagina sono disponibili alcune informazioni di carattere generale sul corso. Informazioni utili \u00b6 Argomento Link - informazioni Email del docente E-mail del docente: angelo.cardellicchio@uniba.it Orari del corso Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 . Ricevimento Le informazioni relative ai ricevimenti sono disponibili a questo link . Comunicazioni con il docente Le informazioni relative alle modalit\u00e0 di comunicazione con il docente sono disponibili a questo link . Svolgimento delle lezioni Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica. Prerequisiti Non sono necessari particolari prerequisiti per l'accesso al corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il corso. Bacheca degli avvisi Gli avvisi inerenti il corso sono disponibili a questo link .","title":"Home del corso"},{"location":"#corso-di-informatica","text":"Benvenuti! In questa pagina sono disponibili alcune informazioni di carattere generale sul corso.","title":"Corso di Informatica"},{"location":"#informazioni-utili","text":"Argomento Link - informazioni Email del docente E-mail del docente: angelo.cardellicchio@uniba.it Orari del corso Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 . Ricevimento Le informazioni relative ai ricevimenti sono disponibili a questo link . Comunicazioni con il docente Le informazioni relative alle modalit\u00e0 di comunicazione con il docente sono disponibili a questo link . Svolgimento delle lezioni Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica. Prerequisiti Non sono necessari particolari prerequisiti per l'accesso al corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il corso. Bacheca degli avvisi Gli avvisi inerenti il corso sono disponibili a questo link .","title":"Informazioni utili"},{"location":"bacheca/","text":"Avvisi \u00b6 17/01/2021 \u00b6 Per gli studenti interessati, saranno a breve resi disponibili qui alcuni esercizi \"sulla scia\" di quelli proponibili per la valutazione della parte pratica durante l'esame scritto. 13/01/2021 \u00b6 Risultati definitivi seconda prova \u00b6 I risultati disponibili a questo indirizzo , e riportati nella sezione File > Seconda prova del canale Temi anno di Microsoft Teams, sono da considerarsi definitivi per ci\u00f2 che concerne la seconda prova. 11/01/2021 \u00b6 Calendario verifiche 11/01/2021 \u00b6 Orario Gruppo 16:30 MADDALENA - MARTINO 16:45 POSA 17:00 SALLUSTIO 17:15 RESTA - CAPPELLANO 17:30 MIOLA 17:45 LEONETTI 18:00 CAPODIFERRO 18:15 PISCITELLI (mancata risposta) 18:30 ROSELLI - GADALETA Calendario verifiche 18/01/2021 \u00b6 Orario Gruppo 16:30 BUCCI All'orario prestabilito, l'interessato ricever\u00e0 una chiamata su Microsoft Teams da parte del docente. Nota Gli orari indicati nella tabella sono indicativi, e suscettibili a variazioni. L'invito \u00e8 quello di essere raggiungibili nei 30 minuti antecedenti e successivi all'orario di convocazione segnalato . 10/01/2021 \u00b6 Aggiornamento voti \u00b6 Sono state inserite le votazioni dei gruppi mancanti. Materiale necessario per Python \u00b6 Per il corretto svolgimento delle prossime lezioni \u00e8 necessario installare l'interprete Python dal sito ufficiale, avendo cura di aggiungerlo al proprio path di sistema ( qui le istruzioni per Windows; qui le istruzioni per Mac; qui quelle per Linux, sul quale dovrebbe comunque essere gi\u00e0 configurato di default). 08/01/2021 - Note sulla consultazione seconda prova \u00b6 Si sottolinea che: durante la consultazione della seconda prova si potr\u00e0, opzionalmente , rispondere ad alcune domande, volte ad effettuare delle verifiche di natura integrativa rispetto alla prova stessa. Ci\u00f2 significa che il voto attualmente riportato non \u00e8 definitivo, ma potr\u00e0 essere suscettibile di modifiche a seguito dell'( eventuale ) verifica orale; tale verifica \u00e8 possibile per tutti quelli che si prenoteranno per la consultazione; gli orari indicati per la consultazione potranno essere estesi in base al numero di richieste pervenute entro i termini stabiliti. 07/01/2021 - Risultati seconda prova \u00b6 A questo indirizzo sono disponibili i risultati relativi alla seconda prova. Nominativi riportati I risultati sono relativi soltanto ai gruppi dei quali risulta essere pervenuta la seconda prova. In caso di discrepanze, \u00e8 necessario inviare una mail secondo le modalit\u00e0 illustrate nella sezione \"Comunicazioni relative a temi d'anno\" della scheda delle comunicazioni con il docente . Parzialit\u00e0 dei risultati I risultati mostrati sono definitivi , a meno dei gruppi per i quali \u00e8 necessaria o consigliata una verifica. Nel caso di verifica consigliata, questa \u00e8 opzionale e, qualora si opti per non farla, diventa definitiva a partire dalle ore 12:00 di luned\u00ec 11/01/2020. Nel caso di verifica necessaria, \u00e8 obbligatorio prenotarsi, pena la perdita del tema d'anno. Consultazione seconda prova \u00b6 Per prenotarsi per la verifica e/o la consultazione della seconda prova, attenersi strettamente alle modalit\u00e0 indicate nella sezione \"Consultazione seconda prova\" della scheda delle comunicazioni con il docente . Il calendario delle revisioni sar\u00e0 stilato in base alle richieste pervenute entro e non oltre le ore 11:00 di luned\u00ec 11/01/2020.","title":"Bacheca avvisi"},{"location":"bacheca/#avvisi","text":"","title":"Avvisi"},{"location":"bacheca/#17012021","text":"Per gli studenti interessati, saranno a breve resi disponibili qui alcuni esercizi \"sulla scia\" di quelli proponibili per la valutazione della parte pratica durante l'esame scritto.","title":"17/01/2021"},{"location":"bacheca/#13012021","text":"","title":"13/01/2021"},{"location":"bacheca/#risultati-definitivi-seconda-prova","text":"I risultati disponibili a questo indirizzo , e riportati nella sezione File > Seconda prova del canale Temi anno di Microsoft Teams, sono da considerarsi definitivi per ci\u00f2 che concerne la seconda prova.","title":"Risultati definitivi seconda prova"},{"location":"bacheca/#11012021","text":"","title":"11/01/2021"},{"location":"bacheca/#calendario-verifiche-11012021","text":"Orario Gruppo 16:30 MADDALENA - MARTINO 16:45 POSA 17:00 SALLUSTIO 17:15 RESTA - CAPPELLANO 17:30 MIOLA 17:45 LEONETTI 18:00 CAPODIFERRO 18:15 PISCITELLI (mancata risposta) 18:30 ROSELLI - GADALETA","title":"Calendario verifiche 11/01/2021"},{"location":"bacheca/#calendario-verifiche-18012021","text":"Orario Gruppo 16:30 BUCCI All'orario prestabilito, l'interessato ricever\u00e0 una chiamata su Microsoft Teams da parte del docente. Nota Gli orari indicati nella tabella sono indicativi, e suscettibili a variazioni. L'invito \u00e8 quello di essere raggiungibili nei 30 minuti antecedenti e successivi all'orario di convocazione segnalato .","title":"Calendario verifiche 18/01/2021"},{"location":"bacheca/#10012021","text":"","title":"10/01/2021"},{"location":"bacheca/#aggiornamento-voti","text":"Sono state inserite le votazioni dei gruppi mancanti.","title":"Aggiornamento voti"},{"location":"bacheca/#materiale-necessario-per-python","text":"Per il corretto svolgimento delle prossime lezioni \u00e8 necessario installare l'interprete Python dal sito ufficiale, avendo cura di aggiungerlo al proprio path di sistema ( qui le istruzioni per Windows; qui le istruzioni per Mac; qui quelle per Linux, sul quale dovrebbe comunque essere gi\u00e0 configurato di default).","title":"Materiale necessario per Python"},{"location":"bacheca/#08012021-note-sulla-consultazione-seconda-prova","text":"Si sottolinea che: durante la consultazione della seconda prova si potr\u00e0, opzionalmente , rispondere ad alcune domande, volte ad effettuare delle verifiche di natura integrativa rispetto alla prova stessa. Ci\u00f2 significa che il voto attualmente riportato non \u00e8 definitivo, ma potr\u00e0 essere suscettibile di modifiche a seguito dell'( eventuale ) verifica orale; tale verifica \u00e8 possibile per tutti quelli che si prenoteranno per la consultazione; gli orari indicati per la consultazione potranno essere estesi in base al numero di richieste pervenute entro i termini stabiliti.","title":"08/01/2021 - Note sulla consultazione seconda prova"},{"location":"bacheca/#07012021-risultati-seconda-prova","text":"A questo indirizzo sono disponibili i risultati relativi alla seconda prova. Nominativi riportati I risultati sono relativi soltanto ai gruppi dei quali risulta essere pervenuta la seconda prova. In caso di discrepanze, \u00e8 necessario inviare una mail secondo le modalit\u00e0 illustrate nella sezione \"Comunicazioni relative a temi d'anno\" della scheda delle comunicazioni con il docente . Parzialit\u00e0 dei risultati I risultati mostrati sono definitivi , a meno dei gruppi per i quali \u00e8 necessaria o consigliata una verifica. Nel caso di verifica consigliata, questa \u00e8 opzionale e, qualora si opti per non farla, diventa definitiva a partire dalle ore 12:00 di luned\u00ec 11/01/2020. Nel caso di verifica necessaria, \u00e8 obbligatorio prenotarsi, pena la perdita del tema d'anno.","title":"07/01/2021 - Risultati seconda prova"},{"location":"bacheca/#consultazione-seconda-prova","text":"Per prenotarsi per la verifica e/o la consultazione della seconda prova, attenersi strettamente alle modalit\u00e0 indicate nella sezione \"Consultazione seconda prova\" della scheda delle comunicazioni con il docente . Il calendario delle revisioni sar\u00e0 stilato in base alle richieste pervenute entro e non oltre le ore 11:00 di luned\u00ec 11/01/2020.","title":"Consultazione seconda prova"},{"location":"comunicazioni/","text":"Comunicazioni con il docente \u00b6 Di seguito, alcune regole da seguire per la comunicazione a mezzo mail con il docente. Nota L'istituzione di questa modalit\u00e0 di comunicazione si \u00e8 resa necessaria per uniformare e gestire al meglio le comunicazioni telematiche. In questa maniera, il flusso delle email viene smistato al meglio, permettendo una migliore interazione tra studente e docente. Nota Non aderire a queste semplici convenzioni non assicura la ricezione di una risposta alle mail inviate. Ricevimento \u00b6 E' necessario prenotare il ricevimento. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [RICEVIMENTO] - NOME_COGNOME dove NOME_COGNOME sono il nome ed il cognome dello studente. Il corpo della mail deve essere vuoto. Il ricevimento sar\u00e0 assegnato nella prima data utile tra quelle disponibili allo stesso , come indicato nella sezione relativa al ricevimento . Richiesta chiarimenti \u00b6 E' possibile richiedere direttamente dei chiarimenti relativi agli argomenti trattati durante il corso. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [CHIARIMENTI] - NOME_COGNOME dove NOME_COGNOME sono il nome ed il cognome dello studente. Il corpo della mail, come ovvio, \u00e8 libero! Informazioni su esami \u00b6 E' possibile richiedere direttamente dei chiarimenti relativi alle modalit\u00e0 di esame, oltre che esporre problemi generici relativi, ad esempio, alle propedeuticit\u00e0. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [ESAMI] - NOME_COGNOME dove NOME_COGNOME sono il nome ed il cognome dello studente. Il corpo della mail, come ovvio, \u00e8 libero! Comunicazioni relative a temi d'anno \u00b6 E' possibile richiedere direttamente dei chiarimenti relativi ai temi d'anno, oltre che esporre problemi generici. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [TEMA ANNO] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo. Il corpo della mail, come ovvio, \u00e8 libero! Consegna temi d'anno \u00b6 Di seguito, i formati (oggetto e corpo) da usare nelle mail per ciascuna delle singole prove. Le mail che non si conformeranno a questo formato non saranno considerate nella valutazione. 1. Prima prova \u00b6 L'oggetto della mail deve essere strutturato come segue: [PRIMA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. Il corpo della mail deve essere vuoto. In allegato \u00e8 possibile inserire fino a due file, in formato esclusivamente PDF/A , di lunghezza non superiore alle quattro pagine complessive. Le pagine dalla quinta in poi saranno ignorate ai fini della valutazione. 2. Seconda e terza prova \u00b6 L'oggetto della mail deve essere strutturato come segue: [SECONDA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO per la seconda prova o [TERZA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. La mail deve essere conforme ad una tra le seguenti possibilit\u00e0. Si noti che le possibilit\u00e0 sono mutualmente esclusive. Possibilit\u00e0 2.1: link a servizi di storage \u00b6 Nel caso si reputi opportuno e/o necessario condividere un link a Google Drive, OneDrive e DropBox, dovr\u00e0 essere fornito all'interno del corpo mail un unico link ad una cartella condivisa su Google Drive. La cartella conterr\u00e0: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - NUMERO PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - NUMERO PROVA ; una ed una sola tra queste quattro alternative: la solution di Visual Studio Community utilizzata per sviluppare il software, comprensiva del codice sorgente esattamente come salvata sul proprio file system ; il codice sorgente (ovvero tutti i file con estensione .c e .h necessari alla compilazione del codice); l'eseguibile da sottoporre a valutazione; un link al servizio esterno repl.it (o simile) contenente il software da valutare. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere ulteriore testo all'interno del corpo mail, se non il link alla cartella condivisa . Possibilit\u00e0 2.2: allegati \u00b6 Nel caso si reputi opportuno e/o necessario mandare la prova in allegato, occorrer\u00e0 allegare: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - NUMERO PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - NUMERO PROVA ; una ed una sola tra queste quattro alternative: la solution di Visual Studio Community utilizzata per sviluppare il software, comprensiva del codice sorgente esattamente come salvata sul proprio file system ; il codice sorgente (ovvero tutti i file con estensione .c e .h necessari alla compilazione del codice); l'eseguibile da sottoporre a valutazione; un link al servizio esterno repl.it (o simile) contenente il software da valutare. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere testo all'interno del corpo mail, se non il link alla cartella condivisa . 3. Quarta prova \u00b6 L'oggetto della mail deve essere strutturato come segue: [QUARTA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. La mail deve essere conforme ad una tra le seguenti possibilit\u00e0. Si noti che le possibilit\u00e0 sono mutualmente esclusive. Possibilit\u00e0 3.1: link a servizi di storage \u00b6 Nel caso si reputi opportuno e/o necessario condividere un link ad un servizio di storage tra Google Drive, OneDrive e DropBox, dovr\u00e0 essere fornito all'interno del corpo mail un unico link ad una cartella condivisa su Google Drive. La cartella conterr\u00e0: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - QUARTA PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - QUARTA PROVA ; il file o la cartella Python da sottoporre a valutazione. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere ulteriore testo all'interno del corpo mail, se non il link alla cartella condivisa . Possibilit\u00e0 3.2: allegati \u00b6 Nel caso si reputi opportuno e/o necessario mandare la prova in allegato, occorrer\u00e0 allegare: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - QUARTA PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - QUARTA PROVA ; il file o la cartella Python da sottoporre a valutazione. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere testo all'interno del corpo mail, se non il link alla cartella condivisa . Nota Ad ogni prova ricevuta sar\u00e0 sempre data una conferma . E' per\u00f2 strettamente necessario evitare di richiedere questa conferma , ed in generale evitare assolutamente l'invio di mail multiple . Verifica tema d'anno \u00b6 Consultazione seconda prova \u00b6 La visione della seconda prova sar\u00e0 possibile nelle seguenti date: Data Orario 11/01/2021 16:30 - 17:30 13/01/2021 16:30 - 17:30 18/01/2021 16:30 - 17:30 20/01/2021 16:30 - 17:30 La verifica avverr\u00e0 mediante Microsoft Teams; sar\u00e0 data proprit\u00e0 ai gruppi il cui elaborato sia contrassegnato per la verifica necessaria o consigliata . Per prenotarsi per la verifica, occorre inviare una email al docente con il seguente oggetto: [VERIFICA SECONDA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. Il corpo della mail deve essere lasciato privo di testo.","title":"Comunicare col docente"},{"location":"comunicazioni/#comunicazioni-con-il-docente","text":"Di seguito, alcune regole da seguire per la comunicazione a mezzo mail con il docente. Nota L'istituzione di questa modalit\u00e0 di comunicazione si \u00e8 resa necessaria per uniformare e gestire al meglio le comunicazioni telematiche. In questa maniera, il flusso delle email viene smistato al meglio, permettendo una migliore interazione tra studente e docente. Nota Non aderire a queste semplici convenzioni non assicura la ricezione di una risposta alle mail inviate.","title":"Comunicazioni con il docente"},{"location":"comunicazioni/#ricevimento","text":"E' necessario prenotare il ricevimento. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [RICEVIMENTO] - NOME_COGNOME dove NOME_COGNOME sono il nome ed il cognome dello studente. Il corpo della mail deve essere vuoto. Il ricevimento sar\u00e0 assegnato nella prima data utile tra quelle disponibili allo stesso , come indicato nella sezione relativa al ricevimento .","title":"Ricevimento"},{"location":"comunicazioni/#richiesta-chiarimenti","text":"E' possibile richiedere direttamente dei chiarimenti relativi agli argomenti trattati durante il corso. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [CHIARIMENTI] - NOME_COGNOME dove NOME_COGNOME sono il nome ed il cognome dello studente. Il corpo della mail, come ovvio, \u00e8 libero!","title":"Richiesta chiarimenti"},{"location":"comunicazioni/#informazioni-su-esami","text":"E' possibile richiedere direttamente dei chiarimenti relativi alle modalit\u00e0 di esame, oltre che esporre problemi generici relativi, ad esempio, alle propedeuticit\u00e0. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [ESAMI] - NOME_COGNOME dove NOME_COGNOME sono il nome ed il cognome dello studente. Il corpo della mail, come ovvio, \u00e8 libero!","title":"Informazioni su esami"},{"location":"comunicazioni/#comunicazioni-relative-a-temi-danno","text":"E' possibile richiedere direttamente dei chiarimenti relativi ai temi d'anno, oltre che esporre problemi generici. In questo caso, l'oggetto dovr\u00e0 essere il seguente: [TEMA ANNO] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo. Il corpo della mail, come ovvio, \u00e8 libero!","title":"Comunicazioni relative a temi d'anno"},{"location":"comunicazioni/#consegna-temi-danno","text":"Di seguito, i formati (oggetto e corpo) da usare nelle mail per ciascuna delle singole prove. Le mail che non si conformeranno a questo formato non saranno considerate nella valutazione.","title":"Consegna temi d'anno"},{"location":"comunicazioni/#1-prima-prova","text":"L'oggetto della mail deve essere strutturato come segue: [PRIMA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. Il corpo della mail deve essere vuoto. In allegato \u00e8 possibile inserire fino a due file, in formato esclusivamente PDF/A , di lunghezza non superiore alle quattro pagine complessive. Le pagine dalla quinta in poi saranno ignorate ai fini della valutazione.","title":"1. Prima prova"},{"location":"comunicazioni/#2-seconda-e-terza-prova","text":"L'oggetto della mail deve essere strutturato come segue: [SECONDA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO per la seconda prova o [TERZA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. La mail deve essere conforme ad una tra le seguenti possibilit\u00e0. Si noti che le possibilit\u00e0 sono mutualmente esclusive.","title":"2. Seconda e terza prova"},{"location":"comunicazioni/#possibilita-21-link-a-servizi-di-storage","text":"Nel caso si reputi opportuno e/o necessario condividere un link a Google Drive, OneDrive e DropBox, dovr\u00e0 essere fornito all'interno del corpo mail un unico link ad una cartella condivisa su Google Drive. La cartella conterr\u00e0: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - NUMERO PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - NUMERO PROVA ; una ed una sola tra queste quattro alternative: la solution di Visual Studio Community utilizzata per sviluppare il software, comprensiva del codice sorgente esattamente come salvata sul proprio file system ; il codice sorgente (ovvero tutti i file con estensione .c e .h necessari alla compilazione del codice); l'eseguibile da sottoporre a valutazione; un link al servizio esterno repl.it (o simile) contenente il software da valutare. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere ulteriore testo all'interno del corpo mail, se non il link alla cartella condivisa .","title":"Possibilit\u00e0 2.1: link a servizi di storage"},{"location":"comunicazioni/#possibilita-22-allegati","text":"Nel caso si reputi opportuno e/o necessario mandare la prova in allegato, occorrer\u00e0 allegare: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - NUMERO PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - NUMERO PROVA ; una ed una sola tra queste quattro alternative: la solution di Visual Studio Community utilizzata per sviluppare il software, comprensiva del codice sorgente esattamente come salvata sul proprio file system ; il codice sorgente (ovvero tutti i file con estensione .c e .h necessari alla compilazione del codice); l'eseguibile da sottoporre a valutazione; un link al servizio esterno repl.it (o simile) contenente il software da valutare. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere testo all'interno del corpo mail, se non il link alla cartella condivisa .","title":"Possibilit\u00e0 2.2: allegati"},{"location":"comunicazioni/#3-quarta-prova","text":"L'oggetto della mail deve essere strutturato come segue: [QUARTA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. La mail deve essere conforme ad una tra le seguenti possibilit\u00e0. Si noti che le possibilit\u00e0 sono mutualmente esclusive.","title":"3. Quarta prova"},{"location":"comunicazioni/#possibilita-31-link-a-servizi-di-storage","text":"Nel caso si reputi opportuno e/o necessario condividere un link ad un servizio di storage tra Google Drive, OneDrive e DropBox, dovr\u00e0 essere fornito all'interno del corpo mail un unico link ad una cartella condivisa su Google Drive. La cartella conterr\u00e0: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - QUARTA PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - QUARTA PROVA ; il file o la cartella Python da sottoporre a valutazione. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere ulteriore testo all'interno del corpo mail, se non il link alla cartella condivisa .","title":"Possibilit\u00e0 3.1: link a servizi di storage"},{"location":"comunicazioni/#possibilita-32-allegati","text":"Nel caso si reputi opportuno e/o necessario mandare la prova in allegato, occorrer\u00e0 allegare: un file, in formato PDF/A , contenente la documentazione richiesta per la prova, e denominato Documentazione Traccia NUMERO TRACCIA - QUARTA PROVA ; un file, in formato PDF/A , contenente una copia carbone del codice sorgente, e denominato Codice Traccia NUMERO TRACCIA - QUARTA PROVA ; il file o la cartella Python da sottoporre a valutazione. Si consiglia inoltre di inserire un file di testo di esempio per le procedure di I/O. Si noti che: non saranno considerati ulteriori file e/o file differenti. La mancanza di questi tre file invalida la prova ; non ci dovr\u00e0 essere testo all'interno del corpo mail, se non il link alla cartella condivisa . Nota Ad ogni prova ricevuta sar\u00e0 sempre data una conferma . E' per\u00f2 strettamente necessario evitare di richiedere questa conferma , ed in generale evitare assolutamente l'invio di mail multiple .","title":"Possibilit\u00e0 3.2: allegati"},{"location":"comunicazioni/#verifica-tema-danno","text":"","title":"Verifica tema d'anno"},{"location":"comunicazioni/#consultazione-seconda-prova","text":"La visione della seconda prova sar\u00e0 possibile nelle seguenti date: Data Orario 11/01/2021 16:30 - 17:30 13/01/2021 16:30 - 17:30 18/01/2021 16:30 - 17:30 20/01/2021 16:30 - 17:30 La verifica avverr\u00e0 mediante Microsoft Teams; sar\u00e0 data proprit\u00e0 ai gruppi il cui elaborato sia contrassegnato per la verifica necessaria o consigliata . Per prenotarsi per la verifica, occorre inviare una email al docente con il seguente oggetto: [VERIFICA SECONDA PROVA] - REFERENTE_GRUPPO - ANNO_ACCADEMICO dove REFERENTE_GRUPPO sono il nome ed il cognome del referente del gruppo, mentre ANNO_ACCADEMICO \u00e8 l'anno accademico di riferimento. Il corpo della mail deve essere lasciato privo di testo.","title":"Consultazione seconda prova"},{"location":"ricevimento/","text":"Ricevimento \u00b6 Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Il ricevimento deve essere concordato a mezzo mail istituzionale . Le modalit\u00e0 di prenotazione sono specificate nella sezione delle comunicazioni con il docente . Nota A.A. 2020/2021 A causa dell'emergenza COVID-19, il ricevimento non avverr\u00e0 in presenza, ma esclusivamente a mezzo Microsoft Teams.","title":"Ricevimento"},{"location":"ricevimento/#ricevimento","text":"Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Il ricevimento deve essere concordato a mezzo mail istituzionale . Le modalit\u00e0 di prenotazione sono specificate nella sezione delle comunicazioni con il docente . Nota A.A. 2020/2021 A causa dell'emergenza COVID-19, il ricevimento non avverr\u00e0 in presenza, ma esclusivamente a mezzo Microsoft Teams.","title":"Ricevimento"},{"location":"00_materiale/programma/","text":"Materiale del corso \u00b6 Argomento Slides 00 - Introduzione al corso Parte 1: Teoria \u00b6 Argomento Slides 01 - Introduzione all'informatica 02 - Introduzione agli algoritmi 03 - Architettura dei calcolatori 04 - Reti di calcolatori 05 - Rappresentazione dei dati 06 - Linguaggi di programmazione 07 - Traduttori 08 - Variabili 09 - Programmazione strutturata 10 - Ricorsione 11 - Diagrammi di flusso 12 - Funzioni 13 - Strutture dati 14 - Complessit\u00e0 computazionale 15 - Algoritmi 1 - Ricerca su array 16 - Algoritmi 2 - Ordinamento 17 - Algoritmi 3 - Ricerca su grafi 18 - Macchina di Turing Parte 2: Cenni al linguaggio C \u00b6 Argomento Slides 19 - Hello, C! 20 - Alcune definizioni 21 - Visibilit\u00e0 di una variabile 22 - Operatori 23 - Array 24 - Puntatori 25 - I/O e file 26 - Typedef, Struct ed Union Parte 3: Cenni al linguaggio C++ \u00b6 Argomento Slides 27 - Dal C al C++ 28 - Alcune definizioni (in C++!) 29 - Le classi (parte 1) 30 - Alcune definizioni (avanzate!) 31 - Le classi (parte 2) 32 - I metodi (alcuni cenni) 33 - Ereditariet\u00e0 34 - Container 35 - La gestione dei file in C++ Parte 4: Cenni al linguaggio Python \u00b6 Argomento Slides 36 - Introduzione al Python 37 - Programmare in Python Riferimenti esterni \u00b6 Testi di riferimento \u00b6 Nota Questi testi sono consigliati . Ci\u00f2 non implica che sia necessario seguirli in maniera pedissequa , ma che occorre intenderli come materiale da usare per motivi di approfondimento personale. Ci\u00f2 comporta due conseguenze: la prima \u00e8 che il corso non segue un testo di riferimento, quanto piuttosto le dispense e le slide proiettate a lezione; la seconda, pi\u00f9 rilevante per lo Studente, \u00e8 che per superare l'esame basta seguire queste ultime. Testi integrativi (per l'approfondimento della materia) \u00b6 Questi testi possono essere considerati come una buona integrazione, da usare per approfondire gli argomenti trattati a lezione. Tanenbaum, Architettura dei calcolatori. Un approccio strutturale Tanenbaum, Reti di calcolatori Deitel, Deitel, C++. Fondamenti di programmazione Testi online \u00b6 Questi testi sono da considerarsi al pari dei testi integrativi per l'approfondimento della materia, con la differenza che sono disponibili (liberamente) online. The Python Tutorial Python Data Science Handbook Testi consigliati (per la data science) \u00b6 Questi testi sono da considerarsi come dei buoni approfondimenti qualora si decida di approfondire, magari in futuro, degli aspetti legati ai principi matematici ed informatici della data science. Goodfellow, Deep Learning G\u00e9ron, Hands-On Machine Learning with Scikit-Learn and Tensorflow: Concepts, Tools, and Techniques to Build Intelligent Systems Esercizi di approfondimento \u00b6 Note Alcuni di questi esercizi fanno riferimento a materiale esterno al corso. Il Docente non \u00e8 responsabile per, n\u00e9 proprietario dei, contenuti presenti a questi link. Inoltre, questi esercizi non sono rappresentativi di tracce di esame, presenti, future o passate. Diagrammi di flusso \u00b6 Esercizi Svolti su Coding Creativo Programmi utili \u00b6 Visual Studio Community 2019 : IDE per lo sviluppo di programmi in C/C++/Python Visual Studio Code : IDE per lo sviluppo di programmi in C/C++/Python Guida ufficiale all'installazione e configurazione di Visual Studio Community 2019 Guida ufficiale all'installazione e configurazione di Visual Studio Code Interprete Python","title":"Slides proiettate a lezione"},{"location":"00_materiale/programma/#materiale-del-corso","text":"Argomento Slides 00 - Introduzione al corso","title":"Materiale del corso"},{"location":"00_materiale/programma/#parte-1-teoria","text":"Argomento Slides 01 - Introduzione all'informatica 02 - Introduzione agli algoritmi 03 - Architettura dei calcolatori 04 - Reti di calcolatori 05 - Rappresentazione dei dati 06 - Linguaggi di programmazione 07 - Traduttori 08 - Variabili 09 - Programmazione strutturata 10 - Ricorsione 11 - Diagrammi di flusso 12 - Funzioni 13 - Strutture dati 14 - Complessit\u00e0 computazionale 15 - Algoritmi 1 - Ricerca su array 16 - Algoritmi 2 - Ordinamento 17 - Algoritmi 3 - Ricerca su grafi 18 - Macchina di Turing","title":"Parte 1: Teoria"},{"location":"00_materiale/programma/#parte-2-cenni-al-linguaggio-c","text":"Argomento Slides 19 - Hello, C! 20 - Alcune definizioni 21 - Visibilit\u00e0 di una variabile 22 - Operatori 23 - Array 24 - Puntatori 25 - I/O e file 26 - Typedef, Struct ed Union","title":"Parte 2: Cenni al linguaggio C"},{"location":"00_materiale/programma/#parte-3-cenni-al-linguaggio-c","text":"Argomento Slides 27 - Dal C al C++ 28 - Alcune definizioni (in C++!) 29 - Le classi (parte 1) 30 - Alcune definizioni (avanzate!) 31 - Le classi (parte 2) 32 - I metodi (alcuni cenni) 33 - Ereditariet\u00e0 34 - Container 35 - La gestione dei file in C++","title":"Parte 3: Cenni al linguaggio C++"},{"location":"00_materiale/programma/#parte-4-cenni-al-linguaggio-python","text":"Argomento Slides 36 - Introduzione al Python 37 - Programmare in Python","title":"Parte 4: Cenni al linguaggio Python"},{"location":"00_materiale/programma/#riferimenti-esterni","text":"","title":"Riferimenti esterni"},{"location":"00_materiale/programma/#testi-di-riferimento","text":"Nota Questi testi sono consigliati . Ci\u00f2 non implica che sia necessario seguirli in maniera pedissequa , ma che occorre intenderli come materiale da usare per motivi di approfondimento personale. Ci\u00f2 comporta due conseguenze: la prima \u00e8 che il corso non segue un testo di riferimento, quanto piuttosto le dispense e le slide proiettate a lezione; la seconda, pi\u00f9 rilevante per lo Studente, \u00e8 che per superare l'esame basta seguire queste ultime.","title":"Testi di riferimento"},{"location":"00_materiale/programma/#testi-integrativi-per-lapprofondimento-della-materia","text":"Questi testi possono essere considerati come una buona integrazione, da usare per approfondire gli argomenti trattati a lezione. Tanenbaum, Architettura dei calcolatori. Un approccio strutturale Tanenbaum, Reti di calcolatori Deitel, Deitel, C++. Fondamenti di programmazione","title":"Testi integrativi (per l'approfondimento della materia)"},{"location":"00_materiale/programma/#testi-online","text":"Questi testi sono da considerarsi al pari dei testi integrativi per l'approfondimento della materia, con la differenza che sono disponibili (liberamente) online. The Python Tutorial Python Data Science Handbook","title":"Testi online"},{"location":"00_materiale/programma/#testi-consigliati-per-la-data-science","text":"Questi testi sono da considerarsi come dei buoni approfondimenti qualora si decida di approfondire, magari in futuro, degli aspetti legati ai principi matematici ed informatici della data science. Goodfellow, Deep Learning G\u00e9ron, Hands-On Machine Learning with Scikit-Learn and Tensorflow: Concepts, Tools, and Techniques to Build Intelligent Systems","title":"Testi consigliati (per la data science)"},{"location":"00_materiale/programma/#esercizi-di-approfondimento","text":"Note Alcuni di questi esercizi fanno riferimento a materiale esterno al corso. Il Docente non \u00e8 responsabile per, n\u00e9 proprietario dei, contenuti presenti a questi link. Inoltre, questi esercizi non sono rappresentativi di tracce di esame, presenti, future o passate.","title":"Esercizi di approfondimento"},{"location":"00_materiale/programma/#diagrammi-di-flusso","text":"Esercizi Svolti su Coding Creativo","title":"Diagrammi di flusso"},{"location":"00_materiale/programma/#programmi-utili","text":"Visual Studio Community 2019 : IDE per lo sviluppo di programmi in C/C++/Python Visual Studio Code : IDE per lo sviluppo di programmi in C/C++/Python Guida ufficiale all'installazione e configurazione di Visual Studio Community 2019 Guida ufficiale all'installazione e configurazione di Visual Studio Code Interprete Python","title":"Programmi utili"},{"location":"01_esami/standard/esercizi/","text":"Esercizi per il corso \u00b6 Questi sono esempi degli esercizi la cui risoluzione potrebbe essere richiesta durante un appello. Parte teorica Si sottolinea che questi esercizi non sono rappresentativi delle domande (a risposta aperta) che verranno poste all'appello; queste ultime, infatti, riguarderanno gli aspetti prettamente teorici del corso. Esercizi ed appelli Questi esercizi sono simili , come difficolt\u00e0 ed impostazione, a quelli che saranno proposti durante un appello; ci\u00f2 implica che, ovviamente, gli esercizi da risolvere non saranno mai scelti tra questi. Esercizi per esame scritto \u00b6 Esercizio 1 \u00b6 Definire una funzione che accetti come parametro in ingresso due interi \\(a\\) e \\(b\\) e stampi a schermo in uscita un valore reale, in cui la parte intera \u00e8 pari ad \\(a\\) , e la parte decimale \u00e8 composta dalle stesse cifre di \\(b\\) . Si tronchi la parte decimale alla seconda cifra dopo la virgola. Ad esempio: \\(a = 8; b = 107; \\Rightarrow res = 8.10\\) E' possibile utilizzare C/C++ o Python. Suggerimento Per stampare a schermo soltanto le prime due cifre decimali, si utilizzi il format specifier %.2f in C/C++, e :.2f in Python. Risoluzione \u00b6 C/C++ void funzione ( int a , int b ) { float c = ( float ) a ; float d = ( float ) b ; while ( d > 1.0 ) { // Divido il valore di b fino a che la parte intera non \u00e8 minore di 1. d = d / 10 ; } c += d ; // Aggiungo c (parte reale) a d (parte decimale) printf ( \"%.2f\" , c ); // Stampo a schermo il risultato. } Python python def funzione(a: int, b: int): while b > 1.0: b = b / 10 a += b print(\"{:.2f}\".format(a)) Esercizio 2 \u00b6 Descrivere l'output delle seguenti funzioni Python. # Funzione A def funzione_a ( s : str ) -> str : print ( 'La stringa passata in ingresso \u00e8 {} \\n ' . format ( s )) s [ 0 ] = 'A' print ( 'La stringa modificata \u00e8 {} \\n ' . format ( s )) return s # Funzione B def funzione_b ( s : str ) -> str : print ( 'La stringa passata in ingresso \u00e8 {} \\n ' . format ( s )) s = 'A' print ( 'La stringa modificata \u00e8 {} \\n ' . format ( s )) return s Risoluzione \u00b6 La funzione A stamper\u00e0 a schermo la stringa passata in ingresso, per poi restituire un errore, in quanto una stringa non \u00e8 mutabile in Python, dunque l'istruzione s[0] = 'A' non \u00e8 valida. La funzione B stamper\u00f2 a schermo la stringa passata in ingresso, per poi stampare a schermo il nuovo valore assunto dalla stringa come variabile locale (ovvero A ). Nonostante questo, la stringa originaria non sar\u00e0 modificata, a meno che non si usi la seguente sintassi: >>> s = 'stringa' >>> s = funzione_b ( s ) Questo \u00e8 legato al fatto che Python gestisce il passaggio dei parametri per valore e non per reference. Esercizio 3 \u00b6 Definire una funzione C++ che aggiunga un elemento ad un vettore passato come argomento alla stessa. Si usi il container vector ed un iteratore. Risoluzione \u00b6 void append ( vector < int > & v , int el ) { v . insert ( v . end (), el ); } La funzione append() accetta un container di tipo vector , contenente a sua volta valori interi, ed un intero. Viene quindi usato un iteratore che punta al termine del container ( v.end() ), in abbinata al metodo insert , per aggiungere l'elemento in coda al vettore. Si noti come il passaggio avvenga per reference , e non per valore , in modo da non dover usare alcuna istruzione return ; la sintassi alternativa (con istruzione return ) sarebbe stata: vector < int > append_v ( vector < int > v , int el ) { v . insert ( v . end (), el ); return v ; } // Esempio di funzionamento int main () { vector < int > v = { 1 }; append ( v , 4 ); for ( vector < int >:: iterator it = v . begin (); it != v . end (); ++ it ) { cout << * it << endl ; } } Esercizi di programmazione \u00b6 Per questi esercizi, \u00e8 disponibile il codice, da usare come base per lo studio. Linguaggio C \u00b6 Esercizio 1: Matematicamente \u00b6 Creare il programma Matematicamente che contiene al suo interno due moduli: il modulo aritmetica , contenente le funzioni aggiungi e moltiplica ; il modulo trigonometria , contenente le funzioni seno e coseno . La descrizione delle funzioni \u00e8 la seguente: aggiungi restituisce la somma di due interi a e b ; moltiplica restituisce il prodotto di due interi a e b ; seno restituisce il seno di un angolo a partire dal suo coseno usando l'identit\u00e0 trigonometrica; coseno restituisce il coseno di un angolo a partire dal suo seno usando l'identit\u00e0 trigonometrica. Provare l'utilizzo dei due moduli. Codice fornito \u00b6 Modulo Link aritmetica.h aritmetica.c trigonometria.h trigonometria.c main.c Esercizio 2. AreaPerimetro \u00b6 Creare il programma AreaPerimetro , che include due funzioni: la funzione calcola_area_quadrato restituisce l'area di un quadrato dato il lato; la funzione calcola_perimetro_quadrato restituisce il perimetro di un quadrato dato il lato. Si verifichi cosa accade se si prova ad accedere al valore del perimetro all'interno della funzione calcola_area_quadrato , e viceversa. Si utilizzi una variabile globale per impostare il valore del lato. Si utilizzi una variabile locale, il cui nome \u00e8 lo stesso di quello associato alla variabile globale, per impostare il valore del lato. Suggerimento Per verificare il valore di area e perimetro, si utilizzi la funzione printf . Codice fornito \u00b6 Modulo Link main.c Esercizio 3. ContatoreStatico \u00b6 Creare il programma ContatoreStatico che include una funzione conta() che, ogni volta che viene chiamata, incrementa il valore numerico intero associato ad un contatore. Fare in modo che: la funzione conta() non accetti in ingresso alcun parametro; il contatore sia una variabile locale alla funzione conta() . Suggerimento Si utilizzi in maniera appropriata la parola chiave static . Codice fornito \u00b6 Modulo Link main.c Esercizio 4. Operandi \u00b6 Parte 1: Quadratico \u00b6 Scriviamo il programma Quadratico , che include una funzione che, dato un valore intero in ingresso, ne calcola il quadrato e lo restituisce. Il valore restituito dovr\u00e0 essere stampato a schermo all'interno della funzione main . Parte 2: Pari e Dispari \u00b6 Scriviamo il programma PariDispari che, dato un valore intero in ingresso, valuta se questo \u00e8 pari mediante un'apposita funzione. Detta funzione restituir\u00e0 un valore booleano in uscita; se questo \u00e8 vero ( true ), avviser\u00e0 l'utente che il numero \u00e8 pari, altrimenti avviser\u00e0 l'utente che il numero \u00e8 dispari. Suggerimento Utilizzare l'header stdbool.h per gestire i valori booleani. In alternativa, ricordare che ogni intero diverso da 0 \u00e8 considerato come un true . Parte 3: Confrontiamoci \u00b6 Scriviamo il programma Confrontiamoci , che confronta due intervalli di valori di tipo \\([a,b]\\) e \\([c,d]\\) con \\((a,b,c,d)\\) numeri interi. Scriviamo in primis una funzione confronto_relazionale che dovr\u00e0: stampare a schermo il maggiore tra gli estremi inferiori \\(a\\) e \\(c\\) ; stampare a schermo il minore tra gli estremi superiori \\(b\\) e \\(d\\) ; stabilire se il numero di elementi all'interno dei due insiemi \u00e8 lo stesso. Successivamente, scriviamo una funzione confronto_logico che dovr\u00e0 verificare, usando solo operatori di logica booleana, se gli intervalli sopraccitati hanno lo stesso numero di elementi e gli estremi degli stessi coincidono, oppure se una sola di queste condizioni \u00e8 verificata. Codice fornito \u00b6 Modulo Link main.c Esercizio 5. Array \u00b6 Un tensore \u00e8 un array ad \\(n\\) dimensioni contenente valori arbitrari. Creare due tensori di dimensioni \\(3 \\times 3 \\times 3\\) , uno contenente valori interi, e l'altro contenente valori in formato double . Usare l'operatore sizeof per confrontare lo spazio occupato in memoria, visualizzando a schermo tutti i valori dell'array pi\u00f9 \"pesante\". Codice fornito \u00b6 Modulo Link main.c Esercizio 6. Puntatori \u00b6 Codice fornito \u00b6 Modulo Link puntatori.h puntatori.c puntatori_funzione.h puntatori_funzione.c main.c Esercizio 7. Typedef \u00b6 Codice fornito \u00b6 Modulo Link main.c Esercizi in C++ \u00b6 Esercizio 1. Namespaces \u00b6 Codice fornito \u00b6 Modulo Link main.cpp Esercizio 2. Variabili reference \u00b6 Codice fornito \u00b6 Modulo Link main.cpp Esercizio 3. I/O in C++ \u00b6 Codice fornito \u00b6 Modulo Link main.cpp Esercizio 4. Classi \u00b6 Codice fornito \u00b6 Modulo Link contratti.cpp contratti.h persona.cpp persona.h main.cpp Esercizio 5. Funzioni avanzate \u00b6 Codice fornito \u00b6 Modulo Link main.cpp Esercizio 6. I/O su file \u00b6 Codice fornito \u00b6 Modulo Link main.cpp Esercizi in Python \u00b6 Esercizio 1. Liste come stack e code \u00b6 Codice fornito \u00b6 Modulo Link run.py Esercizio 2. List comprehension \u00b6 Codice fornito \u00b6 Modulo Link run.py Esercizio 3. Esercizi sui moduli \u00b6 Codice fornito \u00b6 Modulo Link run.py Esercizio 3. Esercizi sulle classi \u00b6 Codice fornito \u00b6 Modulo Link run.py","title":"Esercizi"},{"location":"01_esami/standard/esercizi/#esercizi-per-il-corso","text":"Questi sono esempi degli esercizi la cui risoluzione potrebbe essere richiesta durante un appello. Parte teorica Si sottolinea che questi esercizi non sono rappresentativi delle domande (a risposta aperta) che verranno poste all'appello; queste ultime, infatti, riguarderanno gli aspetti prettamente teorici del corso. Esercizi ed appelli Questi esercizi sono simili , come difficolt\u00e0 ed impostazione, a quelli che saranno proposti durante un appello; ci\u00f2 implica che, ovviamente, gli esercizi da risolvere non saranno mai scelti tra questi.","title":"Esercizi per il corso"},{"location":"01_esami/standard/esercizi/#esercizi-per-esame-scritto","text":"","title":"Esercizi per esame scritto"},{"location":"01_esami/standard/esercizi/#esercizio-1","text":"Definire una funzione che accetti come parametro in ingresso due interi \\(a\\) e \\(b\\) e stampi a schermo in uscita un valore reale, in cui la parte intera \u00e8 pari ad \\(a\\) , e la parte decimale \u00e8 composta dalle stesse cifre di \\(b\\) . Si tronchi la parte decimale alla seconda cifra dopo la virgola. Ad esempio: \\(a = 8; b = 107; \\Rightarrow res = 8.10\\) E' possibile utilizzare C/C++ o Python. Suggerimento Per stampare a schermo soltanto le prime due cifre decimali, si utilizzi il format specifier %.2f in C/C++, e :.2f in Python.","title":"Esercizio 1"},{"location":"01_esami/standard/esercizi/#risoluzione","text":"C/C++ void funzione ( int a , int b ) { float c = ( float ) a ; float d = ( float ) b ; while ( d > 1.0 ) { // Divido il valore di b fino a che la parte intera non \u00e8 minore di 1. d = d / 10 ; } c += d ; // Aggiungo c (parte reale) a d (parte decimale) printf ( \"%.2f\" , c ); // Stampo a schermo il risultato. } Python python def funzione(a: int, b: int): while b > 1.0: b = b / 10 a += b print(\"{:.2f}\".format(a))","title":"Risoluzione"},{"location":"01_esami/standard/esercizi/#esercizio-2","text":"Descrivere l'output delle seguenti funzioni Python. # Funzione A def funzione_a ( s : str ) -> str : print ( 'La stringa passata in ingresso \u00e8 {} \\n ' . format ( s )) s [ 0 ] = 'A' print ( 'La stringa modificata \u00e8 {} \\n ' . format ( s )) return s # Funzione B def funzione_b ( s : str ) -> str : print ( 'La stringa passata in ingresso \u00e8 {} \\n ' . format ( s )) s = 'A' print ( 'La stringa modificata \u00e8 {} \\n ' . format ( s )) return s","title":"Esercizio 2"},{"location":"01_esami/standard/esercizi/#risoluzione_1","text":"La funzione A stamper\u00e0 a schermo la stringa passata in ingresso, per poi restituire un errore, in quanto una stringa non \u00e8 mutabile in Python, dunque l'istruzione s[0] = 'A' non \u00e8 valida. La funzione B stamper\u00f2 a schermo la stringa passata in ingresso, per poi stampare a schermo il nuovo valore assunto dalla stringa come variabile locale (ovvero A ). Nonostante questo, la stringa originaria non sar\u00e0 modificata, a meno che non si usi la seguente sintassi: >>> s = 'stringa' >>> s = funzione_b ( s ) Questo \u00e8 legato al fatto che Python gestisce il passaggio dei parametri per valore e non per reference.","title":"Risoluzione"},{"location":"01_esami/standard/esercizi/#esercizio-3","text":"Definire una funzione C++ che aggiunga un elemento ad un vettore passato come argomento alla stessa. Si usi il container vector ed un iteratore.","title":"Esercizio 3"},{"location":"01_esami/standard/esercizi/#risoluzione_2","text":"void append ( vector < int > & v , int el ) { v . insert ( v . end (), el ); } La funzione append() accetta un container di tipo vector , contenente a sua volta valori interi, ed un intero. Viene quindi usato un iteratore che punta al termine del container ( v.end() ), in abbinata al metodo insert , per aggiungere l'elemento in coda al vettore. Si noti come il passaggio avvenga per reference , e non per valore , in modo da non dover usare alcuna istruzione return ; la sintassi alternativa (con istruzione return ) sarebbe stata: vector < int > append_v ( vector < int > v , int el ) { v . insert ( v . end (), el ); return v ; } // Esempio di funzionamento int main () { vector < int > v = { 1 }; append ( v , 4 ); for ( vector < int >:: iterator it = v . begin (); it != v . end (); ++ it ) { cout << * it << endl ; } }","title":"Risoluzione"},{"location":"01_esami/standard/esercizi/#esercizi-di-programmazione","text":"Per questi esercizi, \u00e8 disponibile il codice, da usare come base per lo studio.","title":"Esercizi di programmazione"},{"location":"01_esami/standard/esercizi/#linguaggio-c","text":"","title":"Linguaggio C"},{"location":"01_esami/standard/esercizi/#esercizio-1-matematicamente","text":"Creare il programma Matematicamente che contiene al suo interno due moduli: il modulo aritmetica , contenente le funzioni aggiungi e moltiplica ; il modulo trigonometria , contenente le funzioni seno e coseno . La descrizione delle funzioni \u00e8 la seguente: aggiungi restituisce la somma di due interi a e b ; moltiplica restituisce il prodotto di due interi a e b ; seno restituisce il seno di un angolo a partire dal suo coseno usando l'identit\u00e0 trigonometrica; coseno restituisce il coseno di un angolo a partire dal suo seno usando l'identit\u00e0 trigonometrica. Provare l'utilizzo dei due moduli.","title":"Esercizio 1: Matematicamente"},{"location":"01_esami/standard/esercizi/#codice-fornito","text":"Modulo Link aritmetica.h aritmetica.c trigonometria.h trigonometria.c main.c","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-2-areaperimetro","text":"Creare il programma AreaPerimetro , che include due funzioni: la funzione calcola_area_quadrato restituisce l'area di un quadrato dato il lato; la funzione calcola_perimetro_quadrato restituisce il perimetro di un quadrato dato il lato. Si verifichi cosa accade se si prova ad accedere al valore del perimetro all'interno della funzione calcola_area_quadrato , e viceversa. Si utilizzi una variabile globale per impostare il valore del lato. Si utilizzi una variabile locale, il cui nome \u00e8 lo stesso di quello associato alla variabile globale, per impostare il valore del lato. Suggerimento Per verificare il valore di area e perimetro, si utilizzi la funzione printf .","title":"Esercizio 2. AreaPerimetro"},{"location":"01_esami/standard/esercizi/#codice-fornito_1","text":"Modulo Link main.c","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-3-contatorestatico","text":"Creare il programma ContatoreStatico che include una funzione conta() che, ogni volta che viene chiamata, incrementa il valore numerico intero associato ad un contatore. Fare in modo che: la funzione conta() non accetti in ingresso alcun parametro; il contatore sia una variabile locale alla funzione conta() . Suggerimento Si utilizzi in maniera appropriata la parola chiave static .","title":"Esercizio 3. ContatoreStatico"},{"location":"01_esami/standard/esercizi/#codice-fornito_2","text":"Modulo Link main.c","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-4-operandi","text":"","title":"Esercizio 4. Operandi"},{"location":"01_esami/standard/esercizi/#parte-1-quadratico","text":"Scriviamo il programma Quadratico , che include una funzione che, dato un valore intero in ingresso, ne calcola il quadrato e lo restituisce. Il valore restituito dovr\u00e0 essere stampato a schermo all'interno della funzione main .","title":"Parte 1: Quadratico"},{"location":"01_esami/standard/esercizi/#parte-2-pari-e-dispari","text":"Scriviamo il programma PariDispari che, dato un valore intero in ingresso, valuta se questo \u00e8 pari mediante un'apposita funzione. Detta funzione restituir\u00e0 un valore booleano in uscita; se questo \u00e8 vero ( true ), avviser\u00e0 l'utente che il numero \u00e8 pari, altrimenti avviser\u00e0 l'utente che il numero \u00e8 dispari. Suggerimento Utilizzare l'header stdbool.h per gestire i valori booleani. In alternativa, ricordare che ogni intero diverso da 0 \u00e8 considerato come un true .","title":"Parte 2: Pari e Dispari"},{"location":"01_esami/standard/esercizi/#parte-3-confrontiamoci","text":"Scriviamo il programma Confrontiamoci , che confronta due intervalli di valori di tipo \\([a,b]\\) e \\([c,d]\\) con \\((a,b,c,d)\\) numeri interi. Scriviamo in primis una funzione confronto_relazionale che dovr\u00e0: stampare a schermo il maggiore tra gli estremi inferiori \\(a\\) e \\(c\\) ; stampare a schermo il minore tra gli estremi superiori \\(b\\) e \\(d\\) ; stabilire se il numero di elementi all'interno dei due insiemi \u00e8 lo stesso. Successivamente, scriviamo una funzione confronto_logico che dovr\u00e0 verificare, usando solo operatori di logica booleana, se gli intervalli sopraccitati hanno lo stesso numero di elementi e gli estremi degli stessi coincidono, oppure se una sola di queste condizioni \u00e8 verificata.","title":"Parte 3: Confrontiamoci"},{"location":"01_esami/standard/esercizi/#codice-fornito_3","text":"Modulo Link main.c","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-5-array","text":"Un tensore \u00e8 un array ad \\(n\\) dimensioni contenente valori arbitrari. Creare due tensori di dimensioni \\(3 \\times 3 \\times 3\\) , uno contenente valori interi, e l'altro contenente valori in formato double . Usare l'operatore sizeof per confrontare lo spazio occupato in memoria, visualizzando a schermo tutti i valori dell'array pi\u00f9 \"pesante\".","title":"Esercizio 5. Array"},{"location":"01_esami/standard/esercizi/#codice-fornito_4","text":"Modulo Link main.c","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-6-puntatori","text":"","title":"Esercizio 6. Puntatori"},{"location":"01_esami/standard/esercizi/#codice-fornito_5","text":"Modulo Link puntatori.h puntatori.c puntatori_funzione.h puntatori_funzione.c main.c","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-7-typedef","text":"","title":"Esercizio 7. Typedef"},{"location":"01_esami/standard/esercizi/#codice-fornito_6","text":"Modulo Link main.c","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizi-in-c","text":"","title":"Esercizi in C++"},{"location":"01_esami/standard/esercizi/#esercizio-1-namespaces","text":"","title":"Esercizio 1. Namespaces"},{"location":"01_esami/standard/esercizi/#codice-fornito_7","text":"Modulo Link main.cpp","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-2-variabili-reference","text":"","title":"Esercizio 2. Variabili reference"},{"location":"01_esami/standard/esercizi/#codice-fornito_8","text":"Modulo Link main.cpp","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-3-io-in-c","text":"","title":"Esercizio 3. I/O in C++"},{"location":"01_esami/standard/esercizi/#codice-fornito_9","text":"Modulo Link main.cpp","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-4-classi","text":"","title":"Esercizio 4. Classi"},{"location":"01_esami/standard/esercizi/#codice-fornito_10","text":"Modulo Link contratti.cpp contratti.h persona.cpp persona.h main.cpp","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-5-funzioni-avanzate","text":"","title":"Esercizio 5. Funzioni avanzate"},{"location":"01_esami/standard/esercizi/#codice-fornito_11","text":"Modulo Link main.cpp","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-6-io-su-file","text":"","title":"Esercizio 6. I/O su file"},{"location":"01_esami/standard/esercizi/#codice-fornito_12","text":"Modulo Link main.cpp","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizi-in-python","text":"","title":"Esercizi in Python"},{"location":"01_esami/standard/esercizi/#esercizio-1-liste-come-stack-e-code","text":"","title":"Esercizio 1. Liste come stack e code"},{"location":"01_esami/standard/esercizi/#codice-fornito_13","text":"Modulo Link run.py","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-2-list-comprehension","text":"","title":"Esercizio 2. List comprehension"},{"location":"01_esami/standard/esercizi/#codice-fornito_14","text":"Modulo Link run.py","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-3-esercizi-sui-moduli","text":"","title":"Esercizio 3. Esercizi sui moduli"},{"location":"01_esami/standard/esercizi/#codice-fornito_15","text":"Modulo Link run.py","title":"Codice fornito"},{"location":"01_esami/standard/esercizi/#esercizio-3-esercizi-sulle-classi","text":"","title":"Esercizio 3. Esercizi sulle classi"},{"location":"01_esami/standard/esercizi/#codice-fornito_16","text":"Modulo Link run.py","title":"Codice fornito"},{"location":"01_esami/standard/intro/","text":"Modalit\u00e0 Standard \u00b6 Prevede una prova scritta ed una prova orale . La prova scritta prevede tre \u2013 cinque domande sui diversi argomenti del corso. All\u2019interno della prova scritta possono esserci esercizi di programmazione da svolgersi direttamente sull\u2019elaborato . La prova scritta \u00e8 valutata in trentesimi. La prova orale \u00e8 obbligatoria se il risultato della prova scritta \u00e8 compreso tra 15 e 17 . Se il risultato della prova scritta \u00e8 maggiore o uguale a 18 , la prova orale \u00e8 a discrezione dello studente. Se il risultato della prova scritta \u00e8 minore o uguale a 14 , lo studente dovr\u00e0 ripetere la prova scritta a partire dall\u2019appello successivo. Studenti fuori corso \u00b6 Gli studenti fuori corso possono sostenere esclusivamente questa modalit\u00e0 di esame. I quesiti saranno opportunamente ritarati tenendo in considerazione i programmi degli anni precedenti. Nota Si raccomanda di prenotarsi per l'esame mediante le opportune modalit\u00e0 e di munirsi di documento di riconoscimento (carta di identit\u00e0). In caso contrario, non sar\u00e0 possibile sostenere l'esame. Date di appello \u00b6 Anno Accademico 2020/2021 \u00b6 Data Orario Aula 25/01/2021 15:00-16:30 Aula I 09/02/2021 09:00-10:30 Aula VI 25/02/2021 09:00-10:30 N.D. 20/04/2021 15:00-16:30 N.D. 25/06/2021 09:00-10:30 N.D. 12/07/2021 09:00-10:30 N.D. 29/07/2021 09:00-10:30 N.D. 01/09/2021 09:00-10:30 N.D. 20/09/2021 09:00-10:30 N.D. 17/11/2021 15:00-16:30 N.D. Tracce di appello (risolte) \u00b6 Data Traccia Risoluzione 25/01/2021 N.D. N.D. 09/02/2021 N.D. N.D. 25/02/2021 N.D. N.D. 20/04/2021 N.D. N.D. 25/06/2021 N.D. N.D. 12/07/2021 N.D. N.D. 29/07/2021 N.D. N.D. 01/09/2021 N.D. N.D. 20/09/2021 N.D. N.D. 17/11/2021 N.D. N.D. Prepararsi all'appello \u00b6 Per prepararsi a sostenere l'appello, \u00e8 necessario e sufficiente il materiale presente sul sito del corso, che \u00e8 da considerarsi comunque come integrativo e complementare rispetto alle lezioni frontali. Sono inoltre disponibili a questo indirizzo alcuni esercizi preparatori.","title":"Introduzione"},{"location":"01_esami/standard/intro/#modalita-standard","text":"Prevede una prova scritta ed una prova orale . La prova scritta prevede tre \u2013 cinque domande sui diversi argomenti del corso. All\u2019interno della prova scritta possono esserci esercizi di programmazione da svolgersi direttamente sull\u2019elaborato . La prova scritta \u00e8 valutata in trentesimi. La prova orale \u00e8 obbligatoria se il risultato della prova scritta \u00e8 compreso tra 15 e 17 . Se il risultato della prova scritta \u00e8 maggiore o uguale a 18 , la prova orale \u00e8 a discrezione dello studente. Se il risultato della prova scritta \u00e8 minore o uguale a 14 , lo studente dovr\u00e0 ripetere la prova scritta a partire dall\u2019appello successivo.","title":"Modalit\u00e0 Standard"},{"location":"01_esami/standard/intro/#studenti-fuori-corso","text":"Gli studenti fuori corso possono sostenere esclusivamente questa modalit\u00e0 di esame. I quesiti saranno opportunamente ritarati tenendo in considerazione i programmi degli anni precedenti. Nota Si raccomanda di prenotarsi per l'esame mediante le opportune modalit\u00e0 e di munirsi di documento di riconoscimento (carta di identit\u00e0). In caso contrario, non sar\u00e0 possibile sostenere l'esame.","title":"Studenti fuori corso"},{"location":"01_esami/standard/intro/#date-di-appello","text":"","title":"Date di appello"},{"location":"01_esami/standard/intro/#anno-accademico-20202021","text":"Data Orario Aula 25/01/2021 15:00-16:30 Aula I 09/02/2021 09:00-10:30 Aula VI 25/02/2021 09:00-10:30 N.D. 20/04/2021 15:00-16:30 N.D. 25/06/2021 09:00-10:30 N.D. 12/07/2021 09:00-10:30 N.D. 29/07/2021 09:00-10:30 N.D. 01/09/2021 09:00-10:30 N.D. 20/09/2021 09:00-10:30 N.D. 17/11/2021 15:00-16:30 N.D.","title":"Anno Accademico 2020/2021"},{"location":"01_esami/standard/intro/#tracce-di-appello-risolte","text":"Data Traccia Risoluzione 25/01/2021 N.D. N.D. 09/02/2021 N.D. N.D. 25/02/2021 N.D. N.D. 20/04/2021 N.D. N.D. 25/06/2021 N.D. N.D. 12/07/2021 N.D. N.D. 29/07/2021 N.D. N.D. 01/09/2021 N.D. N.D. 20/09/2021 N.D. N.D. 17/11/2021 N.D. N.D.","title":"Tracce di appello (risolte)"},{"location":"01_esami/standard/intro/#prepararsi-allappello","text":"Per prepararsi a sostenere l'appello, \u00e8 necessario e sufficiente il materiale presente sul sito del corso, che \u00e8 da considerarsi comunque come integrativo e complementare rispetto alle lezioni frontali. Sono inoltre disponibili a questo indirizzo alcuni esercizi preparatori.","title":"Prepararsi all'appello"},{"location":"01_esami/tema_anno/faq/","text":"FAQ \u00b6 Q : Mi \u00e8 stata assegnata la traccia XYZ. E' possibile richiedere un cambio di traccia? A : No, non \u00e8 possibile chiedere un cambio di traccia, n\u00e9 che la stessa venga modificata, a meno che non si verifichi che alcuni argomenti non siano oggettivamente alla portata di uno studente di Matematica del primo anno. Q : Ho notato delle imprecisioni nella traccia. Le segnalo? A : Assolutamente s\u00ec, \u00e8 possibile farlo secondo le modalit\u00e0 specificate nella sezione delle comunicazioni con il docente . Q : Ho notato che esistono delle condizioni che la traccia non tiene in considerazione. Posso trattarle nel corso del tema d'anno? A : Assolutamente s\u00ec; trattare condizioni non previste dalla traccia in maniera corretta permette una migliore valutazione complessiva dell'esame. Q: Come consegno il tema d'anno? A: Consultare le modalit\u00e0 specificate nella sezione delle comunicazioni con il docente . Q: Posso chiedere chiarimenti sulla traccia? A: Assolutamente s\u00ec. Ricevere un chiarimento ed un esempio di funzionamento \u00e8 pieno diritto dello studente. E' possibile farlo secondo le modalit\u00e0 specificate nella sezione delle comunicazioni con il docente . Q: Posso usare funzioni non trattate a lezione? A: Assolutamente s\u00ec, tenendo presente che se si usano funzioni presenti nelle librerie standard dei diversi linguaggi non saranno eseguiti ulteriori controlli. Tuttavia, qualora si utilizzino librerie terze, sar\u00e0 verificata l'attendibilit\u00e0 delle suddette. Q: Per quello che riguarda lo pseudocodice, \u00e8 un problema se \"assomiglia\" troppo al codice finale? A: Assolutamente no. Q: Posso copiare il codice da fonti esterne? A: A meno che non sia codice esplicitamente fornito dal docente, non \u00e8 possibile copiare \"as-is\" il codice da fonti esterne. E' comunque possibile usarlo come base per il proprio elaborato; potrebbe per\u00f2 essere necessaria una verifica per stabilire l'esatta comprensione del codice da parte dello studente.","title":"FAQ"},{"location":"01_esami/tema_anno/faq/#faq","text":"Q : Mi \u00e8 stata assegnata la traccia XYZ. E' possibile richiedere un cambio di traccia? A : No, non \u00e8 possibile chiedere un cambio di traccia, n\u00e9 che la stessa venga modificata, a meno che non si verifichi che alcuni argomenti non siano oggettivamente alla portata di uno studente di Matematica del primo anno. Q : Ho notato delle imprecisioni nella traccia. Le segnalo? A : Assolutamente s\u00ec, \u00e8 possibile farlo secondo le modalit\u00e0 specificate nella sezione delle comunicazioni con il docente . Q : Ho notato che esistono delle condizioni che la traccia non tiene in considerazione. Posso trattarle nel corso del tema d'anno? A : Assolutamente s\u00ec; trattare condizioni non previste dalla traccia in maniera corretta permette una migliore valutazione complessiva dell'esame. Q: Come consegno il tema d'anno? A: Consultare le modalit\u00e0 specificate nella sezione delle comunicazioni con il docente . Q: Posso chiedere chiarimenti sulla traccia? A: Assolutamente s\u00ec. Ricevere un chiarimento ed un esempio di funzionamento \u00e8 pieno diritto dello studente. E' possibile farlo secondo le modalit\u00e0 specificate nella sezione delle comunicazioni con il docente . Q: Posso usare funzioni non trattate a lezione? A: Assolutamente s\u00ec, tenendo presente che se si usano funzioni presenti nelle librerie standard dei diversi linguaggi non saranno eseguiti ulteriori controlli. Tuttavia, qualora si utilizzino librerie terze, sar\u00e0 verificata l'attendibilit\u00e0 delle suddette. Q: Per quello che riguarda lo pseudocodice, \u00e8 un problema se \"assomiglia\" troppo al codice finale? A: Assolutamente no. Q: Posso copiare il codice da fonti esterne? A: A meno che non sia codice esplicitamente fornito dal docente, non \u00e8 possibile copiare \"as-is\" il codice da fonti esterne. E' comunque possibile usarlo come base per il proprio elaborato; potrebbe per\u00f2 essere necessaria una verifica per stabilire l'esatta comprensione del codice da parte dello studente.","title":"FAQ"},{"location":"01_esami/tema_anno/intro/","text":"Tema d'anno \u00b6 Cosa \u00e8 il tema d'anno? \u00b6 Durante il corso, gli studenti potranno decidere, in maniera autonoma o in gruppo composto al massimo da due componenti, di svolgere un tema d\u2019anno, articolato in quattro parti, valido per l\u2019esonero dalle prove scritta ed orale. Per accedere a questa modalit\u00e0, i gruppi/studenti dovranno essere comunicati al docente entro il termine massimo (improrogabile) stabilito dal docente via email all\u2019indirizzo angelo.cardellicchio@uniba.it . I temi d\u2019anno, in base al numero di gruppi/studenti, verranno proposti dal docente a partire dalla settimana successiva al termine di cui sopra . E' fortemente consigliata la partecipazione in gruppi di due studenti . Assegnazione dei temi \u00b6 Ciascun gruppo/studente dovr\u00e0 comunicare all\u2019email del docente quattro preferenze tra i temi proposti. Il primo tema indicato sar\u00e0 la prima scelta, il secondo tema indicato sar\u00e0 la seconda scelta, e cos\u00ec via fino all'ultima scelta . Si cercher\u00e0 in ogni caso di assegnare ad ogni gruppo la prima scelta, ripiegando eventualmente sulla seconda, poi sulla terza, ed infine sulla quarta. In caso di pi\u00f9 preferenze da diversi gruppi/studenti sullo stesso tema, quest\u2019ultimo sar\u00e0 assegnato secondo un criterio strettamente cronologico di arrivo della richiesta. Ad esempio: a. Tizio esprime preferenza il 17/11/2020 alle 08:35 per i Temi A (prima scelta), B (seconda scelta), C (terza scelta) ed E (quarta scelta). b. Caio esprime preferenza il 17/11/2020 alle 08:40 per i temi A (prima scelta), C (seconda scelta), D (terza scelta) ed F (quarta scelta). c. Sempronio esprime preferenza il 17/11/2020 alle ore 08:30 per i temi B (prima scelta), A (seconda scelta), E (terza scelta) e G (quarta scelta). d. A Tizio sar\u00e0 assegnato il Tema A, a Caio il tema C, a Sempronio il tema B. La scelta dei temi sar\u00e0 articolata in due round . Alla scadenza ( improrogabile ) del primo round, tutti i gruppi dovranno comunicare le prime quattro preferenze, che saranno assegnate come specificato ai punti 2 e 3. L'esito della prima assegnazione sar\u00e0 verificato e comunicato agli studenti entro due giorni dalla scadenza di cui sopra. I gruppi cui non dovesse essere stato possibile assegnare il tema d'anno al primo round, potranno partecipare al secondo, che si articoler\u00e0 secondo modalit\u00e0 analoghe al primo ma con un insieme di temi ridotto , dato dalle tracce non assegnate al primo turno. I gruppi cui non sar\u00e0 stato possibile assegnare un tema d'anno riceveranno una traccia di ufficio tra quelle proposte . Richiesta chiarimenti e/o altre comunicazioni \u00b6 Le comunicazioni avverranno esclusivamente a mezzo mail istituzionale con il referente di ciascun gruppo, secondo le modalit\u00e0 specificate nella sezione relativa alle comunicazioni con il docente . Modalit\u00e0 di consegna \u00b6 Tutte le parti del tema d'anno andranno consegnate a mezzo mail istituzionale . Le modalit\u00e0 di consegna sono specificate nella sezione relativa alle comunicazioni con il docente .","title":"Introduzione"},{"location":"01_esami/tema_anno/intro/#tema-danno","text":"","title":"Tema d'anno"},{"location":"01_esami/tema_anno/intro/#cosa-e-il-tema-danno","text":"Durante il corso, gli studenti potranno decidere, in maniera autonoma o in gruppo composto al massimo da due componenti, di svolgere un tema d\u2019anno, articolato in quattro parti, valido per l\u2019esonero dalle prove scritta ed orale. Per accedere a questa modalit\u00e0, i gruppi/studenti dovranno essere comunicati al docente entro il termine massimo (improrogabile) stabilito dal docente via email all\u2019indirizzo angelo.cardellicchio@uniba.it . I temi d\u2019anno, in base al numero di gruppi/studenti, verranno proposti dal docente a partire dalla settimana successiva al termine di cui sopra . E' fortemente consigliata la partecipazione in gruppi di due studenti .","title":"Cosa \u00e8 il tema d'anno?"},{"location":"01_esami/tema_anno/intro/#assegnazione-dei-temi","text":"Ciascun gruppo/studente dovr\u00e0 comunicare all\u2019email del docente quattro preferenze tra i temi proposti. Il primo tema indicato sar\u00e0 la prima scelta, il secondo tema indicato sar\u00e0 la seconda scelta, e cos\u00ec via fino all'ultima scelta . Si cercher\u00e0 in ogni caso di assegnare ad ogni gruppo la prima scelta, ripiegando eventualmente sulla seconda, poi sulla terza, ed infine sulla quarta. In caso di pi\u00f9 preferenze da diversi gruppi/studenti sullo stesso tema, quest\u2019ultimo sar\u00e0 assegnato secondo un criterio strettamente cronologico di arrivo della richiesta. Ad esempio: a. Tizio esprime preferenza il 17/11/2020 alle 08:35 per i Temi A (prima scelta), B (seconda scelta), C (terza scelta) ed E (quarta scelta). b. Caio esprime preferenza il 17/11/2020 alle 08:40 per i temi A (prima scelta), C (seconda scelta), D (terza scelta) ed F (quarta scelta). c. Sempronio esprime preferenza il 17/11/2020 alle ore 08:30 per i temi B (prima scelta), A (seconda scelta), E (terza scelta) e G (quarta scelta). d. A Tizio sar\u00e0 assegnato il Tema A, a Caio il tema C, a Sempronio il tema B. La scelta dei temi sar\u00e0 articolata in due round . Alla scadenza ( improrogabile ) del primo round, tutti i gruppi dovranno comunicare le prime quattro preferenze, che saranno assegnate come specificato ai punti 2 e 3. L'esito della prima assegnazione sar\u00e0 verificato e comunicato agli studenti entro due giorni dalla scadenza di cui sopra. I gruppi cui non dovesse essere stato possibile assegnare il tema d'anno al primo round, potranno partecipare al secondo, che si articoler\u00e0 secondo modalit\u00e0 analoghe al primo ma con un insieme di temi ridotto , dato dalle tracce non assegnate al primo turno. I gruppi cui non sar\u00e0 stato possibile assegnare un tema d'anno riceveranno una traccia di ufficio tra quelle proposte .","title":"Assegnazione dei temi"},{"location":"01_esami/tema_anno/intro/#richiesta-chiarimenti-eo-altre-comunicazioni","text":"Le comunicazioni avverranno esclusivamente a mezzo mail istituzionale con il referente di ciascun gruppo, secondo le modalit\u00e0 specificate nella sezione relativa alle comunicazioni con il docente .","title":"Richiesta chiarimenti e/o altre comunicazioni"},{"location":"01_esami/tema_anno/intro/#modalita-di-consegna","text":"Tutte le parti del tema d'anno andranno consegnate a mezzo mail istituzionale . Le modalit\u00e0 di consegna sono specificate nella sezione relativa alle comunicazioni con il docente .","title":"Modalit\u00e0 di consegna"},{"location":"01_esami/tema_anno/valutazione/","text":"Criteri di valutazione del tema d'anno \u00b6 Le quattro differenti parti in cui \u00e8 strutturato il tema d'anno saranno valutate come segue. Parte Prima - Analisi del problema \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Descrizione del problema ...analisi e spiegazione dell'approccio usato 0 - 10 punti Individuazione di input ed output ...interpretazione degli input e comunicazione dei risultati i risultati 0 - 4 punti Diagramma di flusso e pseudocodice ...strutturazione della risoluzione del problema 0 - 10 punti Analisi computazionale a priori ...stima del costo di esecuzione dell'algoritmo 0 - 6 punti Parte Seconda - Implementazione in linguaggio C \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Parte Terza - Implementazione in linguaggio C++ \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C++ 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Parte Quarta - Implementazione in linguaggio Python \u00b6 Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio Python 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Il risultato finale sar\u00e0 dato dalla media delle valutazioni ottenute nelle quattro parti. Quantificazione punteggio parametri di valutazione \u00b6 Malus \u00b6 I seguenti malus possono essere applicati ai topic in parte oggettivamente valutabili. Parametro Topic di riferimento Descrizione Punteggio Programma non funzionante Correttezza del programma Problema legato al funzionamento del programma, riprodotto secondo le modalit\u00e0 descritte nella documentazione annessa. Da -5 a -18 punti a seconda dell'entit\u00e0 dei problemi rilevati. Bug Correttezza del programma Bug che compromette, pi\u00f9 o meno seriamente, il funzionamento del programma (che resta comunque fruibile). Da -1 a -4 per bug, a seconda della gravit\u00e0 dello stesso. Feature subottima Correttezza del programma Feature implementata in maniera incompleta, subottima o ridondante, ma senza bug apparenti. Da -1 a -2, a seconda dell'entit\u00e0 dei problemi rilevati. Feature mancante Correttezza del programma Feature richiesta ma non implementatata. Da -1 a -2, a seconda dell'entit\u00e0 dei problemi rilevati. Documentazione incompleta Documentazione del programma Documentazione totalmente o parzialmente assente. Da -1 a -4 punti a seconda della parte di documentazione mancante. Tutti i topic di riferimento non riportati si intendono valutati in maniera discrezionale in base a fattori maggiormente astratti quali presentazione, adesione ai canoni illustrati durante il corso, coerenza, capacit\u00e0 di risoluzione del problema, etc. Impatto del malus Si noti che questi malus vanno ad incidere esclusivamente per le parti di loro pertinenza : ci\u00f2 significa che, ad esempio, consegnando un codice perfettamente funzionante, ma nessuna documentazione, il malus legato alla documentazione non andr\u00e0 ad intaccare la valutazione ricevuta sul codice. Bonus \u00b6 I seguenti bonus sono applicati nella valutazione complessiva degli esoneri. Parametro Punteggio Numero di membri del gruppo +1 per gruppi con un singolo membro. Difficolt\u00e0 traccia 0/+2 in base alla difficolt\u00e0 della traccia. Nota I precedenti bonus non concorrono all'acquisizione della sufficienza o della lode. Nota sulla correzione del codice Le verifiche della seconda, terza e quarta parte del tema d'anno prevedono prevalentemente il test di funzionamento del programma, con conseguente evidenziazione di eventuali bug o feature mancanti, che vanno a concorrere alla valutazione secondo le modalit\u00e0 esplicitate sul sito del corso. Una verifica stretta del codice non sar\u00e0 effettuata, se non in situazioni eccezionali ed individuate discrezionalmente. Voto finale e verbalizzazione \u00b6 Al termine delle quattro prove, sar\u00e0 assegnato a ciascun gruppo un voto parziale, assieme ad una scheda di valutazione (strettamente personale). Tale voto sar\u00e0 dato dalla media dei voti ottenuti nelle quattro prove. Gli studenti che intendessero verbalizzarlo, dovranno iscriversi ad una tra le date d'appello successive mediante le modalit\u00e0 standard riportate da Esse3. Il giorno dell'appello, gli studenti potranno: accettare il voto degli esoneri; richiedere una valutazione orale integrativa. La valutazione orale integrativa \u00e8 strettamente personale : ci\u00f2 significa i membri di un gruppo dovranno necessariamente richiederla (e sottoporvisi) separatamente. Le modalit\u00e0 e le date per l'orale saranno stabilite di volta in volta in base a richieste pervenute e disponibilit\u00e0 del docente. Si noti che la valutazione orale integrativa per il tema d'anno potr\u00e0 far oscillare il voto di un massimo di tre punti , sia in positivo, sia in negativo . Conseguimento della lode \u00b6 In casi eccezionali, \u00e8 possibile assegnare la lode agli studenti meritevoli. Per ottenerla, sar\u00e0 necessario sottoporsi alla valutazione orale integrativa secondo le modalit\u00e0 prima indicate.","title":"Valutazione"},{"location":"01_esami/tema_anno/valutazione/#criteri-di-valutazione-del-tema-danno","text":"Le quattro differenti parti in cui \u00e8 strutturato il tema d'anno saranno valutate come segue.","title":"Criteri di valutazione del tema d'anno"},{"location":"01_esami/tema_anno/valutazione/#parte-prima-analisi-del-problema","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Descrizione del problema ...analisi e spiegazione dell'approccio usato 0 - 10 punti Individuazione di input ed output ...interpretazione degli input e comunicazione dei risultati i risultati 0 - 4 punti Diagramma di flusso e pseudocodice ...strutturazione della risoluzione del problema 0 - 10 punti Analisi computazionale a priori ...stima del costo di esecuzione dell'algoritmo 0 - 6 punti","title":"Parte Prima - Analisi del problema"},{"location":"01_esami/tema_anno/valutazione/#parte-seconda-implementazione-in-linguaggio-c","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti","title":"Parte Seconda - Implementazione in linguaggio C"},{"location":"01_esami/tema_anno/valutazione/#parte-terza-implementazione-in-linguaggio-c","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio C++ 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti","title":"Parte Terza - Implementazione in linguaggio C++"},{"location":"01_esami/tema_anno/valutazione/#parte-quarta-implementazione-in-linguaggio-python","text":"Topic Valutazione della capacit\u00e0 di... Punteggio Correttezza del programma ...utilizzo delle tecniche di programmazione 0 - 18 punti Documentazione del programma ...esposizione delle funzioni e dell'uso del programma ad utenti terzi 0 - 4 punti Stile (commenti, modularit\u00e0, etc.) ...adesione alle best practices considerate per il linguaggio Python 0 - 4 punti Coerenza con flow chart e pseudocodice ...implementazione a partire da un dato documento di design 0 - 4 punti Il risultato finale sar\u00e0 dato dalla media delle valutazioni ottenute nelle quattro parti.","title":"Parte Quarta - Implementazione in linguaggio Python"},{"location":"01_esami/tema_anno/valutazione/#quantificazione-punteggio-parametri-di-valutazione","text":"","title":"Quantificazione punteggio parametri di valutazione"},{"location":"01_esami/tema_anno/valutazione/#malus","text":"I seguenti malus possono essere applicati ai topic in parte oggettivamente valutabili. Parametro Topic di riferimento Descrizione Punteggio Programma non funzionante Correttezza del programma Problema legato al funzionamento del programma, riprodotto secondo le modalit\u00e0 descritte nella documentazione annessa. Da -5 a -18 punti a seconda dell'entit\u00e0 dei problemi rilevati. Bug Correttezza del programma Bug che compromette, pi\u00f9 o meno seriamente, il funzionamento del programma (che resta comunque fruibile). Da -1 a -4 per bug, a seconda della gravit\u00e0 dello stesso. Feature subottima Correttezza del programma Feature implementata in maniera incompleta, subottima o ridondante, ma senza bug apparenti. Da -1 a -2, a seconda dell'entit\u00e0 dei problemi rilevati. Feature mancante Correttezza del programma Feature richiesta ma non implementatata. Da -1 a -2, a seconda dell'entit\u00e0 dei problemi rilevati. Documentazione incompleta Documentazione del programma Documentazione totalmente o parzialmente assente. Da -1 a -4 punti a seconda della parte di documentazione mancante. Tutti i topic di riferimento non riportati si intendono valutati in maniera discrezionale in base a fattori maggiormente astratti quali presentazione, adesione ai canoni illustrati durante il corso, coerenza, capacit\u00e0 di risoluzione del problema, etc. Impatto del malus Si noti che questi malus vanno ad incidere esclusivamente per le parti di loro pertinenza : ci\u00f2 significa che, ad esempio, consegnando un codice perfettamente funzionante, ma nessuna documentazione, il malus legato alla documentazione non andr\u00e0 ad intaccare la valutazione ricevuta sul codice.","title":"Malus"},{"location":"01_esami/tema_anno/valutazione/#bonus","text":"I seguenti bonus sono applicati nella valutazione complessiva degli esoneri. Parametro Punteggio Numero di membri del gruppo +1 per gruppi con un singolo membro. Difficolt\u00e0 traccia 0/+2 in base alla difficolt\u00e0 della traccia. Nota I precedenti bonus non concorrono all'acquisizione della sufficienza o della lode. Nota sulla correzione del codice Le verifiche della seconda, terza e quarta parte del tema d'anno prevedono prevalentemente il test di funzionamento del programma, con conseguente evidenziazione di eventuali bug o feature mancanti, che vanno a concorrere alla valutazione secondo le modalit\u00e0 esplicitate sul sito del corso. Una verifica stretta del codice non sar\u00e0 effettuata, se non in situazioni eccezionali ed individuate discrezionalmente.","title":"Bonus"},{"location":"01_esami/tema_anno/valutazione/#voto-finale-e-verbalizzazione","text":"Al termine delle quattro prove, sar\u00e0 assegnato a ciascun gruppo un voto parziale, assieme ad una scheda di valutazione (strettamente personale). Tale voto sar\u00e0 dato dalla media dei voti ottenuti nelle quattro prove. Gli studenti che intendessero verbalizzarlo, dovranno iscriversi ad una tra le date d'appello successive mediante le modalit\u00e0 standard riportate da Esse3. Il giorno dell'appello, gli studenti potranno: accettare il voto degli esoneri; richiedere una valutazione orale integrativa. La valutazione orale integrativa \u00e8 strettamente personale : ci\u00f2 significa i membri di un gruppo dovranno necessariamente richiederla (e sottoporvisi) separatamente. Le modalit\u00e0 e le date per l'orale saranno stabilite di volta in volta in base a richieste pervenute e disponibilit\u00e0 del docente. Si noti che la valutazione orale integrativa per il tema d'anno potr\u00e0 far oscillare il voto di un massimo di tre punti , sia in positivo, sia in negativo .","title":"Voto finale e verbalizzazione"},{"location":"01_esami/tema_anno/valutazione/#conseguimento-della-lode","text":"In casi eccezionali, \u00e8 possibile assegnare la lode agli studenti meritevoli. Per ottenerla, sar\u00e0 necessario sottoporsi alla valutazione orale integrativa secondo le modalit\u00e0 prima indicate.","title":"Conseguimento della lode"},{"location":"01_esami/tema_anno/2020-2021/chiarimenti/","text":"Chiarimenti tracce \u00b6 Di seguito, i chiarimenti richiesti su alcune delle tracce prima della loro assegnazione . Traccia 34 \u00b6 Il programma richiede in output tutte le coppie di indici \\((i, j)\\) di un vettore \\(n\\) tali per cui i risulta essere minore di \\(j\\) , mentre \\(n[i]\\) \u00e8 maggiore di \\(2 * n[j]\\) . Ad esempio, consideriamo un vettore del tipo: \\[ n = [10 2 1 1] \\] Consideriamo la coppia di indici \\((0, 2)\\) , ovvero gli indici che puntano al primo e terzo elemento del vettore. In questo caso, \\(i\\) \u00e8 sicuramente inferiore a \\(j\\) . Inoltre, \\(n[i]\\) , ovvero l'elemento di \\(n\\) che corrisponde all'indice \\(0\\) , e quindi \\(10\\) , \u00e8 maggiore del doppio di \\(n[j]\\) , ovvero l'elemento di \\(n\\) che corrisponde all'indice 2, e quindi 1. Il controllo va effettuato su tutte le possibili coppie \\((i,j)\\) , ovviamente non considerando quelle coppie per le quali \\(i\\) \u00e8 uguale a \\(j\\) . Traccia 47 \u00b6 L\u2019espressione mostrata nella traccia \u00e8 riassumibile come segue: Dato un valore \\(d\\) , calcolare il massimo tra gli elementi \\(a_j\\) che vanno nell\u2019intervallo che varia tra \\(i\\) ed \\(i + d\\) Questo va reiterato per tutti gli i che vanno da 0 ad \\(n \u2013 d\\) Del risultato della 2, calcolare il minimo Il focus principale non \u00e8 sul calcolo del minimo (quelli in uscita dalla 3 saranno infatti dei minimi \u201crelativi\u201d), ma sull\u2019approccio (evidentemente iterativo) da utilizzare.","title":"Chiarimenti"},{"location":"01_esami/tema_anno/2020-2021/chiarimenti/#chiarimenti-tracce","text":"Di seguito, i chiarimenti richiesti su alcune delle tracce prima della loro assegnazione .","title":"Chiarimenti tracce"},{"location":"01_esami/tema_anno/2020-2021/chiarimenti/#traccia-34","text":"Il programma richiede in output tutte le coppie di indici \\((i, j)\\) di un vettore \\(n\\) tali per cui i risulta essere minore di \\(j\\) , mentre \\(n[i]\\) \u00e8 maggiore di \\(2 * n[j]\\) . Ad esempio, consideriamo un vettore del tipo: \\[ n = [10 2 1 1] \\] Consideriamo la coppia di indici \\((0, 2)\\) , ovvero gli indici che puntano al primo e terzo elemento del vettore. In questo caso, \\(i\\) \u00e8 sicuramente inferiore a \\(j\\) . Inoltre, \\(n[i]\\) , ovvero l'elemento di \\(n\\) che corrisponde all'indice \\(0\\) , e quindi \\(10\\) , \u00e8 maggiore del doppio di \\(n[j]\\) , ovvero l'elemento di \\(n\\) che corrisponde all'indice 2, e quindi 1. Il controllo va effettuato su tutte le possibili coppie \\((i,j)\\) , ovviamente non considerando quelle coppie per le quali \\(i\\) \u00e8 uguale a \\(j\\) .","title":"Traccia 34"},{"location":"01_esami/tema_anno/2020-2021/chiarimenti/#traccia-47","text":"L\u2019espressione mostrata nella traccia \u00e8 riassumibile come segue: Dato un valore \\(d\\) , calcolare il massimo tra gli elementi \\(a_j\\) che vanno nell\u2019intervallo che varia tra \\(i\\) ed \\(i + d\\) Questo va reiterato per tutti gli i che vanno da 0 ad \\(n \u2013 d\\) Del risultato della 2, calcolare il minimo Il focus principale non \u00e8 sul calcolo del minimo (quelli in uscita dalla 3 saranno infatti dei minimi \u201crelativi\u201d), ma sull\u2019approccio (evidentemente iterativo) da utilizzare.","title":"Traccia 47"},{"location":"01_esami/tema_anno/2020-2021/date/","text":"Tabella date rilevanti Tema d'anno - A.A. 2020/2021 \u00b6 Per tutte le date rilevanti, consultare la tabella successiva. Data Evento Scaduto 09 novembre 2020 Termine adesioni esoneri 16 novembre 2020 Proposta temi d'anno 22 novembre 2020 Termine primo round assegnazioni 24 novembre 2020 Comunicazione esito primo round 27 novembre 2020 Termine secondo round assegnazioni 29 novembre 2020 Comunicazione esito secondo round 04 dicembre 2020 Consegna prima parte del tema d'anno (gruppi primo round) 10 dicembre 2020 Consegna prima parte del tema d'anno (gruppi secondo round) 23 dicembre 2020 Comunicazione esiti prima parte del tema d'anno (tutti i gruppi) 30 dicembre 2020 Consegna seconda parte del tema d'anno (tutti i gruppi) 07 gennaio 2021 Comunicazione esiti seconda parte tema d'anno (tutti i gruppi) 18 gennaio 2021 Consegna terza parte tema d'anno (tutti i gruppi) 25 gennaio 2021 Comunicazione esiti terza parte del tema d'anno (tutti i gruppi) 03 febbraio 2021 Consegna quarta parte tema d'anno (tutti i gruppi) 08 febbraio 2021 Comunicazione esiti quarta parte del tema d'anno (tutti i gruppi) Post Scriptum Il mancato rispetto delle date indicate prevede l\u2019esclusione automatica dalla modalit\u00e0 a tema d\u2019anno.","title":"Date rilevanti"},{"location":"01_esami/tema_anno/2020-2021/date/#tabella-date-rilevanti-tema-danno-aa-20202021","text":"Per tutte le date rilevanti, consultare la tabella successiva. Data Evento Scaduto 09 novembre 2020 Termine adesioni esoneri 16 novembre 2020 Proposta temi d'anno 22 novembre 2020 Termine primo round assegnazioni 24 novembre 2020 Comunicazione esito primo round 27 novembre 2020 Termine secondo round assegnazioni 29 novembre 2020 Comunicazione esito secondo round 04 dicembre 2020 Consegna prima parte del tema d'anno (gruppi primo round) 10 dicembre 2020 Consegna prima parte del tema d'anno (gruppi secondo round) 23 dicembre 2020 Comunicazione esiti prima parte del tema d'anno (tutti i gruppi) 30 dicembre 2020 Consegna seconda parte del tema d'anno (tutti i gruppi) 07 gennaio 2021 Comunicazione esiti seconda parte tema d'anno (tutti i gruppi) 18 gennaio 2021 Consegna terza parte tema d'anno (tutti i gruppi) 25 gennaio 2021 Comunicazione esiti terza parte del tema d'anno (tutti i gruppi) 03 febbraio 2021 Consegna quarta parte tema d'anno (tutti i gruppi) 08 febbraio 2021 Comunicazione esiti quarta parte del tema d'anno (tutti i gruppi) Post Scriptum Il mancato rispetto delle date indicate prevede l\u2019esclusione automatica dalla modalit\u00e0 a tema d\u2019anno.","title":"Tabella date rilevanti Tema d'anno - A.A. 2020/2021"},{"location":"01_esami/tema_anno/2020-2021/documenti/","text":"Documenti rilevanti Tema d'Anno - A.A. 2020/2021 \u00b6 Sono disponibili per la consultazione i seguenti documenti. Descrizione Link Elenco tracce Esito primo turno di assegnazione Esito secondo turno di assegnazione Gruppi e tracce assegnate Esiti prima prova Esiti seconda prova Esiti terza prova Esiti quarta prova","title":"Documenti"},{"location":"01_esami/tema_anno/2020-2021/documenti/#documenti-rilevanti-tema-danno-aa-20202021","text":"Sono disponibili per la consultazione i seguenti documenti. Descrizione Link Elenco tracce Esito primo turno di assegnazione Esito secondo turno di assegnazione Gruppi e tracce assegnate Esiti prima prova Esiti seconda prova Esiti terza prova Esiti quarta prova","title":"Documenti rilevanti Tema d'Anno - A.A. 2020/2021"},{"location":"01_esami/tema_anno/esempio/parte_prima/","text":"Descrizione del problema \u00b6 Il problema concerne l'utilizzo della tecnica di selection sort per ordinare un vettore ad \\(n\\) elementi. Il selection sort \u00e8 un algoritmo base per l'ordinamento del vettore; pu\u00f2 essere applicato, ad esempio, per ordinare come segue il vettore \\([1,4,2,3]\\) : \\[ [1, 4, 2, 3] \\Rightarrow [1, 2, 4, 3] \\Rightarrow [1, 2, 3, 4] \\] Il selection sort opera suddividendo l'array in una sequenza ordinata (a sinistra) ed in una non ordinata; essendo un approccio iterativo, ad ogni iterazione viene sostituito l'elemento pi\u00f9 a destra della sequenza ordinata con il minore tra quelli nella sequenza ordinata. Sar\u00e0 quindi necessario usare un approccio iterativo come indicato nella sezione Diagramma di flusso e pseudocodice . Individuazione di input ed output \u00b6 Input: \u00e8 richiesto all'utente di inserire un vettore in input ad \\(n\\) elementi. Questo potr\u00e0 essere inserito in maniera ricorsiva (ad esempio, chiedendo all'utente di inserire un elemento alla volta da riga di comando), oppure chiedendo all'utente di inserire una stringa ed interpretandola di conseguenza, oppure ancora leggendo un file di testo. I valori del vettore saranno ovviamente numerici; saranno comunque trattati come numeri reali, e quindi sar\u00e0 usato il formato float . Output: l'utente si attende in uscita il vettore ordinato; in tal senso, potr\u00e0 scegliere se gli verr\u00e0 restituito sulla riga di comando oppure stampato su un file di testo. Diagramma di flusso e pseudocodice \u00b6 Lo pseudocodice \u00e8 il seguente: STEP 1: read(input); // Lettura dell'input dell'utente STEP 2: i = 0; // Contatore per indicare l'indice del sotto-vettore ordinato STEP 3: for (i; i < length(input) - 1; i++) // Aumento l'indice dell'ultimo elemento del sotto-vettore ordinato fino a che non sono sicuro di aver ordinato l'intero vettore STEP 4: j = i+1; // Contatore per indicare l'indice del sotto-vettore non ordinato STEP 4: for (j; j<= length(input); j++) // Controllo tutti i valori dimanenti dell'array STEP 5: if input[i] > input[j] // Effettuo l'operazione di swap se necessario STEP 6: input[i] = input[j] STEP 7: input[j] = input[i] end end end STEP 8: RETURN(input) Il diagramma di flusso \u00e8 mostrato nella figura seguente: Nota Nel diagramma di flusso le frecce in rosso sulle selezioni indicano un FALSE , mentre quelle in blu un TRUE . Analisi computazionale \u00b6 L'algoritmo nel caso peggiore ha un'analisi di complessit\u00e0 pari proprio a quella del selection sort, ovvero un \\(O(n^2)\\) .","title":"Parte Prima"},{"location":"01_esami/tema_anno/esempio/parte_prima/#descrizione-del-problema","text":"Il problema concerne l'utilizzo della tecnica di selection sort per ordinare un vettore ad \\(n\\) elementi. Il selection sort \u00e8 un algoritmo base per l'ordinamento del vettore; pu\u00f2 essere applicato, ad esempio, per ordinare come segue il vettore \\([1,4,2,3]\\) : \\[ [1, 4, 2, 3] \\Rightarrow [1, 2, 4, 3] \\Rightarrow [1, 2, 3, 4] \\] Il selection sort opera suddividendo l'array in una sequenza ordinata (a sinistra) ed in una non ordinata; essendo un approccio iterativo, ad ogni iterazione viene sostituito l'elemento pi\u00f9 a destra della sequenza ordinata con il minore tra quelli nella sequenza ordinata. Sar\u00e0 quindi necessario usare un approccio iterativo come indicato nella sezione Diagramma di flusso e pseudocodice .","title":"Descrizione del problema"},{"location":"01_esami/tema_anno/esempio/parte_prima/#individuazione-di-input-ed-output","text":"Input: \u00e8 richiesto all'utente di inserire un vettore in input ad \\(n\\) elementi. Questo potr\u00e0 essere inserito in maniera ricorsiva (ad esempio, chiedendo all'utente di inserire un elemento alla volta da riga di comando), oppure chiedendo all'utente di inserire una stringa ed interpretandola di conseguenza, oppure ancora leggendo un file di testo. I valori del vettore saranno ovviamente numerici; saranno comunque trattati come numeri reali, e quindi sar\u00e0 usato il formato float . Output: l'utente si attende in uscita il vettore ordinato; in tal senso, potr\u00e0 scegliere se gli verr\u00e0 restituito sulla riga di comando oppure stampato su un file di testo.","title":"Individuazione di input ed output"},{"location":"01_esami/tema_anno/esempio/parte_prima/#diagramma-di-flusso-e-pseudocodice","text":"Lo pseudocodice \u00e8 il seguente: STEP 1: read(input); // Lettura dell'input dell'utente STEP 2: i = 0; // Contatore per indicare l'indice del sotto-vettore ordinato STEP 3: for (i; i < length(input) - 1; i++) // Aumento l'indice dell'ultimo elemento del sotto-vettore ordinato fino a che non sono sicuro di aver ordinato l'intero vettore STEP 4: j = i+1; // Contatore per indicare l'indice del sotto-vettore non ordinato STEP 4: for (j; j<= length(input); j++) // Controllo tutti i valori dimanenti dell'array STEP 5: if input[i] > input[j] // Effettuo l'operazione di swap se necessario STEP 6: input[i] = input[j] STEP 7: input[j] = input[i] end end end STEP 8: RETURN(input) Il diagramma di flusso \u00e8 mostrato nella figura seguente: Nota Nel diagramma di flusso le frecce in rosso sulle selezioni indicano un FALSE , mentre quelle in blu un TRUE .","title":"Diagramma di flusso e pseudocodice"},{"location":"01_esami/tema_anno/esempio/parte_prima/#analisi-computazionale","text":"L'algoritmo nel caso peggiore ha un'analisi di complessit\u00e0 pari proprio a quella del selection sort, ovvero un \\(O(n^2)\\) .","title":"Analisi computazionale"},{"location":"01_esami/tema_anno/esempio/parte_quarta/","text":"Esempio prova d'esame - Programma in Python \u00b6 Struttura del codice \u00b6 Di seguito, la struttura su file system del codice sorgente. |---algorithms |------__init__.py |------sorting.py |---utils |------__init__.py |------ioutils.py |------parsing.py |---run.py Package \u00b6 Segue una sintetica descrizione dei package presenti sull'applicazione. Package Descrizione Link algorithms Contiene tutti gli algoritmi utilizzati dal programma. utils Contiene le utility utilizzate dal programma. Moduli \u00b6 Segue una sintetica descrizione dei moduli contenuti in ciascun package. algorithms \u00b6 Segue una sintetica descrizione dei moduli contenuti all'interno del package algorithms . sorting.py \u00b6 Il modulo sorting.py contiene le seguenti classi. Classe Descrizione BaseSort Classe base usata per definire gli algoritmi di sorting. Caratterizzata dal metodo astratto sort , da implementare nelle classi derivate. SelectionSort Classe derivata che definisce l'algoritmo di selection sort. BaseSort \u00b6 La classe BaseSort consta dei seguenti metodi ed attributi. Attributo Descrizione Tipo Modificatore ar Lista di valori numerici da ordinare. Utilizza il decorator @property . List private Nota Un'implementazione maggiormente rigorosa potrebbe prevedere l'uso di un array NumPy per rendere superfluo il metodo check_numeric , descritto di seguito. Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito check_numeric Controlla se il valore passato come parametro \u00e8 di tipo intero o float (violando leggermente il principio del duck typing). Metodo statico val: Any bool sort Metodo astratto per l'ordinamento di ar , da implementare nelle classi derivate. Pu\u00f2 opzionalmente effettuare l'ordinamento inplace . Metodo astratto inplace: bool=True List SelectionSort \u00b6 La classe SelectionSort deriva dalla classe BaseSort , ed oltre ad attributi e metodi derivanti da quest'ultima, consta dei seguenti metodi. Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito _compare_sort Metodo ausiliario usato nell'implementazione per diminuire il riutilizzo di codice. Effettua lo swap e la riassegnazione dei due array (left e right) sfruttando la mutabilit\u00e0 delle liste. Metodo statico l_ar: List, r_ar: List None sort Implementa il selection sort. Metodo astratto inplace: bool=True List Nota Non \u00e8 stato definito un metodo swap perch\u00e9 consta di un'unica operazione. utils \u00b6 ioutils.py \u00b6 Il modulo ioutils.py contiene le seguenti classi e funzioni. Classe Descrizione FilePrinter Classe delegata alla scrittura dei risultati in un dato file. Funzione Descrizione Parametri di ingresso Tipo restituito is_file_input Determina le modalit\u00e0 di input desiderate dall'utente. im:str bool read_file Legge un file, restituendo il suo valore come stringa. fn: str, fp: str str Nota Un approccio interessante sarebbe definire un BasePrinter , il quale definisse il modo di formattare la stringa, magari mediante un metodo format , ed implementasse un metodo per la stampa \"astratto\" che si adatta allo specifico stream di output. Lo stesso discorso potrebbe essere esteso ad una classe BaseReader, che potrebbe leggere da diversi tipi di stream di input. FilePrinter \u00b6 La classe FilePrinter consta dei seguenti metodi ed attributi. Attributo Descrizione Tipo Modificatore Valore di default fn Stringa che rappresenta il nome del file di output. Utilizza il decorator @property . str private N.D. fp Stringa che rappresenta il path assoluto del file di output. Utilizza il decorator @property . str private os.getcwd() dl Stringa che rappresenta il delimitatore tra due elementi contigui. Utilizza il decorator @property . str private , op Stringa di apertura del vettore. Utilizza il decorator @property . str private [ cl Stringa di chiusura del vettore. Utilizza il decorator @property . str private ] Nota Un'implementazione maggiormente rigorosa potrebbe prevedere l'uso di un array NumPy per rendere superfluo il metodo check_numeric , descritto di seguito. Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito print_list Stampa su file una lista di interi. Metodo di classe vals: List N.D. parsing.py \u00b6 Il modulo parsing.py contiene le seguenti classi. Classe Descrizione Parser Classe delegata alla conversione di una stringa in una lista di valori numerici. Nota Anche in questo caso, sarebbe interessante usare un approccio gerarchico, o diversi metodi. Parser \u00b6 La classe Parser consta dei seguenti metodi ed attributi. Attributo Descrizione Tipo Modificatore Valore di default st Stringa di input da convertire in lista numerica. Utilizza il decorator @property . str private N.D. dl Delimitatore che suddivide gli elementi numerici contigui. Utilizza il decorator @property . str private N.D. rm Lista dei caratteri da rimuovere. Utilizza il decorator @property . List private [] to_float Indica se gli elementi della lista devono essere convertiti in formato reale. Utilizza il decorator @property . bool private False Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito check_valid Controlla se il valore passato pu\u00f2 essere convertito in intero. Metodo statico val: Any bool parse Effettua il parsing della stringa di input. Metodo di classe N.D. str Nota Il metodo check_valid ha ovvie limitazioni legate al fatto che controlla soltanto gli interi, per cui ci sarebbe una perdita di informazione passando dei float. Sarebbe quindi interessante prevedere anche questa eventualit\u00e0. Funzionamento del programma \u00b6 Ecco una breve guida per illustrare il funzionamento del programma. Recarsi nella cartella dove \u00e8 posizionato il file run.py . cd folder_selection_sort Lanciare il programma. python run.py Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento. Nota Si omette, per brevit\u00e0, la parte relativa all'esempio di funzionamento ed al file da passare in input, in quanto sostanzialmente identica a quella proposta per la seconda e terza parte.","title":"Parte Quarta"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#esempio-prova-desame-programma-in-python","text":"","title":"Esempio prova d'esame - Programma in Python"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#struttura-del-codice","text":"Di seguito, la struttura su file system del codice sorgente. |---algorithms |------__init__.py |------sorting.py |---utils |------__init__.py |------ioutils.py |------parsing.py |---run.py","title":"Struttura del codice"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#package","text":"Segue una sintetica descrizione dei package presenti sull'applicazione. Package Descrizione Link algorithms Contiene tutti gli algoritmi utilizzati dal programma. utils Contiene le utility utilizzate dal programma.","title":"Package"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#moduli","text":"Segue una sintetica descrizione dei moduli contenuti in ciascun package.","title":"Moduli"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#algorithms","text":"Segue una sintetica descrizione dei moduli contenuti all'interno del package algorithms .","title":"algorithms"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#sortingpy","text":"Il modulo sorting.py contiene le seguenti classi. Classe Descrizione BaseSort Classe base usata per definire gli algoritmi di sorting. Caratterizzata dal metodo astratto sort , da implementare nelle classi derivate. SelectionSort Classe derivata che definisce l'algoritmo di selection sort.","title":"sorting.py"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#basesort","text":"La classe BaseSort consta dei seguenti metodi ed attributi. Attributo Descrizione Tipo Modificatore ar Lista di valori numerici da ordinare. Utilizza il decorator @property . List private Nota Un'implementazione maggiormente rigorosa potrebbe prevedere l'uso di un array NumPy per rendere superfluo il metodo check_numeric , descritto di seguito. Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito check_numeric Controlla se il valore passato come parametro \u00e8 di tipo intero o float (violando leggermente il principio del duck typing). Metodo statico val: Any bool sort Metodo astratto per l'ordinamento di ar , da implementare nelle classi derivate. Pu\u00f2 opzionalmente effettuare l'ordinamento inplace . Metodo astratto inplace: bool=True List","title":"BaseSort"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#selectionsort","text":"La classe SelectionSort deriva dalla classe BaseSort , ed oltre ad attributi e metodi derivanti da quest'ultima, consta dei seguenti metodi. Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito _compare_sort Metodo ausiliario usato nell'implementazione per diminuire il riutilizzo di codice. Effettua lo swap e la riassegnazione dei due array (left e right) sfruttando la mutabilit\u00e0 delle liste. Metodo statico l_ar: List, r_ar: List None sort Implementa il selection sort. Metodo astratto inplace: bool=True List Nota Non \u00e8 stato definito un metodo swap perch\u00e9 consta di un'unica operazione.","title":"SelectionSort"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#utils","text":"","title":"utils"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#ioutilspy","text":"Il modulo ioutils.py contiene le seguenti classi e funzioni. Classe Descrizione FilePrinter Classe delegata alla scrittura dei risultati in un dato file. Funzione Descrizione Parametri di ingresso Tipo restituito is_file_input Determina le modalit\u00e0 di input desiderate dall'utente. im:str bool read_file Legge un file, restituendo il suo valore come stringa. fn: str, fp: str str Nota Un approccio interessante sarebbe definire un BasePrinter , il quale definisse il modo di formattare la stringa, magari mediante un metodo format , ed implementasse un metodo per la stampa \"astratto\" che si adatta allo specifico stream di output. Lo stesso discorso potrebbe essere esteso ad una classe BaseReader, che potrebbe leggere da diversi tipi di stream di input.","title":"ioutils.py"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#fileprinter","text":"La classe FilePrinter consta dei seguenti metodi ed attributi. Attributo Descrizione Tipo Modificatore Valore di default fn Stringa che rappresenta il nome del file di output. Utilizza il decorator @property . str private N.D. fp Stringa che rappresenta il path assoluto del file di output. Utilizza il decorator @property . str private os.getcwd() dl Stringa che rappresenta il delimitatore tra due elementi contigui. Utilizza il decorator @property . str private , op Stringa di apertura del vettore. Utilizza il decorator @property . str private [ cl Stringa di chiusura del vettore. Utilizza il decorator @property . str private ] Nota Un'implementazione maggiormente rigorosa potrebbe prevedere l'uso di un array NumPy per rendere superfluo il metodo check_numeric , descritto di seguito. Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito print_list Stampa su file una lista di interi. Metodo di classe vals: List N.D.","title":"FilePrinter"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#parsingpy","text":"Il modulo parsing.py contiene le seguenti classi. Classe Descrizione Parser Classe delegata alla conversione di una stringa in una lista di valori numerici. Nota Anche in questo caso, sarebbe interessante usare un approccio gerarchico, o diversi metodi.","title":"parsing.py"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#parser","text":"La classe Parser consta dei seguenti metodi ed attributi. Attributo Descrizione Tipo Modificatore Valore di default st Stringa di input da convertire in lista numerica. Utilizza il decorator @property . str private N.D. dl Delimitatore che suddivide gli elementi numerici contigui. Utilizza il decorator @property . str private N.D. rm Lista dei caratteri da rimuovere. Utilizza il decorator @property . List private [] to_float Indica se gli elementi della lista devono essere convertiti in formato reale. Utilizza il decorator @property . bool private False Metodo Descrizione Tipo di metodo Parametri di ingresso Tipo restituito check_valid Controlla se il valore passato pu\u00f2 essere convertito in intero. Metodo statico val: Any bool parse Effettua il parsing della stringa di input. Metodo di classe N.D. str Nota Il metodo check_valid ha ovvie limitazioni legate al fatto che controlla soltanto gli interi, per cui ci sarebbe una perdita di informazione passando dei float. Sarebbe quindi interessante prevedere anche questa eventualit\u00e0.","title":"Parser"},{"location":"01_esami/tema_anno/esempio/parte_quarta/#funzionamento-del-programma","text":"Ecco una breve guida per illustrare il funzionamento del programma. Recarsi nella cartella dove \u00e8 posizionato il file run.py . cd folder_selection_sort Lanciare il programma. python run.py Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento. Nota Si omette, per brevit\u00e0, la parte relativa all'esempio di funzionamento ed al file da passare in input, in quanto sostanzialmente identica a quella proposta per la seconda e terza parte.","title":"Funzionamento del programma"},{"location":"01_esami/tema_anno/esempio/parte_seconda/","text":"Struttura del codice \u00b6 Il programma \u00e8 strutturato come segue: |---File di intestazione |------ioutils.h |------parsing.h |------sorting.h |---File di origine |------ioutils.c |------parsing.c |------sorting.c |------source.c |---File di risorse |------array.txt Descrizione sintetica dei file \u00b6 File di intestazione (header) \u00b6 Segue una breve descrizione dei singoli file di intestazione. File Descrizione Link al codice ioutils.h Contiene delle utility di supporto all'I/O. parsing.h Contiene delle utility di supporto al parsing. sorting.h Contiene delle utility di supporto al selection sort. File di origine (sorgenti) \u00b6 Segue una breve descrizione dei singoli file di origine. File Descrizione Link al codice ioutils.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. parsing.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. sorting.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. source.c Contiene il programma principale. File di risorse \u00b6 Segue una breve descrizione dei singoli file di risorce. File Descrizione array.txt Contiene un esempio per l'input di un vettore. Descrizione delle funzioni implementate \u00b6 ioutils \u00b6 Funzione Argomenti Output Descrizione read_file char* string N.D. Legge un file (chiesto in input all'interno della funzione) e va a popolare di conseguenza la stringa ( string ) passata come argomento. Contiene funzioni di verifica degli errori. print_array int array[], int length N.D. Permette di formattare a schermo un determinato array di interi. text_or_shell N.D. char input_mode Chiede all'utente di inserire un carattere tra f ed r per determinare se leggere da file o da riga di comando. save_to_file int array[], int length void Salva un array di interi di lunghezza length nel file di testo richiesto all'utente. Se il file di testo non esiste, viene creato; se esiste, viene sovrascritto. parsing \u00b6 Funzione Argomenti Output Descrizione strstrp char* str_in, char* str_out, char strp, int length N.D. Legge la stringa str_in di lunghezza length , rimuove tutte le occorrenze del carattere strp e la salva nella stringa str_out . string_to_int_array char* string, int* buffer int numbers Converte la stringa di interi string , con interi separati da una virgola, nell'array buffer . Restituisce il numero di interi trovati. sorting \u00b6 Funzione Argomenti Output Descrizione swap int array[], int swap_l_idx, int swap_r_idx, int swap_val N.D. Sostituisce l'elemento all'indice swap l idx con l'elemento swap r idx nell'array di interi vector . selection_sort int vector[], int length N.D. Implementa l'algoritmo di selection sort sul vettore di interi vector . Funzionamento del programma \u00b6 Recarsi nella cartella dove \u00e8 posizionato l'eseguibile fornito usando PowerShell o la Command Prompt. cd folder_selection_sort Lanciare il programma. SelectionSort.exe Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento. Esempio di funzionamento \u00b6 $ cd folder_selection_sort $ SelectionSort.exe % Enter 'f' to use a text file, or 'r' to use shell. -> r $ Please enter array values: -> [ 10 , 4 , 3 , 2 ] $ Sorted vector: $ 2 3 4 10 $ cd folder_selection_sort $ SelectionSort.exe % Enter 'f' to use a text file, or 'r' to use shell. -> f $ Please enter file name: -> array.txt $ Sorted vector: $ 1 2 3 3 4 7 8 12 51 66 File di input \u00b6 Ecco un esempio di file di input. [ 10 , 4 , 3 , 2 ] Il file andr\u00e0 posizionato nella stessa cartella dell'eseguibile.","title":"Parte Seconda"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#struttura-del-codice","text":"Il programma \u00e8 strutturato come segue: |---File di intestazione |------ioutils.h |------parsing.h |------sorting.h |---File di origine |------ioutils.c |------parsing.c |------sorting.c |------source.c |---File di risorse |------array.txt","title":"Struttura del codice"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#descrizione-sintetica-dei-file","text":"","title":"Descrizione sintetica dei file"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#file-di-intestazione-header","text":"Segue una breve descrizione dei singoli file di intestazione. File Descrizione Link al codice ioutils.h Contiene delle utility di supporto all'I/O. parsing.h Contiene delle utility di supporto al parsing. sorting.h Contiene delle utility di supporto al selection sort.","title":"File di intestazione (header)"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#file-di-origine-sorgenti","text":"Segue una breve descrizione dei singoli file di origine. File Descrizione Link al codice ioutils.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. parsing.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. sorting.c Contiene l'implementazione delle funzioni descritte nell'header omonimo. source.c Contiene il programma principale.","title":"File di origine (sorgenti)"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#file-di-risorse","text":"Segue una breve descrizione dei singoli file di risorce. File Descrizione array.txt Contiene un esempio per l'input di un vettore.","title":"File di risorse"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#descrizione-delle-funzioni-implementate","text":"","title":"Descrizione delle funzioni implementate"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#ioutils","text":"Funzione Argomenti Output Descrizione read_file char* string N.D. Legge un file (chiesto in input all'interno della funzione) e va a popolare di conseguenza la stringa ( string ) passata come argomento. Contiene funzioni di verifica degli errori. print_array int array[], int length N.D. Permette di formattare a schermo un determinato array di interi. text_or_shell N.D. char input_mode Chiede all'utente di inserire un carattere tra f ed r per determinare se leggere da file o da riga di comando. save_to_file int array[], int length void Salva un array di interi di lunghezza length nel file di testo richiesto all'utente. Se il file di testo non esiste, viene creato; se esiste, viene sovrascritto.","title":"ioutils"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#parsing","text":"Funzione Argomenti Output Descrizione strstrp char* str_in, char* str_out, char strp, int length N.D. Legge la stringa str_in di lunghezza length , rimuove tutte le occorrenze del carattere strp e la salva nella stringa str_out . string_to_int_array char* string, int* buffer int numbers Converte la stringa di interi string , con interi separati da una virgola, nell'array buffer . Restituisce il numero di interi trovati.","title":"parsing"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#sorting","text":"Funzione Argomenti Output Descrizione swap int array[], int swap_l_idx, int swap_r_idx, int swap_val N.D. Sostituisce l'elemento all'indice swap l idx con l'elemento swap r idx nell'array di interi vector . selection_sort int vector[], int length N.D. Implementa l'algoritmo di selection sort sul vettore di interi vector .","title":"sorting"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#funzionamento-del-programma","text":"Recarsi nella cartella dove \u00e8 posizionato l'eseguibile fornito usando PowerShell o la Command Prompt. cd folder_selection_sort Lanciare il programma. SelectionSort.exe Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento.","title":"Funzionamento del programma"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#esempio-di-funzionamento","text":"$ cd folder_selection_sort $ SelectionSort.exe % Enter 'f' to use a text file, or 'r' to use shell. -> r $ Please enter array values: -> [ 10 , 4 , 3 , 2 ] $ Sorted vector: $ 2 3 4 10 $ cd folder_selection_sort $ SelectionSort.exe % Enter 'f' to use a text file, or 'r' to use shell. -> f $ Please enter file name: -> array.txt $ Sorted vector: $ 1 2 3 3 4 7 8 12 51 66","title":"Esempio di funzionamento"},{"location":"01_esami/tema_anno/esempio/parte_seconda/#file-di-input","text":"Ecco un esempio di file di input. [ 10 , 4 , 3 , 2 ] Il file andr\u00e0 posizionato nella stessa cartella dell'eseguibile.","title":"File di input"},{"location":"01_esami/tema_anno/esempio/parte_terza/","text":"Esempio prova d'esame - Programma in C++ \u00b6 Struttura del codice \u00b6 Di seguito, la struttura su file system del codice sorgente. |---File di intestazione |------ioutils.h |------parsing.h |------sorting.h |---File di origine |------ioutils.cpp |------parsing.cpp |------sorting.cpp |------source.cpp |---File di risorse |------array.txt Descrizione sintetica dei file \u00b6 File di intestazione (header) \u00b6 Segue una breve descrizione dei singoli file di intestazione. File Descrizione Link al codice ioutils.h Contiene delle utility di supporto all'I/O. parsing.h Contiene delle utility di supporto al parsing. sorting.h Contiene delle utility di supporto al selection sort. File di origine (sorgenti) \u00b6 Segue una breve descrizione dei singoli file di origine. File Descrizione Link al codice ioutils.cpp Contiene l'implementazione delle funzioni descritte nell'header omonimo. parsing.cpp Contiene l'implementazione delle funzioni descritte nell'header omonimo. sorting.cpp Contiene l'implementazione delle funzioni descritte nell'header omonimo. source.cpp Contiene il programma principale. File di risorse \u00b6 Segue una breve descrizione dei singoli file di risorce. File Descrizione array.txt Contiene un esempio per l'input di un vettore. Descrizione dettagliata dei file \u00b6 ioutils \u00b6 In questo file \u00e8 definito il namespace ioutils , contenente le seguenti funzioni e classi. Funzioni \u00b6 Nome funzione Lista parametri (tipo - nome) Output (tipo) Descrizione is_file_input N.D. bool Se vero, legge da file; in caso contrario, legge da riga di comando. read_file string file_name string Legge il contenuto di file_name , restituendolo sotto forma di stringa. print_array vector<int> vect void Utility per mostrare a schermo il contenuto di un vettore numerico. Uso di funzioni standalone Usare delle funzioni standalone , ovvero a s\u00e8 stanti, \u00e8 perfettamente lecito. In questo caso, queste funzioni non sono strettamente correlate ad una classe, e non risultano essere tra loro complementari, per cui sono state dichiarate come facenti parte \"globalmente\" del namespace ioutils . Le precedenti funzioni non sono state raggruppate all'interno di una classe a causa del Classi \u00b6 Nome classe Descrizione SaveManager Classe delegata alla gestione del salvataggio su file di un vettore ordinato. SaveManager \u00b6 Variabili membro \u00b6 Nome e tipo variabile Modificatore di accesso Descrizione string fileName private Nome del file di output. vector<int> vect private Vettore da stampare sul file di output. string delimiter private Separatore tra due elementi contingui del vettore. Di default, \u00e8 , . string opener private Carattere che contrassegna l'inizio del vettore. Di default, \u00e8 [ . string closer private Carattere che contrassegna il termine del vettore. Di default, \u00e8 ] . Funzioni membro \u00b6 Nome funzione Lista parametri (tipo - nome) Output (tipo) Modificatore di accesso Descrizione SaveManager string fileName , vector<int> vect , string delimiter , string opener , string closer N.D. public Costruttore parametrizzato. setFileName string fileName void public Setter per fileName . getFileName N.D. string public Getter per fileName . setVect vector<int> vect void public Setter per vect . getVect N.D. vector<int> vect public Getter per vect . setDelimiter string delimiter void public Setter per delimiter . getDelimiter N.D. string public Getter per delimiter . setOpener string opener void public Setter per opener . getOpener N.D. string public Getter per opener . setCloser string closer void public Setter per closer . getCloser N.D. string public Getter per closer . saveToFile N.D. void public Salva il vettore su file. parsing \u00b6 In questo file \u00e8 definito il namespace parsing , contenente le seguenti funzioni e classi. Classi \u00b6 Nome classe Descrizione Parser Classe delegata al parsing dell'input inserito dall'utente. SaveManager \u00b6 Variabili membro \u00b6 Nome e tipo variabile Modificatore di accesso Descrizione string input private Stringa rappresentativa dell'input inserito dall'utente. Funzioni membro \u00b6 Nome funzione Lista parametri (tipo - nome) Output (tipo) Modificatore di accesso Descrizione Parser N.D. N.D. public Costruttore di default. Parser string input N.D. public Costruttore parametrizzato. setInput string input void public Setter per input . getInput N.D. string public Getter per input . strip char to_strip void public Rimuove il carattere to_strip dalla stringa input. Effettua le operazioni in place . strip_multiple vector<char> to_strip void public Rimuove tutti i caratteri specificati nel vettore di caratteri to_strip . Effettua le operazioni in place . parse_int_array string delimiter vector<int> public Converte la stringa di input in un vettore di interi. Il delimitatore che viene considerato di default \u00e8 , . Sulle variabili membro di Parser Noterete che abbiamo scelto come variabili membro di parser soltanto la stringa input . Una scelta valida potrebbe essere inserire anche il vettore di output come variabile membro, anche se ci sarebbe probabilmente un maggiore coupling (accoppiamento) tra classi, in quanto il Sorter (vedere seguito) dipenderebbe da una variabile membro del Parser . Ovviamente, il coupling va evitato (quando possibile). sorting \u00b6 In questo file \u00e8 definito il namespace sorting , contenente le seguenti funzioni e classi. Classi \u00b6 Nome classe Descrizione Sorter Classe delegata all'ordinamento del vettore. SaveManager \u00b6 Variabili membro \u00b6 Nome e tipo variabile Modificatore di accesso Descrizione vector<int> to_sort private Vettore da ordinare. vector<int>::iterator it private Iteratore sul vettore da ordinare. Funzioni membro \u00b6 Nome funzione Lista parametri (tipo - nome) Output (tipo) Modificatore di accesso Descrizione Sorter N.D. N.D. public Costruttore di default. Sorter vector<int> to_sort N.D. public Costruttore parametrizzato. setVector vector<int> vect void public Setter per to_sort . getVector N.D. vector<int> public Getter per to_sort . swap int l_idx , int r_idx void public Effettua la funzione di swap . Chiamato internamente da selectionSort() . selectionSort N.D. void public Applica l'algoritmo di selectionSort sul vettore to_sort . Il metodo swap In questo caso, sarebbe perfettamente lecito assegnare al metodo swap il modificatore di accesso private , in quanto esclusivamente acceduto internamente dal selectionSort() . Funzionamento del programma \u00b6 Recarsi nella cartella dove \u00e8 posizionato l'eseguibile fornito usando PowerShell o la Command Prompt. cd folder_selection_sort Lanciare il programma. SelectionSort.exe Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento. Nota Si omette, per brevit\u00e0, la parte relativa all'esempio di funzionamento ed al file da passare in input, in quanto sostanzialmente identica a quella proposta per la seconda parte.","title":"Parte Terza"},{"location":"01_esami/tema_anno/esempio/parte_terza/#esempio-prova-desame-programma-in-c","text":"","title":"Esempio prova d'esame - Programma in C++"},{"location":"01_esami/tema_anno/esempio/parte_terza/#struttura-del-codice","text":"Di seguito, la struttura su file system del codice sorgente. |---File di intestazione |------ioutils.h |------parsing.h |------sorting.h |---File di origine |------ioutils.cpp |------parsing.cpp |------sorting.cpp |------source.cpp |---File di risorse |------array.txt","title":"Struttura del codice"},{"location":"01_esami/tema_anno/esempio/parte_terza/#descrizione-sintetica-dei-file","text":"","title":"Descrizione sintetica dei file"},{"location":"01_esami/tema_anno/esempio/parte_terza/#file-di-intestazione-header","text":"Segue una breve descrizione dei singoli file di intestazione. File Descrizione Link al codice ioutils.h Contiene delle utility di supporto all'I/O. parsing.h Contiene delle utility di supporto al parsing. sorting.h Contiene delle utility di supporto al selection sort.","title":"File di intestazione (header)"},{"location":"01_esami/tema_anno/esempio/parte_terza/#file-di-origine-sorgenti","text":"Segue una breve descrizione dei singoli file di origine. File Descrizione Link al codice ioutils.cpp Contiene l'implementazione delle funzioni descritte nell'header omonimo. parsing.cpp Contiene l'implementazione delle funzioni descritte nell'header omonimo. sorting.cpp Contiene l'implementazione delle funzioni descritte nell'header omonimo. source.cpp Contiene il programma principale.","title":"File di origine (sorgenti)"},{"location":"01_esami/tema_anno/esempio/parte_terza/#file-di-risorse","text":"Segue una breve descrizione dei singoli file di risorce. File Descrizione array.txt Contiene un esempio per l'input di un vettore.","title":"File di risorse"},{"location":"01_esami/tema_anno/esempio/parte_terza/#descrizione-dettagliata-dei-file","text":"","title":"Descrizione dettagliata dei file"},{"location":"01_esami/tema_anno/esempio/parte_terza/#ioutils","text":"In questo file \u00e8 definito il namespace ioutils , contenente le seguenti funzioni e classi.","title":"ioutils"},{"location":"01_esami/tema_anno/esempio/parte_terza/#funzioni","text":"Nome funzione Lista parametri (tipo - nome) Output (tipo) Descrizione is_file_input N.D. bool Se vero, legge da file; in caso contrario, legge da riga di comando. read_file string file_name string Legge il contenuto di file_name , restituendolo sotto forma di stringa. print_array vector<int> vect void Utility per mostrare a schermo il contenuto di un vettore numerico. Uso di funzioni standalone Usare delle funzioni standalone , ovvero a s\u00e8 stanti, \u00e8 perfettamente lecito. In questo caso, queste funzioni non sono strettamente correlate ad una classe, e non risultano essere tra loro complementari, per cui sono state dichiarate come facenti parte \"globalmente\" del namespace ioutils . Le precedenti funzioni non sono state raggruppate all'interno di una classe a causa del","title":"Funzioni"},{"location":"01_esami/tema_anno/esempio/parte_terza/#classi","text":"Nome classe Descrizione SaveManager Classe delegata alla gestione del salvataggio su file di un vettore ordinato.","title":"Classi"},{"location":"01_esami/tema_anno/esempio/parte_terza/#savemanager","text":"","title":"SaveManager"},{"location":"01_esami/tema_anno/esempio/parte_terza/#variabili-membro","text":"Nome e tipo variabile Modificatore di accesso Descrizione string fileName private Nome del file di output. vector<int> vect private Vettore da stampare sul file di output. string delimiter private Separatore tra due elementi contingui del vettore. Di default, \u00e8 , . string opener private Carattere che contrassegna l'inizio del vettore. Di default, \u00e8 [ . string closer private Carattere che contrassegna il termine del vettore. Di default, \u00e8 ] .","title":"Variabili membro"},{"location":"01_esami/tema_anno/esempio/parte_terza/#funzioni-membro","text":"Nome funzione Lista parametri (tipo - nome) Output (tipo) Modificatore di accesso Descrizione SaveManager string fileName , vector<int> vect , string delimiter , string opener , string closer N.D. public Costruttore parametrizzato. setFileName string fileName void public Setter per fileName . getFileName N.D. string public Getter per fileName . setVect vector<int> vect void public Setter per vect . getVect N.D. vector<int> vect public Getter per vect . setDelimiter string delimiter void public Setter per delimiter . getDelimiter N.D. string public Getter per delimiter . setOpener string opener void public Setter per opener . getOpener N.D. string public Getter per opener . setCloser string closer void public Setter per closer . getCloser N.D. string public Getter per closer . saveToFile N.D. void public Salva il vettore su file.","title":"Funzioni membro"},{"location":"01_esami/tema_anno/esempio/parte_terza/#parsing","text":"In questo file \u00e8 definito il namespace parsing , contenente le seguenti funzioni e classi.","title":"parsing"},{"location":"01_esami/tema_anno/esempio/parte_terza/#classi_1","text":"Nome classe Descrizione Parser Classe delegata al parsing dell'input inserito dall'utente.","title":"Classi"},{"location":"01_esami/tema_anno/esempio/parte_terza/#savemanager_1","text":"","title":"SaveManager"},{"location":"01_esami/tema_anno/esempio/parte_terza/#variabili-membro_1","text":"Nome e tipo variabile Modificatore di accesso Descrizione string input private Stringa rappresentativa dell'input inserito dall'utente.","title":"Variabili membro"},{"location":"01_esami/tema_anno/esempio/parte_terza/#funzioni-membro_1","text":"Nome funzione Lista parametri (tipo - nome) Output (tipo) Modificatore di accesso Descrizione Parser N.D. N.D. public Costruttore di default. Parser string input N.D. public Costruttore parametrizzato. setInput string input void public Setter per input . getInput N.D. string public Getter per input . strip char to_strip void public Rimuove il carattere to_strip dalla stringa input. Effettua le operazioni in place . strip_multiple vector<char> to_strip void public Rimuove tutti i caratteri specificati nel vettore di caratteri to_strip . Effettua le operazioni in place . parse_int_array string delimiter vector<int> public Converte la stringa di input in un vettore di interi. Il delimitatore che viene considerato di default \u00e8 , . Sulle variabili membro di Parser Noterete che abbiamo scelto come variabili membro di parser soltanto la stringa input . Una scelta valida potrebbe essere inserire anche il vettore di output come variabile membro, anche se ci sarebbe probabilmente un maggiore coupling (accoppiamento) tra classi, in quanto il Sorter (vedere seguito) dipenderebbe da una variabile membro del Parser . Ovviamente, il coupling va evitato (quando possibile).","title":"Funzioni membro"},{"location":"01_esami/tema_anno/esempio/parte_terza/#sorting","text":"In questo file \u00e8 definito il namespace sorting , contenente le seguenti funzioni e classi.","title":"sorting"},{"location":"01_esami/tema_anno/esempio/parte_terza/#classi_2","text":"Nome classe Descrizione Sorter Classe delegata all'ordinamento del vettore.","title":"Classi"},{"location":"01_esami/tema_anno/esempio/parte_terza/#savemanager_2","text":"","title":"SaveManager"},{"location":"01_esami/tema_anno/esempio/parte_terza/#variabili-membro_2","text":"Nome e tipo variabile Modificatore di accesso Descrizione vector<int> to_sort private Vettore da ordinare. vector<int>::iterator it private Iteratore sul vettore da ordinare.","title":"Variabili membro"},{"location":"01_esami/tema_anno/esempio/parte_terza/#funzioni-membro_2","text":"Nome funzione Lista parametri (tipo - nome) Output (tipo) Modificatore di accesso Descrizione Sorter N.D. N.D. public Costruttore di default. Sorter vector<int> to_sort N.D. public Costruttore parametrizzato. setVector vector<int> vect void public Setter per to_sort . getVector N.D. vector<int> public Getter per to_sort . swap int l_idx , int r_idx void public Effettua la funzione di swap . Chiamato internamente da selectionSort() . selectionSort N.D. void public Applica l'algoritmo di selectionSort sul vettore to_sort . Il metodo swap In questo caso, sarebbe perfettamente lecito assegnare al metodo swap il modificatore di accesso private , in quanto esclusivamente acceduto internamente dal selectionSort() .","title":"Funzioni membro"},{"location":"01_esami/tema_anno/esempio/parte_terza/#funzionamento-del-programma","text":"Recarsi nella cartella dove \u00e8 posizionato l'eseguibile fornito usando PowerShell o la Command Prompt. cd folder_selection_sort Lanciare il programma. SelectionSort.exe Il programma richieder\u00e0 di scegliere tra la selezione di un file (mediante il carattere f ) o quella della riga di comando (mediante il carattere r ). a. Se viene selezionato il file, occorre inserire un nome valido. Il file dovr\u00e0 essere inserito all'interno della cartella del programma, ed avere estensione .txt . All'interno del file dovr\u00e0 gi\u00e0 essere stato inserito un array. b. Se viene selezionata la riga di comando, occorre inserire un array. I formati validi sono del tipo [el_1, el_2, ..., el_n] oppure {el_1, el_2, ..., el_n} . Il programma provveder\u00e0 a stampare a schermo il risultato dell'algoritmo di ordinamento. Nota Si omette, per brevit\u00e0, la parte relativa all'esempio di funzionamento ed al file da passare in input, in quanto sostanzialmente identica a quella proposta per la seconda parte.","title":"Funzionamento del programma"},{"location":"01_esami/tema_anno/esempio/traccia/","text":"Esempio di tema d'anno \u00b6 Nota Il presente \u00e8 un esempio di tema d'anno svolto dal Docente. Tuttavia, non \u00e8 da considerarsi comparabile al livello di difficolt\u00e0 delle tracce assegnate per i temi d'anno; lo scopo, meramente illustrativo, \u00e8 quello di mostrare l'output atteso. Quesito \u00b6 Dato un vettore \\(n\\) , scrivere un programma che lo ordini mediante l'algoritmo di selection sort .","title":"Traccia"},{"location":"01_esami/tema_anno/esempio/traccia/#esempio-di-tema-danno","text":"Nota Il presente \u00e8 un esempio di tema d'anno svolto dal Docente. Tuttavia, non \u00e8 da considerarsi comparabile al livello di difficolt\u00e0 delle tracce assegnate per i temi d'anno; lo scopo, meramente illustrativo, \u00e8 quello di mostrare l'output atteso.","title":"Esempio di tema d'anno"},{"location":"01_esami/tema_anno/esempio/traccia/#quesito","text":"Dato un vettore \\(n\\) , scrivere un programma che lo ordini mediante l'algoritmo di selection sort .","title":"Quesito"},{"location":"02_dispense/01_introduttivi/01_intro/","text":"Una definizione di Informatica \u00b6 Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico. Il concetto di Informazione \u00b6 L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca. I sistemi Informatici \u00b6 Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0. Il ruolo dell'Informatico \u00b6 Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"01 - Introduzione all'Informatica"},{"location":"02_dispense/01_introduttivi/01_intro/#una-definizione-di-informatica","text":"Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico.","title":"Una definizione di Informatica"},{"location":"02_dispense/01_introduttivi/01_intro/#il-concetto-di-informazione","text":"L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca.","title":"Il concetto di Informazione"},{"location":"02_dispense/01_introduttivi/01_intro/#i-sistemi-informatici","text":"Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0.","title":"I sistemi Informatici"},{"location":"02_dispense/01_introduttivi/01_intro/#il-ruolo-dellinformatico","text":"Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"Il ruolo dell'Informatico"},{"location":"02_dispense/01_introduttivi/02_algoritmi/","text":"Formulare un problema \u00b6 Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio. Il problema come compito \u00b6 Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo . L' ente risolutore \u00b6 La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann. Gli elementi noti e le condizioni fissate \u00b6 La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore. Risolvere un problema \u00b6 La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi. Problemi e soluzioni \u00b6 Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione . Costruire la soluzione \u00b6 Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse. Operazioni atomiche \u00b6 Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.). Combinare operazioni atomiche \u00b6 Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori. Determinare l'insieme di operatori \u00b6 Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema. Da soluzione ad algoritmo \u00b6 La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema. Un esempio \u00b6 Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo. Formulazione del problema \u00b6 Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) . Dati \u00b6 Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo. Algoritmo risolutivo (in operazioni atomiche, o quasi) \u00b6 Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 . Esempio numerico \u00b6 Dati \u00b6 \\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\] Passi dell'algoritmo \u00b6 \\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) . Caratteristiche degli algoritmi risolutivi \u00b6 Le cinque caratteristiche principali \u00b6 Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico. Determinismo \u00b6 Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso. Input, Output e Variabili \u00b6 Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"02 - Gli Algoritmi"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#formulare-un-problema","text":"Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio.","title":"Formulare un problema"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#il-problema-come-compito","text":"Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo .","title":"Il problema come compito"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#lente-risolutore","text":"La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann.","title":"L'ente risolutore"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#gli-elementi-noti-e-le-condizioni-fissate","text":"La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore.","title":"Gli elementi noti e le condizioni fissate"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#risolvere-un-problema","text":"La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi.","title":"Risolvere un problema"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#problemi-e-soluzioni","text":"Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione .","title":"Problemi e soluzioni"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#costruire-la-soluzione","text":"Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse.","title":"Costruire la soluzione"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#operazioni-atomiche","text":"Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.).","title":"Operazioni atomiche"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#combinare-operazioni-atomiche","text":"Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori.","title":"Combinare operazioni atomiche"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#determinare-linsieme-di-operatori","text":"Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema.","title":"Determinare l'insieme di operatori"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#da-soluzione-ad-algoritmo","text":"La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema.","title":"Da soluzione ad algoritmo"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#un-esempio","text":"Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo.","title":"Un esempio"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#formulazione-del-problema","text":"Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) .","title":"Formulazione del problema"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#dati","text":"Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo.","title":"Dati"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#algoritmo-risolutivo-in-operazioni-atomiche-o-quasi","text":"Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 .","title":"Algoritmo risolutivo (in operazioni atomiche, o quasi)"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#esempio-numerico","text":"","title":"Esempio numerico"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#dati_1","text":"\\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\]","title":"Dati"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#passi-dellalgoritmo","text":"\\[ \\begin{eqnarray} \\text{Step 1} & \\rightarrow & {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} & \\rightarrow & {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} & \\rightarrow & v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} & \\rightarrow & \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] Il risultato \u00e8 \\(v_4 = 5\\) .","title":"Passi dell'algoritmo"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#caratteristiche-degli-algoritmi-risolutivi","text":"","title":"Caratteristiche degli algoritmi risolutivi"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#le-cinque-caratteristiche-principali","text":"Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico.","title":"Le cinque caratteristiche principali"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#determinismo","text":"Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso.","title":"Determinismo"},{"location":"02_dispense/01_introduttivi/02_algoritmi/#input-output-e-variabili","text":"Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"Input, Output e Variabili"},{"location":"02_dispense/01_introduttivi/03_architettura/","text":"L'architettura dei calcolatori \u00b6 Un po' di storia \u00b6 Le origini del concetto di calcolatore (o, nell'accezione comune del termine, computer ) possono essere fatte risalire alla storia antica, con invenzioni come l' abaco , ovvero dei veri e propri strumenti di supporto che permettevano all'operatore umano di svolgere in maniera pi\u00f9 rapida calcoli anche complessi. Il calcolatore si \u00e8 poi evoluto in et\u00e0 moderna: si \u00e8 passati dalle prime sperimentazioni, come le macchine di Pascal e di Leibniz, alle prime calcolatrici , per arrivare al primo modello (teorico) di dispositivo programmabile , ovvero in grado di adattarsi a compiti anche molto diversi tra loro, che si deve al matematico britannico Charles Babbage con la sua Macchina Analitica, progettata nel 1833, e considerata il primo progetto di computer nella storia. Nei decenni successivi, vennero introdotti diversi tipi di calcolatori analogici. Successivamente, si pass\u00f2 alla concettualizzazione della macchina di Turing , per poi arrivare ai computer meccanici ed elettromeccanici, ed infine alle architetture digitali ed elettroniche, basate su transistor e circuiti integrati ad altissima densit\u00e0. Le prossime frontiere sono probabilmente quelle dettate dal quantum computing , che potrebbero rivoluzionare completamente l'idea attuale di elaborazione, rendedo vetusta qualsiasi applicazione dell'informatica odierna. Tuttavia, nessuno degli scenari verificatisi negli ultimi 80 anni si sarebbe potuto realizzare se John von Neumann (un altro matematico) non avesse proposto la sua architettura . L'architettura di von Neumann \u00b6 Le architetture precedenti alla definizione della macchina di von Neumann sono anche conosciute come architetture non programmabili . Questo implica che queste macchine, a meno di non procedere al ricablaggio manuale della logica \"insita\" all'interno delle stesse, non potevano modificare il loro funzionamento: per fare un esempio un po' \"estremo\", un calcolatore pensato per effettuare le addizioni non poteva essere usato per svolgere le divisioni! Nota Questo esempio \u00e8 volutamente \"estremo\": anche le calcolatrici pi\u00f9 basilari implementano per lo meno le quattro operazioni aritmetiche fondamentali. Il modello proposto da John von Neumann, quindi, \u00e8 quello unanimamente riconosciuto come la base sulla quale sono basate le moderne architture dei calcolatori, ed ha avuto un ruolo fondamentale nella definizione del paradigma di stored-program computer , ovvero di macchine riprogrammabili . L'architettura di von Neumann, mostrata nell'immagine precedente, consta di quattro entit\u00e0 fondamentali, ovvero: una Central Processing Unit , pi\u00f9 comunemente nota come CPU, a sua volta composta da una Control Unit (CU) ed una Arithmetic Logic Unit (ALU); una unit\u00e0 di memoria; uno o pi\u00f9 dispositivi di input ed output ; un bus di comunicazione . Vediamo nel dettaglio ciascuna di queste parti. TODO: da qui Central Processing Unit \u00b6 Componenti fondamentali \u00b6 La CPU \u00e8 il \"cuore\" della macchina di von Neumann, ed \u00e8 a sua volta divisa in due parti: una control unit , responsabile per il prelievo (fetch) e decodifica (decode) delle istruzioni; una processing unit , responsabile dell'esecuzione delle operazioni aritmetiche e logiche. La control unit contiene al suo interno due registri (ovvero piccole sezioni di memoria rapidamente accessibili) fondamentali, ovvero: il Current Instruction Register ( CIR ), che contiene l'istruzione attualmente in esecuzione; il Program Counter , che contiene l'indirizzo dell'istruzione successiva del programma in esecuzione. La processing unit \u00e8 invece composta da: una Arithmetic Logic Unit ( ALU ), ovvero l'unit\u00e0 delegata alla gestione delle operazioni aritmetiche e logiche; una serie di registri che memorizzano le operazioni fondamentali e pi\u00f9 utilizzate dalla macchina. Alcune varianti della CPU prevedono anche la presenza di un segnale di clock. Memoria \u00b6 Rappresenta la memoria \"centrale\" del sistema, di lavoro. Il suo ruolo \u00e8 assimilabile a quello delle RAM , in quanto contiene tutti i dati e le istruzioni necessarie alla corretta esecuzione del programma attuale. E' importante non confondere questa memoria con la memoria di massa (ovvero gli hard disk o gli SSD), nella quale sono immagazzinati i dati ed i programmi quando questi non sono in uso. La memoria dialoga principalmente con la CPU, ed il suo compito consiste nell'agire da \"magazzino\", accessibile in maniera rapida (anche se non tanto rapida quanto i registri) dalla CPU, allo scopo di recuperare i dati necessari all'esecuzione del programma attuale. Dispositivi di Input/Output \u00b6 Sono i dispositivi con cui, rispettivamente, sono forniti dati e programmi alla CPU (Input) e vengono restituiti dalla CPU i risultati dell'elaborazione . E' interessante notare come una memoria di massa possa fungere sia da dispositivo di input, sia da dispositivo di output. Bus \u00b6 Il bus \u00e8 il mezzo con cui i vari componenti della macchina di von Neumann comunicano tra loro. TODO: Funzionamento \u00b6 Esecuzione di programmi \u00b6 La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite Ciclo Fetch-Decode-Execute \u00b6 L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati FINE TODO: L'importanza della macchina di von Neumann \u00b6 I primi computer \u00b6 I primi computer non avevano una memoria propriamente intesa: i programmi infatti erano spesso \"cablati\" nella logica della macchina. Di conseguenza, un computer progettato per eseguire (ad esempio) determinati calcoli matematici, non poteva essere usato per scrivere, a meno di riprogrammarlo . Questo significava ovviamente imbarcarsi in una procedura lunga, tediosa e complessa, spesso con implicazioni anche di tipo meccanico (ovvero, necessit\u00e0 di ricablare i collegamenti tra le diverse parti della macchina). Per fare un esempio, modificare il programma in esecuzione su una macchina ENIAC (il primo computer general-purpose ) richiedeva circa tre settimane. La macchina di von Neumann permise di superare questo limite introducendo il concetto di stored-program computer , inteso come calcolatore in grado di memorizzare le istruzioni da eseguire in forma elettronica, ottica, o comunque facilmente accessibile . Questo, ovviamente, derivava dalla struttura stessa della macchina, che non implicava una completa integrazione di CPU e memoria, le quali erano bens\u00ec separate ed indipendenti. Va da s\u00e9 che riscrivere la memoria non comportava la riprogrammazione completa della CPU, con un notevole vantaggio in termini di accessibilit\u00e0 e riprogrammabilit\u00e0 del calcolatore. Il collo di bottiglia di von Neumann \u00b6 La macchina di von Neumann soffre di un notevole limite, legato principalmente al rapporto tra la velocit\u00e0 della CPU ed il transfer rate della memoria. Il problema principale \u00e8 legato al fatto che, nel corso del tempo, la velocit\u00e0 delle CPU \u00e8 aumentata seguendo per molti anni la cosiddetta legge di Moore , mentre le evoluzioni delle memorie si sono concentrate sulla loro densit\u00e0 (ovvero sul quantitativo di memoria disponibile) piuttosto che sul throughput (ovvero sul quantitativo di dati che \u00e8 possibile trasferire dalla memoria verso la CPU). Questo fenomeno \u00e8 detto collo di bottiglia di von Neumann , o von Neumann bottleneck . La conseguenza di questo fenomeno sta nel fatto che le CPU elaborano troppe informazioni rispetto a quelle che la memoria pu\u00f2 inviare , e quindi i processori si ritrovano a \"dover attendere\" le istruzioni fornite dalla memoria, lasciando che preziosi cicli di clock passino inutilizzati. Per mitigare questo fenomeno, nel tempo sono stati elaborati diversi approcci, come: creare delle memorie cache , di dimensioni limitate rispetto alle RAM, ma comunque molto pi\u00f9 veloci; fare in modo che dati ed istruzioni viaggino su percorsi differenti, riducendo la congestione sul bus; usare degli algoritmi di branch prediction , che tentano di prevedere quali istruzioni saranno usate successivamente, precaricandole dalla memoria. Nonostante questi \"escamotage\", per\u00f2, la soluzione al von Neumann bottleneck arriv\u00f2 introducendo un'altra architettura. L'architettura Harvard \u00b6 Inizialmente implementata sulla macchina Harvard Mark I , l' architettura Harvard venne introdotta per superare i limiti imposti dal modello di von Neumann, separando la memoria dedicata ai programmi ( instruction memory ) da quella dedicata ai dati ( data memory ). Differenze con l'architettura di von Neumann \u00b6 L'architettura Harvard permette di superare il collo di bottiglia intrinseco nell'architettura di von Neumann permettendo alla CPU di leggere un'istruzione contemporaneamente all'accesso ai dati, anche senza utilizzare una cache; ci\u00f2 significa che, al costo di una complessit\u00e0 circuitale superiore, un computer basato su architettura Harvard \u00e8 pi\u00f9 veloce di uno basato sull'architettura di von Neumann. L'architettura Harvard modificata \u00b6 Una architettura Harvard modificata \u00e8 definita in modo molto vago, ma vi sono tre diverse possibilit\u00e0. Queste architetture sono la Split Cache , access Instruction Memory as Data , e Read Instructions from Data Memory . Access Instruction Memory as Data \u00b6 Questa architettura ricorda l'architettura Harvard standard, ma con uno speciale insieme di istruzioni che permettono di leggere le costanti dalla memoria legata A modified Harvard architecture machine is very much like a Harvard architecture machine, but it relaxes the strict separation between instruction and data while still letting the CPU concurrently access two (or more) memory buses. The most common modification includes separate instruction and data caches backed by a common address space. While the CPU executes from cache, it acts as a pure Harvard machine. When accessing backing memory, it acts like a von Neumann machine (where code can be moved around like data, which is a powerful technique). This modification is widespread in modern processors, such as the ARM architecture, Power ISA and x86 processors. It is sometimes loosely called a Harvard architecture, overlooking the fact that it is actually \"modified\".","title":"L'architettura dei calcolatori"},{"location":"02_dispense/01_introduttivi/03_architettura/#larchitettura-dei-calcolatori","text":"","title":"L'architettura dei calcolatori"},{"location":"02_dispense/01_introduttivi/03_architettura/#un-po-di-storia","text":"Le origini del concetto di calcolatore (o, nell'accezione comune del termine, computer ) possono essere fatte risalire alla storia antica, con invenzioni come l' abaco , ovvero dei veri e propri strumenti di supporto che permettevano all'operatore umano di svolgere in maniera pi\u00f9 rapida calcoli anche complessi. Il calcolatore si \u00e8 poi evoluto in et\u00e0 moderna: si \u00e8 passati dalle prime sperimentazioni, come le macchine di Pascal e di Leibniz, alle prime calcolatrici , per arrivare al primo modello (teorico) di dispositivo programmabile , ovvero in grado di adattarsi a compiti anche molto diversi tra loro, che si deve al matematico britannico Charles Babbage con la sua Macchina Analitica, progettata nel 1833, e considerata il primo progetto di computer nella storia. Nei decenni successivi, vennero introdotti diversi tipi di calcolatori analogici. Successivamente, si pass\u00f2 alla concettualizzazione della macchina di Turing , per poi arrivare ai computer meccanici ed elettromeccanici, ed infine alle architetture digitali ed elettroniche, basate su transistor e circuiti integrati ad altissima densit\u00e0. Le prossime frontiere sono probabilmente quelle dettate dal quantum computing , che potrebbero rivoluzionare completamente l'idea attuale di elaborazione, rendedo vetusta qualsiasi applicazione dell'informatica odierna. Tuttavia, nessuno degli scenari verificatisi negli ultimi 80 anni si sarebbe potuto realizzare se John von Neumann (un altro matematico) non avesse proposto la sua architettura .","title":"Un po' di storia"},{"location":"02_dispense/01_introduttivi/03_architettura/#larchitettura-di-von-neumann","text":"Le architetture precedenti alla definizione della macchina di von Neumann sono anche conosciute come architetture non programmabili . Questo implica che queste macchine, a meno di non procedere al ricablaggio manuale della logica \"insita\" all'interno delle stesse, non potevano modificare il loro funzionamento: per fare un esempio un po' \"estremo\", un calcolatore pensato per effettuare le addizioni non poteva essere usato per svolgere le divisioni! Nota Questo esempio \u00e8 volutamente \"estremo\": anche le calcolatrici pi\u00f9 basilari implementano per lo meno le quattro operazioni aritmetiche fondamentali. Il modello proposto da John von Neumann, quindi, \u00e8 quello unanimamente riconosciuto come la base sulla quale sono basate le moderne architture dei calcolatori, ed ha avuto un ruolo fondamentale nella definizione del paradigma di stored-program computer , ovvero di macchine riprogrammabili . L'architettura di von Neumann, mostrata nell'immagine precedente, consta di quattro entit\u00e0 fondamentali, ovvero: una Central Processing Unit , pi\u00f9 comunemente nota come CPU, a sua volta composta da una Control Unit (CU) ed una Arithmetic Logic Unit (ALU); una unit\u00e0 di memoria; uno o pi\u00f9 dispositivi di input ed output ; un bus di comunicazione . Vediamo nel dettaglio ciascuna di queste parti. TODO: da qui","title":"L'architettura di von Neumann"},{"location":"02_dispense/01_introduttivi/03_architettura/#central-processing-unit","text":"","title":"Central Processing Unit"},{"location":"02_dispense/01_introduttivi/03_architettura/#componenti-fondamentali","text":"La CPU \u00e8 il \"cuore\" della macchina di von Neumann, ed \u00e8 a sua volta divisa in due parti: una control unit , responsabile per il prelievo (fetch) e decodifica (decode) delle istruzioni; una processing unit , responsabile dell'esecuzione delle operazioni aritmetiche e logiche. La control unit contiene al suo interno due registri (ovvero piccole sezioni di memoria rapidamente accessibili) fondamentali, ovvero: il Current Instruction Register ( CIR ), che contiene l'istruzione attualmente in esecuzione; il Program Counter , che contiene l'indirizzo dell'istruzione successiva del programma in esecuzione. La processing unit \u00e8 invece composta da: una Arithmetic Logic Unit ( ALU ), ovvero l'unit\u00e0 delegata alla gestione delle operazioni aritmetiche e logiche; una serie di registri che memorizzano le operazioni fondamentali e pi\u00f9 utilizzate dalla macchina. Alcune varianti della CPU prevedono anche la presenza di un segnale di clock.","title":"Componenti fondamentali"},{"location":"02_dispense/01_introduttivi/03_architettura/#memoria","text":"Rappresenta la memoria \"centrale\" del sistema, di lavoro. Il suo ruolo \u00e8 assimilabile a quello delle RAM , in quanto contiene tutti i dati e le istruzioni necessarie alla corretta esecuzione del programma attuale. E' importante non confondere questa memoria con la memoria di massa (ovvero gli hard disk o gli SSD), nella quale sono immagazzinati i dati ed i programmi quando questi non sono in uso. La memoria dialoga principalmente con la CPU, ed il suo compito consiste nell'agire da \"magazzino\", accessibile in maniera rapida (anche se non tanto rapida quanto i registri) dalla CPU, allo scopo di recuperare i dati necessari all'esecuzione del programma attuale.","title":"Memoria"},{"location":"02_dispense/01_introduttivi/03_architettura/#dispositivi-di-inputoutput","text":"Sono i dispositivi con cui, rispettivamente, sono forniti dati e programmi alla CPU (Input) e vengono restituiti dalla CPU i risultati dell'elaborazione . E' interessante notare come una memoria di massa possa fungere sia da dispositivo di input, sia da dispositivo di output.","title":"Dispositivi di Input/Output"},{"location":"02_dispense/01_introduttivi/03_architettura/#bus","text":"Il bus \u00e8 il mezzo con cui i vari componenti della macchina di von Neumann comunicano tra loro. TODO:","title":"Bus"},{"location":"02_dispense/01_introduttivi/03_architettura/#funzionamento","text":"","title":"Funzionamento"},{"location":"02_dispense/01_introduttivi/03_architettura/#esecuzione-di-programmi","text":"La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite","title":"Esecuzione di programmi"},{"location":"02_dispense/01_introduttivi/03_architettura/#ciclo-fetch-decode-execute","text":"L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati FINE TODO:","title":"Ciclo Fetch-Decode-Execute"},{"location":"02_dispense/01_introduttivi/03_architettura/#limportanza-della-macchina-di-von-neumann","text":"","title":"L'importanza della macchina di von Neumann"},{"location":"02_dispense/01_introduttivi/03_architettura/#i-primi-computer","text":"I primi computer non avevano una memoria propriamente intesa: i programmi infatti erano spesso \"cablati\" nella logica della macchina. Di conseguenza, un computer progettato per eseguire (ad esempio) determinati calcoli matematici, non poteva essere usato per scrivere, a meno di riprogrammarlo . Questo significava ovviamente imbarcarsi in una procedura lunga, tediosa e complessa, spesso con implicazioni anche di tipo meccanico (ovvero, necessit\u00e0 di ricablare i collegamenti tra le diverse parti della macchina). Per fare un esempio, modificare il programma in esecuzione su una macchina ENIAC (il primo computer general-purpose ) richiedeva circa tre settimane. La macchina di von Neumann permise di superare questo limite introducendo il concetto di stored-program computer , inteso come calcolatore in grado di memorizzare le istruzioni da eseguire in forma elettronica, ottica, o comunque facilmente accessibile . Questo, ovviamente, derivava dalla struttura stessa della macchina, che non implicava una completa integrazione di CPU e memoria, le quali erano bens\u00ec separate ed indipendenti. Va da s\u00e9 che riscrivere la memoria non comportava la riprogrammazione completa della CPU, con un notevole vantaggio in termini di accessibilit\u00e0 e riprogrammabilit\u00e0 del calcolatore.","title":"I primi computer"},{"location":"02_dispense/01_introduttivi/03_architettura/#il-collo-di-bottiglia-di-von-neumann","text":"La macchina di von Neumann soffre di un notevole limite, legato principalmente al rapporto tra la velocit\u00e0 della CPU ed il transfer rate della memoria. Il problema principale \u00e8 legato al fatto che, nel corso del tempo, la velocit\u00e0 delle CPU \u00e8 aumentata seguendo per molti anni la cosiddetta legge di Moore , mentre le evoluzioni delle memorie si sono concentrate sulla loro densit\u00e0 (ovvero sul quantitativo di memoria disponibile) piuttosto che sul throughput (ovvero sul quantitativo di dati che \u00e8 possibile trasferire dalla memoria verso la CPU). Questo fenomeno \u00e8 detto collo di bottiglia di von Neumann , o von Neumann bottleneck . La conseguenza di questo fenomeno sta nel fatto che le CPU elaborano troppe informazioni rispetto a quelle che la memoria pu\u00f2 inviare , e quindi i processori si ritrovano a \"dover attendere\" le istruzioni fornite dalla memoria, lasciando che preziosi cicli di clock passino inutilizzati. Per mitigare questo fenomeno, nel tempo sono stati elaborati diversi approcci, come: creare delle memorie cache , di dimensioni limitate rispetto alle RAM, ma comunque molto pi\u00f9 veloci; fare in modo che dati ed istruzioni viaggino su percorsi differenti, riducendo la congestione sul bus; usare degli algoritmi di branch prediction , che tentano di prevedere quali istruzioni saranno usate successivamente, precaricandole dalla memoria. Nonostante questi \"escamotage\", per\u00f2, la soluzione al von Neumann bottleneck arriv\u00f2 introducendo un'altra architettura.","title":"Il collo di bottiglia di von Neumann"},{"location":"02_dispense/01_introduttivi/03_architettura/#larchitettura-harvard","text":"Inizialmente implementata sulla macchina Harvard Mark I , l' architettura Harvard venne introdotta per superare i limiti imposti dal modello di von Neumann, separando la memoria dedicata ai programmi ( instruction memory ) da quella dedicata ai dati ( data memory ).","title":"L'architettura Harvard"},{"location":"02_dispense/01_introduttivi/03_architettura/#differenze-con-larchitettura-di-von-neumann","text":"L'architettura Harvard permette di superare il collo di bottiglia intrinseco nell'architettura di von Neumann permettendo alla CPU di leggere un'istruzione contemporaneamente all'accesso ai dati, anche senza utilizzare una cache; ci\u00f2 significa che, al costo di una complessit\u00e0 circuitale superiore, un computer basato su architettura Harvard \u00e8 pi\u00f9 veloce di uno basato sull'architettura di von Neumann.","title":"Differenze con l'architettura di von Neumann"},{"location":"02_dispense/01_introduttivi/03_architettura/#larchitettura-harvard-modificata","text":"Una architettura Harvard modificata \u00e8 definita in modo molto vago, ma vi sono tre diverse possibilit\u00e0. Queste architetture sono la Split Cache , access Instruction Memory as Data , e Read Instructions from Data Memory .","title":"L'architettura Harvard modificata"},{"location":"02_dispense/01_introduttivi/03_architettura/#access-instruction-memory-as-data","text":"Questa architettura ricorda l'architettura Harvard standard, ma con uno speciale insieme di istruzioni che permettono di leggere le costanti dalla memoria legata A modified Harvard architecture machine is very much like a Harvard architecture machine, but it relaxes the strict separation between instruction and data while still letting the CPU concurrently access two (or more) memory buses. The most common modification includes separate instruction and data caches backed by a common address space. While the CPU executes from cache, it acts as a pure Harvard machine. When accessing backing memory, it acts like a von Neumann machine (where code can be moved around like data, which is a powerful technique). This modification is widespread in modern processors, such as the ARM architecture, Power ISA and x86 processors. It is sometimes loosely called a Harvard architecture, overlooking the fact that it is actually \"modified\".","title":"Access Instruction Memory as Data"},{"location":"02_dispense/01_introduttivi/03_flow_chart/","text":"","title":"03 flow chart"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/","text":"Rappresentare il mondo in forma binaria \u00b6 Le informazioni contenute all'interno di un calcolatore, siano esse dati o istruzioni, sono rappresentate in forma binaria come sequenze finite di simboli 0 ed 1 . Questa notazione permette di definire una delle nozioni fondamentali su cui \u00e8 basata l'informatica, ovvero quella di bit , contrazione di binary digit (cifra binaria): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero). Conseguentemente, \u00e8 possibile definire un'altra nozione fondamentale, ovvero quella di byte , associata ad una sequenza (arbitraria) di otto bit. E' facile verificare che un byte pu\u00f2 assumere uno tra \\(2^8\\) possibili valori. Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso). I dati numerici \u00b6 Rappresentazione di numeri interi \u00b6 Finitezza \u00b6 I calcolatori sono dispositivi reali , ed in grado quindi di elaborare esclusivamente informazioni finite ; pi\u00f9 nello specifico, laddove il mondo reale \u00e8 analogico , e quindi continuo , il mondo \"comprensibile\" dai calcolatori \u00e8 digitale , e quindi \u00e8 una versione discretizzata del mondo reale. Ci\u00f2 comporta che, parlando di numeri interi rappresentabili in un calcolatore, si sta in realt\u00e0 parlando di un'approssimazione finita dell'insieme dei numeri naturali \\(\\mathbb{N}\\) : l'estensione di questa rappresentazione dipende dall'architettura del calcolatore. Ad esempio, la maggior parte dei calcolatori odierni accetta come limite massimo il valore di \\(2^64\\) , pari \\(18.446.744.073.709.551.616\\) (abbastanza per rappresentare il numero massimo di amici che potete avere su Facebook, plausibilmente). Da decimale a binario \u00b6 Siamo abituati a pensare (ed usare) i numeri interi usando una notazione di tipo decimale e posizionale . Ci\u00f2 significa che: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato. Un esempio \u00b6 In generale, sia \\(N\\) un generico numero intero composto da \\(n\\) simboli. Usando la notazione decimale e posizionale \u00e8 possibile esprimerlo come segue: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n *b^n + a_{n-1}* b^{n-1} + ... + a_1 * b + a_0 \\] Per fare un semplice esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\] Conversione \u00b6 Supponiamo di voler rappresentare \\(N = 485\\) in forma binaria (ovvero in base \\(2\\) ). Dovremo procedere dividendo \\(N\\) per la nostra base \\(b = 2\\) , valutare il resto \\(r\\) , che sar\u00e0 di volta in volta il valore meno significativo del nostro numero in forma binaria, e reiterare l'operazione usando il quoziente \\(q\\) . Otteniamo quindi: \\[ \\begin{eqnarray} 485/2 &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ 242/2 &\\Rightarrow q = 121 & r = 0 \\\\ 121/2 &\\Rightarrow q = 60 & r = 1 \\\\ 60/2 &\\Rightarrow q = 30 & r = 0 \\\\ 30/2 &\\Rightarrow q = 15 & r = 0 \\\\ 15/2 &\\Rightarrow q = 7 & r = 1 \\\\ 7/2 &\\Rightarrow q = 3 & r = 1 \\\\ 3/2 &\\Rightarrow q = 1 & r = 1 \\\\ 1/2 &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo). Segno \u00b6 E' importante ricordare che i numeri interi possono essere dotati di segno; questo \u00e8, ovviamente, un fattore di cui va tenuto conto nella rappresentazione del numero stesso, ed \u00e8 legato al fatto che il calcolatore pu\u00f2 contenere solo un quantitativo finito di infomrazione. Immaginiamo infatti che il computer utilizzi una word di \\(W\\) bit per memorizzare gli interi; ci\u00f2 significa che sar\u00e0 possibile memorizzare al pi\u00f9 \\(2^W\\) valori. Nel caso si considerino tutti i valori positivi (includendo nel conteggio \"per convenzione\" anche lo \\(0\\) ), il calcolatore potr\u00e0 rappresentare tutti i numeri che vanno da \\(0\\) a \\(2^W-1\\) . Questa situazione, per\u00f2, cambia nel caso si voglia considerare il segno del numero. Infatti, supponendo di suddividere l'intervallo considerato in valori negativi e valori positivi, il calcolatore sar\u00e0 in grado di rappresentare sempre \\(2^W\\) valori, ma met\u00e0 di questi saranno negativi, mentre l'altra met\u00e0 sar\u00e0 composta da valori positivi. Ci\u00f2 ha come diretta conseguenza il fatto che il range dei numeri rappresentati varia da \\(-2^{W-1}\\) a \\(2^{W-1}-1\\) . Per fare un esempio pratico, supponendo un valore di \\(W = 8\\) , avremo che: se consideriamo solo gli interi positivi, potremo rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^8-1\\) ; se consideriamo anche i valori negativi, potremo rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{W-1}\\) e \\(127 = -2^{W-1}-1\\) . Rappresentazione di numeri reali \u00b6 Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) pu\u00f2 essere rappresentato all'interno di un calcolatore esclusivamente mediante un'approssimazione finita. Per trovare quest'approssimazione, occorre considerare che ogni numero reale \u00e8 composto da una parte intera \\(r\\) ed una parte frazionaria \\(f\\) . Rappresentazione a virgola fissa \u00b6 Supponiamo di avere a disposizione parole composte da \\(W\\) bit. Nella rappresentazione a virgola fissa (o fixed point ) di un numero \\(N\\) , usiamo un numero fisso di bit (ovvero \\(W_r\\) ) per la parte intera di \\(N\\) , ed i rimanenti bit ( \\(W_f\\) ) per la rappresentazione della parte frazionaria. Ovviamente, questa rappresentazione ha lo svantaggio di essere poco flessibile, e le viene spesso preferita quella a virgola mobile . Rappresentazione a virgola mobile \u00b6 La modalit\u00e0 di rappresentazione di un numero reale maggiormente diffusa \u00e8 quella a virgola mobile ( floating point ), che si basa sui concetti di mantissa , ovvero la parte frazionaria di un numero, e caratteristica , o esponente . In particolare, la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_i\\) : \\[ M = n - n_i \\] Ad esempio, la mantissa di \\(5.2\\) \u00e8 pari a \\(0.2\\) . E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . Ne consegue che un numero \\(a\\) \u00e8 rappresentabile in una data base \\(b\\) mediante la seguente relazione: \\[ a = M * b^e \\] Rappresentazione di caratteri \u00b6 Anche i caratteri (ovvero quelli che troviamo normalmente sulle nostre tastiere) possono essere rappresentati in binario. Pi\u00f9 in generale, il concetto di \"carattere\" \u00e8 assimilabile a quello di simbolo , in quanto i calcolatori sono in grado di comprendere simboli che indicano, tra le altre cose, le cifre decimali, la punteggiatura, ed una vasta serie di caratteri speciali (ad esempio, l'underscore, la \"chiocciola\", e via dicendo). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra ogni carattere ed un numero intero. Tale corrispondenza \u00e8 stabilita da standard ben precisi, tra i quali vale la pena di ricordare lo standard ASCII e quello UNICODE. Quest'ultimo \u00e8 particolarmente potente (ed esteso), in quanto permette di codificare la maggior parte dei caratteri conosciuti, compresi quelli di alcune lingue ormai considerate morte (come ad esempio il greco antico). Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri. Essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"04 - Rappresentazione dei dati"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentare-il-mondo-in-forma-binaria","text":"Le informazioni contenute all'interno di un calcolatore, siano esse dati o istruzioni, sono rappresentate in forma binaria come sequenze finite di simboli 0 ed 1 . Questa notazione permette di definire una delle nozioni fondamentali su cui \u00e8 basata l'informatica, ovvero quella di bit , contrazione di binary digit (cifra binaria): Bit Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori 0 (falso) o 1 (vero). Conseguentemente, \u00e8 possibile definire un'altra nozione fondamentale, ovvero quella di byte , associata ad una sequenza (arbitraria) di otto bit. E' facile verificare che un byte pu\u00f2 assumere uno tra \\(2^8\\) possibili valori. Definiamo infine una parola , o word , una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso).","title":"Rappresentare il mondo in forma binaria"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#i-dati-numerici","text":"","title":"I dati numerici"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-di-numeri-interi","text":"","title":"Rappresentazione di numeri interi"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#finitezza","text":"I calcolatori sono dispositivi reali , ed in grado quindi di elaborare esclusivamente informazioni finite ; pi\u00f9 nello specifico, laddove il mondo reale \u00e8 analogico , e quindi continuo , il mondo \"comprensibile\" dai calcolatori \u00e8 digitale , e quindi \u00e8 una versione discretizzata del mondo reale. Ci\u00f2 comporta che, parlando di numeri interi rappresentabili in un calcolatore, si sta in realt\u00e0 parlando di un'approssimazione finita dell'insieme dei numeri naturali \\(\\mathbb{N}\\) : l'estensione di questa rappresentazione dipende dall'architettura del calcolatore. Ad esempio, la maggior parte dei calcolatori odierni accetta come limite massimo il valore di \\(2^64\\) , pari \\(18.446.744.073.709.551.616\\) (abbastanza per rappresentare il numero massimo di amici che potete avere su Facebook, plausibilmente).","title":"Finitezza"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#da-decimale-a-binario","text":"Siamo abituati a pensare (ed usare) i numeri interi usando una notazione di tipo decimale e posizionale . Ci\u00f2 significa che: utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero; sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero. Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\) ; tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato.","title":"Da decimale a binario"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#un-esempio","text":"In generale, sia \\(N\\) un generico numero intero composto da \\(n\\) simboli. Usando la notazione decimale e posizionale \u00e8 possibile esprimerlo come segue: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n *b^n + a_{n-1}* b^{n-1} + ... + a_1 * b + a_0 \\] Per fare un semplice esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\]","title":"Un esempio"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#conversione","text":"Supponiamo di voler rappresentare \\(N = 485\\) in forma binaria (ovvero in base \\(2\\) ). Dovremo procedere dividendo \\(N\\) per la nostra base \\(b = 2\\) , valutare il resto \\(r\\) , che sar\u00e0 di volta in volta il valore meno significativo del nostro numero in forma binaria, e reiterare l'operazione usando il quoziente \\(q\\) . Otteniamo quindi: \\[ \\begin{eqnarray} 485/2 &\\Rightarrow q = 242 & r = 1 & \\Rightarrow LSB\\\\ 242/2 &\\Rightarrow q = 121 & r = 0 \\\\ 121/2 &\\Rightarrow q = 60 & r = 1 \\\\ 60/2 &\\Rightarrow q = 30 & r = 0 \\\\ 30/2 &\\Rightarrow q = 15 & r = 0 \\\\ 15/2 &\\Rightarrow q = 7 & r = 1 \\\\ 7/2 &\\Rightarrow q = 3 & r = 1 \\\\ 3/2 &\\Rightarrow q = 1 & r = 1 \\\\ 1/2 &\\Rightarrow q = 0 & r = 1 & \\Rightarrow MSB \\end{eqnarray} \\] Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da: \\[ N_{2} = (111100101)_2 \\] Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB , acronimo che sta per Least Significant Bit ; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB , acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo).","title":"Conversione"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#segno","text":"E' importante ricordare che i numeri interi possono essere dotati di segno; questo \u00e8, ovviamente, un fattore di cui va tenuto conto nella rappresentazione del numero stesso, ed \u00e8 legato al fatto che il calcolatore pu\u00f2 contenere solo un quantitativo finito di infomrazione. Immaginiamo infatti che il computer utilizzi una word di \\(W\\) bit per memorizzare gli interi; ci\u00f2 significa che sar\u00e0 possibile memorizzare al pi\u00f9 \\(2^W\\) valori. Nel caso si considerino tutti i valori positivi (includendo nel conteggio \"per convenzione\" anche lo \\(0\\) ), il calcolatore potr\u00e0 rappresentare tutti i numeri che vanno da \\(0\\) a \\(2^W-1\\) . Questa situazione, per\u00f2, cambia nel caso si voglia considerare il segno del numero. Infatti, supponendo di suddividere l'intervallo considerato in valori negativi e valori positivi, il calcolatore sar\u00e0 in grado di rappresentare sempre \\(2^W\\) valori, ma met\u00e0 di questi saranno negativi, mentre l'altra met\u00e0 sar\u00e0 composta da valori positivi. Ci\u00f2 ha come diretta conseguenza il fatto che il range dei numeri rappresentati varia da \\(-2^{W-1}\\) a \\(2^{W-1}-1\\) . Per fare un esempio pratico, supponendo un valore di \\(W = 8\\) , avremo che: se consideriamo solo gli interi positivi, potremo rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^8-1\\) ; se consideriamo anche i valori negativi, potremo rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{W-1}\\) e \\(127 = -2^{W-1}-1\\) .","title":"Segno"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-di-numeri-reali","text":"Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) pu\u00f2 essere rappresentato all'interno di un calcolatore esclusivamente mediante un'approssimazione finita. Per trovare quest'approssimazione, occorre considerare che ogni numero reale \u00e8 composto da una parte intera \\(r\\) ed una parte frazionaria \\(f\\) .","title":"Rappresentazione di numeri reali"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-a-virgola-fissa","text":"Supponiamo di avere a disposizione parole composte da \\(W\\) bit. Nella rappresentazione a virgola fissa (o fixed point ) di un numero \\(N\\) , usiamo un numero fisso di bit (ovvero \\(W_r\\) ) per la parte intera di \\(N\\) , ed i rimanenti bit ( \\(W_f\\) ) per la rappresentazione della parte frazionaria. Ovviamente, questa rappresentazione ha lo svantaggio di essere poco flessibile, e le viene spesso preferita quella a virgola mobile .","title":"Rappresentazione a virgola fissa"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-a-virgola-mobile","text":"La modalit\u00e0 di rappresentazione di un numero reale maggiormente diffusa \u00e8 quella a virgola mobile ( floating point ), che si basa sui concetti di mantissa , ovvero la parte frazionaria di un numero, e caratteristica , o esponente . In particolare, la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_i\\) : \\[ M = n - n_i \\] Ad esempio, la mantissa di \\(5.2\\) \u00e8 pari a \\(0.2\\) . E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\) . Ne consegue che un numero \\(a\\) \u00e8 rappresentabile in una data base \\(b\\) mediante la seguente relazione: \\[ a = M * b^e \\]","title":"Rappresentazione a virgola mobile"},{"location":"02_dispense/01_introduttivi/04_rappresentazione/#rappresentazione-di-caratteri","text":"Anche i caratteri (ovvero quelli che troviamo normalmente sulle nostre tastiere) possono essere rappresentati in binario. Pi\u00f9 in generale, il concetto di \"carattere\" \u00e8 assimilabile a quello di simbolo , in quanto i calcolatori sono in grado di comprendere simboli che indicano, tra le altre cose, le cifre decimali, la punteggiatura, ed una vasta serie di caratteri speciali (ad esempio, l'underscore, la \"chiocciola\", e via dicendo). L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra ogni carattere ed un numero intero. Tale corrispondenza \u00e8 stabilita da standard ben precisi, tra i quali vale la pena di ricordare lo standard ASCII e quello UNICODE. Quest'ultimo \u00e8 particolarmente potente (ed esteso), in quanto permette di codificare la maggior parte dei caratteri conosciuti, compresi quelli di alcune lingue ormai considerate morte (come ad esempio il greco antico). Curiosit\u00e0 Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri. Essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.","title":"Rappresentazione di caratteri"},{"location":"02_dispense/02_hardware/02_reti/","text":"Reti di telecomunicazione: cosa sono ed a che servono? \u00b6 Nell'ultima lezione, abbiamo introdotto le principali caratteristiche dell'architettura interna di un calcolatore. Il naturale step successivo \u00e8 quindi chiedersi come possano comunicare tra loro due (o pi\u00f9) calcolatori . Ed \u00e8 a questo scopo che sono state introdotte le reti di telecomunicazione . Alcune definizioni \u00b6 Commutazione di circuito vs. commutazione di pacchetto \u00b6 Le reti a commutazione di circuito stabiliscono una connessione fisica tra il mittente ed il destinatario. Un esempio di rete a commutazione di circuito sono le vecchie reti telefoniche, nelle quali veniva creato appunto un circuito fisico tra i due capi della comunicazione. Le reti a commutazione di pacchetto invece non stabiliscono una connessione fisica tra il mittente ed il destinatario, ma fanno s\u00ec che siano i dispositivi di rete ad instradare i dati, opportunamente suddivisi in pacchetti , tra il mittente ed il destinatario. Topologia di rete \u00b6 Standardizzazione \u00b6 Affinch\u00e9 due calcolatori scambino dati (il che, nel gergo comune, significa \" affinch\u00e8 due computer parlino tra loro \") \u00e8 necessario che entrambi si adeguino ad uno standard di comunicazione. Pensiamoci un attimo: saremmo forse in grado di capire ci\u00f2 che dice il nostro docente di Informatica se non avessimo un protocollo di comunicazione comune? Nota Se alla domanda precedente avete risposto di no , la colpa \u00e8 sicuramente vostra e non del docente di Informatica, che risulta essere chiaro, comprensibile, affabile e disponibile. Lo scambio di dati tra due computer \u00e8 inoltre molto pi\u00f9 complesso rispetto alla comunicazione verbale: infatti, prevede che ciascuno dei due computer sia in grado di: presentare i dati scambiati all'utente finale; identificare sia il mittente sia il destinatario dei dati stessi; codificare i dati sotto forma di segnale fisico da inviare su degli opportuni canali di comunicazione fisici. E' inoltre necessario che la comunicazione sia indipendente dal tipo di dispositivo utilizzato: se ci pensate, alcuni di voi seguono le lezioni da un iPad, altri dal proprio smartphone, altri ancora dal proprio laptop o PC desktop. Abbiamo quindi una serie di vincoli da rispettare affinch\u00e9 due o pi\u00f9 dispositivi comunichino. Ed \u00e8 stato proprio questo il punto di partenza dal quale \u00e8 stato definito un modello concettuale volto a caratterizzare e standardizzare la comunicazione tra dispositivi, indipendentemente dalle tecnologie adottate, ovvero il modello ISO/OSI . Il modello ISO/OSI \u00b6 OSI \u00e8 un acronimo che sta per Open Systems Interconnection , ed indica un modello sviluppato tenendo come obiettivo finale l'interoperabilit\u00e0 di diversi sistemi di comunicazione grazie a protocolli di comunicazione standardizzati . La storia del modello OSI nasce negli anni '70, in cui venne sviluppato per supportare la standardizzazione dei diversi tipi di rete di calcolatori emergenti. Negli anni '80, il modello venne adottato dall' International Organization for Standardization ( ISO ), ed assunse il nome di modello ISO/OSI . Il modello ISO/OSI suddivide il flusso dei dati in un sistema di comunicazione in sette diversi livelli ad astrazione crescente, partendo dall'implementazione fisica della trasmissione dei bit sul canale comunicativo, per arrivare alla rappresentazione dei dati ad alto livello (ovvero quello che viene \"presentato\" all'utente). E' importante sottolineare alcune caratteristiche del modello ISO/OSI. In primis, per quello che riguarda una singola macchina, ogni layer comunica esclusivamente con: il livello sottostante, di cui sfrutta le funzionalit\u00e0; il livello sovrastante, cui fornisce una serie di funzionalit\u00e0; Nella comunicazione tra due macchine, invece, ogni layer comunica con il suo pari ( peer ): ad esempio, il layer fisico della macchina A parler\u00e0 soltanto con il layer fisico della macchina B; il layer di rete della macchina A solo con quello di rete della macchina B, e via dicendo. I livelli del modello ISO/OSI \u00b6 Diamo ora una panoramica dei diversi livelli descritti dal modello. Livello 1: Livello fisico \u00b6 Il layer fisico \u00e8 responsabile per la trasmissione e ricezione di dati grezzi ( raw ) tra due dispositivi. Per farlo, sfrutta un mezzo di trasmissione fisico (come ad esempio una guida d'onda o delle onde radio). La sua funzione principale \u00e8 quella di convertire i bit digitali in segnali di tipo elettrico, radio od ottico. Le specifiche del layer includono caratteristiche come livelli di tensione da utilizzare, bit rate, distanza massima di trasmissione, schema di modulazione dei dati e via dicendo. Permette inoltre di definire tre modalit\u00e0 di trasmissione su un canale: simplex : in questo caso, la trasmissione \u00e8 monodirezionale, senza che il ricevitore si alterni con il trasmettitore (e viceversa); half-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, ma il ricevitore si alterna con il trasmettitore (ovvero, la comunicazione non pu\u00f2 avvenire contemporaneamente in entrambe le direzioni); full-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, e la comunicazione pu\u00f2 avvenire contemporaneamente in entrambe le direzioni. Questi includono dei pin, tensioni, impedenze di linea, specifiche dei cavi, timing del segmale e frequenza per i dispositivi wireless. Il controllo del bit rate \u00e8 fatto a livello fisico e pu\u00f2 definire delle modalit\u00e0 di trasmissione come simplex , half-duplex o full duplex. Livello 2: Livello data link \u00b6 Il livello data link \u00e8 quello che si occupa di stabilire un \"collegamento\" tra due diversi nodi. In particolare: individua e corregge gli errori che avvengono a livello fisico; definisce come vengono instaurate e terminate le connessioni; controlla il flusso dati. Il progetto IEEE 802 \u00b6 Il progetto IEEE 802 definisce, relativamente soprattutto al livello data link, un insieme di standard per le reti locali, in inglese Local Area Networks ( LAN ). In tal senso, la definizione data dal progetto IEEE 802 di rete locale \u00e8 la seguente: Quote Una LAN \u00e8 un sistema di comunicazione che permette ad apparecchiature indipendenti di comunicare fra loro entro un'area delimitata usando un canale fisico a velocit\u00e0 elevata e con basso tasso di errore. Notiamo che la LAN non \u00e8 quindi limitata nell'ambito (domestico, commerciale, industriale) n\u00e9 nelle tecnologie utilizzate: gli unici limiti sono l'area di interesse (giocoforza limitata), velocit\u00e0 ed affidabilit\u00e0 della comunicazione. Il progetto IEEE 802 ha quindi suddiviso il livello data link in due diversi sottolivelli: il livello Medium Access Control ( MAC ) verifica come i dispositivi di rete accedono al mezzo fisico; il livello Logical Link Control ( LLC ) controlla gli errori e sincronizza i frame. Concretamente, esistono diversi protocolli definiti nell'ambito del progetto IEEE 802, che sono usati nelle comunicazioni di tutti i giorni. Un esempio sono le reti Ethernet, che aderiscono allo standard 802.3, e le reti WiFi, che aderiscono a diverse versioni dello standard 802.11 (arrivato di recente alla revisione p ). Livello 3: livello di rete \u00b6 Il livello di rete definisce come trasferire sequenze di lunghezza arbitraria ( pacchetti ) tra due nodi connessi in reti differenti, laddove per rete si potrebbe intendere sia una singola LAN, sia l'interconnessione di diverse LAN. E' sul concetto di rete che \u00e8 necessario focalizzarsi. Infatti, ogni dispositivo in rete \u00e8 comunemente detto nodo , e pu\u00f2 trasferire messaggi agli altri nodi semplicemente specificando l'indirizzo degli stessi (oltre che ovviamente il messaggio); saranno i dispositivi di rete a trovar eil modo di consegnare il messaggio al destiantario, magari instradandolo attraverso i nodi intermedi. Notiamo anche che la consegna dei messaggi a livello di rete non \u00e8 strettamente affidabile ; questo comporta quindi che i messaggi potrebbero essere persi, ed \u00e8 quindi necessario prevedere altri meccanismi per garantire l'affidabilit\u00e0 della comunicazione. Livello 4: livello di trasporto \u00b6 Il livello di trasporto \u00e8 quello delegato a garantire questa affidabilit\u00e0 mediante opportuni meccanismi di controllo di flusso e di errore. Il modello ISO/OSI definisce cinque classi di protocolli a livello di trasporto, in base ai tipi di meccanismi di controllo dell'affidabilit\u00e0. Si va dalla classe TP0 , progettata per essere implementata su connessioni supposte error-free , ed i cui protocolli non forniscono alcun meccanismo per la gestione degli errori, fino alla classe TP4 , che \u00e8 quella che ricorda pi\u00f9 da vicino i protocolli maggiormente usati a livello di trasporto in Internet. Livello 5: livello di sessione \u00b6 Il livello di sessione si occupa di controllare il \"dialogo\", ovvero le connessioni , tra i diversi computer, gestendone, tra le altre cose, l'inizializzazione e la chiusura. Livello 6: livello di presentazione \u00b6 Nel modello ISO/OSI, il livello di presentazione si occupa di stabilire un contesto tra due diverse entit\u00e0, all'interno del quale le due possono comunicare pur usando semantica e sentassi differenti . Il livello di presentazione funziona quindi un po' come un traduttore : fa in modo che due applicazioni, anche differenti, siano in grado di comunicare tra loro, fornendo una sorta di \"dizionario\" (o, pi\u00f9 correttamente, mappatura ) tra i linguaggi da loro compresi. E' anche per questo motivo che alle volte il livello di presentazione \u00e8 anche chiamato syntax layer . Oltre alla funzione di mapping, il livello di presentazione ne offre anche di altre, tra cui quella pi\u00f9 importante \u00e8 quella delegata alla compressione dei dati. Livello 7: Livello applicativo \u00b6 Il livello applicativo \u00e8 quello pi\u00f9 vicino all'utente, ed interagisce direttamente con gli applicativi software da questo utilizzati. E' importante sottolineare che la specifica di questi programmi ricade al di fuori dell'ambito del modello ISO/OSI ; di conseguenza, le specifiche (ad esempio) del browser o di un'app per smartphone non saranno mai dettate dallo standard. Quest'ultima considerazione ci permette di distinguere tra applicazione ed entit\u00e0 legata all'applicazione: ad esempio, in un sito di prenotazione degli alberghi ci possono essere due entit\u00e0, una che usa un protocollo a livello applicativo per comunicare con gli utenti, ed un'altra che usa un protocollo a livello applicativo per salvare i dati su un database remoto. Nessuna di queste due entit\u00e0 ha per\u00f2 a che fare con l'applicazione stessa, che \u00e8 definita dalla logica di business (in questo caso, la prenotazione degli alberghi). Lo standard del mondo reale: lo stack TCP/IP \u00b6 Il modello ISO/OSI non trova riscontro diretto nelle applicazioni reali: piuttosto, \u00e8 l' Internet Protocol Suite , o stack TCP/IP , lo stack protocollare usato ed implementato su Internet. Come vedremo, la denominazione stack TCP/IP deriva direttamente dal nome dei due principali protocolli su cui \u00e8 basato lo stack, ovvero il Transmission Control Protocol ( TCP ) e l' Internet Protocol ( IP ). I livelli dello stack TCP/IP \u00b6 A differenza del modello ISO/OSI, lo stack TCP/IP \u00e8 organizzato in quattro diversi livelli, pi\u00f9 o meno riconducibili a quelli dell'ISO/OSI. Questi sono, dal pi\u00f9 basso al pi\u00f9 alto, il livello link , il livello internet , il livello trasporto ed il livello applicativo . Vediamoli di seguito. Livello 1: Livello link \u00b6 Il livello link si occupa di gestire la connessione limitatamente all'ambito della rete locale cui un host \u00e8 collegato. Il link , o collegamento , include quindi tutti gli host che \u00e8 possibile raggiungere senza dover coinvolgere un router (che \u00e8 il dispositivo che permette la connessione tra diverse reti locali). Va da s\u00e9 che la dimensione del link \u00e8 determinata dal progetto della rete stessa. Nel confronto con il modello ISO/OSI, il livello link racchiude le funzionalit\u00e0 corrispondenti a quelle del secondo layer (ovvero il data link ). E' importante sottolieare come l'effettiva implementazione del progetto IEEE 802 sia avvenuta proprio a questo livello. Livello 2: Livello internet \u00b6 La comunicazione tra diverse reti richiede che i dati siano correttamente instradati dalla rete iniziale a quella di destinazione, secondo un processo chiamato routing e supportato dall'identificazione degli indirizzi degli host coinvolti mediante il sistema degli indirizzi IP . Il livello internet fornisce una comunicazione non affidabile su reti differenti, garantendo l'inoltro dei pacchetti mediante dei dispositivi chiamati router. Il livello permette quindi l'interoperabilit\u00e0 di reti eterogenee, e definisce Internet nel modo in cui la conosciamo oggi. Il protocollo principale usato a questo livello \u00e8 l' Internet Protocol , che definisce due diversi sistemi di indirizzamento per l'identificazione degli host sulla rete. Il sistema originario di indirizzamento \u00e8 chiamato Internet Protocol version 4 ( IPv4 ), ed usa un indirizzo a 32 bit per identificare un numero massimo di \\(2^32\\) host. Ovviamente, con il progressivo diffondersi delle reti di telecomunicazione, questo valore ha rappresentato un limite, che \u00e8 stato dapprima arginato inserendo diverse classi di indirizzi riservati alle macchine interne ad ogni LAN, per poi essere superato nel 1998 mediante la standardizzazione dell'Internet Protocol version 6 (IPv6), che usa indirizzi a 128 bit. Tuttavia, nonostante le schede di rete in grado di supportare IPv6 esistano dal 2006 circa, l'IPv4 \u00e8 ancora il protocollo di comunicazione maggiormente utilizzato. Livello 3: Livello di trasporto \u00b6 Il livello di trasporto permette di creare dei \"canali dati\", che le applicazioni usano per lo scambio di messaggi specifici per determinati task. La connettivit\u00e0 pu\u00f2 essere implementata sia come connection-oriented , mediante il protocollo TCP, o connectionless , mediante il protocollo UDP. E' possibile fornire canali di trasmissione specifici per diversi processi mediante il concetto di porta di rete , ovvero la creazione di un costrutto logico numerico allocato specificamente per ognuno dei canali di comunicazione necessari. E' importante notare come, per molti servizi, questi numeri di porta siano stati standardizzati, in modo che i computer client possano indirizzare servizi specifici senza necessitare di tecniche di service discovery . Ad esempio, l'utilizzo standard del protocollo HTTP prevede il coinvolgimento della porta 80, mentre il protocollo SSH la porta 22. Il layer di trasporto dello stack TCP/IP corrisponde approssimativamente al quarto livello del modello OSI, chiamato transport layer. Trasmission Control Protocol \u00b6 Il protocollo TCP \u00e8 un protocollo connection-oriented che risolve i problemi di affidabilit\u00e0 che possono riscontrarsi nella fornitura di un flusso di byte affidabile. In particolare, il TCP garantisce che: i dati arrivino in ordine; i dati siano correttamente ricevuti; i dati duplicati siano scartati; i pacchetti persi o scartati siano nuovamente inviati; la congestione del traffico sia adeguatamente controllata. User Datagram Protocol \u00b6 Il protocollo UDP ( User Datagram Protocol ) \u00e8, a differenza del TCP, un protocollo connectionless , e si occupa di fornire una trasmissione dati non affidabile ma, non includendo il controllo degli errori tipico di TCP, pi\u00f9 veloce. L'UDP \u00e8 tipicamente usato per applicazioni legate allo streaming (audio, video e VoIP), dove l'arrivo in tempo dei dati \u00e8 pi\u00f9 importante dell'effettiva consegna degli stessi. Altri tipi di applicazioni sono quelle che prevedono esclusivamente semplici cicli di richiesta/risposta. Livello 4: Livello applicativo \u00b6 Il livello applicativo include i protocolli usati dalla maggior part edelle applicazioni per fornire servizi all'utente. Questi possono includere servizi di supporto di rete, come protocolli per il routing e la configurazione di rete. Un esempio di protocollo a livello applicativo sono l*Hypertext Transfer Protocol* ( HTTP ). I dati codificati secondo i protocolli a livello applicativo vengono quindi incapsulati in unit\u00e0 a livello di trasporto (ad esempio, in formato TCP o UDP), per poi venire ulteriormente incapsulati man mano che si scende verso il layer fisico. E' interessante notare come lo stack TCP/IP non specifichi la formattazione e la presentazione dei dati, e non definisca dei layer aggiuntivi tra quello applicativo e di trasporto. Per quello che riguarda la comunicazione con il livello di trasporto (e quelli sottostanti), il livello applicativo tratta quest'ultimo come una black box : non si occupa quindi dei dettagli implementativi dello stesso, anche se \u00e8 a conoscenza di alcune informazioni fondamentali come indirizzo IP e numero di porta utilizzati. Dal punto di vista del confronto con il modello ISO/OSI, possiamo dire che il layer applicativo del modello TCP/IP \u00e8 spesso comparato ad una combinazione dei livelli di sessione, presentazione ed applicazione del primo.","title":"02 reti"},{"location":"02_dispense/02_hardware/02_reti/#reti-di-telecomunicazione-cosa-sono-ed-a-che-servono","text":"Nell'ultima lezione, abbiamo introdotto le principali caratteristiche dell'architettura interna di un calcolatore. Il naturale step successivo \u00e8 quindi chiedersi come possano comunicare tra loro due (o pi\u00f9) calcolatori . Ed \u00e8 a questo scopo che sono state introdotte le reti di telecomunicazione .","title":"Reti di telecomunicazione: cosa sono ed a che servono?"},{"location":"02_dispense/02_hardware/02_reti/#alcune-definizioni","text":"","title":"Alcune definizioni"},{"location":"02_dispense/02_hardware/02_reti/#commutazione-di-circuito-vs-commutazione-di-pacchetto","text":"Le reti a commutazione di circuito stabiliscono una connessione fisica tra il mittente ed il destinatario. Un esempio di rete a commutazione di circuito sono le vecchie reti telefoniche, nelle quali veniva creato appunto un circuito fisico tra i due capi della comunicazione. Le reti a commutazione di pacchetto invece non stabiliscono una connessione fisica tra il mittente ed il destinatario, ma fanno s\u00ec che siano i dispositivi di rete ad instradare i dati, opportunamente suddivisi in pacchetti , tra il mittente ed il destinatario.","title":"Commutazione di circuito vs. commutazione di pacchetto"},{"location":"02_dispense/02_hardware/02_reti/#topologia-di-rete","text":"","title":"Topologia di rete"},{"location":"02_dispense/02_hardware/02_reti/#standardizzazione","text":"Affinch\u00e9 due calcolatori scambino dati (il che, nel gergo comune, significa \" affinch\u00e8 due computer parlino tra loro \") \u00e8 necessario che entrambi si adeguino ad uno standard di comunicazione. Pensiamoci un attimo: saremmo forse in grado di capire ci\u00f2 che dice il nostro docente di Informatica se non avessimo un protocollo di comunicazione comune? Nota Se alla domanda precedente avete risposto di no , la colpa \u00e8 sicuramente vostra e non del docente di Informatica, che risulta essere chiaro, comprensibile, affabile e disponibile. Lo scambio di dati tra due computer \u00e8 inoltre molto pi\u00f9 complesso rispetto alla comunicazione verbale: infatti, prevede che ciascuno dei due computer sia in grado di: presentare i dati scambiati all'utente finale; identificare sia il mittente sia il destinatario dei dati stessi; codificare i dati sotto forma di segnale fisico da inviare su degli opportuni canali di comunicazione fisici. E' inoltre necessario che la comunicazione sia indipendente dal tipo di dispositivo utilizzato: se ci pensate, alcuni di voi seguono le lezioni da un iPad, altri dal proprio smartphone, altri ancora dal proprio laptop o PC desktop. Abbiamo quindi una serie di vincoli da rispettare affinch\u00e9 due o pi\u00f9 dispositivi comunichino. Ed \u00e8 stato proprio questo il punto di partenza dal quale \u00e8 stato definito un modello concettuale volto a caratterizzare e standardizzare la comunicazione tra dispositivi, indipendentemente dalle tecnologie adottate, ovvero il modello ISO/OSI .","title":"Standardizzazione"},{"location":"02_dispense/02_hardware/02_reti/#il-modello-isoosi","text":"OSI \u00e8 un acronimo che sta per Open Systems Interconnection , ed indica un modello sviluppato tenendo come obiettivo finale l'interoperabilit\u00e0 di diversi sistemi di comunicazione grazie a protocolli di comunicazione standardizzati . La storia del modello OSI nasce negli anni '70, in cui venne sviluppato per supportare la standardizzazione dei diversi tipi di rete di calcolatori emergenti. Negli anni '80, il modello venne adottato dall' International Organization for Standardization ( ISO ), ed assunse il nome di modello ISO/OSI . Il modello ISO/OSI suddivide il flusso dei dati in un sistema di comunicazione in sette diversi livelli ad astrazione crescente, partendo dall'implementazione fisica della trasmissione dei bit sul canale comunicativo, per arrivare alla rappresentazione dei dati ad alto livello (ovvero quello che viene \"presentato\" all'utente). E' importante sottolineare alcune caratteristiche del modello ISO/OSI. In primis, per quello che riguarda una singola macchina, ogni layer comunica esclusivamente con: il livello sottostante, di cui sfrutta le funzionalit\u00e0; il livello sovrastante, cui fornisce una serie di funzionalit\u00e0; Nella comunicazione tra due macchine, invece, ogni layer comunica con il suo pari ( peer ): ad esempio, il layer fisico della macchina A parler\u00e0 soltanto con il layer fisico della macchina B; il layer di rete della macchina A solo con quello di rete della macchina B, e via dicendo.","title":"Il modello ISO/OSI"},{"location":"02_dispense/02_hardware/02_reti/#i-livelli-del-modello-isoosi","text":"Diamo ora una panoramica dei diversi livelli descritti dal modello.","title":"I livelli del modello ISO/OSI"},{"location":"02_dispense/02_hardware/02_reti/#livello-1-livello-fisico","text":"Il layer fisico \u00e8 responsabile per la trasmissione e ricezione di dati grezzi ( raw ) tra due dispositivi. Per farlo, sfrutta un mezzo di trasmissione fisico (come ad esempio una guida d'onda o delle onde radio). La sua funzione principale \u00e8 quella di convertire i bit digitali in segnali di tipo elettrico, radio od ottico. Le specifiche del layer includono caratteristiche come livelli di tensione da utilizzare, bit rate, distanza massima di trasmissione, schema di modulazione dei dati e via dicendo. Permette inoltre di definire tre modalit\u00e0 di trasmissione su un canale: simplex : in questo caso, la trasmissione \u00e8 monodirezionale, senza che il ricevitore si alterni con il trasmettitore (e viceversa); half-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, ma il ricevitore si alterna con il trasmettitore (ovvero, la comunicazione non pu\u00f2 avvenire contemporaneamente in entrambe le direzioni); full-duplex : in questo caso, la modalit\u00e0 di trasmissione \u00e8 bidirezionale, e la comunicazione pu\u00f2 avvenire contemporaneamente in entrambe le direzioni. Questi includono dei pin, tensioni, impedenze di linea, specifiche dei cavi, timing del segmale e frequenza per i dispositivi wireless. Il controllo del bit rate \u00e8 fatto a livello fisico e pu\u00f2 definire delle modalit\u00e0 di trasmissione come simplex , half-duplex o full duplex.","title":"Livello 1: Livello fisico"},{"location":"02_dispense/02_hardware/02_reti/#livello-2-livello-data-link","text":"Il livello data link \u00e8 quello che si occupa di stabilire un \"collegamento\" tra due diversi nodi. In particolare: individua e corregge gli errori che avvengono a livello fisico; definisce come vengono instaurate e terminate le connessioni; controlla il flusso dati.","title":"Livello 2: Livello data link"},{"location":"02_dispense/02_hardware/02_reti/#il-progetto-ieee-802","text":"Il progetto IEEE 802 definisce, relativamente soprattutto al livello data link, un insieme di standard per le reti locali, in inglese Local Area Networks ( LAN ). In tal senso, la definizione data dal progetto IEEE 802 di rete locale \u00e8 la seguente: Quote Una LAN \u00e8 un sistema di comunicazione che permette ad apparecchiature indipendenti di comunicare fra loro entro un'area delimitata usando un canale fisico a velocit\u00e0 elevata e con basso tasso di errore. Notiamo che la LAN non \u00e8 quindi limitata nell'ambito (domestico, commerciale, industriale) n\u00e9 nelle tecnologie utilizzate: gli unici limiti sono l'area di interesse (giocoforza limitata), velocit\u00e0 ed affidabilit\u00e0 della comunicazione. Il progetto IEEE 802 ha quindi suddiviso il livello data link in due diversi sottolivelli: il livello Medium Access Control ( MAC ) verifica come i dispositivi di rete accedono al mezzo fisico; il livello Logical Link Control ( LLC ) controlla gli errori e sincronizza i frame. Concretamente, esistono diversi protocolli definiti nell'ambito del progetto IEEE 802, che sono usati nelle comunicazioni di tutti i giorni. Un esempio sono le reti Ethernet, che aderiscono allo standard 802.3, e le reti WiFi, che aderiscono a diverse versioni dello standard 802.11 (arrivato di recente alla revisione p ).","title":"Il progetto IEEE 802"},{"location":"02_dispense/02_hardware/02_reti/#livello-3-livello-di-rete","text":"Il livello di rete definisce come trasferire sequenze di lunghezza arbitraria ( pacchetti ) tra due nodi connessi in reti differenti, laddove per rete si potrebbe intendere sia una singola LAN, sia l'interconnessione di diverse LAN. E' sul concetto di rete che \u00e8 necessario focalizzarsi. Infatti, ogni dispositivo in rete \u00e8 comunemente detto nodo , e pu\u00f2 trasferire messaggi agli altri nodi semplicemente specificando l'indirizzo degli stessi (oltre che ovviamente il messaggio); saranno i dispositivi di rete a trovar eil modo di consegnare il messaggio al destiantario, magari instradandolo attraverso i nodi intermedi. Notiamo anche che la consegna dei messaggi a livello di rete non \u00e8 strettamente affidabile ; questo comporta quindi che i messaggi potrebbero essere persi, ed \u00e8 quindi necessario prevedere altri meccanismi per garantire l'affidabilit\u00e0 della comunicazione.","title":"Livello 3: livello di rete"},{"location":"02_dispense/02_hardware/02_reti/#livello-4-livello-di-trasporto","text":"Il livello di trasporto \u00e8 quello delegato a garantire questa affidabilit\u00e0 mediante opportuni meccanismi di controllo di flusso e di errore. Il modello ISO/OSI definisce cinque classi di protocolli a livello di trasporto, in base ai tipi di meccanismi di controllo dell'affidabilit\u00e0. Si va dalla classe TP0 , progettata per essere implementata su connessioni supposte error-free , ed i cui protocolli non forniscono alcun meccanismo per la gestione degli errori, fino alla classe TP4 , che \u00e8 quella che ricorda pi\u00f9 da vicino i protocolli maggiormente usati a livello di trasporto in Internet.","title":"Livello 4: livello di trasporto"},{"location":"02_dispense/02_hardware/02_reti/#livello-5-livello-di-sessione","text":"Il livello di sessione si occupa di controllare il \"dialogo\", ovvero le connessioni , tra i diversi computer, gestendone, tra le altre cose, l'inizializzazione e la chiusura.","title":"Livello 5: livello di sessione"},{"location":"02_dispense/02_hardware/02_reti/#livello-6-livello-di-presentazione","text":"Nel modello ISO/OSI, il livello di presentazione si occupa di stabilire un contesto tra due diverse entit\u00e0, all'interno del quale le due possono comunicare pur usando semantica e sentassi differenti . Il livello di presentazione funziona quindi un po' come un traduttore : fa in modo che due applicazioni, anche differenti, siano in grado di comunicare tra loro, fornendo una sorta di \"dizionario\" (o, pi\u00f9 correttamente, mappatura ) tra i linguaggi da loro compresi. E' anche per questo motivo che alle volte il livello di presentazione \u00e8 anche chiamato syntax layer . Oltre alla funzione di mapping, il livello di presentazione ne offre anche di altre, tra cui quella pi\u00f9 importante \u00e8 quella delegata alla compressione dei dati.","title":"Livello 6: livello di presentazione"},{"location":"02_dispense/02_hardware/02_reti/#livello-7-livello-applicativo","text":"Il livello applicativo \u00e8 quello pi\u00f9 vicino all'utente, ed interagisce direttamente con gli applicativi software da questo utilizzati. E' importante sottolineare che la specifica di questi programmi ricade al di fuori dell'ambito del modello ISO/OSI ; di conseguenza, le specifiche (ad esempio) del browser o di un'app per smartphone non saranno mai dettate dallo standard. Quest'ultima considerazione ci permette di distinguere tra applicazione ed entit\u00e0 legata all'applicazione: ad esempio, in un sito di prenotazione degli alberghi ci possono essere due entit\u00e0, una che usa un protocollo a livello applicativo per comunicare con gli utenti, ed un'altra che usa un protocollo a livello applicativo per salvare i dati su un database remoto. Nessuna di queste due entit\u00e0 ha per\u00f2 a che fare con l'applicazione stessa, che \u00e8 definita dalla logica di business (in questo caso, la prenotazione degli alberghi).","title":"Livello 7: Livello applicativo"},{"location":"02_dispense/02_hardware/02_reti/#lo-standard-del-mondo-reale-lo-stack-tcpip","text":"Il modello ISO/OSI non trova riscontro diretto nelle applicazioni reali: piuttosto, \u00e8 l' Internet Protocol Suite , o stack TCP/IP , lo stack protocollare usato ed implementato su Internet. Come vedremo, la denominazione stack TCP/IP deriva direttamente dal nome dei due principali protocolli su cui \u00e8 basato lo stack, ovvero il Transmission Control Protocol ( TCP ) e l' Internet Protocol ( IP ).","title":"Lo standard del mondo reale: lo stack TCP/IP"},{"location":"02_dispense/02_hardware/02_reti/#i-livelli-dello-stack-tcpip","text":"A differenza del modello ISO/OSI, lo stack TCP/IP \u00e8 organizzato in quattro diversi livelli, pi\u00f9 o meno riconducibili a quelli dell'ISO/OSI. Questi sono, dal pi\u00f9 basso al pi\u00f9 alto, il livello link , il livello internet , il livello trasporto ed il livello applicativo . Vediamoli di seguito.","title":"I livelli dello stack TCP/IP"},{"location":"02_dispense/02_hardware/02_reti/#livello-1-livello-link","text":"Il livello link si occupa di gestire la connessione limitatamente all'ambito della rete locale cui un host \u00e8 collegato. Il link , o collegamento , include quindi tutti gli host che \u00e8 possibile raggiungere senza dover coinvolgere un router (che \u00e8 il dispositivo che permette la connessione tra diverse reti locali). Va da s\u00e9 che la dimensione del link \u00e8 determinata dal progetto della rete stessa. Nel confronto con il modello ISO/OSI, il livello link racchiude le funzionalit\u00e0 corrispondenti a quelle del secondo layer (ovvero il data link ). E' importante sottolieare come l'effettiva implementazione del progetto IEEE 802 sia avvenuta proprio a questo livello.","title":"Livello 1: Livello link"},{"location":"02_dispense/02_hardware/02_reti/#livello-2-livello-internet","text":"La comunicazione tra diverse reti richiede che i dati siano correttamente instradati dalla rete iniziale a quella di destinazione, secondo un processo chiamato routing e supportato dall'identificazione degli indirizzi degli host coinvolti mediante il sistema degli indirizzi IP . Il livello internet fornisce una comunicazione non affidabile su reti differenti, garantendo l'inoltro dei pacchetti mediante dei dispositivi chiamati router. Il livello permette quindi l'interoperabilit\u00e0 di reti eterogenee, e definisce Internet nel modo in cui la conosciamo oggi. Il protocollo principale usato a questo livello \u00e8 l' Internet Protocol , che definisce due diversi sistemi di indirizzamento per l'identificazione degli host sulla rete. Il sistema originario di indirizzamento \u00e8 chiamato Internet Protocol version 4 ( IPv4 ), ed usa un indirizzo a 32 bit per identificare un numero massimo di \\(2^32\\) host. Ovviamente, con il progressivo diffondersi delle reti di telecomunicazione, questo valore ha rappresentato un limite, che \u00e8 stato dapprima arginato inserendo diverse classi di indirizzi riservati alle macchine interne ad ogni LAN, per poi essere superato nel 1998 mediante la standardizzazione dell'Internet Protocol version 6 (IPv6), che usa indirizzi a 128 bit. Tuttavia, nonostante le schede di rete in grado di supportare IPv6 esistano dal 2006 circa, l'IPv4 \u00e8 ancora il protocollo di comunicazione maggiormente utilizzato.","title":"Livello 2: Livello internet"},{"location":"02_dispense/02_hardware/02_reti/#livello-3-livello-di-trasporto","text":"Il livello di trasporto permette di creare dei \"canali dati\", che le applicazioni usano per lo scambio di messaggi specifici per determinati task. La connettivit\u00e0 pu\u00f2 essere implementata sia come connection-oriented , mediante il protocollo TCP, o connectionless , mediante il protocollo UDP. E' possibile fornire canali di trasmissione specifici per diversi processi mediante il concetto di porta di rete , ovvero la creazione di un costrutto logico numerico allocato specificamente per ognuno dei canali di comunicazione necessari. E' importante notare come, per molti servizi, questi numeri di porta siano stati standardizzati, in modo che i computer client possano indirizzare servizi specifici senza necessitare di tecniche di service discovery . Ad esempio, l'utilizzo standard del protocollo HTTP prevede il coinvolgimento della porta 80, mentre il protocollo SSH la porta 22. Il layer di trasporto dello stack TCP/IP corrisponde approssimativamente al quarto livello del modello OSI, chiamato transport layer.","title":"Livello 3: Livello di trasporto"},{"location":"02_dispense/02_hardware/02_reti/#trasmission-control-protocol","text":"Il protocollo TCP \u00e8 un protocollo connection-oriented che risolve i problemi di affidabilit\u00e0 che possono riscontrarsi nella fornitura di un flusso di byte affidabile. In particolare, il TCP garantisce che: i dati arrivino in ordine; i dati siano correttamente ricevuti; i dati duplicati siano scartati; i pacchetti persi o scartati siano nuovamente inviati; la congestione del traffico sia adeguatamente controllata.","title":"Trasmission Control Protocol"},{"location":"02_dispense/02_hardware/02_reti/#user-datagram-protocol","text":"Il protocollo UDP ( User Datagram Protocol ) \u00e8, a differenza del TCP, un protocollo connectionless , e si occupa di fornire una trasmissione dati non affidabile ma, non includendo il controllo degli errori tipico di TCP, pi\u00f9 veloce. L'UDP \u00e8 tipicamente usato per applicazioni legate allo streaming (audio, video e VoIP), dove l'arrivo in tempo dei dati \u00e8 pi\u00f9 importante dell'effettiva consegna degli stessi. Altri tipi di applicazioni sono quelle che prevedono esclusivamente semplici cicli di richiesta/risposta.","title":"User Datagram Protocol"},{"location":"02_dispense/02_hardware/02_reti/#livello-4-livello-applicativo","text":"Il livello applicativo include i protocolli usati dalla maggior part edelle applicazioni per fornire servizi all'utente. Questi possono includere servizi di supporto di rete, come protocolli per il routing e la configurazione di rete. Un esempio di protocollo a livello applicativo sono l*Hypertext Transfer Protocol* ( HTTP ). I dati codificati secondo i protocolli a livello applicativo vengono quindi incapsulati in unit\u00e0 a livello di trasporto (ad esempio, in formato TCP o UDP), per poi venire ulteriormente incapsulati man mano che si scende verso il layer fisico. E' interessante notare come lo stack TCP/IP non specifichi la formattazione e la presentazione dei dati, e non definisca dei layer aggiuntivi tra quello applicativo e di trasporto. Per quello che riguarda la comunicazione con il livello di trasporto (e quelli sottostanti), il livello applicativo tratta quest'ultimo come una black box : non si occupa quindi dei dettagli implementativi dello stesso, anche se \u00e8 a conoscenza di alcune informazioni fondamentali come indirizzo IP e numero di porta utilizzati. Dal punto di vista del confronto con il modello ISO/OSI, possiamo dire che il layer applicativo del modello TCP/IP \u00e8 spesso comparato ad una combinazione dei livelli di sessione, presentazione ed applicazione del primo.","title":"Livello 4: Livello applicativo"},{"location":"02_dispense/03_linguaggi/01_linguaggi/","text":"Il Linguaggio Naturale \u00b6 Il Linguaggio Naturale \u00e8 usato per la comunicazione (scritta ed orale) tra gli esseri umani. Ovviamente, il linguaggio naturale presenta diverse fonti di ambiguit\u00e0, tra cui: evoluzione del linguaggio : molto spesso, termini arcaici o neologismi potrebbero non essere ben compresi, come atavico o skippare ; polisemia : esistono termini che hanno un significato diverso a seconda del contesto (ad esempio, i principi non hanno principi ); ambiguit\u00e0 intrinseca : frasi e termini che per essere interpretati hanno necessariamente bisogno del contesto ( una vecchia porta la sbarra ). Questi motivi, oltre all'enorme variabilit\u00e0, fanno s\u00ec che il linguaggio naturale non sia adatto a permettere la comunicazione tra uomo e macchina. E' quindi l'umano a doversi giocoforza adattare. Definizione formale di Linguaggio \u00b6 Iniziamo dando una definizione (pi\u00f9 o meno) formale di linguaggio. Linguaggio Un linguaggio \u00e8 l'insieme di parole ottenute applicando le regole di una data grammatica. La grammatica, a sua volta, \u00e8 definita come segue: Grammatica Una grammatica \u00e8 un formalismo atto a definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle parole. E' chiaro come le due definizioni siano strettamente correlate tra loro, in quanto l'una discende direttamente dall'altra. Sintassi e semantica (nel linguaggio naturale) \u00b6 Le parole di un linguaggio possono essere analizzate da due diversi punti di vista: sintattico : comporta la verifica della correttezza della forma linguistica in cui \u00e8 codificato; semantico : comporta la verifica del significato associato alla forma linguistica. In realt\u00e0, esiste anche l'analisi pragmatica del testo, che ne prevede l'analisi nel contesto dell'utilizzo comune; quest'ultima, tuttavia, esula dai nostri obiettivi, e l'eventuale approfondimento \u00e8 demandato al lettore. Una frase scorretta dal punto di vista sintattico \u00e8 la seguente: Io ho andato a scuola. Una frase corretta dal punto di vista sintattico, ma semanticamente inconsistente \u00e8 la seguente: Tu hai suonato il cellulare al contrario. I Linguaggi di Programmazione \u00b6 I Linguaggi di Programmazione definiscono una notazione specificamente pensata per definire degli algoritmi . La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). Ci\u00f2 \u00e8 possibile usando appositi traduttori (ci ritorneremo pi\u00f9 avanti). Livelli di astrazione \u00b6 In generale, comunque, i linguaggi di programmazione sfruttano appieno il concetto di astrazione delle risorse della macchina su cui viene eseguito un programma. Questo \u00e8 un concetto ricorrente in informatica; ne abbiamo infatti avuto un \"assaggio\" quando abbiamo parlato del modello ISO/OSI, nel quale ogni layer rappresenta una ulteriore \"astrazione\" rispetto a quello sottostante, in modo da rendere il messaggio pi\u00f9 facilmente comprensibile da parte di un utente umano. Nell'ambito dei linguaggi di programmazione, astrarre significa mettere a disposizione i canali fisici di elaborazione dei dati (ovvero, i circuiti) ad un'entit\u00e0 (lo sviluppatore) che parla un linguaggio naturale. Diversi linguaggi di programmazione offrono diversi livelli di astrazione. Linguaggi ad alto livello \u00b6 In generale, i linguaggi ad alto livello , come ad esempio Python, sono molto \"vicini\" al linguaggio parlato da un essere umano, ed astraggono l'accesso alle risorse del calcolatore. Ad esempio, Python non richiede che sia lo sviluppatore a gestire la (tediosa e complessa) operazione di gestione della memoria, ma la gestisce in automatico mediante tecniche di garbage collection . Ci\u00f2 comporta vantaggi e svantaggi: da un lato, \u00e8 pi\u00f9 semplice scrivere programmi in un linguaggio ad alto livello; dall'altro, per\u00f2, vi \u00e8 una certa \"mancanza di controllo\" sulle operazioni compiute dalla macchina che, nonostante non risulti essere un problema nella maggior parte dei casi, pu\u00f2 essere necessaria in caso di applicazioni che richiedono delle procedure di ottimizzazione specifiche. Linguaggi a basso livello \u00b6 A differenza dei linguaggi ad alto livello, quelli a basso livello sono pi\u00f9 vicini al linguaggio parlato dalla macchina. In tal senso, i linguaggi di questo tipo delegano allo sviluppatore operazioni di gestione diretta delle risorse del calcolatore, ed i programmi scritti in questi linguaggi sono contestualmente pi\u00f9 complessi, richiedendo un grado di attenzione ed ottimizzazione pi\u00f9 elevato rispetto a quelli scritti in linguaggi ad alto livello. Ci\u00f2 lascia per\u00f2 spazio al programmatore esperto, che potr\u00e0 ottimizzare in maniera pi\u00f9 granulare le proprie applicazioni, senza dover sottostare ai meccanismi di astrazione delle risorse usati dai linguaggi ad alto livello. Nota sulla gestione delle risorse I meccanismi di gestione delle risorse dei linguaggi ad alto livello non sono \"poco efficienti\". Tutt'altro: essendo scritti da ottimi programmatori, sono molto spesso estremamente pi\u00f9 performanti rispetto a quelli che scriverebbe lo sviluppatore quadratico medio. Tuttavia, questi meccanismi sono, giocoforza, generici , dato che devono adattarsi all'intero ventaglio dei possibili algoritmi implementabili dal linguaggio di programmazione. La genericit\u00e0 determina, in specifiche e limitate circostanze, uno svantaggio, che potrebbe rendere preferibile un maggior controllo sulle risorse della macchina. E' importante sottolineare comunque come la maggior parte dei linguaggi di programmazione ad alto livello offra metodi specifici per gestire questo tipo di situazioni. Linguaggi imperativi vs. linguaggi dichiarativi \u00b6 In generale, \u00e8 possibile operare un'ulteriore distinzione tra linguaggi di programmazione, in base alle modalit\u00e0 con cui viene definita la serie di operazioni che il programma dovr\u00e0 eseguire. Nella programmazione imperativa (o procedurale ), \u00e8 possibile controllare lo stato del programma, specificando il flusso di esecuzione delle istruzioni. Tipici esempi di linguaggi procedurali sono Python, C e C++. Nella programmazione dichiarativa (o non procedurale ), invece, viene semplicemente indicato al programma il risultato che vogliamo ottenere. Esempi di linguaggi di questo tipo sono SQL e Prolog. Facciamo un esempio. In un linguaggio imperativo, \"imponiamo\" al programma le istruzioni da compiere; specifichiamo quindi come ottenere un risultato. Ad esempio: x = 12 y = x * 2 print ( \"Il valore di x \u00e8: {} \" . format ( x )) Nell'esempio precedente, scritto in Python, indichiamo al programma che deve valutare il valore di x , moltiplicarlo per 2, assegnarlo ad y e mostrarlo a schermo. Un esempio di programmazione dichiarativa \u00e8 invece quello che usiamo quando interroghiamo un database mediante istruzioni SQL. Ad esempio: SELECT * FROM TABLE STUDENTI ; In questo caso, \u00e8 chiaro come non si stia specificando come interrogare il database, ma soltanto quello che ci si aspetta da esso (il cosa ). Espressitiv\u00e0 \u00b6 In generale, un linguaggio \u00e8 una rappresentazione scritta o verbale di una serie di concetti ; la quantit\u00e0 e qualit\u00e0 di questa rappresentazione \u00e8 determinata dalla potenza espressiva di un linguaggio. Per quello che riguarda i linguaggi di programmazione, l'espressivit\u00e0 \u00e8 associata ai problemi che sono in grado di risolvere e, di conseguenza, agli algoritmi che sono in grado di rappresentare . In particolare, i linguaggi di programmazione pi\u00f9 comuni sono spesso definiti come Turing-completi , in quanto possono implementare tutti gli algoritmi risolvibili da una macchina di Turing universale (torneremo pi\u00f9 avanti su questo concetto). I linguaggi di markup, come ad esempio HTML ed XML, non sono normalmente considerati linguaggi di programmazione. Sintassi e semantica (nei linguaggi di programmazione) \u00b6 Come nei linguaggi naturali, anche per i linguaggi di programmazione sono essenziali i concetti di sintassi e semantica . In particolare, la sintassi specifica le regole con le quali un'istruzione viene ritenuta valida. In generale, queste variano da linguaggio a linguaggio (rimanendo pur sempre abbastanza \"affini\"), e sono estremamente rigide : un programma non conforme alle regole sintattiche indicate per il linguaggio non potr\u00e0 in alcun modo essere eseguito. Per fortuna, queste regole sono poche , semplici e ben definite per ogni linguaggio. Neanche lontanamente complesse come l'uso dei congiuntivi, quindi. Anche la semantica ha un rapporto estremamente \"stretto\" con l'analogo concetto usato nei linguaggi naturali, dato che ci permette di valutare il contenuto informativo di un programma. In particolare, ci sono tre metodi per trattare formalmente la semantica di un programma, allo scopo di caratterizzarne il comportamento: nella semantica operazionale si specifica come i costrutti del linguaggio vengano eseguiti su di una macchina astratta; nella semantica denotazionale si specifica come interpretare il significato dei costrutti scritti in un linguaggio; nella semantica assiomatica si specifica come determinare il significato dei costrutti scritti in un linguaggio usando degli assiomi (ovvero regole di \"correttezza\" data una certa logica).","title":"01 linguaggi"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#il-linguaggio-naturale","text":"Il Linguaggio Naturale \u00e8 usato per la comunicazione (scritta ed orale) tra gli esseri umani. Ovviamente, il linguaggio naturale presenta diverse fonti di ambiguit\u00e0, tra cui: evoluzione del linguaggio : molto spesso, termini arcaici o neologismi potrebbero non essere ben compresi, come atavico o skippare ; polisemia : esistono termini che hanno un significato diverso a seconda del contesto (ad esempio, i principi non hanno principi ); ambiguit\u00e0 intrinseca : frasi e termini che per essere interpretati hanno necessariamente bisogno del contesto ( una vecchia porta la sbarra ). Questi motivi, oltre all'enorme variabilit\u00e0, fanno s\u00ec che il linguaggio naturale non sia adatto a permettere la comunicazione tra uomo e macchina. E' quindi l'umano a doversi giocoforza adattare.","title":"Il Linguaggio Naturale"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#definizione-formale-di-linguaggio","text":"Iniziamo dando una definizione (pi\u00f9 o meno) formale di linguaggio. Linguaggio Un linguaggio \u00e8 l'insieme di parole ottenute applicando le regole di una data grammatica. La grammatica, a sua volta, \u00e8 definita come segue: Grammatica Una grammatica \u00e8 un formalismo atto a definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle parole. E' chiaro come le due definizioni siano strettamente correlate tra loro, in quanto l'una discende direttamente dall'altra.","title":"Definizione formale di Linguaggio"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#sintassi-e-semantica-nel-linguaggio-naturale","text":"Le parole di un linguaggio possono essere analizzate da due diversi punti di vista: sintattico : comporta la verifica della correttezza della forma linguistica in cui \u00e8 codificato; semantico : comporta la verifica del significato associato alla forma linguistica. In realt\u00e0, esiste anche l'analisi pragmatica del testo, che ne prevede l'analisi nel contesto dell'utilizzo comune; quest'ultima, tuttavia, esula dai nostri obiettivi, e l'eventuale approfondimento \u00e8 demandato al lettore. Una frase scorretta dal punto di vista sintattico \u00e8 la seguente: Io ho andato a scuola. Una frase corretta dal punto di vista sintattico, ma semanticamente inconsistente \u00e8 la seguente: Tu hai suonato il cellulare al contrario.","title":"Sintassi e semantica (nel linguaggio naturale)"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#i-linguaggi-di-programmazione","text":"I Linguaggi di Programmazione definiscono una notazione specificamente pensata per definire degli algoritmi . La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). Ci\u00f2 \u00e8 possibile usando appositi traduttori (ci ritorneremo pi\u00f9 avanti).","title":"I Linguaggi di Programmazione"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#livelli-di-astrazione","text":"In generale, comunque, i linguaggi di programmazione sfruttano appieno il concetto di astrazione delle risorse della macchina su cui viene eseguito un programma. Questo \u00e8 un concetto ricorrente in informatica; ne abbiamo infatti avuto un \"assaggio\" quando abbiamo parlato del modello ISO/OSI, nel quale ogni layer rappresenta una ulteriore \"astrazione\" rispetto a quello sottostante, in modo da rendere il messaggio pi\u00f9 facilmente comprensibile da parte di un utente umano. Nell'ambito dei linguaggi di programmazione, astrarre significa mettere a disposizione i canali fisici di elaborazione dei dati (ovvero, i circuiti) ad un'entit\u00e0 (lo sviluppatore) che parla un linguaggio naturale. Diversi linguaggi di programmazione offrono diversi livelli di astrazione.","title":"Livelli di astrazione"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#linguaggi-ad-alto-livello","text":"In generale, i linguaggi ad alto livello , come ad esempio Python, sono molto \"vicini\" al linguaggio parlato da un essere umano, ed astraggono l'accesso alle risorse del calcolatore. Ad esempio, Python non richiede che sia lo sviluppatore a gestire la (tediosa e complessa) operazione di gestione della memoria, ma la gestisce in automatico mediante tecniche di garbage collection . Ci\u00f2 comporta vantaggi e svantaggi: da un lato, \u00e8 pi\u00f9 semplice scrivere programmi in un linguaggio ad alto livello; dall'altro, per\u00f2, vi \u00e8 una certa \"mancanza di controllo\" sulle operazioni compiute dalla macchina che, nonostante non risulti essere un problema nella maggior parte dei casi, pu\u00f2 essere necessaria in caso di applicazioni che richiedono delle procedure di ottimizzazione specifiche.","title":"Linguaggi ad alto livello"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#linguaggi-a-basso-livello","text":"A differenza dei linguaggi ad alto livello, quelli a basso livello sono pi\u00f9 vicini al linguaggio parlato dalla macchina. In tal senso, i linguaggi di questo tipo delegano allo sviluppatore operazioni di gestione diretta delle risorse del calcolatore, ed i programmi scritti in questi linguaggi sono contestualmente pi\u00f9 complessi, richiedendo un grado di attenzione ed ottimizzazione pi\u00f9 elevato rispetto a quelli scritti in linguaggi ad alto livello. Ci\u00f2 lascia per\u00f2 spazio al programmatore esperto, che potr\u00e0 ottimizzare in maniera pi\u00f9 granulare le proprie applicazioni, senza dover sottostare ai meccanismi di astrazione delle risorse usati dai linguaggi ad alto livello. Nota sulla gestione delle risorse I meccanismi di gestione delle risorse dei linguaggi ad alto livello non sono \"poco efficienti\". Tutt'altro: essendo scritti da ottimi programmatori, sono molto spesso estremamente pi\u00f9 performanti rispetto a quelli che scriverebbe lo sviluppatore quadratico medio. Tuttavia, questi meccanismi sono, giocoforza, generici , dato che devono adattarsi all'intero ventaglio dei possibili algoritmi implementabili dal linguaggio di programmazione. La genericit\u00e0 determina, in specifiche e limitate circostanze, uno svantaggio, che potrebbe rendere preferibile un maggior controllo sulle risorse della macchina. E' importante sottolineare comunque come la maggior parte dei linguaggi di programmazione ad alto livello offra metodi specifici per gestire questo tipo di situazioni.","title":"Linguaggi a basso livello"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#linguaggi-imperativi-vs-linguaggi-dichiarativi","text":"In generale, \u00e8 possibile operare un'ulteriore distinzione tra linguaggi di programmazione, in base alle modalit\u00e0 con cui viene definita la serie di operazioni che il programma dovr\u00e0 eseguire. Nella programmazione imperativa (o procedurale ), \u00e8 possibile controllare lo stato del programma, specificando il flusso di esecuzione delle istruzioni. Tipici esempi di linguaggi procedurali sono Python, C e C++. Nella programmazione dichiarativa (o non procedurale ), invece, viene semplicemente indicato al programma il risultato che vogliamo ottenere. Esempi di linguaggi di questo tipo sono SQL e Prolog. Facciamo un esempio. In un linguaggio imperativo, \"imponiamo\" al programma le istruzioni da compiere; specifichiamo quindi come ottenere un risultato. Ad esempio: x = 12 y = x * 2 print ( \"Il valore di x \u00e8: {} \" . format ( x )) Nell'esempio precedente, scritto in Python, indichiamo al programma che deve valutare il valore di x , moltiplicarlo per 2, assegnarlo ad y e mostrarlo a schermo. Un esempio di programmazione dichiarativa \u00e8 invece quello che usiamo quando interroghiamo un database mediante istruzioni SQL. Ad esempio: SELECT * FROM TABLE STUDENTI ; In questo caso, \u00e8 chiaro come non si stia specificando come interrogare il database, ma soltanto quello che ci si aspetta da esso (il cosa ).","title":"Linguaggi imperativi vs. linguaggi dichiarativi"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#espressitiva","text":"In generale, un linguaggio \u00e8 una rappresentazione scritta o verbale di una serie di concetti ; la quantit\u00e0 e qualit\u00e0 di questa rappresentazione \u00e8 determinata dalla potenza espressiva di un linguaggio. Per quello che riguarda i linguaggi di programmazione, l'espressivit\u00e0 \u00e8 associata ai problemi che sono in grado di risolvere e, di conseguenza, agli algoritmi che sono in grado di rappresentare . In particolare, i linguaggi di programmazione pi\u00f9 comuni sono spesso definiti come Turing-completi , in quanto possono implementare tutti gli algoritmi risolvibili da una macchina di Turing universale (torneremo pi\u00f9 avanti su questo concetto). I linguaggi di markup, come ad esempio HTML ed XML, non sono normalmente considerati linguaggi di programmazione.","title":"Espressitiv\u00e0"},{"location":"02_dispense/03_linguaggi/01_linguaggi/#sintassi-e-semantica-nei-linguaggi-di-programmazione","text":"Come nei linguaggi naturali, anche per i linguaggi di programmazione sono essenziali i concetti di sintassi e semantica . In particolare, la sintassi specifica le regole con le quali un'istruzione viene ritenuta valida. In generale, queste variano da linguaggio a linguaggio (rimanendo pur sempre abbastanza \"affini\"), e sono estremamente rigide : un programma non conforme alle regole sintattiche indicate per il linguaggio non potr\u00e0 in alcun modo essere eseguito. Per fortuna, queste regole sono poche , semplici e ben definite per ogni linguaggio. Neanche lontanamente complesse come l'uso dei congiuntivi, quindi. Anche la semantica ha un rapporto estremamente \"stretto\" con l'analogo concetto usato nei linguaggi naturali, dato che ci permette di valutare il contenuto informativo di un programma. In particolare, ci sono tre metodi per trattare formalmente la semantica di un programma, allo scopo di caratterizzarne il comportamento: nella semantica operazionale si specifica come i costrutti del linguaggio vengano eseguiti su di una macchina astratta; nella semantica denotazionale si specifica come interpretare il significato dei costrutti scritti in un linguaggio; nella semantica assiomatica si specifica come determinare il significato dei costrutti scritti in un linguaggio usando degli assiomi (ovvero regole di \"correttezza\" data una certa logica).","title":"Sintassi e semantica (nei linguaggi di programmazione)"},{"location":"02_dispense/03_linguaggi/02_traduttori/","text":"Traduttori \u00b6 Parlando dei linguaggi di programmazione, abbiamo detto che: Il Docente, o, alternativamente, Queste Dispense. La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). L'esecuzione di questo task \u00e8 delegato ad un apposito programma chiamato traduttore , che si occupa di tradurre il codice scritto in un linguaggio (chiamato linguaggio sorgente ) in codice scritto in un altro linguaggio (chiamato linguaggio obiettivo ). Normalmente, il linguaggio sorgente \u00e8 ad un livello di astrazione pi\u00f9 alto rispetto al linguaggio obiettivo: ad esempio, il linguaggio sorgente potrebbe essere il C, mentre il linguaggio obiettivo potrebbe essere Assembly. Il traduttore ha diversi compiti: per prima cosa, si occupa di verificare la correttezza sintattica del codice scritto in linguaggio sorgente. Per fare un esempio, il traduttore valider\u00e0 questa istruzione: a = 1 + 2 ma non questa: a = = 2 + 'pippo' Una volta validata la correttezza sintattica delle istruzioni analizzate, attribuir\u00e0 a ciascuna di esse un opportuno significato , associando le corrispondenti istruzioni nel linguaggio obiettivo. E' importante sottolinare come l'interpretazione debba essere univoca , onde garantire la propriet\u00e0 di non ambiguit\u00e0 degli algoritmi. Esistono principalmente due categorie di traduttori: i compilatori e gli interpreti . Compilatori \u00b6 Il termine compilatore viene usato per indicare i traduttori che si occupano di tradurre direttamente il codice da un linguaggio sorgente ad alto livello ad un linguaggio obiettivo a basso livello, come assembly, codice oggetto o codice macchina. Nota Il fatto che un compilatore traduca direttamente il codice da linguaggio ad alto livello a codice oggetto/macchina implica che quest'ultimo sia specifico per un certo tipo di hardware e software. Ci\u00f2 comporta che, in molte situazioni, non saremo in grado di eseguire il codice compilato per i nostri PC su dispositivi come Arduino o i nostri smartphone! Tipologie di compilatore (alcuni esempi) \u00b6 Esistono diversi tipi di compilatore. Ad esempio, se il programma compilato pu\u00f2 essere eseguito su un computer le cui caratteristiche hardware o software sono diverse da quelle del computer sul quale il programma \u00e8 stato compilato, siamo di fronte ad un cross-compilatore . Nota Per \"caratteristiche hardware o software\" si intendono prevalentemente CPU (ed il suo instruction set) e sistema operativo (ed i driver che comandano i diversi dispositivi). Il programma duale di un compilatore \u00e8 chiamato decompilatore , ed \u00e8, prevedibilmente, un programma che traduce il codice da un linguaggio sorgente a basso livello ad un linguaggio obiettivo a pi\u00f9 alto livello. Un altro esempio di compilatore \u00e8 il transcompilatore , che traduce un programma scritto in un sorgente ad alto livello in codice scritto in un obiettivo sempre ad alto livello. Operazioni di un compilatore \u00b6 La maggior parte dei compilatori odierni segue un percorso articolato in tre diverse fasi ( three-stage compilers ), chiamate rispettivamente front end , middle end e back end . Front end \u00b6 Lo scopo del front end \u00e8 quello di analizzare il codice scritto in liguaggio sorgente, creando una rappresentazione intermedia del programma. Il processo supportato dalla fase di front end si articola in quattro diverse fasi. Preprocessing \u00b6 La fase di preprocessing (in italiano pre-elaborazione ) si occupa di sostituire alcune direttive specifiche per il linguaggio (ad esempio, le direttive #define in C) con il corrispondente codice sorgente. Analisi lessicale \u00b6 La fase di analisi lessicale prevede la lettura del sorgente come un'unica stringa, e la successiva suddivisione della stessa in \"parti\" dette token , i quali sono delimitati da caratteri come segni di interpunzione (ad esempio, virgole, punti, etc.), operatori matematici (ad esempio, i segni + , - , etc.), parentesi, o anche nomi di variabile e parole riservate. Un esempio di tokenizzazione \u00e8 il seguente. il codice sorgente: if ( x > 0.0 ) { y = 1.0 ; } diventa: if ( x > 0.0 ) y = 1.0 ; che produce i token if , ( , x , > , 0.0 , ) , y , = , 1.0 . Analisi sintattica \u00b6 La fase di analisi sintattica , comunemente nota anche come parsing , prevede l'analisi dei singoli token allo scopo di valutarne la correttezza sintattica , ovvero l'adesione alle regole grammaticali stabilite per quel linguaggio. L'analisi sintattica crea una struttura ad albero costruita a partire dalle regole formali del linguaggio, chiamata albero di parsing ( parse tree ). Analisi semantica \u00b6 La fase di analisi semantica integra le informazioni immagazzinate nel parse tree con informazioni di tipo semantico, come ad esempio il type checking , che controlla la coerenza tra i diversi tipi assunti dalle variabili. Middle End \u00b6 Lo scopo del middle end \u00e8 quello di ottimizzare la rappresentazione intermedia ottenuta dal front end. Per far questo, sono implementate delle tecniche di analisi del programma (ad esempio, mediante l'analisi del flusso di esecuzione, allo scopo di valutare e la presenza di eventuali ridondanze) ed ottimizzazione (ad esempio, rimuovendo le ridondanze individuate nella fase precedente). Un esempio di ridondanza \u00e8 il seguente: int main ( void ) { int a = 0 ; // Codice ridondante! if ( 1 == 0 ) { a = 1 ; } return a ; } Il codice all'interno dell'istruzione condizionale non \u00e8 raggiungibile , in quanto la condizione di uguaglianza tra uno e zero non \u00e8, per le conoscenze attuali, mai verificata. Back End \u00b6 Lo scopo del back end \u00e8 quello di inserire (opzionalmente) delle ottimizzazioni specifiche per l'architettura corrente (ovvero per il processore per il quale il codice sta venendo compilato), e generare il codice oggetto . Nota Il codice oggetto non \u00e8 il programma eseguibile. Generare l'eseguibile \u00e8 compito di un altro programma, spesso integrato in quelli che generalmente sono indicati come compilatori, chiamato linker . Interpreti \u00b6 L'altro tipo di traduttore comunemente utilizzato al giorno d'oggi \u00e8 chiamato interprete . L'approccio usato dall'interprete si differenzia da quello usato dal compilatore principalmente per un dettaglio: laddove il compilatore fa in modo che l'intero processo di traduzione da codice sorgente a programma eseguibile avvenga prima dell'esecuzione del programma, in un lasso di tempo chiamato compile time , l'interprete esegue un'istruzione immediatamente ; in teoria, ogni istruzione in un linguaggio interpretata potrebbe essere eseguita immediatamente dopo la sua scrittura. Non vi \u00e8 quindi una netta separazione, almeno dal punto di vista dell'utente, tra compile time e run time (con quest'ultimo il lasso di tempo in cui il programma \u00e8 in esecuzione). Gli step di interpetazione sono quindi essenzialmente tre: controllo dell'istruzione sul codice sorgente; traduzione in linguaggio macchina; esecuzione dell'istruzione tradotta. Ne consegue che un programma interpretato potrebbe interrompersi \"al volo\" (ovvero a run time), proprio perch\u00e9 l'interprete non \u00e8 in grado di anticipare eventuali errori sul sorgente. Compilatore vs. Interprete \u00b6 Di seguito una tabella comparativa di vantaggi e svantaggi legati all'adozione di un compilatore o di un interprete. Compilatore Interpete Vantaggi Ottimizzazione del codice Maggiore velocit\u00e0 di esecuzione Controllo sintattico e semantico Compile time nullo o ridotto Maggiore portabilit\u00e0 tra architettura Possibilit\u00e0 di debug con granularit\u00e0 a livello di singola istruzione Svantaggi Minore portabilit\u00e0 tra architetture Debug complesso da effettuare Minore velocit\u00e0 di esecuzione Performance non ottimizzate Possibili errori imprevisti a run time Linguaggi compilati e linguaggi interpretati \u00b6 Per linguaggio compilato si intende un linguaggio di programmazione le cui implementazioni sono tipicamente compilate ; di converso, un linguaggio interpretato prevede l'uso estensivo di interpeti. La distinzione \u00e8 per\u00f2 alquanto vaga. Infatti, almeno in linea di principio, qualunque linguaggio pu\u00f2 essere implementato indifferentemente mediante un compilatore od un itnerprete. E' anche possibile combinare entrambe le soluzioni: un compilatore pu\u00f2 ad esempio occuparsi della traduzione del codice sorgente nella rappresentazione intermedia, chiamata in questi casi bytecode , che viene passata ad un interprete che la esegue. E' questo ad esempio il caso di Java, che utilizza questo tipo di soluzione per passare il bytecode alla Java Virtual Machine , di cui esiste un'implementazione per la maggior parte delle architetture esistenti.","title":"02 traduttori"},{"location":"02_dispense/03_linguaggi/02_traduttori/#traduttori","text":"Parlando dei linguaggi di programmazione, abbiamo detto che: Il Docente, o, alternativamente, Queste Dispense. La principale differenza che intercorre con il linguaggio naturale \u00e8 che mentre quest'ultimo \u00e8 orientato alla comunicazione con altri esseri umani, i linguaggi di programmazione permettono agli umani di comunicare una serie di istruzioni ad una macchina, la quale potrebbe controllare dei dispositivi esterni di I/O (quali stampanti ed hard disk, ma anche bracci robotici, ad esempio). L'esecuzione di questo task \u00e8 delegato ad un apposito programma chiamato traduttore , che si occupa di tradurre il codice scritto in un linguaggio (chiamato linguaggio sorgente ) in codice scritto in un altro linguaggio (chiamato linguaggio obiettivo ). Normalmente, il linguaggio sorgente \u00e8 ad un livello di astrazione pi\u00f9 alto rispetto al linguaggio obiettivo: ad esempio, il linguaggio sorgente potrebbe essere il C, mentre il linguaggio obiettivo potrebbe essere Assembly. Il traduttore ha diversi compiti: per prima cosa, si occupa di verificare la correttezza sintattica del codice scritto in linguaggio sorgente. Per fare un esempio, il traduttore valider\u00e0 questa istruzione: a = 1 + 2 ma non questa: a = = 2 + 'pippo' Una volta validata la correttezza sintattica delle istruzioni analizzate, attribuir\u00e0 a ciascuna di esse un opportuno significato , associando le corrispondenti istruzioni nel linguaggio obiettivo. E' importante sottolinare come l'interpretazione debba essere univoca , onde garantire la propriet\u00e0 di non ambiguit\u00e0 degli algoritmi. Esistono principalmente due categorie di traduttori: i compilatori e gli interpreti .","title":"Traduttori"},{"location":"02_dispense/03_linguaggi/02_traduttori/#compilatori","text":"Il termine compilatore viene usato per indicare i traduttori che si occupano di tradurre direttamente il codice da un linguaggio sorgente ad alto livello ad un linguaggio obiettivo a basso livello, come assembly, codice oggetto o codice macchina. Nota Il fatto che un compilatore traduca direttamente il codice da linguaggio ad alto livello a codice oggetto/macchina implica che quest'ultimo sia specifico per un certo tipo di hardware e software. Ci\u00f2 comporta che, in molte situazioni, non saremo in grado di eseguire il codice compilato per i nostri PC su dispositivi come Arduino o i nostri smartphone!","title":"Compilatori"},{"location":"02_dispense/03_linguaggi/02_traduttori/#tipologie-di-compilatore-alcuni-esempi","text":"Esistono diversi tipi di compilatore. Ad esempio, se il programma compilato pu\u00f2 essere eseguito su un computer le cui caratteristiche hardware o software sono diverse da quelle del computer sul quale il programma \u00e8 stato compilato, siamo di fronte ad un cross-compilatore . Nota Per \"caratteristiche hardware o software\" si intendono prevalentemente CPU (ed il suo instruction set) e sistema operativo (ed i driver che comandano i diversi dispositivi). Il programma duale di un compilatore \u00e8 chiamato decompilatore , ed \u00e8, prevedibilmente, un programma che traduce il codice da un linguaggio sorgente a basso livello ad un linguaggio obiettivo a pi\u00f9 alto livello. Un altro esempio di compilatore \u00e8 il transcompilatore , che traduce un programma scritto in un sorgente ad alto livello in codice scritto in un obiettivo sempre ad alto livello.","title":"Tipologie di compilatore (alcuni esempi)"},{"location":"02_dispense/03_linguaggi/02_traduttori/#operazioni-di-un-compilatore","text":"La maggior parte dei compilatori odierni segue un percorso articolato in tre diverse fasi ( three-stage compilers ), chiamate rispettivamente front end , middle end e back end .","title":"Operazioni di un compilatore"},{"location":"02_dispense/03_linguaggi/02_traduttori/#front-end","text":"Lo scopo del front end \u00e8 quello di analizzare il codice scritto in liguaggio sorgente, creando una rappresentazione intermedia del programma. Il processo supportato dalla fase di front end si articola in quattro diverse fasi.","title":"Front end"},{"location":"02_dispense/03_linguaggi/02_traduttori/#preprocessing","text":"La fase di preprocessing (in italiano pre-elaborazione ) si occupa di sostituire alcune direttive specifiche per il linguaggio (ad esempio, le direttive #define in C) con il corrispondente codice sorgente.","title":"Preprocessing"},{"location":"02_dispense/03_linguaggi/02_traduttori/#analisi-lessicale","text":"La fase di analisi lessicale prevede la lettura del sorgente come un'unica stringa, e la successiva suddivisione della stessa in \"parti\" dette token , i quali sono delimitati da caratteri come segni di interpunzione (ad esempio, virgole, punti, etc.), operatori matematici (ad esempio, i segni + , - , etc.), parentesi, o anche nomi di variabile e parole riservate. Un esempio di tokenizzazione \u00e8 il seguente. il codice sorgente: if ( x > 0.0 ) { y = 1.0 ; } diventa: if ( x > 0.0 ) y = 1.0 ; che produce i token if , ( , x , > , 0.0 , ) , y , = , 1.0 .","title":"Analisi lessicale"},{"location":"02_dispense/03_linguaggi/02_traduttori/#analisi-sintattica","text":"La fase di analisi sintattica , comunemente nota anche come parsing , prevede l'analisi dei singoli token allo scopo di valutarne la correttezza sintattica , ovvero l'adesione alle regole grammaticali stabilite per quel linguaggio. L'analisi sintattica crea una struttura ad albero costruita a partire dalle regole formali del linguaggio, chiamata albero di parsing ( parse tree ).","title":"Analisi sintattica"},{"location":"02_dispense/03_linguaggi/02_traduttori/#analisi-semantica","text":"La fase di analisi semantica integra le informazioni immagazzinate nel parse tree con informazioni di tipo semantico, come ad esempio il type checking , che controlla la coerenza tra i diversi tipi assunti dalle variabili.","title":"Analisi semantica"},{"location":"02_dispense/03_linguaggi/02_traduttori/#middle-end","text":"Lo scopo del middle end \u00e8 quello di ottimizzare la rappresentazione intermedia ottenuta dal front end. Per far questo, sono implementate delle tecniche di analisi del programma (ad esempio, mediante l'analisi del flusso di esecuzione, allo scopo di valutare e la presenza di eventuali ridondanze) ed ottimizzazione (ad esempio, rimuovendo le ridondanze individuate nella fase precedente). Un esempio di ridondanza \u00e8 il seguente: int main ( void ) { int a = 0 ; // Codice ridondante! if ( 1 == 0 ) { a = 1 ; } return a ; } Il codice all'interno dell'istruzione condizionale non \u00e8 raggiungibile , in quanto la condizione di uguaglianza tra uno e zero non \u00e8, per le conoscenze attuali, mai verificata.","title":"Middle End"},{"location":"02_dispense/03_linguaggi/02_traduttori/#back-end","text":"Lo scopo del back end \u00e8 quello di inserire (opzionalmente) delle ottimizzazioni specifiche per l'architettura corrente (ovvero per il processore per il quale il codice sta venendo compilato), e generare il codice oggetto . Nota Il codice oggetto non \u00e8 il programma eseguibile. Generare l'eseguibile \u00e8 compito di un altro programma, spesso integrato in quelli che generalmente sono indicati come compilatori, chiamato linker .","title":"Back End"},{"location":"02_dispense/03_linguaggi/02_traduttori/#interpreti","text":"L'altro tipo di traduttore comunemente utilizzato al giorno d'oggi \u00e8 chiamato interprete . L'approccio usato dall'interprete si differenzia da quello usato dal compilatore principalmente per un dettaglio: laddove il compilatore fa in modo che l'intero processo di traduzione da codice sorgente a programma eseguibile avvenga prima dell'esecuzione del programma, in un lasso di tempo chiamato compile time , l'interprete esegue un'istruzione immediatamente ; in teoria, ogni istruzione in un linguaggio interpretata potrebbe essere eseguita immediatamente dopo la sua scrittura. Non vi \u00e8 quindi una netta separazione, almeno dal punto di vista dell'utente, tra compile time e run time (con quest'ultimo il lasso di tempo in cui il programma \u00e8 in esecuzione). Gli step di interpetazione sono quindi essenzialmente tre: controllo dell'istruzione sul codice sorgente; traduzione in linguaggio macchina; esecuzione dell'istruzione tradotta. Ne consegue che un programma interpretato potrebbe interrompersi \"al volo\" (ovvero a run time), proprio perch\u00e9 l'interprete non \u00e8 in grado di anticipare eventuali errori sul sorgente.","title":"Interpreti"},{"location":"02_dispense/03_linguaggi/02_traduttori/#compilatore-vs-interprete","text":"Di seguito una tabella comparativa di vantaggi e svantaggi legati all'adozione di un compilatore o di un interprete. Compilatore Interpete Vantaggi Ottimizzazione del codice Maggiore velocit\u00e0 di esecuzione Controllo sintattico e semantico Compile time nullo o ridotto Maggiore portabilit\u00e0 tra architettura Possibilit\u00e0 di debug con granularit\u00e0 a livello di singola istruzione Svantaggi Minore portabilit\u00e0 tra architetture Debug complesso da effettuare Minore velocit\u00e0 di esecuzione Performance non ottimizzate Possibili errori imprevisti a run time","title":"Compilatore vs. Interprete"},{"location":"02_dispense/03_linguaggi/02_traduttori/#linguaggi-compilati-e-linguaggi-interpretati","text":"Per linguaggio compilato si intende un linguaggio di programmazione le cui implementazioni sono tipicamente compilate ; di converso, un linguaggio interpretato prevede l'uso estensivo di interpeti. La distinzione \u00e8 per\u00f2 alquanto vaga. Infatti, almeno in linea di principio, qualunque linguaggio pu\u00f2 essere implementato indifferentemente mediante un compilatore od un itnerprete. E' anche possibile combinare entrambe le soluzioni: un compilatore pu\u00f2 ad esempio occuparsi della traduzione del codice sorgente nella rappresentazione intermedia, chiamata in questi casi bytecode , che viene passata ad un interprete che la esegue. E' questo ad esempio il caso di Java, che utilizza questo tipo di soluzione per passare il bytecode alla Java Virtual Machine , di cui esiste un'implementazione per la maggior parte delle architetture esistenti.","title":"Linguaggi compilati e linguaggi interpretati"},{"location":"02_dispense/04_programmazione/01_strutturata/","text":"Dal GOTO alla Programmazione Strutturata \u00b6 Il teorema di Bohm-Jacopini \u00b6 TODO: RIVEDERE Il teorema di Bohm-Jacopini dice che: orema di B\u00f6hm-Jacopini, enunciato nel 1966[1] dagli informatici Corrado B\u00f6hm e Giuseppe Jacopini, \u00e8 un teorema di informatica teorica il quale afferma che qualunque algoritmo pu\u00f2 essere implementato in fase di programmazione (in diagramma di flusso, pseudocodice o codice sorgente) utilizzando tre sole strutture dette strutture di controllo: la sequenza, la selezione ed il ciclo (iterazione), da applicare ricorsivamente alla composizione di istruzioni elementari (ad esempio, istruzioni eseguibili con il modello di base della macchina di Turing). Le implicazioni sono ovviamente importanti. Questo teorema ha un interesse anche teorico, in quanto i linguaggi di programmazione tendono a dotarsi di pi\u00f9 tipi di istruzioni di larga portata per evitare che i programmatori debbano occuparsi di istruzioni di portata molto minuta e quindi dispersive per quanto attiene alla padronanza delle finalit\u00e0 dell'algoritmo (esistono per\u00f2 linguaggi minimalisti, come Brainfuck, che si attengono alla lettera al teorema). Il suo valore va visto nella sua capacit\u00e0 di fornire indicazioni generali per le attivit\u00e0 di progettazione di nuovi linguaggi e di strategie di programmazione. In effetti, esso ha contribuito alla critica dell'uso sconsiderato delle istruzioni go to e alla definizione delle linee guida della programmazione strutturata che si sono avuti intorno al 1970. I diagrammi di flusso sono delle rappresentazioni grafiche del flusso di esecuzione di un algoritmo imperativo. Flussi \u00b6 Analizziamo adesso tre diversi tipi di flusso dati, ovvero la sequenza , la selezione ed il ciclo . Sequenza \u00b6 Il concetto di sequenza prevede una serie di istruzioni che siano realizzate l'una in cascata all'altra. Ad esempio, nel montaggio di un mobile IKEA, abbiamo normalmente una sequenza di istruzioni che portano al collegamento in maniera (sperabilmente) univoca dei vari pezzi tra loro. Per comprendere al meglio il concetto di sequenza, immaginiamo la seguente funzione (in Python). def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Valutazione della differenza tra punto_a_x e punto_b_x 3 > Valutazione del quadrato della differenza calcolata al punto 2 4 > Valutazione della differenza tra punto_a_y e punto_b_y 5 > Valutazione del quadrato della differenza calcolata al punto 4 6 > Estrazione della radice quadrata del valore calcolato al punto 5 Graficamente: TODO: rappresentare Selezione \u00b6 La selezione prevede invece la scelta tra due istruzioni che possono essere realizzate in maniera mutualmente esclusiva. Questo si traduce nella struttura IF - THEN - ELSE, che pu\u00f2 essere riassunta in linguaggio naturale come: Cite IF una data condizione \u00e8 verificata THEN esegui queste istruzioni ELSE esegui queste altre istruzioni. Immaginiamo ad esempio di inserire dei controlli alla precedente istruzione per verificare che i punti di cui vogliamo calcolare la distanza non coincidano. def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): if ( punto_a_x == punto_b_x and punto_a_y == punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 else : distanza = 0.0 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Se le coordinate di a e di b coincidono... 3a > ...valutazione della differenza tra punto_a_x e punto_b_x 4a > Valutazione del quadrato della differenza calcolata al punto 2 5a > Valutazione della differenza tra punto_a_y e punto_b_y 6a > Valutazione del quadrato della differenza calcolata al punto 4 7a > Estrazione della radice quadrata del valore calcolato al punto 5 ...altrimenti... 3b > Assegna a distanza il valore 0.0 8 > Restituisci il valore di distanza Graficamente: TODO: rappresentare Istruzione switch \u00b6 TODO: ricordare che lo switch non \u00e8 sempre presente in tutti i linguaggi TODO: perch\u00e9 switch e non struttura gerarchica di IF Ciclo \u00b6 L'ultimo tipo di struttura di controllo che esiste \u00e8 il ciclo , o iterazione . Anche comprendere come si strutturi l'iterazione \u00e8 intuitivo: in particolare, il ciclo prevede che siano reiterate pi\u00f9 volte una o pi\u00f9 istruzioni, fino a che non sia verificata una condizione. Istruzione For \u00b6 Istruzione While \u00b6","title":"01 strutturata"},{"location":"02_dispense/04_programmazione/01_strutturata/#dal-goto-alla-programmazione-strutturata","text":"","title":"Dal GOTO alla Programmazione Strutturata"},{"location":"02_dispense/04_programmazione/01_strutturata/#il-teorema-di-bohm-jacopini","text":"TODO: RIVEDERE Il teorema di Bohm-Jacopini dice che: orema di B\u00f6hm-Jacopini, enunciato nel 1966[1] dagli informatici Corrado B\u00f6hm e Giuseppe Jacopini, \u00e8 un teorema di informatica teorica il quale afferma che qualunque algoritmo pu\u00f2 essere implementato in fase di programmazione (in diagramma di flusso, pseudocodice o codice sorgente) utilizzando tre sole strutture dette strutture di controllo: la sequenza, la selezione ed il ciclo (iterazione), da applicare ricorsivamente alla composizione di istruzioni elementari (ad esempio, istruzioni eseguibili con il modello di base della macchina di Turing). Le implicazioni sono ovviamente importanti. Questo teorema ha un interesse anche teorico, in quanto i linguaggi di programmazione tendono a dotarsi di pi\u00f9 tipi di istruzioni di larga portata per evitare che i programmatori debbano occuparsi di istruzioni di portata molto minuta e quindi dispersive per quanto attiene alla padronanza delle finalit\u00e0 dell'algoritmo (esistono per\u00f2 linguaggi minimalisti, come Brainfuck, che si attengono alla lettera al teorema). Il suo valore va visto nella sua capacit\u00e0 di fornire indicazioni generali per le attivit\u00e0 di progettazione di nuovi linguaggi e di strategie di programmazione. In effetti, esso ha contribuito alla critica dell'uso sconsiderato delle istruzioni go to e alla definizione delle linee guida della programmazione strutturata che si sono avuti intorno al 1970. I diagrammi di flusso sono delle rappresentazioni grafiche del flusso di esecuzione di un algoritmo imperativo.","title":"Il teorema di Bohm-Jacopini"},{"location":"02_dispense/04_programmazione/01_strutturata/#flussi","text":"Analizziamo adesso tre diversi tipi di flusso dati, ovvero la sequenza , la selezione ed il ciclo .","title":"Flussi"},{"location":"02_dispense/04_programmazione/01_strutturata/#sequenza","text":"Il concetto di sequenza prevede una serie di istruzioni che siano realizzate l'una in cascata all'altra. Ad esempio, nel montaggio di un mobile IKEA, abbiamo normalmente una sequenza di istruzioni che portano al collegamento in maniera (sperabilmente) univoca dei vari pezzi tra loro. Per comprendere al meglio il concetto di sequenza, immaginiamo la seguente funzione (in Python). def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Valutazione della differenza tra punto_a_x e punto_b_x 3 > Valutazione del quadrato della differenza calcolata al punto 2 4 > Valutazione della differenza tra punto_a_y e punto_b_y 5 > Valutazione del quadrato della differenza calcolata al punto 4 6 > Estrazione della radice quadrata del valore calcolato al punto 5 Graficamente: TODO: rappresentare","title":"Sequenza"},{"location":"02_dispense/04_programmazione/01_strutturata/#selezione","text":"La selezione prevede invece la scelta tra due istruzioni che possono essere realizzate in maniera mutualmente esclusiva. Questo si traduce nella struttura IF - THEN - ELSE, che pu\u00f2 essere riassunta in linguaggio naturale come: Cite IF una data condizione \u00e8 verificata THEN esegui queste istruzioni ELSE esegui queste altre istruzioni. Immaginiamo ad esempio di inserire dei controlli alla precedente istruzione per verificare che i punti di cui vogliamo calcolare la distanza non coincidano. def distanza_euclidea ( punto_a_x , punto_a_y , punto_b_x , punto_b_y ): if ( punto_a_x == punto_b_x and punto_a_y == punto_b_y ): distanza_x = ( punto_a_x - punto_b_x ) ** 2 distanza_y = ( punto_a_y - punto_b_y ) ** 2 distanza = ( distanza_x + distanza_y ) ** 1 / 2 else : distanza = 0.0 return distanza Le operazioni che vengono eseguite possono essere schematizzate come segue: 1 > Analisi degli ingressi 2 > Se le coordinate di a e di b coincidono... 3a > ...valutazione della differenza tra punto_a_x e punto_b_x 4a > Valutazione del quadrato della differenza calcolata al punto 2 5a > Valutazione della differenza tra punto_a_y e punto_b_y 6a > Valutazione del quadrato della differenza calcolata al punto 4 7a > Estrazione della radice quadrata del valore calcolato al punto 5 ...altrimenti... 3b > Assegna a distanza il valore 0.0 8 > Restituisci il valore di distanza Graficamente: TODO: rappresentare","title":"Selezione"},{"location":"02_dispense/04_programmazione/01_strutturata/#istruzione-switch","text":"TODO: ricordare che lo switch non \u00e8 sempre presente in tutti i linguaggi TODO: perch\u00e9 switch e non struttura gerarchica di IF","title":"Istruzione switch"},{"location":"02_dispense/04_programmazione/01_strutturata/#ciclo","text":"L'ultimo tipo di struttura di controllo che esiste \u00e8 il ciclo , o iterazione . Anche comprendere come si strutturi l'iterazione \u00e8 intuitivo: in particolare, il ciclo prevede che siano reiterate pi\u00f9 volte una o pi\u00f9 istruzioni, fino a che non sia verificata una condizione.","title":"Ciclo"},{"location":"02_dispense/04_programmazione/01_strutturata/#istruzione-for","text":"","title":"Istruzione For"},{"location":"02_dispense/04_programmazione/01_strutturata/#istruzione-while","text":"","title":"Istruzione While"},{"location":"02_dispense/04_programmazione/02_ricorsione/","text":"La ricorsione \u00e8 una tecnica che permette di progettare un algoritmo per risolvere un problema risolvendo delle istanze pi\u00f9 piccole dello stesso, fino a quando il problema non \u00e8 cos\u00ec piccolo che possiamo risolverlo direttamente. Per il primo esempio, vediamo come calcolare la funzione fatoriale. Indichiamo il fattoriale di \\(n\\) con \\(n!\\) . Il fattoriale \u00e8 definito come il prodotto degli interi che vanno da \\(1\\) ad \\(n\\) . Ad esempio, \\(5!\\) \u00e8 pari a \\(1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5\\) , ovvero \\(120\\) . Ci si potrebbe chiedere perch\u00e9 ci dovrebbe interessare la funzione fattoriale. E' molto utile per quando stiamo provando a contare quanti diversi modi di combinare diverse cose ci sono. Immaginiamo ad esempio di dover combinare \\(n\\) cose. Abbiamo \\(n\\) modi di disporre la prima cosa. Per la seconda, ce ne rimangono \\(n-1\\) ; combinandoli, abbiamo che i modi possibili per disporre le due cose sono \\(n \\cdot (n - 1)\\) . Ovvaimente, il concetto pu\u00f2 essere espanso, ed avremo che alla fine il modo di disporrre le \\(n\\) cose sar\u00e0 pari ad \\(n \\cdot (n - 1) \\cdot (n - 2) \\cdot ... \\cdot 2 \\cdot 1\\) . Il fattoriale \u00e8 definito per tutti gli interi positivi, assieme allo 0, con \\(0! = 1\\) . Calcolare il fattoriale in maniera iterativa \u00b6 Calcolare il fattoriale in maniera iterativa \u00e8 molto semplice. Infatti: STEP 1 -> RES = 1; STEP 2 -> FOR I = 1; I <= N; I++ RES = RES * I; STEP 3 -> RETURN N_FATT; L'implementazione \u00e8 in realt\u00e0 abbastanza semplice: si tratta, nella pratica, di fare una serie di moltiplicazioni: \\[ n! = n \\cdot (n - 1) \\ldot 2 \\cdot 1 \\] Notiamo per\u00f2 che \\((n - 1) ! = (n - 1) \\ldot 2 \\cdot 1\\) , per cui possiamo scrivere che: \\[ n! = n \\cdot (n - 1)! \\] In questa situazione, \\((n - 1)!\\) diventa un sottoproblema che dobbiamo risolvere per calcolare \\(n!\\) . Ad esempio: \\[ 5! = 5 * 4! \\] Estendendo il concetto, e minimizzando le dimensioni del sottoproblema, abbiamo che: \\[ 5! = 5 * 4! = 5 * 4 * 3! = 5 * 4 * 3 * 2! = 5 * 4 * 3 * 2 * 1! = 5 * 4 * 3 * 2 * 1 * 0! \\] Usando la propriet\u00e0 commutativa: \\[ \\begin{eqnarray} 0! * 1 &= 1 &= 1! &\\Rightarrow \\\\ 1! * 2 &= 2 &= 2! &!Rightarrow \\\\ 2! * 3 &= 2 &= 3! &!Rightarrow \\\\ 3! * 4 &= 2 &= 4! &!Rightarrow \\\\ 4! * 5 &= 2 &= 5! \\end{eqnarray} \\] Risulta che: nel caso n = 0, allora n! = 1 (caso base); nel caso n > 0, allora possiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\) Possiamo quindi rivedere la nostra funzione utilizzando un approccio ricorsivo . STEP 1 -> IF N = 0 return 1 ELSE return n * factorial(n - 1) Note \u00b6 Affinch\u00e9 un algoritmo ricorsivo funzioni, deve essere ricorsivamente condotto al caso base. Ad esempio, quando si calcola \\(n!\\) in maniera ricorsiva, il sottoproblema diventa sempre pi\u00f9 piccolo fino a che no si arriva al caso base. Usare algoritmi ricorsivi nel senso opposto potrebbe non portare mai a convergenza.","title":"02 ricorsione"},{"location":"02_dispense/04_programmazione/02_ricorsione/#calcolare-il-fattoriale-in-maniera-iterativa","text":"Calcolare il fattoriale in maniera iterativa \u00e8 molto semplice. Infatti: STEP 1 -> RES = 1; STEP 2 -> FOR I = 1; I <= N; I++ RES = RES * I; STEP 3 -> RETURN N_FATT; L'implementazione \u00e8 in realt\u00e0 abbastanza semplice: si tratta, nella pratica, di fare una serie di moltiplicazioni: \\[ n! = n \\cdot (n - 1) \\ldot 2 \\cdot 1 \\] Notiamo per\u00f2 che \\((n - 1) ! = (n - 1) \\ldot 2 \\cdot 1\\) , per cui possiamo scrivere che: \\[ n! = n \\cdot (n - 1)! \\] In questa situazione, \\((n - 1)!\\) diventa un sottoproblema che dobbiamo risolvere per calcolare \\(n!\\) . Ad esempio: \\[ 5! = 5 * 4! \\] Estendendo il concetto, e minimizzando le dimensioni del sottoproblema, abbiamo che: \\[ 5! = 5 * 4! = 5 * 4 * 3! = 5 * 4 * 3 * 2! = 5 * 4 * 3 * 2 * 1! = 5 * 4 * 3 * 2 * 1 * 0! \\] Usando la propriet\u00e0 commutativa: \\[ \\begin{eqnarray} 0! * 1 &= 1 &= 1! &\\Rightarrow \\\\ 1! * 2 &= 2 &= 2! &!Rightarrow \\\\ 2! * 3 &= 2 &= 3! &!Rightarrow \\\\ 3! * 4 &= 2 &= 4! &!Rightarrow \\\\ 4! * 5 &= 2 &= 5! \\end{eqnarray} \\] Risulta che: nel caso n = 0, allora n! = 1 (caso base); nel caso n > 0, allora possiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\) Possiamo quindi rivedere la nostra funzione utilizzando un approccio ricorsivo . STEP 1 -> IF N = 0 return 1 ELSE return n * factorial(n - 1)","title":"Calcolare il fattoriale in maniera iterativa"},{"location":"02_dispense/04_programmazione/02_ricorsione/#note","text":"Affinch\u00e9 un algoritmo ricorsivo funzioni, deve essere ricorsivamente condotto al caso base. Ad esempio, quando si calcola \\(n!\\) in maniera ricorsiva, il sottoproblema diventa sempre pi\u00f9 piccolo fino a che no si arriva al caso base. Usare algoritmi ricorsivi nel senso opposto potrebbe non portare mai a convergenza.","title":"Note"},{"location":"02_dispense/04_programmazione/03_variabili/","text":"Abbiamo gi\u00e0 accennato al concetto di variabile nella parte introduttiva del corso, dove lo abbiamo definito come dato di supporto . Questo suggerisce che una variabile non sia n\u00e9 un dato di ingresso al nostro programma, n\u00e9 un risultato atteso; \u00e8 piuttosto una rappresentazione dello stato interno dell'algoritmo ad un dato istante. E' facile osservare come le variabili siano di un'utilit\u00e0 estrema. Pensiamo ad esempio alla possibilit\u00e0 di inserire un contatore all'interno del nostro programma, che conti (ad esempio) il numero di operazioni eseguite, oppure ad una variabile di supporto, che ci permetta di modellare dei valori intermedi durante l'esecuzione di calcoli complessi. La variabile, come indica il nome stesso, pu\u00f2 variare durante l'esecuzione del programma. Ne esiste quindi una \"controparte\", assimilabile per\u00f2 dal punto di vista concettuale, chiamata costante : questa, ovviamente, non varia durante l'esecuzione del programma, ed \u00e8 utilizzata per caratterizzare (ad esempio) delle costanti matematiche come il \\(\\pi\\) . Nota sulle costanti Normalmente, le costanti matematiche sono gi\u00e0 caratterizzate all'interno del linguaggio di programmazione. Tuttavia, l'uso delle costanti deve essere valutato a seconda del programma, tenendo presente che la scelta tra variabile e costante \u00e8, molto spesso, soltanto da intendersi come aiuto al programmatore. Dichiarazione ed inizializzazione \u00b6 La procedura per poter utilizzare una variabile si articola in due step fondamentali. Il primo \u00e8 la dichiarazione della variabile, operazione mediante la quale il computer \"viene a conoscenza\" dell'esistenza della variabile, associandovi un identificatore (o nome ) ed un tipo (ci ritorneremo a breve). Per esempio, ecco come \u00e8 possibile dichiarare una variabile chiamata numero che rappresenta un numero intero in linguaggio C: int numero ; Una volta dichiarata la variabile, \u00e8 necessario associarle un valore. Per farlo, si usa la procedura di inizializzazione , sfruttando l'operatore di assegnamento = . Ad esempio, assegnamo alla variabile numero il valore 1 : numero = 1 ; E' possibile combinare le procedure di dichiarazione ed inizializzazione in un'unica istruzione: int altro_numero = 2 ; Tipo della variabile \u00b6 Per tipo della variabile si intende il formato associato alla stessa, che ne influenza di conseguenza i valori che questa pu\u00f2 rappresentare. I linguaggi di programmazione utilizzano quindi questo tipo di soluzione per differenziare (ad esempio) valori numerici di tipo intero da valori numerici di tipo reale, oppure ancora valori booleani da caratteri. Importanza del tipo \u00b6 Tenere in conto il tipo di dato durante lo sviluppo di un programma \u00e8 estremamente importante principalmente per due ragioni. 1. Flusso logico del programma \u00b6 La prima \u00e8 legata alla gestione del flusso logico del programma . Immaginiamo, infatti, di dover sommare due numeri reali x ed y , e di voler associare il valore risultante da questa operazione alla variabile z , che per\u00f2 \u00e8 di tipo intero: float x = 1.1 ; float y = 1.2 ; int z ; z = x + y ; E' facile comprendere come, nonostante il valore atteso di z sia pari a 2.3 , avremo in realt\u00e0 2 a causa del fatto che z \u00e8 un valore intero, con un errore di troncamento pari a 0.3 . Questo, ovviamente, nel caso in cui il programma venga comunque compilato: infatti, se il linguaggio impone un controllo stringente sul tipo di dato, \u00e8 probabile che la procedura di compilazione non vada a buon fine. Strani errori e come trovarli \u00b6 E' importante stare attenti a situazioni nelle quali si sommano degli interi a dei caratteri. Ricordiamo infatti che ogni carattere ha una rappresentazione numerica associata in un determinato formato; quindi, in un linguaggio \"particolarmente\" permissivo, potrebbe essere concesso sommare un intero ad un char , ottenendo per\u00f2 risultati inaspettati. Ad esempio, provando ad eseguire questa addizione: int x = 1 ; char y = '1' ; int z = x + y ; il valore di z ottenuto non sar\u00e0 pari a 2, ma a 50! 2. Quantit\u00e0 di memoria allocata per la variabile \u00b6 Il tipo di dato ha forti implicazioni sulla quantit\u00e0 di memoria utilizzata da ogni variabile, e quindi sul numero di valori che \u00e8 possibile rappresentare. La seguente tabella riporta queste associazioni per alcuni tipi di dato comunemente utilizzati. Denominazione Spazio occupato Descrizione short 16 bit Rappresenta un tipo di dato intero con precisione a 16 bit. int 32 bit Rappresenta un dato di tipo intero con segno. uint 32 bit Rappresenta un tipo di dato intero senza segno ( unsigned ) long 64 bit Rappresenta un tipo di dato intero con precisione a 64 bit. float 32 bit Rappresenta un tipo di dato reale con precisione a 32 bit. double 64 bit Rappresenta un tipo di dato reale con precisione a 64 bit. bool 1 bit Rappresenta un valore nell'algebra booleana (ovvero uno 0 o un 1 ). char 1 byte Rappresenta un singolo carattere. E' quindi importante scegliere il tipo di dato adatto alla specifica situazione. Se siamo sicuri, ad esempio, che tratteremo solo interi inferiori al 100, potremmo scegliere un formato di tipo short per risparmiare quanta pi\u00f9 memoria possibile. Cosa accadrebbe per\u00f2 se \"infrangessimo\" il limite massimo di valori degli short, ovvero \\(2^{16}\\) ? In questo caso, ovviamente, il tipo di dato (e quindi il quantitativo di memoria riservato per la variabile) non cambierebbe; ci\u00f2 significa che avremmo un errore di troncamento legato al fatto che ogni valore superiore a \\(2^{16}\\) (per la cronaca, 65.536) sarebbe approssimato (o meglio, troncato ) proprio a quest'ultimo. Tipizzazione forte e debole E' importante porre particolare attenzione alla tipizzazione offerta dal linguaggio in uso. In un linguaggio a tipizzazione forte, come il C, \u00e8 sempre necessario specificare il tipo della variabile, ed \u00e8 opportuno tenerne strettamente conto durante l'intero arco di esecuzione del programma. I linguaggi a tipizzazione debole, invece, come il Python, sono pi\u00f9 permissivi da questo punto di vista. Tuttavia, laddove scrivere un programma in un linguaggio a tipizzazione debole pu\u00f2 essere pi\u00f9 semplice, \u00e8 comunque facile ritrovarsi in situazioni inattese, in quanto al programmatore non verranno date indicazioni a priori sulla correttezza del flusso di esecuzione del programma.","title":"11 - Variabili"},{"location":"02_dispense/04_programmazione/03_variabili/#dichiarazione-ed-inizializzazione","text":"La procedura per poter utilizzare una variabile si articola in due step fondamentali. Il primo \u00e8 la dichiarazione della variabile, operazione mediante la quale il computer \"viene a conoscenza\" dell'esistenza della variabile, associandovi un identificatore (o nome ) ed un tipo (ci ritorneremo a breve). Per esempio, ecco come \u00e8 possibile dichiarare una variabile chiamata numero che rappresenta un numero intero in linguaggio C: int numero ; Una volta dichiarata la variabile, \u00e8 necessario associarle un valore. Per farlo, si usa la procedura di inizializzazione , sfruttando l'operatore di assegnamento = . Ad esempio, assegnamo alla variabile numero il valore 1 : numero = 1 ; E' possibile combinare le procedure di dichiarazione ed inizializzazione in un'unica istruzione: int altro_numero = 2 ;","title":"Dichiarazione ed inizializzazione"},{"location":"02_dispense/04_programmazione/03_variabili/#tipo-della-variabile","text":"Per tipo della variabile si intende il formato associato alla stessa, che ne influenza di conseguenza i valori che questa pu\u00f2 rappresentare. I linguaggi di programmazione utilizzano quindi questo tipo di soluzione per differenziare (ad esempio) valori numerici di tipo intero da valori numerici di tipo reale, oppure ancora valori booleani da caratteri.","title":"Tipo della variabile"},{"location":"02_dispense/04_programmazione/03_variabili/#importanza-del-tipo","text":"Tenere in conto il tipo di dato durante lo sviluppo di un programma \u00e8 estremamente importante principalmente per due ragioni.","title":"Importanza del tipo"},{"location":"02_dispense/04_programmazione/03_variabili/#1-flusso-logico-del-programma","text":"La prima \u00e8 legata alla gestione del flusso logico del programma . Immaginiamo, infatti, di dover sommare due numeri reali x ed y , e di voler associare il valore risultante da questa operazione alla variabile z , che per\u00f2 \u00e8 di tipo intero: float x = 1.1 ; float y = 1.2 ; int z ; z = x + y ; E' facile comprendere come, nonostante il valore atteso di z sia pari a 2.3 , avremo in realt\u00e0 2 a causa del fatto che z \u00e8 un valore intero, con un errore di troncamento pari a 0.3 . Questo, ovviamente, nel caso in cui il programma venga comunque compilato: infatti, se il linguaggio impone un controllo stringente sul tipo di dato, \u00e8 probabile che la procedura di compilazione non vada a buon fine.","title":"1. Flusso logico del programma"},{"location":"02_dispense/04_programmazione/03_variabili/#strani-errori-e-come-trovarli","text":"E' importante stare attenti a situazioni nelle quali si sommano degli interi a dei caratteri. Ricordiamo infatti che ogni carattere ha una rappresentazione numerica associata in un determinato formato; quindi, in un linguaggio \"particolarmente\" permissivo, potrebbe essere concesso sommare un intero ad un char , ottenendo per\u00f2 risultati inaspettati. Ad esempio, provando ad eseguire questa addizione: int x = 1 ; char y = '1' ; int z = x + y ; il valore di z ottenuto non sar\u00e0 pari a 2, ma a 50!","title":"Strani errori e come trovarli"},{"location":"02_dispense/04_programmazione/03_variabili/#2-quantita-di-memoria-allocata-per-la-variabile","text":"Il tipo di dato ha forti implicazioni sulla quantit\u00e0 di memoria utilizzata da ogni variabile, e quindi sul numero di valori che \u00e8 possibile rappresentare. La seguente tabella riporta queste associazioni per alcuni tipi di dato comunemente utilizzati. Denominazione Spazio occupato Descrizione short 16 bit Rappresenta un tipo di dato intero con precisione a 16 bit. int 32 bit Rappresenta un dato di tipo intero con segno. uint 32 bit Rappresenta un tipo di dato intero senza segno ( unsigned ) long 64 bit Rappresenta un tipo di dato intero con precisione a 64 bit. float 32 bit Rappresenta un tipo di dato reale con precisione a 32 bit. double 64 bit Rappresenta un tipo di dato reale con precisione a 64 bit. bool 1 bit Rappresenta un valore nell'algebra booleana (ovvero uno 0 o un 1 ). char 1 byte Rappresenta un singolo carattere. E' quindi importante scegliere il tipo di dato adatto alla specifica situazione. Se siamo sicuri, ad esempio, che tratteremo solo interi inferiori al 100, potremmo scegliere un formato di tipo short per risparmiare quanta pi\u00f9 memoria possibile. Cosa accadrebbe per\u00f2 se \"infrangessimo\" il limite massimo di valori degli short, ovvero \\(2^{16}\\) ? In questo caso, ovviamente, il tipo di dato (e quindi il quantitativo di memoria riservato per la variabile) non cambierebbe; ci\u00f2 significa che avremmo un errore di troncamento legato al fatto che ogni valore superiore a \\(2^{16}\\) (per la cronaca, 65.536) sarebbe approssimato (o meglio, troncato ) proprio a quest'ultimo. Tipizzazione forte e debole E' importante porre particolare attenzione alla tipizzazione offerta dal linguaggio in uso. In un linguaggio a tipizzazione forte, come il C, \u00e8 sempre necessario specificare il tipo della variabile, ed \u00e8 opportuno tenerne strettamente conto durante l'intero arco di esecuzione del programma. I linguaggi a tipizzazione debole, invece, come il Python, sono pi\u00f9 permissivi da questo punto di vista. Tuttavia, laddove scrivere un programma in un linguaggio a tipizzazione debole pu\u00f2 essere pi\u00f9 semplice, \u00e8 comunque facile ritrovarsi in situazioni inattese, in quanto al programmatore non verranno date indicazioni a priori sulla correttezza del flusso di esecuzione del programma.","title":"2. Quantit\u00e0 di memoria allocata per la variabile"},{"location":"02_dispense/04_programmazione/04_funzioni/","text":"La funzione , o metodo , \u00e8 un costrutto che permette di raggruppare una serie di istruzioni che sono eseguite pi\u00f9 volte all'interno del nostro programma. Una funzione \u00e8 articolata in due parti: una firma ed un corpo . La firma della funzione \u00e8 dove sono definiti: nome della funzione (ovvero un identificativo utile a richiamarla in altre parti del programma); tipo di ritorno , ovvero il tipo del valore in output alla funzione; parametri di ingresso , ovvero il tipo ed i nomi dei valori che saranno mandati in input alla funzione. Nel corpo sono invece definite le istruzioni vere e proprie, oltre che il valore restituito dalla funzione (che, ovviamente, deve essere del tipo specificato in firma.) Ad esempio: // Questa \u00e8 la firma! tipo_ritorno nome_funzione ( tipo_par_1 par_1 , tipo_par_2 par_2 ) { // Questo \u00e8 il corpo istr_1 ; istr_2 ; tipo_ritorno valore_ritorno = istr_3 ; return valore_ritorno ; } E' importante sottolineare come il tipo di ritorno ed i tipi dei parametri in ingresso possono essere omessi in caso di linguaggio non fortemente tipizzato. Molti linguaggi specificano inoltre dei modificatori di accesso alla funzione; ne parleremo in seguito, quando introdurremo la programmazione orientata agli oggetti. Riutilizzo del codice \u00b6 Il principio alla base dello sviluppo delle funzioni \u00e8 quello secondo il quale vogliamo minimizzare il quantitativo di codice scritto. Meno codice, infatti, significa meno possibilit\u00e0 di refusi, che in linguaggi dalla grammatica \"rigida\" come quello per i computer possono anche significare l'impossibilit\u00e0 di eseguire il programma. Inoltre, una funzione pu\u00f2 essere intesa, molto alla lontana, come un teorema matematico: ad esempio, le relazioni definite dal teorema di Pitagora valgono indipendentemente dai valori dei cateti e dell'ipotenusa. Ci\u00f2 ci permette quindi di avere un insieme di istruzioni fisse e controllabili , che possiamo manipolare e verificare a piacimento, conservando la coerenza del nostro programma: saremo infatti sicuri che il comportamento di una funzione sar\u00e0 replicato alla stessa maniera ogni volta che la chiameremo , indipendentemente dal programma considerato. Facciamo un esempio. def ipotenusa ( c_1 , c_2 ): c_1_quad = c_1 ** 2 c_2_quad = c_2 ** 2 i = ( c_1_quad + c_2_quad ) ** 1 / 2 return i # Questo \u00e8 il nostro programma if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d ) Se non avessimo utilizzato la funzione ipotenusa, avremmo dovuto scrivere due volte la formula per il calcolo dell'ipotenusa, con il rischio di sbagliare una volta, o comunque scrivere due metodi di calcolo differenti. La stessa funzione in C L'esempio precedente \u00e8 scritto in Python, linguaggio non fortemente tipizzato. In C la funzione sarebbe int ipotenusa ( int c_1 , int c_2 ) { int c_1_quad = c_1 * c_1 ; int c_2_quad = c_2 * c_2 ; int c_quad_sum = c_1_quad + c_2_quad ; int i = sqrt ( c_quad_sum ); return i ; } Modularit\u00e0 \u00b6 Le funzioni permettono anche di scrivere del codice modulare . Ci\u00f2 significa che ogni funzione asserve ad un determinato scopo, ed il nostro programma pu\u00f2 \"comporsi\" a partire da diversi metodi, cambiando i quali se ne cambiano anche scopi e finalit\u00e0. Ad esempio, se si dovesse in futuro scoprire una nuova formulazione per il teorema di Pitagora, non dovremmo cambiare tutto il nostro programma, ma basterebbe modificare esclusivamente la funzione che implementa il teorema di Pitagora: def ipotenusa ( c_1 , c_2 ): i = ( c_1 + c_2 ) return i # Il programma non cambia! if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d )","title":"12 - Funzioni"},{"location":"02_dispense/04_programmazione/04_funzioni/#riutilizzo-del-codice","text":"Il principio alla base dello sviluppo delle funzioni \u00e8 quello secondo il quale vogliamo minimizzare il quantitativo di codice scritto. Meno codice, infatti, significa meno possibilit\u00e0 di refusi, che in linguaggi dalla grammatica \"rigida\" come quello per i computer possono anche significare l'impossibilit\u00e0 di eseguire il programma. Inoltre, una funzione pu\u00f2 essere intesa, molto alla lontana, come un teorema matematico: ad esempio, le relazioni definite dal teorema di Pitagora valgono indipendentemente dai valori dei cateti e dell'ipotenusa. Ci\u00f2 ci permette quindi di avere un insieme di istruzioni fisse e controllabili , che possiamo manipolare e verificare a piacimento, conservando la coerenza del nostro programma: saremo infatti sicuri che il comportamento di una funzione sar\u00e0 replicato alla stessa maniera ogni volta che la chiameremo , indipendentemente dal programma considerato. Facciamo un esempio. def ipotenusa ( c_1 , c_2 ): c_1_quad = c_1 ** 2 c_2_quad = c_2 ** 2 i = ( c_1_quad + c_2_quad ) ** 1 / 2 return i # Questo \u00e8 il nostro programma if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d ) Se non avessimo utilizzato la funzione ipotenusa, avremmo dovuto scrivere due volte la formula per il calcolo dell'ipotenusa, con il rischio di sbagliare una volta, o comunque scrivere due metodi di calcolo differenti. La stessa funzione in C L'esempio precedente \u00e8 scritto in Python, linguaggio non fortemente tipizzato. In C la funzione sarebbe int ipotenusa ( int c_1 , int c_2 ) { int c_1_quad = c_1 * c_1 ; int c_2_quad = c_2 * c_2 ; int c_quad_sum = c_1_quad + c_2_quad ; int i = sqrt ( c_quad_sum ); return i ; }","title":"Riutilizzo del codice"},{"location":"02_dispense/04_programmazione/04_funzioni/#modularita","text":"Le funzioni permettono anche di scrivere del codice modulare . Ci\u00f2 significa che ogni funzione asserve ad un determinato scopo, ed il nostro programma pu\u00f2 \"comporsi\" a partire da diversi metodi, cambiando i quali se ne cambiano anche scopi e finalit\u00e0. Ad esempio, se si dovesse in futuro scoprire una nuova formulazione per il teorema di Pitagora, non dovremmo cambiare tutto il nostro programma, ma basterebbe modificare esclusivamente la funzione che implementa il teorema di Pitagora: def ipotenusa ( c_1 , c_2 ): i = ( c_1 + c_2 ) return i # Il programma non cambia! if __name__ == \"__main__\" : a = 3 b = 4 i_1 = ipotenusa ( a , b ) c = 6 d = 8 i_2 = ipotenusa ( c , d )","title":"Modularit\u00e0"},{"location":"02_dispense/04_programmazione/05_complessita/","text":"Analisi degli algoritmi \u00b6 L'analisi delle performance di un algoritmo pu\u00f2 essere effettuata in due diverse fasi, ovvero prima ( analisi a priori ) e dopo ( analisi a posteriori ) l'implementazione. Analisi a priori \u00b6 L' analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato, o la quantit\u00e0 di memoria disponibile (RAM, cache e registri), siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso. Nota Ovviamente, sta al lettore comprendere il contesto legato alle premesse dell'analisi a priori. Ci\u00f2 significa che \u00e8 fortemente sconsigliato provare ad eseguire un algoritmo che ha difficolt\u00e0 a girare su una GeForce 3090 su un Raspberry Pi 2, indipendentemente dalle considerazioni derivanti dall'analisi a priori. Analisi a posteriori \u00b6 L' analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata. Importanza del contesto Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore, che rappresentano spesso il vero e proprio collo di bottiglia. Statistica ed analisi E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti. Ad ogni modo, che si parli di analisi a priori od a posteriori, questa procedura \u00e8 necessaria per valutare la complessit\u00e0 dell'algoritmo. Complessit\u00e0 degli algoritmi \u00b6 Supponiamo che un algoritmo \\(X\\) abbia un insieme di dati in ingresso di cardinalit\u00e0 \\(N\\) . La complessit\u00e0 dell'algoritmo \u00e8 strettamente correlata a due fattori, ovvero il tempo richiesto per l'esecuzione dell'algoritmo e lo spazio occupato da questo in memoria. In particolare, la complessit\u00e0 temporale \u00e8 determinata contando il numero di operazioni effettuate. Per esempio, negli algoritmi di ordinamento, il fattore temporale \u00e8 direttamente proporzionale al numero di confronti tra gli elementi che saranno ordinati. La complessit\u00e0 spaziale \u00e8 invece determinata valutando lo spazio massimo richiesto dall'algoritmo in termini di memoria occupata. Iniziamo parlando proprio di quest'ultima. Complessit\u00e0 spaziale \u00b6 La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria dall'inizio alla fine della sua esecuzione. Questo \u00e8 pari alla somma di due componenti: una parte fissa, pari allo spazio richiesto per la memorizzazione di dati \"fissi\", come funzioni e costanti, che non variano a seconda del problema; una parte variabile, data dallo spazio richiesto per la memorizzazione (appunto) delle variabili, la cui dimensione \u00e8 dipendente dal problema stesso. Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(S(X)\\) di un algoritmo \\(X\\) come: \\[ S(X) = S_F + S_V(C) \\] con \\(S_F\\) parte fissa ed \\(S_V\\) parte variabile e dipendente dalle caratteristiche \\(C\\) dell'algoritmo \\(X\\) . Nota Le caratteristiche \\(C\\) non coincidono con il numero di variabili in input per l'algoritmo \\(N\\) . Un esempio \u00b6 Consideriamo il seguente algoritmo (in pseudocodice): SUM_ONE(P, Q) Step 1 -> START Step 2 -> R = P + Q + 1 Step 3 -> STOP Analisi a priori \u00b6 Il numero di variabili in questo algoritmo \u00e8 pari a 3, ovvero P e Q (input) ed R (output). Abbiamo inoltre una costante (il valore 1 ). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a: \\[ S(X) = S_F + S_V(C) = 1 + 3 \\] Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria. Analisi a posteriori \u00b6 Supponiamo che l'effettiva implementazione dell'algoritmo sia in linguaggio C, e che il tipo di dato associato a ciascuna variabile sia un intero. La complessit\u00e0 spaziale (analizzata a posteriori) sar\u00e0 pari a: \\[ m_{int} = 32 bit \\Rightarrow S(X) = S_F + S_V(C) = 4 m_{int} = 128 bit \\] Complessit\u00e0 temporale \u00b6 Abbiamo visto come la complessit\u00e0 temporale di un algoritmo sia associata alla quantit\u00e0 di tempo richiesto dallo stesso per una sua completa esecuzione. Anche questa complessit\u00e0 pu\u00f2 essere espressa come una funzione numerica del tipo \\(T(I)\\) , con \\(I\\) numero di step necessari al completamento dell'istruzione. Un esempio \u00b6 Analisi a priori \u00b6 Torniamo al precedente algoritmo. In questo caso, abbiamo elencato tre step, anche se, nei fatti, ci sono solo due operazioni di cui tenere conto, ovvero due addizione. Quindi, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(T(I) = 2\\) . Analisi a posteriori \u00b6 Anche in questo caso, per effettuare l'analisi a posteriori avremo bisogno di fissare alcune condizioni. Supponiamo, ad esempio, che il nostro processore impieghi un microsecondo per eseguire una somma. Di conseguenza, la complessit\u00e0 temporale analizzata a posteriori sar\u00e0 pari a 2 microsecondi. Complessit\u00e0 di caso peggiore \u00b6 L'esempio che abbiamo visto \u00e8, al solito, estremamente semplice. In realt\u00e0, \u00e8 difficile che nella realt\u00e0 sia necessario calcolare la complessit\u00e0 computazionale di situazioni cos\u00ec poco articolate; \u00e8 pi\u00f9 facile avere un'idea abbastanza sommaria della complessit\u00e0 spaziale e temporale di un algoritmo, che va quindi stimata assumendo il caso peggiore , ovvero calcolando il numero massimo di operazioni e/o spazio che, nel peggiore dei casi, il nostro algoritmo dovrebbe dover effettuare e/o occupare. Per far questo, si utilizza la notazione O-grande , utilizzata spesso per descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. Detto in maniera meno formale: un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(T(n) = O(n^2)\\) avr\u00e0 un costo, in termini di tempo, pari al pi\u00f9 ad \\(n^2\\) ; un algoritmo con una complessit\u00e0 \\(T(n) = O(n * log(n))\\) \"coster\u00e0\" al massimo \\(n*log(n)\\) operazioni, e cos\u00ec via. Alcuni esempi \u00b6 Semplice ciclo for \u00b6 Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo for : int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \"%d\" , i ); i ++ ; } Notiamo innanzitutto che il valore del contatore i viene incrementato di due ad ogni iterazione. Ci\u00f2 significa che, al pi\u00f9 , saranno eseguite \\(n/2\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale sia nell'ordine di \\(O(n/2)\\) . Cicli for annidati \u00b6 Vediamo cosa accade nel caso si considerino due cicli for l'uno annidato all'interno dell'altro. int n = 10 ; for ( int i = 0 ; i < n 0 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { printf ( \"%d\" , i ); } } Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile i ) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile j ). La complessit\u00e0 di caso peggiore sar\u00e0 quindi \\(O(n^2)\\) .","title":"13 - Complessit\u00e0 computazionale"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-degli-algoritmi","text":"L'analisi delle performance di un algoritmo pu\u00f2 essere effettuata in due diverse fasi, ovvero prima ( analisi a priori ) e dopo ( analisi a posteriori ) l'implementazione.","title":"Analisi degli algoritmi"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-priori","text":"L' analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato, o la quantit\u00e0 di memoria disponibile (RAM, cache e registri), siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso. Nota Ovviamente, sta al lettore comprendere il contesto legato alle premesse dell'analisi a priori. Ci\u00f2 significa che \u00e8 fortemente sconsigliato provare ad eseguire un algoritmo che ha difficolt\u00e0 a girare su una GeForce 3090 su un Raspberry Pi 2, indipendentemente dalle considerazioni derivanti dall'analisi a priori.","title":"Analisi a priori"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-posteriori","text":"L' analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata. Importanza del contesto Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore, che rappresentano spesso il vero e proprio collo di bottiglia. Statistica ed analisi E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti. Ad ogni modo, che si parli di analisi a priori od a posteriori, questa procedura \u00e8 necessaria per valutare la complessit\u00e0 dell'algoritmo.","title":"Analisi a posteriori"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-degli-algoritmi","text":"Supponiamo che un algoritmo \\(X\\) abbia un insieme di dati in ingresso di cardinalit\u00e0 \\(N\\) . La complessit\u00e0 dell'algoritmo \u00e8 strettamente correlata a due fattori, ovvero il tempo richiesto per l'esecuzione dell'algoritmo e lo spazio occupato da questo in memoria. In particolare, la complessit\u00e0 temporale \u00e8 determinata contando il numero di operazioni effettuate. Per esempio, negli algoritmi di ordinamento, il fattore temporale \u00e8 direttamente proporzionale al numero di confronti tra gli elementi che saranno ordinati. La complessit\u00e0 spaziale \u00e8 invece determinata valutando lo spazio massimo richiesto dall'algoritmo in termini di memoria occupata. Iniziamo parlando proprio di quest'ultima.","title":"Complessit\u00e0 degli algoritmi"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-spaziale","text":"La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria dall'inizio alla fine della sua esecuzione. Questo \u00e8 pari alla somma di due componenti: una parte fissa, pari allo spazio richiesto per la memorizzazione di dati \"fissi\", come funzioni e costanti, che non variano a seconda del problema; una parte variabile, data dallo spazio richiesto per la memorizzazione (appunto) delle variabili, la cui dimensione \u00e8 dipendente dal problema stesso. Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(S(X)\\) di un algoritmo \\(X\\) come: \\[ S(X) = S_F + S_V(C) \\] con \\(S_F\\) parte fissa ed \\(S_V\\) parte variabile e dipendente dalle caratteristiche \\(C\\) dell'algoritmo \\(X\\) . Nota Le caratteristiche \\(C\\) non coincidono con il numero di variabili in input per l'algoritmo \\(N\\) .","title":"Complessit\u00e0 spaziale"},{"location":"02_dispense/04_programmazione/05_complessita/#un-esempio","text":"Consideriamo il seguente algoritmo (in pseudocodice): SUM_ONE(P, Q) Step 1 -> START Step 2 -> R = P + Q + 1 Step 3 -> STOP","title":"Un esempio"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-priori_1","text":"Il numero di variabili in questo algoritmo \u00e8 pari a 3, ovvero P e Q (input) ed R (output). Abbiamo inoltre una costante (il valore 1 ). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a: \\[ S(X) = S_F + S_V(C) = 1 + 3 \\] Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria.","title":"Analisi a priori"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-posteriori_1","text":"Supponiamo che l'effettiva implementazione dell'algoritmo sia in linguaggio C, e che il tipo di dato associato a ciascuna variabile sia un intero. La complessit\u00e0 spaziale (analizzata a posteriori) sar\u00e0 pari a: \\[ m_{int} = 32 bit \\Rightarrow S(X) = S_F + S_V(C) = 4 m_{int} = 128 bit \\]","title":"Analisi a posteriori"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-temporale","text":"Abbiamo visto come la complessit\u00e0 temporale di un algoritmo sia associata alla quantit\u00e0 di tempo richiesto dallo stesso per una sua completa esecuzione. Anche questa complessit\u00e0 pu\u00f2 essere espressa come una funzione numerica del tipo \\(T(I)\\) , con \\(I\\) numero di step necessari al completamento dell'istruzione.","title":"Complessit\u00e0 temporale"},{"location":"02_dispense/04_programmazione/05_complessita/#un-esempio_1","text":"","title":"Un esempio"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-priori_2","text":"Torniamo al precedente algoritmo. In questo caso, abbiamo elencato tre step, anche se, nei fatti, ci sono solo due operazioni di cui tenere conto, ovvero due addizione. Quindi, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(T(I) = 2\\) .","title":"Analisi a priori"},{"location":"02_dispense/04_programmazione/05_complessita/#analisi-a-posteriori_2","text":"Anche in questo caso, per effettuare l'analisi a posteriori avremo bisogno di fissare alcune condizioni. Supponiamo, ad esempio, che il nostro processore impieghi un microsecondo per eseguire una somma. Di conseguenza, la complessit\u00e0 temporale analizzata a posteriori sar\u00e0 pari a 2 microsecondi.","title":"Analisi a posteriori"},{"location":"02_dispense/04_programmazione/05_complessita/#complessita-di-caso-peggiore","text":"L'esempio che abbiamo visto \u00e8, al solito, estremamente semplice. In realt\u00e0, \u00e8 difficile che nella realt\u00e0 sia necessario calcolare la complessit\u00e0 computazionale di situazioni cos\u00ec poco articolate; \u00e8 pi\u00f9 facile avere un'idea abbastanza sommaria della complessit\u00e0 spaziale e temporale di un algoritmo, che va quindi stimata assumendo il caso peggiore , ovvero calcolando il numero massimo di operazioni e/o spazio che, nel peggiore dei casi, il nostro algoritmo dovrebbe dover effettuare e/o occupare. Per far questo, si utilizza la notazione O-grande , utilizzata spesso per descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. Detto in maniera meno formale: un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(T(n) = O(n^2)\\) avr\u00e0 un costo, in termini di tempo, pari al pi\u00f9 ad \\(n^2\\) ; un algoritmo con una complessit\u00e0 \\(T(n) = O(n * log(n))\\) \"coster\u00e0\" al massimo \\(n*log(n)\\) operazioni, e cos\u00ec via.","title":"Complessit\u00e0 di caso peggiore"},{"location":"02_dispense/04_programmazione/05_complessita/#alcuni-esempi","text":"","title":"Alcuni esempi"},{"location":"02_dispense/04_programmazione/05_complessita/#semplice-ciclo-for","text":"Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo for : int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) { printf ( \"%d\" , i ); i ++ ; } Notiamo innanzitutto che il valore del contatore i viene incrementato di due ad ogni iterazione. Ci\u00f2 significa che, al pi\u00f9 , saranno eseguite \\(n/2\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale sia nell'ordine di \\(O(n/2)\\) .","title":"Semplice ciclo for"},{"location":"02_dispense/04_programmazione/05_complessita/#cicli-for-annidati","text":"Vediamo cosa accade nel caso si considerino due cicli for l'uno annidato all'interno dell'altro. int n = 10 ; for ( int i = 0 ; i < n 0 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { printf ( \"%d\" , i ); } } Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile i ) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile j ). La complessit\u00e0 di caso peggiore sar\u00e0 quindi \\(O(n^2)\\) .","title":"Cicli for annidati"},{"location":"02_dispense/04_programmazione/06_strutture_dati/","text":"I linguaggi di programmazione sfruttano il cocnetto struttura dati per organizzare , gestire e memorizzare una serie di valori nella maniera pi\u00f9 efficiente psosibile. Le strutture dati non sono quindi altro che degli insiemi , o collezioni , di valori, che caratterizzano anche le relazioni intercorrenti tra essi, oltre che le operazioni che vi possono essere applicate. Esistono diverse tipologie di strutture dati, ognuna delle quali particolarmente adatta a determinati scopi. Vediamone alcune di seguito. Array \u00b6 Un array \u00e8 concettualmente riconducibile ad un vettore, inteso nel senso pi\u00f9 \"algebrico\" del termine. Un array contiene quindi un vettore (o, per estensione, una matrice) di elementi, tipicamente (ma, a seconda del linguaggio, non necessariamente ) dello stesso tipo, i quali sono organizzati seguendo un ordine specifico, esplorabile mediante il concetto di indice . Questo definisce la modalit\u00e0 di accesso ai dati di un array, che \u00e8 chiamata accesso diretto o casuale : in pratica, l'elemento viene estratto in maniera diretta, utilizzando l'indice, e di conseguenza l'operazione \u00e8 immediata (in termini di complessit\u00e0 computazionale, abbiamo un \\(O(1)\\) , ovvero un'unica operazione necessaria). Questo vantaggio ha per\u00f2 come contraltare la necessit\u00e0 di implementare una serie laboriosa di operazioni di accesso alla memoria nel caso si voglia inserire o rimuovere un elemento nell'array. Una tipica rappresentazione di un array \u00e8 la seguente: [8, 5, 12, 7, 4] In particolare, il precedente array \u00e8 composto esclusivamente da elementi di tipo intero, ed ha lunghezza pari a 5 ; da notare che l'indice del primo elemento (in questo caso, il valore 3 ) non \u00e8 quasi mai pari ad 1 : nella maggior parte dei linguaggi di programmazione, infatti, l'indicizzazione parte da 0 e termina ad un valore n - 1 , con n lunghezza dell'array. Nel caso precedente: Liste \u00b6 Una lista (conosciuta anche come linked list ) \u00e8 una struttura dati simile agli array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento a quello successivo. Vediamo un esempio nella seguente figura: Dall'immagine precedente, vediamo che: il primo elemento nella lista ha valore 5 , e conserva un riferimento all'elemento successivo R3 ; il secondo elemento nella lista ha valore 3 , e conserva un riferimento all'elemento successivo R2 ; ci\u00f2 prosegue sino all'elemento 7 , che conserva un riferimento all'ultimo elemento R12 . Questa particolarit\u00e0 della lista rispetto all'array ha due effetti. Il primo consiste nel fatto che la lista \u00e8 una struttura ad accesso sequenziale ; in parole povere, occorrer\u00e0 \"scorrere\" tutti gli elementi della lista fino ad arrivare a quello desiderato. In molti linguaggi di programmazione, esistono appositi costrutti per compiere questa operazione chiamati iteratori . La seconda conseguenza sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o riumuovere un elemento alla lista, specie se comparato con l'array: baster\u00e0 infatti manipolare opportunamente i riferimenti agli elementi successivi della lista. Struct \u00b6 Una struct (conosciuta anche come tupla ) \u00e8 una struttura dati che contiene a sua volta un insieme di valori chiamati membri o campi . In una struct, il numero, la sequenza ed il tipo dei campi sono solitamente fissi. Ecco un esempio di struct che ci permette di rappresentare una persona: struct persona { char nome [ 16 ]; char cognome [ 32 ]; int eta ; } ettore ; La struct precedente ci permetter\u00e0 quindi di definire la variabile ettore con nome, cognome ed et\u00e0. Union \u00b6 Una union \u00e8 una struttura dati che specifica il tipo del valore che pu\u00f2 essere memorizzato tra un certo numero di tipi primitivi. Nonostante sia sintatticamente simile alla struct, ne differisce semanticamente e funzionalmente , in quanto ammette la presenza di un unico valore per volta (che per\u00f2 pu\u00f2 essere di tipo di volta in volta differente). Ad esempio: union lettura_sensore { int lettura_intera ; float lettura_reale ; } lettura ; Analogamente alla struct, potremo definire la variabile lettura come valore intero o reale. Pile e code \u00b6 Abbiamo visto che gli array sono strutture ad accesso casuale, mentre le liste sono ad accesso sequenziale. Esiste un altro tipo di accesso ai dati presenti in una struttura, detto accesso limitato , che viene usato da alcune strutture dati come pile e code . Scopriamolo insieme. Pile \u00b6 Una pila (o stack ) \u00e8 un contenitore di oggetti che possono essere inseriti o rimossi seguendo il principio LIFO ( Last-In, First-Out ). In parole povere, questo significa che l'ultimo elemento che accede alla pila \u00e8 anche il primo ad uscirne . Lo stack prevede due diverse operazioni: la prima \u00e8 quella di push , ovvero di inserimento di un oggetto all'interno dello stack, mentre la seconda \u00e8 quella di pop , ovvero di estrazione di un elemento dallo stack. Il fatto che l'accesso sia limitato \u00e8 dovuto proprio ad una limitazione a queste due operazioni: in particolare, sia il push, sia il pop, possono essere effettuati soltanto sugli elementi in cima alla pila. Quindi: Operazione di push L'operazione di push permette di inserire un oggetto in cima ad uno stack. Operazione di pop L'operazione di pop permette di estrarre l'oggetto attualmente in cima allo stack. Notiamo anche che lo stack \u00e8 una struttura dati di tipo ricorsivo: infatti, \u00e8 facile dimostrare che uno stack non vuoto \u00e8 in realt\u00e0 composto da un elemento in cima ( top ) ad un altro stack. Pila come array \u00b6 Per implementare una pila sotto forma di array, abbiamo bisogno dei seguenti elementi: un array di lunghezza superiore ad uno ( stack ); una variabile che caratterizza l'elemento in cima all'array ( top ); una variabile che si riferisce alla lunghezza dell'array ( capacity ). Lo stack \u00e8 pieno quando top \u00e8 pari a capacity - 1 ; invece, \u00e8 vuoto quando top \u00e8 pari a -1 . Questi principi sono riassunti nella figura successiva: E' importante notare che possiamo avere due tipi di implementazione: una in cui la dimensione dell'array \u00e8 fissa, ed una in cui la dimensione dell'array varia in maniera dinamica. Nella prima, ovviamente, quando il top \u00e8 pari a capacity si genera un errore; ci\u00f2 non avviene nel secondo caso. L'operazione di push prevede quindi che sia inserito un nuovo elemento all'indice top dell'array; di converso, l'operazione di pop prevede che tale elemento sia rimosso. In etrambi i casi, \u00e8 importante aggiornare il valore di top . push(array, top, capacity, element) STEP 1 -> top = top + 1; STEP 2 -> if (top >= capacity) return ERROR; STEP 3 -> array[top] = element; pop(array, top) STEP 1 -> element = array[top]; STEP 2 -> top = top - 1; STEP 3 -> return element; Code \u00b6 Una coda ( queue ) \u00e8 un contenitore di oggetti che sono inseriti o rimossi secondo il principio FIFO ( first-in, first-out ). Concettualmente, \u00e8 quella che siamo abituati a vedere negli Uffici Postali, ad esempio: il primo arrivato sar\u00e0 il primo ad essere servito (e, di conseguenza, rimosso dalla coda ). Definiremo quindi una funzione enqueue per mettere in coda un nuovo elemento, e dequeue per togliere dalla coda l'elemento presente da pi\u00f9 tempo. La differenza fondamentale rispetto agli stack sta nella rimozione degli oggetti: in uno stack, rimuoviamo l'oggetti che abbiamo aggiunto pi\u00f9 di recente, mentre in una coda rimuoviamo quello che abbiamo aggiunto meno di recente. Esempio di implementazione come array \u00b6 Nel caso volessimo implementare una coda come array, dovremmo definire almeno i metodi enqueue e dequeue . In particolare, la procedura di enqueue prevede che sia posto come primo membro dell'array proprio l'elemento che si vuole aggiungere. Per farlo, potremmo ad esempio salvare l'array in una variabile temporanea, e concatenarlo all'elemento che entra in coda. enqueue(array, element) STEP 1 -> temp_array = array; STEP 2 -> new_array = concatenate(element, temp_array); STEP 3 -> return new_array; La procedura di dequeue di converso comporta la semplice rimozione dell'ultimo elemento nell'array. dequeue(array) STEP 1 -> element = array[length(array) - 1] STEP 2 -> new_array = remove_last(array) STEP 3 -> return new_array, element Grafi \u00b6 Ecco un modo per rappresentare una rete sociale: Le linee presenti tra i nomi di due persone indicano che queste si conoscono tra loro. Ovviamente, la conoscenza \u00e8 bidirezionale : dato che Alice conosce Bob, anche Bob conosce Alice. Questo modo di schematizzare una rete sociale \u00e8 conosciuto come grafo . Vertici ed archi \u00b6 Ciascun nodo \u00e8 noto come vertice , mentre ogni linea \u00e8 un arco che connette due vertici. L'insieme dei vertici \u00e8 dato da \\(V\\) , mentre quello degli archi \u00e8 dato da \\(E\\) . Il grafo \u00e8 quindi rappresentabile come una coppia \\(G=(V,E)\\) . Anche i nodi possono essere rappresentati a coppie: in particolare, due nodi \\(u\\) e \\(v\\) connessi da un arco sono una coppia \\((u, v)\\) . Grafo non diretto \u00b6 Abbiamo detto che le relazioni rappresentate nella nostra rete sociale sono bidirezionali: ci\u00f2 significa che non \u00e8 possibile individuare una \"direzione\" specifica nella relazione. Siamo quindi in presenza di un grafo non diretto . In un grafo non diretto, un arco \\((u, v)\\) equivale all'arco \\((v, u)\\) . Ciascun arco incide su entrambi i vertici, ed i vertici connessi da un arco sono adiacenti o vicini . Definiamo inoltre il numero di archi che incide su un vertice come grado dello stesso. Cammini e cicli \u00b6 Immaginiamo che Bob voglia conoscere Eric. non vi \u00e8 un arco che li collega; per\u00f2, Bob potrebbe chiedere ad Alice di presentargli David, che a sua volta potrebbe presentargli Eric. Esiste quindi un percorso , o cammino , composto da tre archi tra Bob ed Eric, e rappresenta il modo pi\u00f9 diretto per i due per incontrarsi. Chiamiamo un percorso del genere (ovvero il percorso con un numero minimo di archi) cammino minimo , o shortest path . Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo . Ad esempio, quello che va da Alice, passa per David, Eric e Charlie, e torna ad Alice, \u00e8 appunto un ciclo. Grafo pesato \u00b6 Alle volte, gli archi sono pesati , ovvero correlati da valori numerici. Ad esempio, potremmo rappresentare la distanza tra diverse citt\u00e0 come segue: Il termine generale per ognuno dei numeri che mettiamo su un lato \u00e8 peso , ed un grafo i cui archi hanno dei pesi \u00e8 un grafo pesato . In questo caso, volendo trovare il percorso minimo tra due posizioni, dovremo tenere contro del valore dei pesi. Ad esempio, per Andare da Bari a Napoli, occorrer\u00e0, nel nostro caso, passare da Roma e Milano (piuttosto che da Torino). Nota Il Docente si scusa per questa interpretazione poco realistica. Non seguite questa mappa, e risparmierete molte ore. Grafo diretto \u00b6 Cosa accade se inseriamo informazioni inerenti i sensi di marcia all'interno del grafo precedente? Otteniamo un grafo diretto . Le direzioni degli archi mostrano quali percorsi possono essere affrontati, e quali no. In questo caso, ad esempio, non potremo uscire da Bari, in quanto non ci saranno archi uscenti. Roma invece perde il suo status, in quanto si dimostra che non tutte le strade portano a Roma . Possiamo fare altre due osservazioni su questo grafo: il grafo non ha alcun ciclo, per cui siamo in presenza di un grafo aciclico diretto ; il grafo conserva i pesi, per cui siamo comunque in presenza di un grafo pesato. Per quello che riguarda infine il grado di ogni arco, abbiamo due termini da tenere in considerazione: il grado esterno , o out-degree , \u00e8 il numero di archi in uscita da un vertice; il grado interno , o in-degree , \u00e8 il numero di archi in ingresso in un vertice. Alberi \u00b6 Un albero \u00e8 una struttura dati, particolarmente usata in ambito informatico, che simula una struttura gerarchica, con un valore radice ed una serie di figli, rappresentata sotto forma di grafo non orientato , connesso ed aciclico . In particolare, il fatto che l'albero sia connesso indica che esiste almeno un cammino che connette tutti gli archi . Un particolare tipo di albero \u00e8 poi l' albero binario , nel quale ciascun nodo ha (al pi\u00f9) due figli. Un nodo terminale (ovvero uno in basso nella gerarchia) \u00e8 chiamato foglia .","title":"14 - Strutture dati"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#array","text":"Un array \u00e8 concettualmente riconducibile ad un vettore, inteso nel senso pi\u00f9 \"algebrico\" del termine. Un array contiene quindi un vettore (o, per estensione, una matrice) di elementi, tipicamente (ma, a seconda del linguaggio, non necessariamente ) dello stesso tipo, i quali sono organizzati seguendo un ordine specifico, esplorabile mediante il concetto di indice . Questo definisce la modalit\u00e0 di accesso ai dati di un array, che \u00e8 chiamata accesso diretto o casuale : in pratica, l'elemento viene estratto in maniera diretta, utilizzando l'indice, e di conseguenza l'operazione \u00e8 immediata (in termini di complessit\u00e0 computazionale, abbiamo un \\(O(1)\\) , ovvero un'unica operazione necessaria). Questo vantaggio ha per\u00f2 come contraltare la necessit\u00e0 di implementare una serie laboriosa di operazioni di accesso alla memoria nel caso si voglia inserire o rimuovere un elemento nell'array. Una tipica rappresentazione di un array \u00e8 la seguente: [8, 5, 12, 7, 4] In particolare, il precedente array \u00e8 composto esclusivamente da elementi di tipo intero, ed ha lunghezza pari a 5 ; da notare che l'indice del primo elemento (in questo caso, il valore 3 ) non \u00e8 quasi mai pari ad 1 : nella maggior parte dei linguaggi di programmazione, infatti, l'indicizzazione parte da 0 e termina ad un valore n - 1 , con n lunghezza dell'array. Nel caso precedente:","title":"Array"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#liste","text":"Una lista (conosciuta anche come linked list ) \u00e8 una struttura dati simile agli array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento a quello successivo. Vediamo un esempio nella seguente figura: Dall'immagine precedente, vediamo che: il primo elemento nella lista ha valore 5 , e conserva un riferimento all'elemento successivo R3 ; il secondo elemento nella lista ha valore 3 , e conserva un riferimento all'elemento successivo R2 ; ci\u00f2 prosegue sino all'elemento 7 , che conserva un riferimento all'ultimo elemento R12 . Questa particolarit\u00e0 della lista rispetto all'array ha due effetti. Il primo consiste nel fatto che la lista \u00e8 una struttura ad accesso sequenziale ; in parole povere, occorrer\u00e0 \"scorrere\" tutti gli elementi della lista fino ad arrivare a quello desiderato. In molti linguaggi di programmazione, esistono appositi costrutti per compiere questa operazione chiamati iteratori . La seconda conseguenza sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o riumuovere un elemento alla lista, specie se comparato con l'array: baster\u00e0 infatti manipolare opportunamente i riferimenti agli elementi successivi della lista.","title":"Liste"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#struct","text":"Una struct (conosciuta anche come tupla ) \u00e8 una struttura dati che contiene a sua volta un insieme di valori chiamati membri o campi . In una struct, il numero, la sequenza ed il tipo dei campi sono solitamente fissi. Ecco un esempio di struct che ci permette di rappresentare una persona: struct persona { char nome [ 16 ]; char cognome [ 32 ]; int eta ; } ettore ; La struct precedente ci permetter\u00e0 quindi di definire la variabile ettore con nome, cognome ed et\u00e0.","title":"Struct"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#union","text":"Una union \u00e8 una struttura dati che specifica il tipo del valore che pu\u00f2 essere memorizzato tra un certo numero di tipi primitivi. Nonostante sia sintatticamente simile alla struct, ne differisce semanticamente e funzionalmente , in quanto ammette la presenza di un unico valore per volta (che per\u00f2 pu\u00f2 essere di tipo di volta in volta differente). Ad esempio: union lettura_sensore { int lettura_intera ; float lettura_reale ; } lettura ; Analogamente alla struct, potremo definire la variabile lettura come valore intero o reale.","title":"Union"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#pile-e-code","text":"Abbiamo visto che gli array sono strutture ad accesso casuale, mentre le liste sono ad accesso sequenziale. Esiste un altro tipo di accesso ai dati presenti in una struttura, detto accesso limitato , che viene usato da alcune strutture dati come pile e code . Scopriamolo insieme.","title":"Pile e code"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#pile","text":"Una pila (o stack ) \u00e8 un contenitore di oggetti che possono essere inseriti o rimossi seguendo il principio LIFO ( Last-In, First-Out ). In parole povere, questo significa che l'ultimo elemento che accede alla pila \u00e8 anche il primo ad uscirne . Lo stack prevede due diverse operazioni: la prima \u00e8 quella di push , ovvero di inserimento di un oggetto all'interno dello stack, mentre la seconda \u00e8 quella di pop , ovvero di estrazione di un elemento dallo stack. Il fatto che l'accesso sia limitato \u00e8 dovuto proprio ad una limitazione a queste due operazioni: in particolare, sia il push, sia il pop, possono essere effettuati soltanto sugli elementi in cima alla pila. Quindi: Operazione di push L'operazione di push permette di inserire un oggetto in cima ad uno stack. Operazione di pop L'operazione di pop permette di estrarre l'oggetto attualmente in cima allo stack. Notiamo anche che lo stack \u00e8 una struttura dati di tipo ricorsivo: infatti, \u00e8 facile dimostrare che uno stack non vuoto \u00e8 in realt\u00e0 composto da un elemento in cima ( top ) ad un altro stack.","title":"Pile"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#pila-come-array","text":"Per implementare una pila sotto forma di array, abbiamo bisogno dei seguenti elementi: un array di lunghezza superiore ad uno ( stack ); una variabile che caratterizza l'elemento in cima all'array ( top ); una variabile che si riferisce alla lunghezza dell'array ( capacity ). Lo stack \u00e8 pieno quando top \u00e8 pari a capacity - 1 ; invece, \u00e8 vuoto quando top \u00e8 pari a -1 . Questi principi sono riassunti nella figura successiva: E' importante notare che possiamo avere due tipi di implementazione: una in cui la dimensione dell'array \u00e8 fissa, ed una in cui la dimensione dell'array varia in maniera dinamica. Nella prima, ovviamente, quando il top \u00e8 pari a capacity si genera un errore; ci\u00f2 non avviene nel secondo caso. L'operazione di push prevede quindi che sia inserito un nuovo elemento all'indice top dell'array; di converso, l'operazione di pop prevede che tale elemento sia rimosso. In etrambi i casi, \u00e8 importante aggiornare il valore di top . push(array, top, capacity, element) STEP 1 -> top = top + 1; STEP 2 -> if (top >= capacity) return ERROR; STEP 3 -> array[top] = element; pop(array, top) STEP 1 -> element = array[top]; STEP 2 -> top = top - 1; STEP 3 -> return element;","title":"Pila come array"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#code","text":"Una coda ( queue ) \u00e8 un contenitore di oggetti che sono inseriti o rimossi secondo il principio FIFO ( first-in, first-out ). Concettualmente, \u00e8 quella che siamo abituati a vedere negli Uffici Postali, ad esempio: il primo arrivato sar\u00e0 il primo ad essere servito (e, di conseguenza, rimosso dalla coda ). Definiremo quindi una funzione enqueue per mettere in coda un nuovo elemento, e dequeue per togliere dalla coda l'elemento presente da pi\u00f9 tempo. La differenza fondamentale rispetto agli stack sta nella rimozione degli oggetti: in uno stack, rimuoviamo l'oggetti che abbiamo aggiunto pi\u00f9 di recente, mentre in una coda rimuoviamo quello che abbiamo aggiunto meno di recente.","title":"Code"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#esempio-di-implementazione-come-array","text":"Nel caso volessimo implementare una coda come array, dovremmo definire almeno i metodi enqueue e dequeue . In particolare, la procedura di enqueue prevede che sia posto come primo membro dell'array proprio l'elemento che si vuole aggiungere. Per farlo, potremmo ad esempio salvare l'array in una variabile temporanea, e concatenarlo all'elemento che entra in coda. enqueue(array, element) STEP 1 -> temp_array = array; STEP 2 -> new_array = concatenate(element, temp_array); STEP 3 -> return new_array; La procedura di dequeue di converso comporta la semplice rimozione dell'ultimo elemento nell'array. dequeue(array) STEP 1 -> element = array[length(array) - 1] STEP 2 -> new_array = remove_last(array) STEP 3 -> return new_array, element","title":"Esempio di implementazione come array"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafi","text":"Ecco un modo per rappresentare una rete sociale: Le linee presenti tra i nomi di due persone indicano che queste si conoscono tra loro. Ovviamente, la conoscenza \u00e8 bidirezionale : dato che Alice conosce Bob, anche Bob conosce Alice. Questo modo di schematizzare una rete sociale \u00e8 conosciuto come grafo .","title":"Grafi"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#vertici-ed-archi","text":"Ciascun nodo \u00e8 noto come vertice , mentre ogni linea \u00e8 un arco che connette due vertici. L'insieme dei vertici \u00e8 dato da \\(V\\) , mentre quello degli archi \u00e8 dato da \\(E\\) . Il grafo \u00e8 quindi rappresentabile come una coppia \\(G=(V,E)\\) . Anche i nodi possono essere rappresentati a coppie: in particolare, due nodi \\(u\\) e \\(v\\) connessi da un arco sono una coppia \\((u, v)\\) .","title":"Vertici ed archi"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafo-non-diretto","text":"Abbiamo detto che le relazioni rappresentate nella nostra rete sociale sono bidirezionali: ci\u00f2 significa che non \u00e8 possibile individuare una \"direzione\" specifica nella relazione. Siamo quindi in presenza di un grafo non diretto . In un grafo non diretto, un arco \\((u, v)\\) equivale all'arco \\((v, u)\\) . Ciascun arco incide su entrambi i vertici, ed i vertici connessi da un arco sono adiacenti o vicini . Definiamo inoltre il numero di archi che incide su un vertice come grado dello stesso.","title":"Grafo non diretto"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#cammini-e-cicli","text":"Immaginiamo che Bob voglia conoscere Eric. non vi \u00e8 un arco che li collega; per\u00f2, Bob potrebbe chiedere ad Alice di presentargli David, che a sua volta potrebbe presentargli Eric. Esiste quindi un percorso , o cammino , composto da tre archi tra Bob ed Eric, e rappresenta il modo pi\u00f9 diretto per i due per incontrarsi. Chiamiamo un percorso del genere (ovvero il percorso con un numero minimo di archi) cammino minimo , o shortest path . Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo . Ad esempio, quello che va da Alice, passa per David, Eric e Charlie, e torna ad Alice, \u00e8 appunto un ciclo.","title":"Cammini e cicli"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafo-pesato","text":"Alle volte, gli archi sono pesati , ovvero correlati da valori numerici. Ad esempio, potremmo rappresentare la distanza tra diverse citt\u00e0 come segue: Il termine generale per ognuno dei numeri che mettiamo su un lato \u00e8 peso , ed un grafo i cui archi hanno dei pesi \u00e8 un grafo pesato . In questo caso, volendo trovare il percorso minimo tra due posizioni, dovremo tenere contro del valore dei pesi. Ad esempio, per Andare da Bari a Napoli, occorrer\u00e0, nel nostro caso, passare da Roma e Milano (piuttosto che da Torino). Nota Il Docente si scusa per questa interpretazione poco realistica. Non seguite questa mappa, e risparmierete molte ore.","title":"Grafo pesato"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#grafo-diretto","text":"Cosa accade se inseriamo informazioni inerenti i sensi di marcia all'interno del grafo precedente? Otteniamo un grafo diretto . Le direzioni degli archi mostrano quali percorsi possono essere affrontati, e quali no. In questo caso, ad esempio, non potremo uscire da Bari, in quanto non ci saranno archi uscenti. Roma invece perde il suo status, in quanto si dimostra che non tutte le strade portano a Roma . Possiamo fare altre due osservazioni su questo grafo: il grafo non ha alcun ciclo, per cui siamo in presenza di un grafo aciclico diretto ; il grafo conserva i pesi, per cui siamo comunque in presenza di un grafo pesato. Per quello che riguarda infine il grado di ogni arco, abbiamo due termini da tenere in considerazione: il grado esterno , o out-degree , \u00e8 il numero di archi in uscita da un vertice; il grado interno , o in-degree , \u00e8 il numero di archi in ingresso in un vertice.","title":"Grafo diretto"},{"location":"02_dispense/04_programmazione/06_strutture_dati/#alberi","text":"Un albero \u00e8 una struttura dati, particolarmente usata in ambito informatico, che simula una struttura gerarchica, con un valore radice ed una serie di figli, rappresentata sotto forma di grafo non orientato , connesso ed aciclico . In particolare, il fatto che l'albero sia connesso indica che esiste almeno un cammino che connette tutti gli archi . Un particolare tipo di albero \u00e8 poi l' albero binario , nel quale ciascun nodo ha (al pi\u00f9) due figli. Un nodo terminale (ovvero uno in basso nella gerarchia) \u00e8 chiamato foglia .","title":"Alberi"},{"location":"02_dispense/05_algoritmi/01_binary_search/","text":"Introduzione al problema \u00b6 Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica. Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare ( linear search ). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto? Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2 , che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice. Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search . Definizione del problema Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata . Descrizione dell'algoritmo \u00b6 L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli . Facciamo un rapido esempio per capire al meglio di cosa si tratta. Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento . Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore . Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra. La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false , ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore . Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta. La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore . Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0. Il gioco prosegue come segue. ROUND 3 -------------------------------- ALICE -> 62 --- BOB -> INFERIORE -------------------------------- ROUND 4 -------------------------------- ALICE -> 56 --- BOB -> SUPERIORE -------------------------------- ROUND 5 -------------------------------- ALICE -> 59 --- BOB -> SUPERIORE -------------------------------- ROUND 6 (BOB IMPALLIDISCE) -------------------------------- ALICE -> 61 --- BOB -> INFERIORE -------------------------------- ROUND 7 (BOB TREMANTE...) -------------------------------- ALICE -> 60 --- BOB -> PAGARE In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato. Fase di progettazione. \u00b6 Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc. Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice , e poi definirne il flow chart. TODO: da qui Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole. Ecco un'implementazione step-by-step: sia min = 1 e max = n troviamo il valore medio tra min e max, arrotondato ad un intero se abbiamo trovato il numero, fermiamoci. altrimenti se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1 se l'ipotesi era troppo altra, impostiamo max a n/2 - 1 torniamo al passo 2 TODO: flow chart \u00b6 Complessit\u00e0 computazionale \u00b6 Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi. Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica. L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta. Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni. Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni. Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\) . Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\) . Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\) , fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22. Nota I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22. Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente.","title":"01 binary search"},{"location":"02_dispense/05_algoritmi/01_binary_search/#introduzione-al-problema","text":"Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica. Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare ( linear search ). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto? Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2 , che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice. Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search . Definizione del problema Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata .","title":"Introduzione al problema"},{"location":"02_dispense/05_algoritmi/01_binary_search/#descrizione-dellalgoritmo","text":"L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli . Facciamo un rapido esempio per capire al meglio di cosa si tratta. Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento . Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore . Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra. La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false , ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore . Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta. La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore . Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0. Il gioco prosegue come segue. ROUND 3 -------------------------------- ALICE -> 62 --- BOB -> INFERIORE -------------------------------- ROUND 4 -------------------------------- ALICE -> 56 --- BOB -> SUPERIORE -------------------------------- ROUND 5 -------------------------------- ALICE -> 59 --- BOB -> SUPERIORE -------------------------------- ROUND 6 (BOB IMPALLIDISCE) -------------------------------- ALICE -> 61 --- BOB -> INFERIORE -------------------------------- ROUND 7 (BOB TREMANTE...) -------------------------------- ALICE -> 60 --- BOB -> PAGARE In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/01_binary_search/#fase-di-progettazione","text":"Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc. Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice , e poi definirne il flow chart. TODO: da qui Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole. Ecco un'implementazione step-by-step: sia min = 1 e max = n troviamo il valore medio tra min e max, arrotondato ad un intero se abbiamo trovato il numero, fermiamoci. altrimenti se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1 se l'ipotesi era troppo altra, impostiamo max a n/2 - 1 torniamo al passo 2","title":"Fase di progettazione."},{"location":"02_dispense/05_algoritmi/01_binary_search/#todo-flow-chart","text":"","title":"TODO: flow chart"},{"location":"02_dispense/05_algoritmi/01_binary_search/#complessita-computazionale","text":"Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi. Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica. L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta. Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni. Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni. Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\) . Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\) . Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\) , fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22. Nota I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22. Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente.","title":"Complessit\u00e0 computazionale"},{"location":"02_dispense/05_algoritmi/02_selection_sort/","text":"Introduzione al problema \u00b6 Ordinare una lista di elementi (ovviamente dello stesso tipo) pu\u00f2 aiutare ad individuare rapidamente un certo elemento della stessa. In tal senso, esistono diversi algoritmi, chiamati algoritmi di ordinamento (o, in inglese, sorting algorithms ). Il primo, e pi\u00f9 semplice, algoritmo di ordinamento \u00e8 chiamato selection sort . Per comprenderne il funzionamento, ricorriamo (al solito) ai nostri cari Alice e Bob. Descrizione dell'algoritmo \u00b6 Il selection sort \u00e8 un algoritmo iterativo : ad ogni iterazione, viene analizzato un elemento della lista L'idea alla base del selection sort \u00e8 quella di *scambia Invece di sviluppare il tema d\u2019anno di Informatica, Alice e Bob decidono di prendersi il pomeriggio libero, e si imbattono nel vecchio mazzo di carte del cugino di Bob. \u201cAlice, ricordi il caff\u00e8 che ho perso l\u2019altra volta? Beh, ho in mente un modo per riaverlo indietro.\u201d \u201cDimmi pure. Cosa hai in mente?\u201d \u201cScommetto che non riesci a trovare una maniera algoritmica per ordinare questo vecchio mazzo.\u201d \u201cScommessa accettata.\u201d Alice, che ricordiamo essere una assidua frequentatrice del corso di Informatica, inizia facendo queste mosse. Per prima cosa, dispone tutte le carte presenti nel mazzo lungo un\u2019unica fila. A quel punto, inizia a cercare la carta pi\u00f9 piccola, e la posiziona al primo posto. Successivamente, suddivide la fila in due: a sinistra mette le carte gi\u00e0 ordinate (ovvero, la prima carta), ed a destra quelle ancora da ordinare. A quel punto, prende dalla fila di destra la carta pi\u00f9 piccola, e la posiziona immediatamente a destra dell\u2019ultimo elemento della fila di sinistra. Fatto questo, reitera questa procedura fino a che la fila di destra non \u00e8 completamente vuota, mentre quella di sinistra ha al suo interno tutte le carte ordinate. \u201cOk, Alice, hai ordinato le carte, ma non vedo alcun algoritmo.\u201d \u201cE\u2019 qui che ti sbagli, mio caro.\u201d Ed Alice, pregustando la vittoria, elenca a Bob le istruzioni che ha eseguito, dimostrando che la procedura che ha eseguito \u00e8 modellabile secondo l\u2019algoritmo di selection sort. Sia x un array di n elementi interi. Associare ad i il primo indice dell\u2019array (0), ed a j l\u2019ultimo (n-1). Associare ad una variabile il valore di x(0), e supporre che sia il valore minore. Confrontare tutti gli elementi di x(k), con k che va da 1 ad n - 1, con x(0). Aggiornare il valore di x(0) nel caso x(k) minore di x (0). Incrementare di 1 il valore di i. Ritornare all\u2019istruzione 4 fino a che i == j. Un esempio pratico Immaginiamo di avere un array con valori [12, 4, 8, 7, 2]. Per prima cosa, vediamo che il valore di i sar\u00e0 pari a 0, mentre j sar\u00e0 pari a 4. A questo punto, poniamo min = x(0) = 12. Vediamo che x(1) = 4 \u00e8 minore di 12, per cui il valore min viene aggiornato, e risulta essere pari a 4. Andiamo avanti, e compiamo soltanto un altro aggiornamento, ovvero quando vediamo che x(4) minore di min. A questo punto, inseriamo x(0) all\u2019estrema sinistra (posizione i). Aggiorniamo il valore di i ad 1, e reiteriamo la procedura, fino ad ottenere l\u2019array finale: [12, 4, 8, 7, 2] i = 0; j = 4; min = x(0) = 12; min = x(4) = 2; new = [2, 12, 4, 8, 7] i = 1; min = x(1) = 12; min = x(2) = 4; new = [2, 4, 12, 8, 7] i = 2; min = x(2) = 12; min = x(4) = 7; new = [2, 4, 7, 12, 8] i = 3; min = x(3) = 12; min = x(4) = 8; new = [2, 4, 7, 8, 12] return TODO FLOW CHART Analisi dell\u2019algoritmo Il selection sort itera su tutti gli indici di un array. Supponiamo di avere un array di n elementi; avremo (ovviamente) n indici. Per capire quante operazioni sono necessarie per completare l\u2019operazione di ordinamento, dobbiamo contare il numero di confronti necessari ad individuare l\u2019elemento minore attualmente presente nell\u2019array. In particolare, alla prima iterazione, quando i = 0, avremo la necessit\u00e0 di effettuare n operazioni, una per ogni elemento dell\u2019array. Alla seconda iterazione, quando i = 1, dovremo fare n - 1 confronti; alla terza, basteranno n - 2 confronti, e cos\u00ec via. Ci\u00f2 significa che avremo bisogno di n + (n-1) + \u2026 + 2 + 1 confronti; ci\u00f2 equivale ad una serie aritmetica pari a (n^2/2) + n/2. La complessit\u00e0 di caso peggiore tiene per\u00f2 conto di un limite asintoticamente superiore di questa serie, che \u00e8 pari ad n^2; ci\u00f2 significa che saremo in una situazione per cui la complessit\u00e0 computazionale \u00e8 pari ad O(n^2). Nota Una complessit\u00e0 di questo tipo ci permette di notare che il tempo richiesto all\u2019esecuzione dell\u2019algoritmo cresce molto velocemente al crescere del numero di elementi dell\u2019array. Con n = 10, infatti, avremo bisogno di 100 unit\u00e0 di tempo. Supponendo che un\u2019unit\u00e0 di tempo sia pari ad un microsecondo, avremo bisogno di 0.1 secondi. Se n = 100, allora avremo bisogno di 10 secondi. Se n = 1.000, invece, avremo bisogno di 1.000 secondi (ovvero quasi 17 minuti!).","title":"02 selection sort"},{"location":"02_dispense/05_algoritmi/02_selection_sort/#introduzione-al-problema","text":"Ordinare una lista di elementi (ovviamente dello stesso tipo) pu\u00f2 aiutare ad individuare rapidamente un certo elemento della stessa. In tal senso, esistono diversi algoritmi, chiamati algoritmi di ordinamento (o, in inglese, sorting algorithms ). Il primo, e pi\u00f9 semplice, algoritmo di ordinamento \u00e8 chiamato selection sort . Per comprenderne il funzionamento, ricorriamo (al solito) ai nostri cari Alice e Bob.","title":"Introduzione al problema"},{"location":"02_dispense/05_algoritmi/02_selection_sort/#descrizione-dellalgoritmo","text":"Il selection sort \u00e8 un algoritmo iterativo : ad ogni iterazione, viene analizzato un elemento della lista L'idea alla base del selection sort \u00e8 quella di *scambia Invece di sviluppare il tema d\u2019anno di Informatica, Alice e Bob decidono di prendersi il pomeriggio libero, e si imbattono nel vecchio mazzo di carte del cugino di Bob. \u201cAlice, ricordi il caff\u00e8 che ho perso l\u2019altra volta? Beh, ho in mente un modo per riaverlo indietro.\u201d \u201cDimmi pure. Cosa hai in mente?\u201d \u201cScommetto che non riesci a trovare una maniera algoritmica per ordinare questo vecchio mazzo.\u201d \u201cScommessa accettata.\u201d Alice, che ricordiamo essere una assidua frequentatrice del corso di Informatica, inizia facendo queste mosse. Per prima cosa, dispone tutte le carte presenti nel mazzo lungo un\u2019unica fila. A quel punto, inizia a cercare la carta pi\u00f9 piccola, e la posiziona al primo posto. Successivamente, suddivide la fila in due: a sinistra mette le carte gi\u00e0 ordinate (ovvero, la prima carta), ed a destra quelle ancora da ordinare. A quel punto, prende dalla fila di destra la carta pi\u00f9 piccola, e la posiziona immediatamente a destra dell\u2019ultimo elemento della fila di sinistra. Fatto questo, reitera questa procedura fino a che la fila di destra non \u00e8 completamente vuota, mentre quella di sinistra ha al suo interno tutte le carte ordinate. \u201cOk, Alice, hai ordinato le carte, ma non vedo alcun algoritmo.\u201d \u201cE\u2019 qui che ti sbagli, mio caro.\u201d Ed Alice, pregustando la vittoria, elenca a Bob le istruzioni che ha eseguito, dimostrando che la procedura che ha eseguito \u00e8 modellabile secondo l\u2019algoritmo di selection sort. Sia x un array di n elementi interi. Associare ad i il primo indice dell\u2019array (0), ed a j l\u2019ultimo (n-1). Associare ad una variabile il valore di x(0), e supporre che sia il valore minore. Confrontare tutti gli elementi di x(k), con k che va da 1 ad n - 1, con x(0). Aggiornare il valore di x(0) nel caso x(k) minore di x (0). Incrementare di 1 il valore di i. Ritornare all\u2019istruzione 4 fino a che i == j. Un esempio pratico Immaginiamo di avere un array con valori [12, 4, 8, 7, 2]. Per prima cosa, vediamo che il valore di i sar\u00e0 pari a 0, mentre j sar\u00e0 pari a 4. A questo punto, poniamo min = x(0) = 12. Vediamo che x(1) = 4 \u00e8 minore di 12, per cui il valore min viene aggiornato, e risulta essere pari a 4. Andiamo avanti, e compiamo soltanto un altro aggiornamento, ovvero quando vediamo che x(4) minore di min. A questo punto, inseriamo x(0) all\u2019estrema sinistra (posizione i). Aggiorniamo il valore di i ad 1, e reiteriamo la procedura, fino ad ottenere l\u2019array finale: [12, 4, 8, 7, 2] i = 0; j = 4; min = x(0) = 12; min = x(4) = 2; new = [2, 12, 4, 8, 7] i = 1; min = x(1) = 12; min = x(2) = 4; new = [2, 4, 12, 8, 7] i = 2; min = x(2) = 12; min = x(4) = 7; new = [2, 4, 7, 12, 8] i = 3; min = x(3) = 12; min = x(4) = 8; new = [2, 4, 7, 8, 12] return TODO FLOW CHART Analisi dell\u2019algoritmo Il selection sort itera su tutti gli indici di un array. Supponiamo di avere un array di n elementi; avremo (ovviamente) n indici. Per capire quante operazioni sono necessarie per completare l\u2019operazione di ordinamento, dobbiamo contare il numero di confronti necessari ad individuare l\u2019elemento minore attualmente presente nell\u2019array. In particolare, alla prima iterazione, quando i = 0, avremo la necessit\u00e0 di effettuare n operazioni, una per ogni elemento dell\u2019array. Alla seconda iterazione, quando i = 1, dovremo fare n - 1 confronti; alla terza, basteranno n - 2 confronti, e cos\u00ec via. Ci\u00f2 significa che avremo bisogno di n + (n-1) + \u2026 + 2 + 1 confronti; ci\u00f2 equivale ad una serie aritmetica pari a (n^2/2) + n/2. La complessit\u00e0 di caso peggiore tiene per\u00f2 conto di un limite asintoticamente superiore di questa serie, che \u00e8 pari ad n^2; ci\u00f2 significa che saremo in una situazione per cui la complessit\u00e0 computazionale \u00e8 pari ad O(n^2). Nota Una complessit\u00e0 di questo tipo ci permette di notare che il tempo richiesto all\u2019esecuzione dell\u2019algoritmo cresce molto velocemente al crescere del numero di elementi dell\u2019array. Con n = 10, infatti, avremo bisogno di 100 unit\u00e0 di tempo. Supponendo che un\u2019unit\u00e0 di tempo sia pari ad un microsecondo, avremo bisogno di 0.1 secondi. Se n = 100, allora avremo bisogno di 10 secondi. Se n = 1.000, invece, avremo bisogno di 1.000 secondi (ovvero quasi 17 minuti!).","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/03_insertion_sort/","text":"Introduzione al problema \u00b6 Abbiamo visto INSERTION SORT Ci sono molti modi diversi di effettuare il sort. un altro modo \u00e8 l\u2019insertion sort. Immaginiamo che stimao giocando un gioco di carte. Stiamo tenendo delle carte in mano, e tutte queste carte sono ordinate. Il dealer ci d\u00e0 esattamente una nuova carta. Si deve metterla nel posto corretto in modo che la carta cheabbiamo in mano siano ancora ordinate. Nel selection sort, ogni elemento che aggiungiamo all\u2019array ordinato non pu\u00f2 essere pi\u00f9 piccolo degli elementi gi\u00e0 presenti nell\u2019arry ordinato. Ma nel nostro esempio, la nuova carta pu\u00f2 essere pi\u00f9 piccola delle carte che abbiamo gi\u00e0 in mano, per cui dobbiamo andare gi\u00f9 nella linea, comparando le nuove card con ognuna delle carte in mano, fino a che non troviamo un posto epr inserirla. Inseriamo la nuova carta nel punto giusto, e nuovamente la nostra mano ha delle card completamente ordinate. Quindi il dealer ci da un\u2019altra carta, e si ripete la stesa procedura. Quindi un\u2019altra carta, e via dicendo, fino a che il dealer non ci d\u00e0 pi\u00f9 alcuna carta. Questa \u00e8 l\u2019idea dietro linsertion sort. Iterare nelle posizsioni dell\u2019array, a partire dall\u2019indice 1. COn ogni nuova posizione \u00e8 come la nuova carta che civieen data dal dealer, e dobbiamo inserirla nel psto corretto nel subarray ordinato a sinistra di quella posizione. Immaginiamo che il subarray dall\u2019indice 0 all\u2019indice 5 sia gi\u00e0 ordinato, e vogliamo inserire l\u2019ekemeto attuamlmente all\u2019indice 6 in questo subarray gi\u00e0 ordinato, in modo che il subarray dall\u2019indice 0 all\u2019indice 6 sia ordinato. 2 3 7 8 10 13 5 PER ARRIVARE A 2 3 5 7 9 10 13 Per inserire l\u2019eeento in posizione 6 nel subarray alla sua sinsitra, compariamo ripetutatmente questo con gli elementi alla sua sinistra, andando da destra verso sinistra. Chiamaiamo quindi l\u00ecelemento in posizione 6 chiave. ogni volta che capiamo che la chiave \u00e8 inferiroe di un elemento alla sua sinistra, lo spostiamo verso destra, dal momento che sappiamo che la chiave dovr\u00e0 andare alla sinistra di quell\u2019elemento. Dovremo fare altre due cose per far funzionare questa idea: dovremo avere un\u2019operazione slide (che sposta un elemento di una posizione a destra), e dovremo salvare il valore della chiave in un puno separato. Nel nostro esempio, : 1.- inseriamo l\u2019elemento all\u2019indice 6 in ua variabile chiamata key compariamo key con l\u2019elemento alla posizione 5. sappiamo che key \u00e8 inferiore all\u2019elemento in posizione 5, quindi faccioamo lo slide di questo alla posizione 6. Notiamo che l\u2019operazione di slide si limita a copiare l\u2019eemento una posizione a destra. Quindi, compariamo key con l\u2019elemento in posizione 4. troviamo che key \u00e8 inferiore, e reiteriamo la procedura. Quando l\u2019elemento\u00e8 inferiore di key, non effettuiamo l\u2019operazione di slide. Invece, lasciamo la variabile key in quella posizione, immediatamente all\u2019elemento a destra. Il risultato \u00e8 \u2018ordinamento di tutto l\u2019array. Il nome dell\u2019insertion sort deriva dal fatto che questo inserisce ripetutamente un elemento nel subarray a sinistra dell\u2019elemento che sta valutando. Di conseguenza, nel caso generale, si parte considerando sempre il primo elemento del subarray (o meglio un subarray di un elemento), che non pu\u00f2 non essere ordinato (\u00e8 ordinato rispetto a se stesso). La prima chiave sar\u00e0 quindi l\u2019elemento con indice 1. 10 7 3 13 7 10 3 13 A questo punto, il subarray ordinato va da 0 ad 1, quindi il nuovo key \u00e8 indice 2. compariamo questo con quelli a sinistra ed abbiamo: 7 10 3 13 7 3 10 13 3 7 10 13 Ci sono un paio di situazioni limite. Il primo \u00e8 quando l\u2019elemento chiave \u00e8 inferiore a tutti gli elementi nel subarray ordinato; il secondo \u00e8 qunado invece \u00e8 superiore. Nel primo, ogni elemento del subarray deve effettuare uno slide, nel secondo non ci sono slide da effettuare. pseudocdice chiamo insert per inserire l\u2019elemento cheinizia all\u2019indice 1 nell\u2019array ordinato all\u2019indice 0. chiamo insert per insierire l\u2019elemento che inizia all\u2019indice 2 nell\u2019array ordinato in un indice che va da 0 ad 1. \u2026 Chiamo insert per insserire l\u2019elemento che inizia all\u2019indice n-1 nell\u2019array ordinato nell\u2019indice che va da 0 ad n - 2. analisi come nel caso del selection sort, l\u2019insertion sort fa un loop sugli indici dell\u2019array. chiama semplicemente insert sugli elementi di indice che vanno da 1 ad n-1. Ogni chiamata ad insert richiede un certo periodo di tempo. Prendiamo una situazione nella quale chiamoiamo insrt ed il valore che viene inserito nel subarray \u00e8 inferiore ad ogni elemento nel sybarray. Quindi, ogni elemento nel subarray dovr\u00e0 effettuare lo slide di una posizione a sinistra. Per cui, in generale, se stiamo inserendo un nuovo elemento in un subarray con k elementi, tutti i k elementi dovranno effettuare uno slide di una posizione. Pitutosto che contare esattamente quante linee di codice dobbiamo usare, diciamo che questo numero \u00e8 c. Quindi, potremmo aver bisogno di c * k linee per inserire un valore in un subarray di k elementi. Supponiamo che ad ogni chiamata ad insert, il valore che venga inserito sia inferirore ad ogni elmento nel subarray alla sua sinsitra. Quando chiamiamo insert la prima vlta, con k = 1. La seconda volta, k = 2. La terza volta, k = 3. E via, fino all\u2019ultima volta, quando k = n -1. Quinid, il tempo totale speso ad inserire qualcosa nel sub array \u00e8 c * (1 + 2 + .. + n-1). Anche in questo caso abbiamo una serie aritmetica. Tornando alla notazione, O(n^2). Molto probabilmente, per\u00f2, l\u2019insertion sort potrebbe avere meno tempo necessario (ad esempio, questo accadrebbe nel caso avessimo un array gi\u00e0 ordinato). Per\u00f2 non \u00e8 detto, quindi \u00e8 necessario sempre e comunque considerare un tempo pari a O(n^2). Potremmo per\u00f2 considerare il caso migliroe, che avrebbe un O(n) (in questo caso l\u2019array \u00e8 gi\u00e0 quasi ordinato).","title":"03 insertion sort"},{"location":"02_dispense/05_algoritmi/03_insertion_sort/#introduzione-al-problema","text":"Abbiamo visto INSERTION SORT Ci sono molti modi diversi di effettuare il sort. un altro modo \u00e8 l\u2019insertion sort. Immaginiamo che stimao giocando un gioco di carte. Stiamo tenendo delle carte in mano, e tutte queste carte sono ordinate. Il dealer ci d\u00e0 esattamente una nuova carta. Si deve metterla nel posto corretto in modo che la carta cheabbiamo in mano siano ancora ordinate. Nel selection sort, ogni elemento che aggiungiamo all\u2019array ordinato non pu\u00f2 essere pi\u00f9 piccolo degli elementi gi\u00e0 presenti nell\u2019arry ordinato. Ma nel nostro esempio, la nuova carta pu\u00f2 essere pi\u00f9 piccola delle carte che abbiamo gi\u00e0 in mano, per cui dobbiamo andare gi\u00f9 nella linea, comparando le nuove card con ognuna delle carte in mano, fino a che non troviamo un posto epr inserirla. Inseriamo la nuova carta nel punto giusto, e nuovamente la nostra mano ha delle card completamente ordinate. Quindi il dealer ci da un\u2019altra carta, e si ripete la stesa procedura. Quindi un\u2019altra carta, e via dicendo, fino a che il dealer non ci d\u00e0 pi\u00f9 alcuna carta. Questa \u00e8 l\u2019idea dietro linsertion sort. Iterare nelle posizsioni dell\u2019array, a partire dall\u2019indice 1. COn ogni nuova posizione \u00e8 come la nuova carta che civieen data dal dealer, e dobbiamo inserirla nel psto corretto nel subarray ordinato a sinistra di quella posizione. Immaginiamo che il subarray dall\u2019indice 0 all\u2019indice 5 sia gi\u00e0 ordinato, e vogliamo inserire l\u2019ekemeto attuamlmente all\u2019indice 6 in questo subarray gi\u00e0 ordinato, in modo che il subarray dall\u2019indice 0 all\u2019indice 6 sia ordinato. 2 3 7 8 10 13 5 PER ARRIVARE A 2 3 5 7 9 10 13 Per inserire l\u2019eeento in posizione 6 nel subarray alla sua sinsitra, compariamo ripetutatmente questo con gli elementi alla sua sinistra, andando da destra verso sinistra. Chiamaiamo quindi l\u00ecelemento in posizione 6 chiave. ogni volta che capiamo che la chiave \u00e8 inferiroe di un elemento alla sua sinistra, lo spostiamo verso destra, dal momento che sappiamo che la chiave dovr\u00e0 andare alla sinistra di quell\u2019elemento. Dovremo fare altre due cose per far funzionare questa idea: dovremo avere un\u2019operazione slide (che sposta un elemento di una posizione a destra), e dovremo salvare il valore della chiave in un puno separato. Nel nostro esempio, : 1.- inseriamo l\u2019elemento all\u2019indice 6 in ua variabile chiamata key compariamo key con l\u2019elemento alla posizione 5. sappiamo che key \u00e8 inferiore all\u2019elemento in posizione 5, quindi faccioamo lo slide di questo alla posizione 6. Notiamo che l\u2019operazione di slide si limita a copiare l\u2019eemento una posizione a destra. Quindi, compariamo key con l\u2019elemento in posizione 4. troviamo che key \u00e8 inferiore, e reiteriamo la procedura. Quando l\u2019elemento\u00e8 inferiore di key, non effettuiamo l\u2019operazione di slide. Invece, lasciamo la variabile key in quella posizione, immediatamente all\u2019elemento a destra. Il risultato \u00e8 \u2018ordinamento di tutto l\u2019array. Il nome dell\u2019insertion sort deriva dal fatto che questo inserisce ripetutamente un elemento nel subarray a sinistra dell\u2019elemento che sta valutando. Di conseguenza, nel caso generale, si parte considerando sempre il primo elemento del subarray (o meglio un subarray di un elemento), che non pu\u00f2 non essere ordinato (\u00e8 ordinato rispetto a se stesso). La prima chiave sar\u00e0 quindi l\u2019elemento con indice 1. 10 7 3 13 7 10 3 13 A questo punto, il subarray ordinato va da 0 ad 1, quindi il nuovo key \u00e8 indice 2. compariamo questo con quelli a sinistra ed abbiamo: 7 10 3 13 7 3 10 13 3 7 10 13 Ci sono un paio di situazioni limite. Il primo \u00e8 quando l\u2019elemento chiave \u00e8 inferiore a tutti gli elementi nel subarray ordinato; il secondo \u00e8 qunado invece \u00e8 superiore. Nel primo, ogni elemento del subarray deve effettuare uno slide, nel secondo non ci sono slide da effettuare. pseudocdice chiamo insert per inserire l\u2019elemento cheinizia all\u2019indice 1 nell\u2019array ordinato all\u2019indice 0. chiamo insert per insierire l\u2019elemento che inizia all\u2019indice 2 nell\u2019array ordinato in un indice che va da 0 ad 1. \u2026 Chiamo insert per insserire l\u2019elemento che inizia all\u2019indice n-1 nell\u2019array ordinato nell\u2019indice che va da 0 ad n - 2. analisi come nel caso del selection sort, l\u2019insertion sort fa un loop sugli indici dell\u2019array. chiama semplicemente insert sugli elementi di indice che vanno da 1 ad n-1. Ogni chiamata ad insert richiede un certo periodo di tempo. Prendiamo una situazione nella quale chiamoiamo insrt ed il valore che viene inserito nel subarray \u00e8 inferiore ad ogni elemento nel sybarray. Quindi, ogni elemento nel subarray dovr\u00e0 effettuare lo slide di una posizione a sinistra. Per cui, in generale, se stiamo inserendo un nuovo elemento in un subarray con k elementi, tutti i k elementi dovranno effettuare uno slide di una posizione. Pitutosto che contare esattamente quante linee di codice dobbiamo usare, diciamo che questo numero \u00e8 c. Quindi, potremmo aver bisogno di c * k linee per inserire un valore in un subarray di k elementi. Supponiamo che ad ogni chiamata ad insert, il valore che venga inserito sia inferirore ad ogni elmento nel subarray alla sua sinsitra. Quando chiamiamo insert la prima vlta, con k = 1. La seconda volta, k = 2. La terza volta, k = 3. E via, fino all\u2019ultima volta, quando k = n -1. Quinid, il tempo totale speso ad inserire qualcosa nel sub array \u00e8 c * (1 + 2 + .. + n-1). Anche in questo caso abbiamo una serie aritmetica. Tornando alla notazione, O(n^2). Molto probabilmente, per\u00f2, l\u2019insertion sort potrebbe avere meno tempo necessario (ad esempio, questo accadrebbe nel caso avessimo un array gi\u00e0 ordinato). Per\u00f2 non \u00e8 detto, quindi \u00e8 necessario sempre e comunque considerare un tempo pari a O(n^2). Potremmo per\u00f2 considerare il caso migliroe, che avrebbe un O(n) (in questo caso l\u2019array \u00e8 gi\u00e0 quasi ordinato).","title":"Introduzione al problema"},{"location":"02_dispense/05_algoritmi/04_merge_sort/","text":"Il paradigma Divide-et-Impera (Divide-and-Conquer) \u00b6 Prima di introdurre questo algoritmo ed il successivo, \u00e8 opportuno parlare dell'approccio su cui sono basati, chiamato divide-et-impera o, in inglese, divide-and-conquer . Useremo la notazione inglese perch\u00e9 fa pi\u00f9 \"stile\", ovviamente. Il paradigma divide-and-conquer \u00e8 puramente ricorsivo: infatti, divide un problema in diversi sotto-problemi, che risultano essere riconducibili al caso originario, pur rimanendo meno complessi. Una volta ricondottisi ai singoli casi base, l'approccio risolve ciascuno dei singoli problemi, combinando le soluzioni per risolvere il problema originario. E' quindi possibile schematizzare il paradigma in tre parti: divide : suddividiamo il problema in diversi sotto problemi, che rappresentano delle istanze pi\u00f9 piccole del problema originario. conquer : risolviamo ogni sotto-problema, se riconducibile ad un caso base. combine : combiniamo le soluzioni ai sottoproblemi, arrivando a quella del problema originario. Schematizzando: Descrizione dell'algoritmo \u00b6 Abbiamo gi\u00e0 detto come il merge sort si basi su un approccio di tipo divide-and-conquer. Di conseguenza, partendo dal nostro solito problema (ovvero, l'ordinamento di un array), dobbiamo definire il sotto-problema da risolvere . Banalmente, questo potr\u00e0 essere proprio quello di ordinare ciascun sotto-array in cui viene scomposto il nostro array originario. Utilizziamo in tal senso una notazione specifica per indicare il sotto-array che va dall'elemento di indice \\(l\\) all'elemento di indice \\(r\\) , denotandolo con array[l, r] . Per fare un esempio, se il nostro array iniziale fosse: array = [8, 5, 12, 7, 4]; allora: l = 0; r = 2; array[l,r] = [8, 5, 12]; Il merge sort utilizza l'approccio divide-and-conquer come segue: divide : trova il valore \\(q\\) intermedio tra \\(l\\) ed \\(r\\) . Se \\(q\\) \u00e8 dispari, lo approssimiamo all'intero inferiore; conquer : ordina i due sotto-array creati dal passo divide . Ci\u00f2 significa che si agir\u00e0 su array[l,q] ed array[q+1,r] ; combine : unisci i due sotto-array in uno singolo array[l, r] . Ovviamente, come tutti i problemi ricorsivi, avremo bisogno di un caso base. Ci\u00f2 avviene quando gli array risultanti dal passo conquer hanno meno di due elementi, ovvero quando \\(l \\geq r\\) : questo \u00e8 ovviamente legato al fatto che un array vuoto o con un solo elemento \u00e8 gi\u00e0 ordinato di suo. Un esempio \u00b6 Vediamo un esempio di utilizzo del merge sort. In tal senso, usiamo il nostro solito array con valori [8, 5, 12, 7, 4] . Al primo livello, l'array da considerare \u00e8 quello completo, e quindi: l = 0; r = 4; array[l,r] = [8, 5, 12, 7, 4] divide : in questo passo, calcoliamo \\(q=2\\) ; conquer : in questo passo, notiamo che i due array non sono riconducibili ad un caso base, per cui ripetiamo il divide ; Avremo quindi il secondo livello. In questo passo, l'array array[0,1] avr\u00e0 ancora due elementi, per cui sar\u00e0 necessario suddividerlo ulteriormente; stesso vale per array[2,4] . Arrivando in fondo, avremo la scomposizione di ogni array a livello di singolo elemento. Ci\u00f2 comporta che si arriver\u00e0 ad un certo punto ad una situazione in cui tutti gli array sotto esame saranno composti da un unico elemento, come mostrato in figura. A questo punto, ci si \u00e8 ricondotti in ogni situazione al caso base. Potr\u00e0 quindi avvenire lo step conquer , dove saranno ordinati i diversi sotto-array, ed infine lo step combine , che combiner\u00e0 i risultati in uscita dal conquer . Questo processo \u00e8 mostrato in figura. Notiamo come, dal punto di vista logico, i passaggi divide e conquer del merge sort siano in realt\u00e0 abbastanza semplici. Il punto \"complesso\", quello dove avviene l'ordinamento vero \u00e8 proprio, \u00e8 il combine . Merging \u00b6 Il passo combine \u00e8 quello che ci permette di \"unire\" due sotto-array adiacenti, ovvero array[l, q] ed array[q+1, r] , in un singolo array ordinato. Supponiamo che l'array iniziale array[l, r] abbia \\(n\\) elementi. E' necessario esaminare ciascuno di essi, per cui, nel caso migliore, potremo sperare in un tempo per l'unione in un \\(O(n)\\) . Detto questo chiamiamo, per comodit\u00e0, array[l,q] con il nome di left , ed array[q+1, r] con il nome di right . Vogliamo fare in modo che nell'elemento pi\u00f9 a sinistra di array , ovvero array[l] , venga inserito l'elemento pi\u00f9 minore presente sia in left sia in right . Ovviamente, dato che left e right si suppongono ordinati, il valore pi\u00f9 piccolo pu\u00f2 essere, all'inizio, o in left[0] o in right[0] . Possiamo usare quindi tre variabili per indicizzare gli array: i indicizza il primo elemento di left non ancora copiato in array . Inizialmente, i = 0 ; j indicizza il primo elemento di right non ancora copiato in array . Inizialmente, j = 0 ; k indicizza la posizione successiva di array in cui copiare. Inizialmente, k = l . In pratica, avremo un ciclo all'interno del quale verranno reiterate le seguenti istruzioni: if ( left [ i ] > right [ j ]) { array [ k ] = right [ j ]; j ++ ; } else { array [ k ] = left [ i ]; i ++ ; } k ++ ; Potr\u00e0 ovviamente accadere che uno tra left e right si \"svuoti\" per primo; di conseguenza, dato che l'altro \u00e8 comunque ordinato, potremo semplicemente limitarci a copiarlo integralmente negli elementi restanti di array , senza la necessit\u00e0 di effettuare alcuna ulteriore comparazione. Analisi computazionale \u00b6 Passo combine \u00b6 Verifichiamo che il costo legato allo step combine sia in \\(O(n)\\) . L'operazione di unione avviene in tre parti: nella prima, creiamo i due array left e right ; fino a che ci sono degli elementi non copiati da left o right in array , compariamo il primo elemento non ancora copiato di left a quello non ancora copiato di right , e copiamo il minore in array ; una volta che abbiamo copiato tutti gli elementi da left (o right ) in array , copiamo ogni elemento rimanente da right (o left ) in array . E' chiaro che, al massimo, dovremo effettuare n comparazioni ed n operazioni di copia. Ci\u00f2 significa che, al pi\u00f9, avremo \\(2 \\cdot n\\) operazioni, per cui la complessit\u00e0 sar\u00e0 in un \\(O(n)\\) . Analisi di caso peggiore \u00b6 Per effettuare l'analisi della complessit\u00e0 globale dell'algoritmo, consideriamo i tempi di esecuzione di ciascuno degli step coinvolti. Assumiamo, al solito, di stare ordinando un array ad \\(n\\) elementi. Nel passo divide , abbiamo bisogno di un tempo costante, ed indipendente dalla dimensione degli array coinvolti. Infatti, stiamo semplicemente calcolando il valore medio tra l ed r , per cui abbiamo bisogno di un'unica operazione. Nel passo conquer , ordiniamo ricorsivamente due sotto-array di approsimativamente \\(n/2\\) elementi. Nel passo combine , uniamo \\(n\\) elementi, ed abbiamo gi\u00e0 verificato avere bisogno di un \\(O(n)\\) . Considerando i passi divide e combine assieme, notiamo che il tempo necessario al divide \u00e8 trascurabile, per cui possiamo considerare solo quello per il combine . Resta da calcolare il tempo necessario al conquer . Per mantenere le cose semplici, consideriamo \\(n\\) pari e potenza di due (nel caso \\(n\\) sia dispari, il calcolo della complessit\u00e0 non cambia molto). Notiamo poi che l'esecuzione del merge sort su un array ad \\(n\\) elementi richieder\u00e0 (approssimativamente) lo stesso tempo dell'esecuzione di due merge sort su array ad \\(n/2\\) elementi, ciascuno dei quali richiede il doppio dell'esecuzione del merge sort su un array ad \\(n/4\\) elementi, e cos\u00ec via. Ricordando che il merge sort pu\u00f2 essere visto come un albero binario, \u00e8 evidente come ad ogni livello successivo dell'albero il numero di problemi raddoppi , mentre il tempo necessario alla risoluzione di un singolo problema si dimezzi . Questi due effetti si annullano reciprocamente, per cui potremo dire che, ad ogni livello, avremo bisogno al pi\u00f9 di \\(n\\) operazioni. Il tempo totale necessario \u00e8 quindi considerando un \\(O(n)\\) per ogni livello dell'albero prodotto dal merge sort. Con \\(c\\) livelli, avremo che il tempo totale necessario sar\u00e0 al pi\u00f9 \\(c \\cdot n\\) . Qual \u00e8 quindi il valore di \\(c\\) ? Dato che stiamo parlando di un albero binario, e che stiamo considerando un valore di \\(n\\) pari e potenza di due, sappiamo che \\(c = log_2n\\) . Di conseguenza, il tempo necessario per il merge sort sar\u00e0 dato da \\(n\\) (ovvero il numero di operazioni da effettuare a ciascun livello) moltiplicato per \\(c\\) (il numero di livelli), ovvero un \\(O(n \\cdot log_n2)\\) .","title":"17 - Merge sort"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#il-paradigma-divide-et-impera-divide-and-conquer","text":"Prima di introdurre questo algoritmo ed il successivo, \u00e8 opportuno parlare dell'approccio su cui sono basati, chiamato divide-et-impera o, in inglese, divide-and-conquer . Useremo la notazione inglese perch\u00e9 fa pi\u00f9 \"stile\", ovviamente. Il paradigma divide-and-conquer \u00e8 puramente ricorsivo: infatti, divide un problema in diversi sotto-problemi, che risultano essere riconducibili al caso originario, pur rimanendo meno complessi. Una volta ricondottisi ai singoli casi base, l'approccio risolve ciascuno dei singoli problemi, combinando le soluzioni per risolvere il problema originario. E' quindi possibile schematizzare il paradigma in tre parti: divide : suddividiamo il problema in diversi sotto problemi, che rappresentano delle istanze pi\u00f9 piccole del problema originario. conquer : risolviamo ogni sotto-problema, se riconducibile ad un caso base. combine : combiniamo le soluzioni ai sottoproblemi, arrivando a quella del problema originario. Schematizzando:","title":"Il paradigma Divide-et-Impera (Divide-and-Conquer)"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#descrizione-dellalgoritmo","text":"Abbiamo gi\u00e0 detto come il merge sort si basi su un approccio di tipo divide-and-conquer. Di conseguenza, partendo dal nostro solito problema (ovvero, l'ordinamento di un array), dobbiamo definire il sotto-problema da risolvere . Banalmente, questo potr\u00e0 essere proprio quello di ordinare ciascun sotto-array in cui viene scomposto il nostro array originario. Utilizziamo in tal senso una notazione specifica per indicare il sotto-array che va dall'elemento di indice \\(l\\) all'elemento di indice \\(r\\) , denotandolo con array[l, r] . Per fare un esempio, se il nostro array iniziale fosse: array = [8, 5, 12, 7, 4]; allora: l = 0; r = 2; array[l,r] = [8, 5, 12]; Il merge sort utilizza l'approccio divide-and-conquer come segue: divide : trova il valore \\(q\\) intermedio tra \\(l\\) ed \\(r\\) . Se \\(q\\) \u00e8 dispari, lo approssimiamo all'intero inferiore; conquer : ordina i due sotto-array creati dal passo divide . Ci\u00f2 significa che si agir\u00e0 su array[l,q] ed array[q+1,r] ; combine : unisci i due sotto-array in uno singolo array[l, r] . Ovviamente, come tutti i problemi ricorsivi, avremo bisogno di un caso base. Ci\u00f2 avviene quando gli array risultanti dal passo conquer hanno meno di due elementi, ovvero quando \\(l \\geq r\\) : questo \u00e8 ovviamente legato al fatto che un array vuoto o con un solo elemento \u00e8 gi\u00e0 ordinato di suo.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#un-esempio","text":"Vediamo un esempio di utilizzo del merge sort. In tal senso, usiamo il nostro solito array con valori [8, 5, 12, 7, 4] . Al primo livello, l'array da considerare \u00e8 quello completo, e quindi: l = 0; r = 4; array[l,r] = [8, 5, 12, 7, 4] divide : in questo passo, calcoliamo \\(q=2\\) ; conquer : in questo passo, notiamo che i due array non sono riconducibili ad un caso base, per cui ripetiamo il divide ; Avremo quindi il secondo livello. In questo passo, l'array array[0,1] avr\u00e0 ancora due elementi, per cui sar\u00e0 necessario suddividerlo ulteriormente; stesso vale per array[2,4] . Arrivando in fondo, avremo la scomposizione di ogni array a livello di singolo elemento. Ci\u00f2 comporta che si arriver\u00e0 ad un certo punto ad una situazione in cui tutti gli array sotto esame saranno composti da un unico elemento, come mostrato in figura. A questo punto, ci si \u00e8 ricondotti in ogni situazione al caso base. Potr\u00e0 quindi avvenire lo step conquer , dove saranno ordinati i diversi sotto-array, ed infine lo step combine , che combiner\u00e0 i risultati in uscita dal conquer . Questo processo \u00e8 mostrato in figura. Notiamo come, dal punto di vista logico, i passaggi divide e conquer del merge sort siano in realt\u00e0 abbastanza semplici. Il punto \"complesso\", quello dove avviene l'ordinamento vero \u00e8 proprio, \u00e8 il combine .","title":"Un esempio"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#merging","text":"Il passo combine \u00e8 quello che ci permette di \"unire\" due sotto-array adiacenti, ovvero array[l, q] ed array[q+1, r] , in un singolo array ordinato. Supponiamo che l'array iniziale array[l, r] abbia \\(n\\) elementi. E' necessario esaminare ciascuno di essi, per cui, nel caso migliore, potremo sperare in un tempo per l'unione in un \\(O(n)\\) . Detto questo chiamiamo, per comodit\u00e0, array[l,q] con il nome di left , ed array[q+1, r] con il nome di right . Vogliamo fare in modo che nell'elemento pi\u00f9 a sinistra di array , ovvero array[l] , venga inserito l'elemento pi\u00f9 minore presente sia in left sia in right . Ovviamente, dato che left e right si suppongono ordinati, il valore pi\u00f9 piccolo pu\u00f2 essere, all'inizio, o in left[0] o in right[0] . Possiamo usare quindi tre variabili per indicizzare gli array: i indicizza il primo elemento di left non ancora copiato in array . Inizialmente, i = 0 ; j indicizza il primo elemento di right non ancora copiato in array . Inizialmente, j = 0 ; k indicizza la posizione successiva di array in cui copiare. Inizialmente, k = l . In pratica, avremo un ciclo all'interno del quale verranno reiterate le seguenti istruzioni: if ( left [ i ] > right [ j ]) { array [ k ] = right [ j ]; j ++ ; } else { array [ k ] = left [ i ]; i ++ ; } k ++ ; Potr\u00e0 ovviamente accadere che uno tra left e right si \"svuoti\" per primo; di conseguenza, dato che l'altro \u00e8 comunque ordinato, potremo semplicemente limitarci a copiarlo integralmente negli elementi restanti di array , senza la necessit\u00e0 di effettuare alcuna ulteriore comparazione.","title":"Merging"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#analisi-computazionale","text":"","title":"Analisi computazionale"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#passo-combine","text":"Verifichiamo che il costo legato allo step combine sia in \\(O(n)\\) . L'operazione di unione avviene in tre parti: nella prima, creiamo i due array left e right ; fino a che ci sono degli elementi non copiati da left o right in array , compariamo il primo elemento non ancora copiato di left a quello non ancora copiato di right , e copiamo il minore in array ; una volta che abbiamo copiato tutti gli elementi da left (o right ) in array , copiamo ogni elemento rimanente da right (o left ) in array . E' chiaro che, al massimo, dovremo effettuare n comparazioni ed n operazioni di copia. Ci\u00f2 significa che, al pi\u00f9, avremo \\(2 \\cdot n\\) operazioni, per cui la complessit\u00e0 sar\u00e0 in un \\(O(n)\\) .","title":"Passo combine"},{"location":"02_dispense/05_algoritmi/04_merge_sort/#analisi-di-caso-peggiore","text":"Per effettuare l'analisi della complessit\u00e0 globale dell'algoritmo, consideriamo i tempi di esecuzione di ciascuno degli step coinvolti. Assumiamo, al solito, di stare ordinando un array ad \\(n\\) elementi. Nel passo divide , abbiamo bisogno di un tempo costante, ed indipendente dalla dimensione degli array coinvolti. Infatti, stiamo semplicemente calcolando il valore medio tra l ed r , per cui abbiamo bisogno di un'unica operazione. Nel passo conquer , ordiniamo ricorsivamente due sotto-array di approsimativamente \\(n/2\\) elementi. Nel passo combine , uniamo \\(n\\) elementi, ed abbiamo gi\u00e0 verificato avere bisogno di un \\(O(n)\\) . Considerando i passi divide e combine assieme, notiamo che il tempo necessario al divide \u00e8 trascurabile, per cui possiamo considerare solo quello per il combine . Resta da calcolare il tempo necessario al conquer . Per mantenere le cose semplici, consideriamo \\(n\\) pari e potenza di due (nel caso \\(n\\) sia dispari, il calcolo della complessit\u00e0 non cambia molto). Notiamo poi che l'esecuzione del merge sort su un array ad \\(n\\) elementi richieder\u00e0 (approssimativamente) lo stesso tempo dell'esecuzione di due merge sort su array ad \\(n/2\\) elementi, ciascuno dei quali richiede il doppio dell'esecuzione del merge sort su un array ad \\(n/4\\) elementi, e cos\u00ec via. Ricordando che il merge sort pu\u00f2 essere visto come un albero binario, \u00e8 evidente come ad ogni livello successivo dell'albero il numero di problemi raddoppi , mentre il tempo necessario alla risoluzione di un singolo problema si dimezzi . Questi due effetti si annullano reciprocamente, per cui potremo dire che, ad ogni livello, avremo bisogno al pi\u00f9 di \\(n\\) operazioni. Il tempo totale necessario \u00e8 quindi considerando un \\(O(n)\\) per ogni livello dell'albero prodotto dal merge sort. Con \\(c\\) livelli, avremo che il tempo totale necessario sar\u00e0 al pi\u00f9 \\(c \\cdot n\\) . Qual \u00e8 quindi il valore di \\(c\\) ? Dato che stiamo parlando di un albero binario, e che stiamo considerando un valore di \\(n\\) pari e potenza di due, sappiamo che \\(c = log_2n\\) . Di conseguenza, il tempo necessario per il merge sort sar\u00e0 dato da \\(n\\) (ovvero il numero di operazioni da effettuare a ciascun livello) moltiplicato per \\(c\\) (il numero di livelli), ovvero un \\(O(n \\cdot log_n2)\\) .","title":"Analisi di caso peggiore"},{"location":"02_dispense/05_algoritmi/05_quick_sort/","text":"Descrizione dell'algoritmo \u00b6 Cos\u00ec come il merge sort, il quick sort utilizza l'approccio divide-and-conquer , ed \u00e8 ovviamente un algoritmo di tipo ricorsivo. Tuttavia, laddove nel merge sort lo step divide \u00e8 praticamente ininfluente, ed \u00e8 il combine ad essere quello pi\u00f9 rilevante per il riordinamento, nel quick sort i ruoli si invertono. Ecco quindi come si articolano i tre diversi step del divide-and-conquer nel quick sort. Divide e procedura di partitioning \u00b6 Nel passo divide , scegliamo un elemento dell'array array[l,r] chiamato elemento pivot . A questo punto, gli elementi presenti nell'array saranno disposti in modo che: tutti gli elementi minori o uguali del pivot siano alla sua sinistra ; tutti gli elementi strettamente maggiori del pivot siano alla sua destra . Questa procedura \u00e8 chiamata partitioning (partizionamento). Nota Non ci interessa l'ordine relativo degli elementi a sinistra o a destra del pivot. Nella pratica, vedremo come conviene scegliere come pivot sempre l'elemento pi\u00f9 a destra nell'array, ovvero array[r] . Ad esempio, con il nostro array [8, 4, 5, 12, 7] , il pivot ad essere scelto alla prima iterazione sar\u00e0 proprio il 7 . Dopo il partizionamento, l'array sar\u00e0 riscritto come [4, 5, 7, 8, 12] , ed indicheremo con q il nuovo indice del pivot (in questo caso, q = 2 ). Nota Il fatto che siamo riusciti a riordinare l'array in una sola mossa \u00e8 puramente fortuito. Conquer \u00b6 Nel passo conquer ordiniamo in maniera ricorsiva gli array array[l, q-1] (ovvero tutti gli elementi minori o uguali al pivot) ed array[q+1, r] (ovvero tutti gli elementi maggiori del pivot). Combine \u00b6 Come accennato in precedenza, il passo combine non fa effettivamente niente, dato che tutti gli elementi a sinistra del pivot saranno ordinati, e lo stesso varr\u00e0 per gli elementi a destra dello stesso. Partitioning \u00b6 Abbiamo visto che il \"lavoro\" vero e proprio dell'algoritmo di quick sort avviene durante lo step divide ; ricordiamo inoltre che \u00e8 opportuno scegliere come pivot l'elemento pi\u00f9 a destra nell'array sotto analisi. Dopo aver scelto il pivot, dividiamo il nostro array come segue. Per prima cosa, usiamo due indici, chiamati \\(q\\) e \\(j\\) , per dividere l'array in quattro gruppi. La variabile q sar\u00e0 quella che contiene il riferimento all'indice nel quale inseriremo il pivot; la variabile j invece sar\u00e0 usata come contatore. In particolare, avremo: un gruppo \\(L\\) , in cui saranno inseriti tutti gli elementi di array[l, q-1] (ovvero quelli minori o uguali al pivot); un gruppo \\(G\\) , in cui saranno inseriti tutti gli elementi di array[q+1, j-1] (ovvero quelli maggiori del pivot); un gruppo \\(U\\) , in cui saranno inseriti tutti gli elementi di array[j, r-1] (ovvero quelli la cui relazione con il pivot non \u00e8 conosciuta perch\u00e9 non ancora comparati). Il pivot \u00e8 contraddistinto con array[r] . All'inizio, sia q sia j sono uguali ad l . Ad ogni step, si compara array[j] , ovvero l'elemento pi\u00f9 a sinistra del gruppo \\(U\\) , con il pivot. Se array[j] \u00e8 maggiore del pivot, ci limitiamo ad incrementare il valore di j ; se invece array[j] \u00e8 inferiore al pivot, allora lo sostituiamo con array[q] , aumentando contestualmente j e q . Una volta arrivati al pivot, il gruppo \\(U\\) risulta essere vuoto. A quel punto, sostituiamo il pivot con l'elemento pi\u00f9 a sinistra del gruppo \\(G\\) , ovvero sostituendo array[r] con array[q] . Questo cambio mette il pivot sempre tra i gruppi \\(L\\) e \\(G\\) . Analisi computazionale \u00b6 Analisi del partitioning \u00b6 Il partitioning di un array ad n elementi si effettua in \\(O(n)\\) . Questo \u00e8 legato al fatto che ogni elemento array[j] viene comparato una volta sola con il pivot; a seguito della comparazione, pu\u00f2 avvenire uno swap, q pu\u00f2 essere incrementato o meno, e j \u00e8 sempre incrementato. Analisi di caso peggiore \u00b6 Partiamo dall'analisi di caso peggiore. Supponiamo infatti che le dimensioni delle partizioni non siano bilanciate, e che il pivot scelto sia l'elemento pi\u00f9 piccolo o grande dell'array. Di conseguenza, una delle partizioni non avr\u00e0 alcun elemento, mentre l'altra ne avr\u00e0 \\(n-1\\) (ovvero tutti tranne il pivot). Di conseguenza, dovremo valutare ricorsivamente un array ad \\(n-i\\) elementi, con \\(1 \\leq i \\leq n\\) . Notiamo quindi che, in questo caso, avremo una serie del tipo \\(n + (n - 1) + \\ldots + 2 + 1\\) , che abbiamo visto essere in un \\(O(n^2)\\) . Analisi di caso migliore \u00b6 Nel caso migliore, le partizioni sono ben bilanciate. Ad esempio, potremmo trovarci nel caso in cui l'array analizzato ha un numero dispari di elementi, ed il pivot si trova esattamente al centro dopo il primo partitioning, per cui ogni partizione ha \\((n-1)/2\\) elementi. Oppure ancora, avendo un numero pari di elementi, avremo che la partizione di sinistra avr\u00e0 \\(n/2\\) elementi, mentre quella di destra \\((n - 2)/2\\) . In questi casi, l'albero \u00e8 facilmente riconducibile a quello del merge sort, per cui la complessit\u00e0 \u00e8 in \\(O(n \\cdot log_2n)\\) .","title":"18 - Quick sort"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#descrizione-dellalgoritmo","text":"Cos\u00ec come il merge sort, il quick sort utilizza l'approccio divide-and-conquer , ed \u00e8 ovviamente un algoritmo di tipo ricorsivo. Tuttavia, laddove nel merge sort lo step divide \u00e8 praticamente ininfluente, ed \u00e8 il combine ad essere quello pi\u00f9 rilevante per il riordinamento, nel quick sort i ruoli si invertono. Ecco quindi come si articolano i tre diversi step del divide-and-conquer nel quick sort.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#divide-e-procedura-di-partitioning","text":"Nel passo divide , scegliamo un elemento dell'array array[l,r] chiamato elemento pivot . A questo punto, gli elementi presenti nell'array saranno disposti in modo che: tutti gli elementi minori o uguali del pivot siano alla sua sinistra ; tutti gli elementi strettamente maggiori del pivot siano alla sua destra . Questa procedura \u00e8 chiamata partitioning (partizionamento). Nota Non ci interessa l'ordine relativo degli elementi a sinistra o a destra del pivot. Nella pratica, vedremo come conviene scegliere come pivot sempre l'elemento pi\u00f9 a destra nell'array, ovvero array[r] . Ad esempio, con il nostro array [8, 4, 5, 12, 7] , il pivot ad essere scelto alla prima iterazione sar\u00e0 proprio il 7 . Dopo il partizionamento, l'array sar\u00e0 riscritto come [4, 5, 7, 8, 12] , ed indicheremo con q il nuovo indice del pivot (in questo caso, q = 2 ). Nota Il fatto che siamo riusciti a riordinare l'array in una sola mossa \u00e8 puramente fortuito.","title":"Divide e procedura di partitioning"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#conquer","text":"Nel passo conquer ordiniamo in maniera ricorsiva gli array array[l, q-1] (ovvero tutti gli elementi minori o uguali al pivot) ed array[q+1, r] (ovvero tutti gli elementi maggiori del pivot).","title":"Conquer"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#combine","text":"Come accennato in precedenza, il passo combine non fa effettivamente niente, dato che tutti gli elementi a sinistra del pivot saranno ordinati, e lo stesso varr\u00e0 per gli elementi a destra dello stesso.","title":"Combine"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#partitioning","text":"Abbiamo visto che il \"lavoro\" vero e proprio dell'algoritmo di quick sort avviene durante lo step divide ; ricordiamo inoltre che \u00e8 opportuno scegliere come pivot l'elemento pi\u00f9 a destra nell'array sotto analisi. Dopo aver scelto il pivot, dividiamo il nostro array come segue. Per prima cosa, usiamo due indici, chiamati \\(q\\) e \\(j\\) , per dividere l'array in quattro gruppi. La variabile q sar\u00e0 quella che contiene il riferimento all'indice nel quale inseriremo il pivot; la variabile j invece sar\u00e0 usata come contatore. In particolare, avremo: un gruppo \\(L\\) , in cui saranno inseriti tutti gli elementi di array[l, q-1] (ovvero quelli minori o uguali al pivot); un gruppo \\(G\\) , in cui saranno inseriti tutti gli elementi di array[q+1, j-1] (ovvero quelli maggiori del pivot); un gruppo \\(U\\) , in cui saranno inseriti tutti gli elementi di array[j, r-1] (ovvero quelli la cui relazione con il pivot non \u00e8 conosciuta perch\u00e9 non ancora comparati). Il pivot \u00e8 contraddistinto con array[r] . All'inizio, sia q sia j sono uguali ad l . Ad ogni step, si compara array[j] , ovvero l'elemento pi\u00f9 a sinistra del gruppo \\(U\\) , con il pivot. Se array[j] \u00e8 maggiore del pivot, ci limitiamo ad incrementare il valore di j ; se invece array[j] \u00e8 inferiore al pivot, allora lo sostituiamo con array[q] , aumentando contestualmente j e q . Una volta arrivati al pivot, il gruppo \\(U\\) risulta essere vuoto. A quel punto, sostituiamo il pivot con l'elemento pi\u00f9 a sinistra del gruppo \\(G\\) , ovvero sostituendo array[r] con array[q] . Questo cambio mette il pivot sempre tra i gruppi \\(L\\) e \\(G\\) .","title":"Partitioning"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-computazionale","text":"","title":"Analisi computazionale"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-del-partitioning","text":"Il partitioning di un array ad n elementi si effettua in \\(O(n)\\) . Questo \u00e8 legato al fatto che ogni elemento array[j] viene comparato una volta sola con il pivot; a seguito della comparazione, pu\u00f2 avvenire uno swap, q pu\u00f2 essere incrementato o meno, e j \u00e8 sempre incrementato.","title":"Analisi del partitioning"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-di-caso-peggiore","text":"Partiamo dall'analisi di caso peggiore. Supponiamo infatti che le dimensioni delle partizioni non siano bilanciate, e che il pivot scelto sia l'elemento pi\u00f9 piccolo o grande dell'array. Di conseguenza, una delle partizioni non avr\u00e0 alcun elemento, mentre l'altra ne avr\u00e0 \\(n-1\\) (ovvero tutti tranne il pivot). Di conseguenza, dovremo valutare ricorsivamente un array ad \\(n-i\\) elementi, con \\(1 \\leq i \\leq n\\) . Notiamo quindi che, in questo caso, avremo una serie del tipo \\(n + (n - 1) + \\ldots + 2 + 1\\) , che abbiamo visto essere in un \\(O(n^2)\\) .","title":"Analisi di caso peggiore"},{"location":"02_dispense/05_algoritmi/05_quick_sort/#analisi-di-caso-migliore","text":"Nel caso migliore, le partizioni sono ben bilanciate. Ad esempio, potremmo trovarci nel caso in cui l'array analizzato ha un numero dispari di elementi, ed il pivot si trova esattamente al centro dopo il primo partitioning, per cui ogni partizione ha \\((n-1)/2\\) elementi. Oppure ancora, avendo un numero pari di elementi, avremo che la partizione di sinistra avr\u00e0 \\(n/2\\) elementi, mentre quella di destra \\((n - 2)/2\\) . In questi casi, l'albero \u00e8 facilmente riconducibile a quello del merge sort, per cui la complessit\u00e0 \u00e8 in \\(O(n \\cdot log_2n)\\) .","title":"Analisi di caso migliore"},{"location":"02_dispense/05_algoritmi/06_bfs/","text":"Descrizione dell'algoritmo \u00b6 La ricerca in ampiezza , o, in inglese, breath-first search ( BFS ), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi. Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\) , oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi. Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda . Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi. BFS sugli alberi \u00b6 Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero. La BFS opera considerando due parametri: il nodo attualmente ispezionato; i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato. In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i il nodo radice , ovvero quello da cui parte la ricerca; la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice; il predecessore del nodo Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore \u00e8 la distanza , che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\) . Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8. Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\) , la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste. TODO: esempio vertice isolato Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\) . TODO: ESEMPIO SU ALBERO Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null. L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda. In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue(). TODO: esempio su albero Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\) . In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\) . Analisi della BFS \u00b6 Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\) ? La risposta \u00e8 un tempo pari a \\(O(V + E)\\) . Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\) , che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi: \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\) , allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\) . Se, per\u00f2, abbiamo \\(|E| < |V|\\) , allora: \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\) . Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\) . In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\) , \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\) . Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\) ? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a null , per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.","title":"06 bfs"},{"location":"02_dispense/05_algoritmi/06_bfs/#descrizione-dellalgoritmo","text":"La ricerca in ampiezza , o, in inglese, breath-first search ( BFS ), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi. Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\) , oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi. Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda . Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi.","title":"Descrizione dell'algoritmo"},{"location":"02_dispense/05_algoritmi/06_bfs/#bfs-sugli-alberi","text":"Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero. La BFS opera considerando due parametri: il nodo attualmente ispezionato; i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato. In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i il nodo radice , ovvero quello da cui parte la ricerca; la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice; il predecessore del nodo Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\) . Il primo valore \u00e8 la distanza , che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\) . Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8. Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\) , la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste. TODO: esempio vertice isolato Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\) . TODO: ESEMPIO SU ALBERO Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null. L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda. In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue(). TODO: esempio su albero Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\) . In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\) .","title":"BFS sugli alberi"},{"location":"02_dispense/05_algoritmi/06_bfs/#analisi-della-bfs","text":"Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\) ? La risposta \u00e8 un tempo pari a \\(O(V + E)\\) . Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\) , che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi: \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\) , allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\) . Se, per\u00f2, abbiamo \\(|E| < |V|\\) , allora: \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\) . Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\) . In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\) , \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\) . Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\) ? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a null , per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.","title":"Analisi della BFS"},{"location":"02_dispense/06_modelli/01_turing/","text":"Modelli di calcolo \u00b6 Con il termine modello di calcolo rappresentiamo tutte quelle macchine, astratte o reali, in grado di risolvere degli algoritmi. E' quindi bene premettere che non esiste un modello di calcolo univoco : ogni modello adotta un esecutore con caratteristiche e capacit\u00e0 variabili, il che porta ad un approccio differente alla risoluzione di un problema. Dall'altro lato, basarsi su un modello di calcolo comune \u00e8 necessario per confrontare l'efficienza di diversi algoritmi, ed \u00e8 quindi un ottimo modo di integrare le nostre capacit\u00e0 di analisi computazionale a priori . Nonostante esistano quindi diversi modelli, alcuni dei quali recenti o in fase di sviluppo, come ad esempio il quantum computing o il DNA computing , il modello di riferimento in informatica \u00e8 sempre stato, e probabilmente rimarr\u00e0, la macchina di Turing . Macchina di Turing \u00b6 Ideata nel 1936 da uno dei \"padri\" dell'informatica, il famoso matematico inglese Alan Turing, la macchina di Turing \u00e8 un modello di calcolo astratto composto essenzialmente da due componenti: in primis, un nastro infinito , che opera da dispositivo di memorizzazione (in pratica, tramite il nastro, la macchina pu\u00f2 accedere alle informazioni); in secundis, una testina di lettura e scrittura che, scorrendo sul nastro, pu\u00f2 leggerne e modificarne il contenuto. Nota La macchina di Turing \u00e8 un modello astratto, ma non c'\u00e8 alcun modello astratto che i Lego non possano rappresentare, come dimostra la seguente figura. La macchina di Turing funziona modificando il suo stato sulla base del contenuto (o simbolo ) presente sul nastro in corrispondenza della testina. Infatti, la macchina valuta il contenuto della posizione corrente del nastro ed il suo stato interno attuale; a partire da questi, \u00e8 in grado di passare in un altro stato, eventualmente accedendo in scrittura al nastro, e scorrendo sullo stesso a destra o sinistra. Questo ci permette di definire la macchina di Turing come un Automa a Stati Finiti Deterministico . Automa a Stati Finiti Deterministico La definizione formale di Automa a Stati Finiti Deterministico esula dagli obiettivi del corso. Tuttavia, possiamo darne una rapida definizione informale , come \"macchina\" che pu\u00f2 avere un numero finito di possibili stati interni, ognuno dei quali \u00e8 determinato a partire dallo stato precedente e dalla lettura del nastro in posizione attuale. Nastro inifinto ed ASFD Da notare che il fatto che il nastro abbia lunghezza infinita non modifica il fatto che gli stati raggiungibili siano in quantit\u00e0 finita. Risoluzione di problemi mediante la macchina di Turing \u00b6 La risoluzione di un problema (e, quindi, la definizione di un algoritmo atto a risolverlo) richiede la progettazione di un'adeguata macchina di Turing. In tal senso, \u00e8 necessario definire almeno cinque parametri: un alfabeto \\(\\Sigma\\) dei simboli che \u00e8 possibile scrivere (leggere) sul (dal) nastro; un insieme di stati \\(S\\) in cui si pu\u00f2 trovare la macchina; uno stato iniziale \\(s_0\\) nel quale la macchina si trova inizialmente, con \\(s_o \\in S\\) ; un insieme di stati finali \\(S_f\\) nel quale la macchina si arresta, con \\(S_f \\in S\\) ; una funzione di transizione \\(\\delta\\) che determina il passaggio da uno stato ad un altro. La funzione di transizione pu\u00f2 essere definita come segue: \\[ \\delta: \\langle \\sigma_I, s_I \\rangle \\rightarrow \\langle t, \\sigma_F, s_F \\rangle \\] dove: \\(\\sigma_I\\) \u00e8 il simbolo letto dalla testina sul nastro; \\(\\s_I\\) \u00e8 lo stato della macchina di Turing antecedente la transizione; \\(t\\) \u00e8 la transizione che verr\u00e0 applicata al nastro (es. scorrimento verso destra o sinistra); \\(\\sigma_f\\) \u00e8 il simbolo scritto dalla testina sul nastro dopo la transizione; \\(\\s_F\\) \u00e8 lo stato della macchina di Turing successivo alla transizione. Formalmente, \u00e8 possibile definire una macchina di Turing \\(T\\) come: \\[ T = \\langle \\Sigma, S, s_0, S_f, \\delta \\rangle \\] Un esempio \u00b6 Vediamo come \u00e8 possibile risolvere un problema mediante una macchina di Turing. Per farlo, utilizzeremo un grafo degli stati per rappresentare l'automa. Il nostro problema \u00e8 quello di valutare se una stringa contiene il carattere \\(a\\) . Per questo, definiamo una macchina di Turing nel seguente modo: l'alfabeto \\(\\Sigma\\) sar\u00e0 dato da tutte le lettere dell'alfabeto inglese, pi\u00f9 il simbolo #, che indica la fine della stringa; l'insieme degli stati \\(S\\) sar\u00e0 dato da \\({s_0, s_1, s_T, s_F}\\) ; lo stato iniziale \u00e8 \\(s_0\\) (stringa non contenente \\(a\\) ); gli stati finali sono \\(s_T\\) (vero) ed \\(s_F\\) (falso). La strategia risolutiva ci permette di individuare la funzione \\(\\delta\\) . Infatti: partiamo dal primo carattere della stringa, e scorriamo il nastro verso destra; se incontriamo il carattere \\(a\\) , la macchina entra nello stato \\(s_1\\) , e ivi permane. Il nastro continua a scorrere verso destra fino a che non trova il carattere #, al quale si sposta in \\(s_T\\) ; se non incontriamo il carattere \\(a\\) , scorriamo il nastro fino al carattere #, al quale si sposta in \\(s_F\\) . Ci\u00f2 definisce la seguente funzione di transizione (in formato matriciale): \\(s_0\\) \\(s_1\\) \\(s_T\\) \\(s_F\\) \\(a\\) \\(\\langle D, s_1, - \\rangle\\) $ \\(\\langle D, s_1, - \\rangle\\) / / \\(b-z\\) \\(\\langle D, s_0, - \\rangle\\) \\(\\langle D, s_1, - \\rangle\\) / / # \\(\\langle -, s_F, - \\rangle\\) \\(\\langle -, s_T, - \\rangle\\) / / L'automa a stati finiti corrispondente sar\u00e0: Tesi di Church-Turing \u00b6 Abbiamo detto che la macchina di Turing \u00e8 un modello di riferimento . Ci\u00f2 significa che \u00e8 possibile dimostrare che tutti i diversi tipi di modello sono equiva\u00f2enti , e quindi un problema risolvibile usando la macchina di Turing \u00e8 risolvibile mediante qualsiasi modello di calcolo, astratto o reale. La tesi di Church - Turing afferma che: Tesi di Church - Turing Se un problema \u00e8 umanamente calcolabile, allora esister\u00e0 una macchina di Turing in grado di risolverlo (cio\u00e8 di calcolarlo) E' importante sottolineare come questa sia solo una tesi , e non un teorema .","title":"20 - Macchina di Turing"},{"location":"02_dispense/06_modelli/01_turing/#modelli-di-calcolo","text":"Con il termine modello di calcolo rappresentiamo tutte quelle macchine, astratte o reali, in grado di risolvere degli algoritmi. E' quindi bene premettere che non esiste un modello di calcolo univoco : ogni modello adotta un esecutore con caratteristiche e capacit\u00e0 variabili, il che porta ad un approccio differente alla risoluzione di un problema. Dall'altro lato, basarsi su un modello di calcolo comune \u00e8 necessario per confrontare l'efficienza di diversi algoritmi, ed \u00e8 quindi un ottimo modo di integrare le nostre capacit\u00e0 di analisi computazionale a priori . Nonostante esistano quindi diversi modelli, alcuni dei quali recenti o in fase di sviluppo, come ad esempio il quantum computing o il DNA computing , il modello di riferimento in informatica \u00e8 sempre stato, e probabilmente rimarr\u00e0, la macchina di Turing .","title":"Modelli di calcolo"},{"location":"02_dispense/06_modelli/01_turing/#macchina-di-turing","text":"Ideata nel 1936 da uno dei \"padri\" dell'informatica, il famoso matematico inglese Alan Turing, la macchina di Turing \u00e8 un modello di calcolo astratto composto essenzialmente da due componenti: in primis, un nastro infinito , che opera da dispositivo di memorizzazione (in pratica, tramite il nastro, la macchina pu\u00f2 accedere alle informazioni); in secundis, una testina di lettura e scrittura che, scorrendo sul nastro, pu\u00f2 leggerne e modificarne il contenuto. Nota La macchina di Turing \u00e8 un modello astratto, ma non c'\u00e8 alcun modello astratto che i Lego non possano rappresentare, come dimostra la seguente figura. La macchina di Turing funziona modificando il suo stato sulla base del contenuto (o simbolo ) presente sul nastro in corrispondenza della testina. Infatti, la macchina valuta il contenuto della posizione corrente del nastro ed il suo stato interno attuale; a partire da questi, \u00e8 in grado di passare in un altro stato, eventualmente accedendo in scrittura al nastro, e scorrendo sullo stesso a destra o sinistra. Questo ci permette di definire la macchina di Turing come un Automa a Stati Finiti Deterministico . Automa a Stati Finiti Deterministico La definizione formale di Automa a Stati Finiti Deterministico esula dagli obiettivi del corso. Tuttavia, possiamo darne una rapida definizione informale , come \"macchina\" che pu\u00f2 avere un numero finito di possibili stati interni, ognuno dei quali \u00e8 determinato a partire dallo stato precedente e dalla lettura del nastro in posizione attuale. Nastro inifinto ed ASFD Da notare che il fatto che il nastro abbia lunghezza infinita non modifica il fatto che gli stati raggiungibili siano in quantit\u00e0 finita.","title":"Macchina di Turing"},{"location":"02_dispense/06_modelli/01_turing/#risoluzione-di-problemi-mediante-la-macchina-di-turing","text":"La risoluzione di un problema (e, quindi, la definizione di un algoritmo atto a risolverlo) richiede la progettazione di un'adeguata macchina di Turing. In tal senso, \u00e8 necessario definire almeno cinque parametri: un alfabeto \\(\\Sigma\\) dei simboli che \u00e8 possibile scrivere (leggere) sul (dal) nastro; un insieme di stati \\(S\\) in cui si pu\u00f2 trovare la macchina; uno stato iniziale \\(s_0\\) nel quale la macchina si trova inizialmente, con \\(s_o \\in S\\) ; un insieme di stati finali \\(S_f\\) nel quale la macchina si arresta, con \\(S_f \\in S\\) ; una funzione di transizione \\(\\delta\\) che determina il passaggio da uno stato ad un altro. La funzione di transizione pu\u00f2 essere definita come segue: \\[ \\delta: \\langle \\sigma_I, s_I \\rangle \\rightarrow \\langle t, \\sigma_F, s_F \\rangle \\] dove: \\(\\sigma_I\\) \u00e8 il simbolo letto dalla testina sul nastro; \\(\\s_I\\) \u00e8 lo stato della macchina di Turing antecedente la transizione; \\(t\\) \u00e8 la transizione che verr\u00e0 applicata al nastro (es. scorrimento verso destra o sinistra); \\(\\sigma_f\\) \u00e8 il simbolo scritto dalla testina sul nastro dopo la transizione; \\(\\s_F\\) \u00e8 lo stato della macchina di Turing successivo alla transizione. Formalmente, \u00e8 possibile definire una macchina di Turing \\(T\\) come: \\[ T = \\langle \\Sigma, S, s_0, S_f, \\delta \\rangle \\]","title":"Risoluzione di problemi mediante la macchina di Turing"},{"location":"02_dispense/06_modelli/01_turing/#un-esempio","text":"Vediamo come \u00e8 possibile risolvere un problema mediante una macchina di Turing. Per farlo, utilizzeremo un grafo degli stati per rappresentare l'automa. Il nostro problema \u00e8 quello di valutare se una stringa contiene il carattere \\(a\\) . Per questo, definiamo una macchina di Turing nel seguente modo: l'alfabeto \\(\\Sigma\\) sar\u00e0 dato da tutte le lettere dell'alfabeto inglese, pi\u00f9 il simbolo #, che indica la fine della stringa; l'insieme degli stati \\(S\\) sar\u00e0 dato da \\({s_0, s_1, s_T, s_F}\\) ; lo stato iniziale \u00e8 \\(s_0\\) (stringa non contenente \\(a\\) ); gli stati finali sono \\(s_T\\) (vero) ed \\(s_F\\) (falso). La strategia risolutiva ci permette di individuare la funzione \\(\\delta\\) . Infatti: partiamo dal primo carattere della stringa, e scorriamo il nastro verso destra; se incontriamo il carattere \\(a\\) , la macchina entra nello stato \\(s_1\\) , e ivi permane. Il nastro continua a scorrere verso destra fino a che non trova il carattere #, al quale si sposta in \\(s_T\\) ; se non incontriamo il carattere \\(a\\) , scorriamo il nastro fino al carattere #, al quale si sposta in \\(s_F\\) . Ci\u00f2 definisce la seguente funzione di transizione (in formato matriciale): \\(s_0\\) \\(s_1\\) \\(s_T\\) \\(s_F\\) \\(a\\) \\(\\langle D, s_1, - \\rangle\\) $ \\(\\langle D, s_1, - \\rangle\\) / / \\(b-z\\) \\(\\langle D, s_0, - \\rangle\\) \\(\\langle D, s_1, - \\rangle\\) / / # \\(\\langle -, s_F, - \\rangle\\) \\(\\langle -, s_T, - \\rangle\\) / / L'automa a stati finiti corrispondente sar\u00e0:","title":"Un esempio"},{"location":"02_dispense/06_modelli/01_turing/#tesi-di-church-turing","text":"Abbiamo detto che la macchina di Turing \u00e8 un modello di riferimento . Ci\u00f2 significa che \u00e8 possibile dimostrare che tutti i diversi tipi di modello sono equiva\u00f2enti , e quindi un problema risolvibile usando la macchina di Turing \u00e8 risolvibile mediante qualsiasi modello di calcolo, astratto o reale. La tesi di Church - Turing afferma che: Tesi di Church - Turing Se un problema \u00e8 umanamente calcolabile, allora esister\u00e0 una macchina di Turing in grado di risolverlo (cio\u00e8 di calcolarlo) E' importante sottolineare come questa sia solo una tesi , e non un teorema .","title":"Tesi di Church-Turing"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/","text":"Cosa \u00e8 C? \u00b6 Il linguaggio C \u00e8 un linguaggio ad alto livello inizialmente sviluppato da Dennis M. Ritchie nell'ambito dello sviluppo del sistema operativo UNIX ai Bell Labs. La sua prima implementazione risale al 1972 su un computer DEC PDP-11. Il primo draft disponibile venne reso disponibile al grande pubblico nel 1978, in quello che \u00e8 conosciuto al giorno d'oggi come K&R standard ; venne poi formalizzato dall' American National Standard Institute ( ANSI ) nel 1988. Al giorno d'oggi, C \u00e8 uno dei linguaggi di programmazioni maggiormente utilizzati. Le sue applicazioni sono estese, e vanno dai sistemi operativi, ai compilatori, ai text editor, passando per database e programmi ottimizzati per smartphone. Vediamo insieme la struttura di un primo programma in C. Hello, C! \u00b6 La Via dell'Informatico ci impone di partire in maniera abbastanza classica, andando a definire un primo, rudimentale, ma famigerato programma: l' Hello, World . #include <stdio.h> int main () { // Ora sono un programmatore! printf ( \"Hello, World! \\n \" ); return 0 ; } Ecco fatto, semplice, vero? Beh, certo, per\u00f2, nonostante la loro semplicit\u00e0, in queste poche righe di codice sono racchiusi tutti i concetti fondamentali a scrivere programmi ben pi\u00f9 complessi. Vediamole una ad una. #include \u00b6 La prima istruzione \u00e8 una direttiva . Se ricordate, \u00e8 proprio una di quelle parti di codice che vengono pre-elaborate dal compilatore. In particolare, questa \u00e8 una direttiva include , che prevede un parametro che pu\u00f2 essere incluso tra i simboli < e > , oppure tra doppi apici, e rappresenta il nome di un file. Quando il compilatore incontra una include , cerca il file specificato (in questo caso, stdio.h , che fa parte dello \"standard\" dettato dal C), e ne copia integralmente il contenuto nel file che andr\u00e0 poi al front end del compilatore. L'uso dei simboli < e > non \u00e8 intercambiabile con quello dei doppi apici: infatti, nel primo caso, la ricerca avviene all'interno della directory in cui si trovano i file di intestazione della libreria standard di C (torneremo in avanti sul concetto di libreria), mentre nel secondo la ricerca avviene all'interno della directory corrente. int main() \u00b6 Questa istruzione \u00e8 la firma di una particolare funzione, ovvero il main() . La funzione main sarebbe una normalissima funzione, se non fosse per un piccolo dettaglio: rappresenta infatti il punto di accesso di un programma, ovvero la parte di codice che verr\u00e0 effettivamente eseguita a runtime, richiamando e componendo alla bisogna le altre istruzioni e funzioni invocate dal programma. // Questo \u00e8 un commento \u00b6 Le istruzioni che hanno preposti due caratteri di slash ( // ) sono chiamate commenti . Queste righe permettono al programmatore di inserire dei \"suggerimenti\" per spiegare meglio il codice ad altri sviluppatori (o per ricordare in futuro cosa si era fatto). Questo tipo di commento \u00e8 a singola linea; esistono anche i commenti multilinea: /* * Questo \u00e8 un commento multilinea! */ // E questo \u00e8 un commento a linea singola! printf(\"Hello, World! \\n\") \u00b6 Questa istruzione richiama una funzione integrata nel file stdio.h che abbiamo invocato in precedenza nella direttiva include , ovvero la funzione printf . Questa accetta in ingresso una stringa (logicamente equivalente ad un array di char), ovvero \"Hello, World! \\n\" , e la stampa a schermo (spesso in una shell). Interessante notare la presenza di un escape character , ovvero \\n , che indica al compilatore di andare a capo dopo il termine della stringa. return 0 \u00b6 La funzione main() prevede in uscita un valore intero; di conseguenza, il return 0 indica il termine del main() stesso. Per convenzione, il return 0 indica il successo del programma, mentre altri valori di ritorno possono indicare degli errori intercorsi durante l'esecuzione.","title":"01 - Introduzione al C"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/#cosa-e-c","text":"Il linguaggio C \u00e8 un linguaggio ad alto livello inizialmente sviluppato da Dennis M. Ritchie nell'ambito dello sviluppo del sistema operativo UNIX ai Bell Labs. La sua prima implementazione risale al 1972 su un computer DEC PDP-11. Il primo draft disponibile venne reso disponibile al grande pubblico nel 1978, in quello che \u00e8 conosciuto al giorno d'oggi come K&R standard ; venne poi formalizzato dall' American National Standard Institute ( ANSI ) nel 1988. Al giorno d'oggi, C \u00e8 uno dei linguaggi di programmazioni maggiormente utilizzati. Le sue applicazioni sono estese, e vanno dai sistemi operativi, ai compilatori, ai text editor, passando per database e programmi ottimizzati per smartphone. Vediamo insieme la struttura di un primo programma in C.","title":"Cosa \u00e8 C?"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/#hello-c","text":"La Via dell'Informatico ci impone di partire in maniera abbastanza classica, andando a definire un primo, rudimentale, ma famigerato programma: l' Hello, World . #include <stdio.h> int main () { // Ora sono un programmatore! printf ( \"Hello, World! \\n \" ); return 0 ; } Ecco fatto, semplice, vero? Beh, certo, per\u00f2, nonostante la loro semplicit\u00e0, in queste poche righe di codice sono racchiusi tutti i concetti fondamentali a scrivere programmi ben pi\u00f9 complessi. Vediamole una ad una.","title":"Hello, C!"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/#include","text":"La prima istruzione \u00e8 una direttiva . Se ricordate, \u00e8 proprio una di quelle parti di codice che vengono pre-elaborate dal compilatore. In particolare, questa \u00e8 una direttiva include , che prevede un parametro che pu\u00f2 essere incluso tra i simboli < e > , oppure tra doppi apici, e rappresenta il nome di un file. Quando il compilatore incontra una include , cerca il file specificato (in questo caso, stdio.h , che fa parte dello \"standard\" dettato dal C), e ne copia integralmente il contenuto nel file che andr\u00e0 poi al front end del compilatore. L'uso dei simboli < e > non \u00e8 intercambiabile con quello dei doppi apici: infatti, nel primo caso, la ricerca avviene all'interno della directory in cui si trovano i file di intestazione della libreria standard di C (torneremo in avanti sul concetto di libreria), mentre nel secondo la ricerca avviene all'interno della directory corrente.","title":"#include"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/#int-main","text":"Questa istruzione \u00e8 la firma di una particolare funzione, ovvero il main() . La funzione main sarebbe una normalissima funzione, se non fosse per un piccolo dettaglio: rappresenta infatti il punto di accesso di un programma, ovvero la parte di codice che verr\u00e0 effettivamente eseguita a runtime, richiamando e componendo alla bisogna le altre istruzioni e funzioni invocate dal programma.","title":"int main()"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/#questo-e-un-commento","text":"Le istruzioni che hanno preposti due caratteri di slash ( // ) sono chiamate commenti . Queste righe permettono al programmatore di inserire dei \"suggerimenti\" per spiegare meglio il codice ad altri sviluppatori (o per ricordare in futuro cosa si era fatto). Questo tipo di commento \u00e8 a singola linea; esistono anche i commenti multilinea: /* * Questo \u00e8 un commento multilinea! */ // E questo \u00e8 un commento a linea singola!","title":"// Questo \u00e8 un commento"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/#printfhello-world-n","text":"Questa istruzione richiama una funzione integrata nel file stdio.h che abbiamo invocato in precedenza nella direttiva include , ovvero la funzione printf . Questa accetta in ingresso una stringa (logicamente equivalente ad un array di char), ovvero \"Hello, World! \\n\" , e la stampa a schermo (spesso in una shell). Interessante notare la presenza di un escape character , ovvero \\n , che indica al compilatore di andare a capo dopo il termine della stringa.","title":"printf(\"Hello, World! \\n\")"},{"location":"02_dispense/programmazione/01_linguaggio_c/01_introduzione/#return-0","text":"La funzione main() prevede in uscita un valore intero; di conseguenza, il return 0 indica il termine del main() stesso. Per convenzione, il return 0 indica il successo del programma, mentre altri valori di ritorno possono indicare degli errori intercorsi durante l'esecuzione.","title":"return 0"},{"location":"02_dispense/programmazione/01_linguaggio_c/02_nozioni/","text":"Parole riservate \u00b6 In ogni linguaggio di programmazione esiste una serie di parole riservate , o keyword , che indicano delle specifiche funzionalit\u00e0 dello stesso, e che pertanto non possono essere in alcun modo utilizzate dall'utente. Normalmente, queste parole chiave sono quelle relative a fattori come il tipo di una variabile, oppure ancora dei particolari attributi assegnabili ad una struttura dati o ad una funzione. Ad esempio, proviamo ad esempio a creare la seguente variabile in C: int int = 10 ; Provando a compilare, Visual Studio ci dar\u00e0 i seguenti messaggi di errore: error C2632: 'int' non pu\u00f2 essere seguito da 'int' error C2513: 'int' : nessuna variabile dichiarata prima di '=' Per una lista di keyword usate nei vari linguaggi, controllare l'appendice D. Modularit\u00e0, prototipi e file header \u00b6 Funzioni e procedure \u00b6 In C++, cos\u00ec come nel C, la diferenza tra funzioni e procedure \u00e8 solo teorica. Le procedure, in programmazione puramente procedrale, sono blocchi che espletano una determinata operazione senza produrre un valore di ritorno. Le funzioni, invece, mutuano il concetto matematico di relazione, ed associano ad un elemento del proprio dominio (variabili e parametri) un elemento di un codominio (valore di ritorno). Ecco quindi come il void assume un significato diverso: una procedura \u00e8 un tipo particolare di funzione che non ha codominio, e quindi presenta un valore di ritorno void .","title":"02 nozioni"},{"location":"02_dispense/programmazione/01_linguaggio_c/02_nozioni/#parole-riservate","text":"In ogni linguaggio di programmazione esiste una serie di parole riservate , o keyword , che indicano delle specifiche funzionalit\u00e0 dello stesso, e che pertanto non possono essere in alcun modo utilizzate dall'utente. Normalmente, queste parole chiave sono quelle relative a fattori come il tipo di una variabile, oppure ancora dei particolari attributi assegnabili ad una struttura dati o ad una funzione. Ad esempio, proviamo ad esempio a creare la seguente variabile in C: int int = 10 ; Provando a compilare, Visual Studio ci dar\u00e0 i seguenti messaggi di errore: error C2632: 'int' non pu\u00f2 essere seguito da 'int' error C2513: 'int' : nessuna variabile dichiarata prima di '=' Per una lista di keyword usate nei vari linguaggi, controllare l'appendice D.","title":"Parole riservate"},{"location":"02_dispense/programmazione/01_linguaggio_c/02_nozioni/#modularita-prototipi-e-file-header","text":"","title":"Modularit\u00e0, prototipi e file header"},{"location":"02_dispense/programmazione/01_linguaggio_c/02_nozioni/#funzioni-e-procedure","text":"In C++, cos\u00ec come nel C, la diferenza tra funzioni e procedure \u00e8 solo teorica. Le procedure, in programmazione puramente procedrale, sono blocchi che espletano una determinata operazione senza produrre un valore di ritorno. Le funzioni, invece, mutuano il concetto matematico di relazione, ed associano ad un elemento del proprio dominio (variabili e parametri) un elemento di un codominio (valore di ritorno). Ecco quindi come il void assume un significato diverso: una procedura \u00e8 un tipo particolare di funzione che non ha codominio, e quindi presenta un valore di ritorno void .","title":"Funzioni e procedure"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/","text":"Il concetto di stream \u00b6 Il linguaggio C (e, come vedremo, anche il C++) adotta il concetto di stream come base per favorire i meccanismi di input ed output rispettivamente da e verso l'utente. Cosa \u00e8 un file? \u00b6 Possiamo definire un file come un insieme di dati, i quali vengono organizzati e memorizzati sulla maniera ordinata. Il C riconosce due categorie di file: i file di testo ed i file binari . I file di testo sono formati da una sequenza di caratteri organizzati in linee , ciascuna delle quali termina con il carattere \\n ; i file binari, invece, sono costituiti da una sequenza di byte. Accedere ad un file C \u00b6 Per accedere ad un file in C, possiamo usare due diverse modalit\u00e0. La prima \u00e8 l'accesso sequenziale : in questo modo, possiamo accedere ad un elemento scorrendo tutti quelli precedenti. La seconda \u00e8 invece l'accesso casuale , o diretto , che permette di raggiungere un elemento direttamente. Il linguaggio C crea un livello intermedio tra il programma e il file che prende il nome di stream , nel quale si memorizzano le informazioni da gestire. Dunque, il nostro programma non gestisce direttamente il file, quanto piuttosto lo stream , che ha il compito di filtrare le istruzioni. puntatore a FILE \u00b6 per accedere ad un file occorre usare un puntatore a FILE, ovvero un indirizzo di memoria o locazione iniziale del file cui si vuole accedere. FILE \u00e8 un tipo definito nell'header stdio.h. La sintassi \u00e8: #include <stdio.h> // ... FILE * fp ; fopen in C \u00b6 la funzione fopen in C serve ad aprire un file in diverse modalit\u00e0. La sintassi \u00e8 la seguente: FILE fopen(char nomefile, char *modo) I modi sono diversi, ed in particolare: | Modo | Funzione | Creazione file | | -- | -- | |-- | | r | Apre un file in lettura | No (file deve esistere) | | r+ | Apre un file esistente in lettura/scrittura | No (file deve esistere) | | w | Crea un nuovo file in scrittura; se il file esiste, viene cancellato il contenuto | S\u00ec. Se il file esiste, viene cancellato il contenuto. | | w+ | Crea un nuovo file in lettura/scrittura; se il file esiste, wiene cancellato il contentuo | S\u00ec, se il file esiste viene cancellato il contenuto | | a | Aggiunge alla fine del file. Se non esiste, crealo. | S\u00ec | | a+ | Aggiunge e legge a partire dalla fine del file. | S\u00ec (se non esiste viene creato) | E' inoltre possibile specificare il tipo di file usando, rispettivament,e le lettere b o t (binario o di testo). Di default, si usa il valore t. Un esempio di uso \u00e8 il seguente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } Notiamo come controlliamo che il file esiste. Una possibile causa di fallimento potrebbe essere usare la modalit\u00e0 r su un file che non esiste. fclose \u00b6 La funzione fclose serve a chiudere un file dopo averlo utilizzato, di modo da rendere lo stream disponibile per altri utilizzo. La sintassi \u00e8 la seguente: int fclose ( FILE * fp ) La funzione restituisce un valore intero. se tutto \u00e8 andato a buon fine, viene restituito 0; in alternativa, viene restituito EOF, che \u00e8 un valore costante. Volendo estendere il programma precedente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } // uso fclose ( fp ); Nota Tutti i file vengono chiusi in maniera automatica se il programma termina regolarmente; in questi casi, non \u00e8 necessaria la funzione fclose. fprintf \u00b6 La funzione fprintf permette di scrivere sul file in modo formattato dopo l'apertura dello stesso con fopen. Questa funzione \u00e8 molto simile quindi alla printf, ed opera sullo stream del file aperto con la funzione fopen. La sintassi della funzione \u00e8 la seguente: int fprintf ( FILE * fp , char * format , [ args ]) In pratica, \u00e8 analoga alla printf, se non per due differenze: la prima \u00e8 che accetta come primo argomento un puntatore a file; la seconda \u00e8 che restituisce un valore di ritorno, ovvero un intero. Il valore di ritorno della fprintf \u00e8 il numero di caratteri scritti nello stream in caso di successo o un EOF in caso di errore. #include <stdio.h> #include <stdlib.h> int main () { FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } fprintf ( fp , \"Il file esiste!\" ); fclose ( fp ); } scanf \u00b6 La funzione scanf ci permette di acquisire una sequenza di caratteri (lettere o cifre) dalla tastiera e memorizzarla in una variabile opportuna. E' la funzione duale della printf. La sua sintassi \u00e8 la seguente: scanf ( char * format , [ args ]) dove: format rappresenta uno o pi\u00f9 specificatori di formato args rappresenta uno o pi\u00f9 riferimenti alle variabili da popolare. Ad esempio: scanf ( \"%d%, &x) far\u00e0 s\u00ec che il valore passato da tastiera sia salvato nella variabile di tipo intero x, mentre: scanf ( \"%d %f\" , & x , & y ) legger\u00e0 un intero ed un decimale andandoli a mettere nelle variabili x ed y rispettivamente. Nota In realt\u00e0, l'uso di scanf \u00e8 sconsigliato. Per maggiori informazioni, leggete qui . fscanf \u00b6 La funzione fscanf serve a leggere un file in modo formattato, chiaramente dopo l'apertura con fopen. E', come la fprintf, l'equivalente sugli stream della scanf. La differenza in questo caso \u00e8 anche qui valutabile andando ad esaminare il prootipo della funzione: int fscanf ( FILE * fp , char * format , [ args ]) Notiamo infatti che viene restituito un intero, che rappresenta il numero di caratteri letti, e che come primo argomento viene passato il puntatore al file di riferimento. feof \u00b6 La funzione feof infine serve a sapere se ci troviamo alla fine di un file. Questa \u00e8 definita come segue: int feof ( FILE * fp ) e restituisce 0 se non \u00e8 stata raggiunta laf ine del file, o true altrimenti. Possiamo farlo per leggere nel file fino a che non abbiamo raggiunto la fine dello stesso. Un esempio \u00e8 il seguente: #include <stdio.h> #include <stdlib.h> #define N 5 int main () { FILE * fp ; char cognome [ 20 ]; char nome [ 20 ]; int i , voto ; if (( fp = fopen ( \"alunni.txt\" , \"rt\" )) == NULL ) { printf ( \"Errore nell'apertura del file'\" ); exit ( 1 ); } while ( ! feof ( fp )){ fscanf ( fp , \"%s %s %d \\n \" , & cognome , & nome , & voto ); printf ( \"cognome: %s, nome: %s, voto: %d \\n \" , cognome , nome , voto ); } fclose ( fp ); return 0 ; }","title":"Il concetto di stream"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#il-concetto-di-stream","text":"Il linguaggio C (e, come vedremo, anche il C++) adotta il concetto di stream come base per favorire i meccanismi di input ed output rispettivamente da e verso l'utente.","title":"Il concetto di stream"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#cosa-e-un-file","text":"Possiamo definire un file come un insieme di dati, i quali vengono organizzati e memorizzati sulla maniera ordinata. Il C riconosce due categorie di file: i file di testo ed i file binari . I file di testo sono formati da una sequenza di caratteri organizzati in linee , ciascuna delle quali termina con il carattere \\n ; i file binari, invece, sono costituiti da una sequenza di byte.","title":"Cosa \u00e8 un file?"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#accedere-ad-un-file-c","text":"Per accedere ad un file in C, possiamo usare due diverse modalit\u00e0. La prima \u00e8 l'accesso sequenziale : in questo modo, possiamo accedere ad un elemento scorrendo tutti quelli precedenti. La seconda \u00e8 invece l'accesso casuale , o diretto , che permette di raggiungere un elemento direttamente. Il linguaggio C crea un livello intermedio tra il programma e il file che prende il nome di stream , nel quale si memorizzano le informazioni da gestire. Dunque, il nostro programma non gestisce direttamente il file, quanto piuttosto lo stream , che ha il compito di filtrare le istruzioni.","title":"Accedere ad un file C"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#puntatore-a-file","text":"per accedere ad un file occorre usare un puntatore a FILE, ovvero un indirizzo di memoria o locazione iniziale del file cui si vuole accedere. FILE \u00e8 un tipo definito nell'header stdio.h. La sintassi \u00e8: #include <stdio.h> // ... FILE * fp ;","title":"puntatore a FILE"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#fopen-in-c","text":"la funzione fopen in C serve ad aprire un file in diverse modalit\u00e0. La sintassi \u00e8 la seguente: FILE fopen(char nomefile, char *modo) I modi sono diversi, ed in particolare: | Modo | Funzione | Creazione file | | -- | -- | |-- | | r | Apre un file in lettura | No (file deve esistere) | | r+ | Apre un file esistente in lettura/scrittura | No (file deve esistere) | | w | Crea un nuovo file in scrittura; se il file esiste, viene cancellato il contenuto | S\u00ec. Se il file esiste, viene cancellato il contenuto. | | w+ | Crea un nuovo file in lettura/scrittura; se il file esiste, wiene cancellato il contentuo | S\u00ec, se il file esiste viene cancellato il contenuto | | a | Aggiunge alla fine del file. Se non esiste, crealo. | S\u00ec | | a+ | Aggiunge e legge a partire dalla fine del file. | S\u00ec (se non esiste viene creato) | E' inoltre possibile specificare il tipo di file usando, rispettivament,e le lettere b o t (binario o di testo). Di default, si usa il valore t. Un esempio di uso \u00e8 il seguente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } Notiamo come controlliamo che il file esiste. Una possibile causa di fallimento potrebbe essere usare la modalit\u00e0 r su un file che non esiste.","title":"fopen in C"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#fclose","text":"La funzione fclose serve a chiudere un file dopo averlo utilizzato, di modo da rendere lo stream disponibile per altri utilizzo. La sintassi \u00e8 la seguente: int fclose ( FILE * fp ) La funzione restituisce un valore intero. se tutto \u00e8 andato a buon fine, viene restituito 0; in alternativa, viene restituito EOF, che \u00e8 un valore costante. Volendo estendere il programma precedente: FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } // uso fclose ( fp ); Nota Tutti i file vengono chiusi in maniera automatica se il programma termina regolarmente; in questi casi, non \u00e8 necessaria la funzione fclose.","title":"fclose"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#fprintf","text":"La funzione fprintf permette di scrivere sul file in modo formattato dopo l'apertura dello stesso con fopen. Questa funzione \u00e8 molto simile quindi alla printf, ed opera sullo stream del file aperto con la funzione fopen. La sintassi della funzione \u00e8 la seguente: int fprintf ( FILE * fp , char * format , [ args ]) In pratica, \u00e8 analoga alla printf, se non per due differenze: la prima \u00e8 che accetta come primo argomento un puntatore a file; la seconda \u00e8 che restituisce un valore di ritorno, ovvero un intero. Il valore di ritorno della fprintf \u00e8 il numero di caratteri scritti nello stream in caso di successo o un EOF in caso di errore. #include <stdio.h> #include <stdlib.h> int main () { FILE * fp ; if ( fp = fopen ( \"prova.txt\" , \"w+t\" ) == NULL ) { printf ( \"Errore nell'apertura del file desiderato.\" ); } fprintf ( fp , \"Il file esiste!\" ); fclose ( fp ); }","title":"fprintf"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#scanf","text":"La funzione scanf ci permette di acquisire una sequenza di caratteri (lettere o cifre) dalla tastiera e memorizzarla in una variabile opportuna. E' la funzione duale della printf. La sua sintassi \u00e8 la seguente: scanf ( char * format , [ args ]) dove: format rappresenta uno o pi\u00f9 specificatori di formato args rappresenta uno o pi\u00f9 riferimenti alle variabili da popolare. Ad esempio: scanf ( \"%d%, &x) far\u00e0 s\u00ec che il valore passato da tastiera sia salvato nella variabile di tipo intero x, mentre: scanf ( \"%d %f\" , & x , & y ) legger\u00e0 un intero ed un decimale andandoli a mettere nelle variabili x ed y rispettivamente. Nota In realt\u00e0, l'uso di scanf \u00e8 sconsigliato. Per maggiori informazioni, leggete qui .","title":"scanf"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#fscanf","text":"La funzione fscanf serve a leggere un file in modo formattato, chiaramente dopo l'apertura con fopen. E', come la fprintf, l'equivalente sugli stream della scanf. La differenza in questo caso \u00e8 anche qui valutabile andando ad esaminare il prootipo della funzione: int fscanf ( FILE * fp , char * format , [ args ]) Notiamo infatti che viene restituito un intero, che rappresenta il numero di caratteri letti, e che come primo argomento viene passato il puntatore al file di riferimento.","title":"fscanf"},{"location":"02_dispense/programmazione/01_linguaggio_c/07_file/#feof","text":"La funzione feof infine serve a sapere se ci troviamo alla fine di un file. Questa \u00e8 definita come segue: int feof ( FILE * fp ) e restituisce 0 se non \u00e8 stata raggiunta laf ine del file, o true altrimenti. Possiamo farlo per leggere nel file fino a che non abbiamo raggiunto la fine dello stesso. Un esempio \u00e8 il seguente: #include <stdio.h> #include <stdlib.h> #define N 5 int main () { FILE * fp ; char cognome [ 20 ]; char nome [ 20 ]; int i , voto ; if (( fp = fopen ( \"alunni.txt\" , \"rt\" )) == NULL ) { printf ( \"Errore nell'apertura del file'\" ); exit ( 1 ); } while ( ! feof ( fp )){ fscanf ( fp , \"%s %s %d \\n \" , & cognome , & nome , & voto ); printf ( \"cognome: %s, nome: %s, voto: %d \\n \" , cognome , nome , voto ); } fclose ( fp ); return 0 ; }","title":"feof"},{"location":"02_dispense/programmazione/01_linguaggio_c/08_typedef/","text":"Nel linguaggio C, le struct sono usate per raggrupapre diversi tipi di varaibili sotto lo stesso nome. Ad esempio, potremmo creare una struttura \"persona\", fatta da due stringhe ed un intero. struct persona { char * nome ; char * cognome ; int eta ; }; Con la dichiarazione della struttura abbiamno creato un nuovo tipo chiamato persona. Prima di poter usare il tipo telefono, occorre creare una variabile del tipo telefono. Ad esempio: #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona pippo ; return 0 ; } Per accedere ai membri della struttura persona, dobbiamo inserire un punto tra il nome della struttura e quello della variabile. #include <stdio.h> struct persona { char * nome ; char * cognome ; int eta ; }; int main () { struct persona studente ; studente . nome = \"Piero\" ; studente . cognome = \"Scamarcio\" ; studente . eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente . name , studente . cognome , studente . eta ); return 0 ; } typedef \u00b6 Le definizioni di tipo rendono anche possibile creare i nostri tipi di variabile. Ad esempio, possiamo creare un tipo che rappresenta un puntatore a double. #include <stdio.h> typedef double * double_pointer ; int main () { double val = 0.0 ; double_pointer pointer = & val ; printf ( \"Il valore del puntatore e': %p\" , pointer ); return 0 ; } Questa tecnica pu\u00f2 anche essere estesa alle struct. Ci\u00f2 significa che: #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA pippo ; return 0 ; } otiamo che il nome del tipo associaot alla sturttura \u00e8 quello indicato in maiuscolo immediatamente dopo alla stessa. Puntatori a strutture \u00b6 Possiamo usare anche dei puntatori a strutture. In questo caso, per accedere alla singola propriet\u00e0 della struct, dovremo usare l'operatore infix (->) #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA studente ; PERSONA * puntatore_studente ; studente -> nome = \"Piero\" ; // Prima era studente.nome! studente -> cognome = \"Scamarcio\" ; studente -> eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente -> name , studente -> cognome , studente -> eta ); return 0 ; } Union \u00b6 Le union sono analoghe alle struct dal punto di vista della sintassi, semplicemente per\u00f2 implementano delle strutture dati differenti. Un esempio \u00e8 il seguente. #include <stdio.h> typedef union lettura_sensore { double d ; int i ; } LETTURA_SENSORE ; int main () { LETTURA_SENSORE lettura ; lettura . d = 12.0 ; lettura . i = 5 ; }","title":"08 typedef"},{"location":"02_dispense/programmazione/01_linguaggio_c/08_typedef/#typedef","text":"Le definizioni di tipo rendono anche possibile creare i nostri tipi di variabile. Ad esempio, possiamo creare un tipo che rappresenta un puntatore a double. #include <stdio.h> typedef double * double_pointer ; int main () { double val = 0.0 ; double_pointer pointer = & val ; printf ( \"Il valore del puntatore e': %p\" , pointer ); return 0 ; } Questa tecnica pu\u00f2 anche essere estesa alle struct. Ci\u00f2 significa che: #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA pippo ; return 0 ; } otiamo che il nome del tipo associaot alla sturttura \u00e8 quello indicato in maiuscolo immediatamente dopo alla stessa.","title":"typedef"},{"location":"02_dispense/programmazione/01_linguaggio_c/08_typedef/#puntatori-a-strutture","text":"Possiamo usare anche dei puntatori a strutture. In questo caso, per accedere alla singola propriet\u00e0 della struct, dovremo usare l'operatore infix (->) #include <stdio.h> typedef struct persona { char * nome ; char * cognome ; int eta ; } PERSONA ; int main () { PERSONA studente ; PERSONA * puntatore_studente ; studente -> nome = \"Piero\" ; // Prima era studente.nome! studente -> cognome = \"Scamarcio\" ; studente -> eta = 19 ; printf ( \"Lo studente %s %s ha %d anni \\n \" , studente -> name , studente -> cognome , studente -> eta ); return 0 ; }","title":"Puntatori a strutture"},{"location":"02_dispense/programmazione/01_linguaggio_c/08_typedef/#union","text":"Le union sono analoghe alle struct dal punto di vista della sintassi, semplicemente per\u00f2 implementano delle strutture dati differenti. Un esempio \u00e8 il seguente. #include <stdio.h> typedef union lettura_sensore { double d ; int i ; } LETTURA_SENSORE ; int main () { LETTURA_SENSORE lettura ; lettura . d = 12.0 ; lettura . i = 5 ; }","title":"Union"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/01_c_vs_cpp/","text":"Partiamo con quello che, probabilmente, rappresenta il concetto pi\u00f9 importante da sottolineare, ovvero: Affermazione importantissima Il C++ \u00e8 un superset del C. Ci\u00f2 significa, banalmente, che le istruzioni che abbiamo visto ed usato finora in C definiscono un sottoinsieme del C++. Di conseguenza, i due linguaggi condividono una sintassi ed una semantica comune; ci\u00f2 tuttavia non deve trarre in inganno, perch\u00e9 il C++ utilizza diversi concetti avanzati che il C non ha a sua disposizione. Vediamoli insieme. Differenze generali \u00b6 In primis, vediamo riassunte nella seguente tabella alcune differenze fondamentali che intercorrono tra i due linguaggi. Argomento C C++ Keyword 32 52 Paradigma di programmazione Imperativo Imperativo/OOP Focus principale Metodi e processi Dati Tipi definiti dall'utente Supporto limitato con typedef Pieno supporto mediante le classi Gestione delle eccezioni Non presente Presente Nella precedente tabella, vediamo un semplice dato \"numerico\", dato dal maggior numero di keyword a disposizione per il C++; ci\u00f2 indica la presenza di una sintassi comunque pi\u00f9 ricca ed articolata, necessaria a supportare alcuni concetti avanzati non a disposizione del C. La prima differenza di peso sta nel paradigma di programmazione utilizzato: laddove il C infatti utilizza esclusivamente il concetto di programmazione imperativa, il C++ permette di sfruttare la potenza della programmazione orientata agli oggetti (in inglese, object oriented programming , OOP ). Conseguenza naturale \u00e8 il focus del programma: laddove in C l'obiettivo \u00e8 modellare il processo alla base del nostro algoritmo, nel C++ \u00e8 necessario focalizzarsi sui dati che viaggiano da un'istruzione all'altra. Altra cosa importante da considerare \u00e8 il supporto ai tipi definiti dall'utente. Anche C lo offriva: abbiamo infatti visto che, grazie alla parola chiave typedef , \u00e8 possibile definire tipi personalizzati anche abbastanza complessi usando adeguatamente struct ed union. Tuttavia, C++ riesce a potenziare gli strumenti in mano al programmatore grazie al concetto di classe . In ultimo, a differenza del C, il C++ \u00e8 in grado di gestire situazioni inattese grazie al meccanismo delle eccezioni , che ci permettono di \"verificare\" il risultato di una serie di istruzioni, gestendo direttamente nel codice sorgente eventuali errori insorti. Differenze legate alla OOP \u00b6 Ed \u00e8 qui che arriviamo al \"succo\" delle differenze tra C e C++, ovvero quelle che nascono dall'adesione di quest'ultimo al paradigma OOP. Vediamole brevemente riassunte nella seguente tabella. Argomento C C++ Namespace Non presente Presente Allocazione dinamica della memoria malloc() e calloc() new() e delete() Rapporto tra variabili e funzioni Separate Incapsulate negli oggetti Modificatori di accesso No S\u00ec La prima importante differenza \u00e8 quella legata all'adozione, da parte del C++, del concetto di namespace , utile ad evitare delle \"collisioni\" di dominio. In parole povere, usare i namespace permette di diminuire drasticamente le ambiguit\u00e0 presenti nel codice. La seconda importante differenza \u00e8 quella legata ai meccanismi di allocazione dinamica della memoria: in C, questi vengono gestiti mediante l'utilizzo di funzioni come malloc() , calloc() e free() , mentre nel C++ ci si concentra sugli operatori di creazione e distruzione degli oggetti. Altre importanti differenze stanno nel rapporto tra variabili e funzioni, che in C++ fanno largo uso del concetto di incapsulamento per evitare l'accesso da parte di codice esterno e, potenzialmente, dannoso, e nell'utilizzo dei modificatori di accesso per regolare la visibilit\u00e0 di un attributo o di una funzione di una classe. In generale, per\u00f2, i concetti maggiormente importanti sono tre, ovvero incapsulamento , polimorfismo ed ereditariet\u00e0 ; li vedremo pi\u00f9 avanti, quando parleremo pi\u00f9 estesamente della programmazione orientata agli oggetti.","title":"01 - C vs. C++"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/01_c_vs_cpp/#differenze-generali","text":"In primis, vediamo riassunte nella seguente tabella alcune differenze fondamentali che intercorrono tra i due linguaggi. Argomento C C++ Keyword 32 52 Paradigma di programmazione Imperativo Imperativo/OOP Focus principale Metodi e processi Dati Tipi definiti dall'utente Supporto limitato con typedef Pieno supporto mediante le classi Gestione delle eccezioni Non presente Presente Nella precedente tabella, vediamo un semplice dato \"numerico\", dato dal maggior numero di keyword a disposizione per il C++; ci\u00f2 indica la presenza di una sintassi comunque pi\u00f9 ricca ed articolata, necessaria a supportare alcuni concetti avanzati non a disposizione del C. La prima differenza di peso sta nel paradigma di programmazione utilizzato: laddove il C infatti utilizza esclusivamente il concetto di programmazione imperativa, il C++ permette di sfruttare la potenza della programmazione orientata agli oggetti (in inglese, object oriented programming , OOP ). Conseguenza naturale \u00e8 il focus del programma: laddove in C l'obiettivo \u00e8 modellare il processo alla base del nostro algoritmo, nel C++ \u00e8 necessario focalizzarsi sui dati che viaggiano da un'istruzione all'altra. Altra cosa importante da considerare \u00e8 il supporto ai tipi definiti dall'utente. Anche C lo offriva: abbiamo infatti visto che, grazie alla parola chiave typedef , \u00e8 possibile definire tipi personalizzati anche abbastanza complessi usando adeguatamente struct ed union. Tuttavia, C++ riesce a potenziare gli strumenti in mano al programmatore grazie al concetto di classe . In ultimo, a differenza del C, il C++ \u00e8 in grado di gestire situazioni inattese grazie al meccanismo delle eccezioni , che ci permettono di \"verificare\" il risultato di una serie di istruzioni, gestendo direttamente nel codice sorgente eventuali errori insorti.","title":"Differenze generali"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/01_c_vs_cpp/#differenze-legate-alla-oop","text":"Ed \u00e8 qui che arriviamo al \"succo\" delle differenze tra C e C++, ovvero quelle che nascono dall'adesione di quest'ultimo al paradigma OOP. Vediamole brevemente riassunte nella seguente tabella. Argomento C C++ Namespace Non presente Presente Allocazione dinamica della memoria malloc() e calloc() new() e delete() Rapporto tra variabili e funzioni Separate Incapsulate negli oggetti Modificatori di accesso No S\u00ec La prima importante differenza \u00e8 quella legata all'adozione, da parte del C++, del concetto di namespace , utile ad evitare delle \"collisioni\" di dominio. In parole povere, usare i namespace permette di diminuire drasticamente le ambiguit\u00e0 presenti nel codice. La seconda importante differenza \u00e8 quella legata ai meccanismi di allocazione dinamica della memoria: in C, questi vengono gestiti mediante l'utilizzo di funzioni come malloc() , calloc() e free() , mentre nel C++ ci si concentra sugli operatori di creazione e distruzione degli oggetti. Altre importanti differenze stanno nel rapporto tra variabili e funzioni, che in C++ fanno largo uso del concetto di incapsulamento per evitare l'accesso da parte di codice esterno e, potenzialmente, dannoso, e nell'utilizzo dei modificatori di accesso per regolare la visibilit\u00e0 di un attributo o di una funzione di una classe. In generale, per\u00f2, i concetti maggiormente importanti sono tre, ovvero incapsulamento , polimorfismo ed ereditariet\u00e0 ; li vedremo pi\u00f9 avanti, quando parleremo pi\u00f9 estesamente della programmazione orientata agli oggetti.","title":"Differenze legate alla OOP"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/","text":"Alcune definizioni \u00b6 Namespace \u00b6 Quando abbiamo parlato delle variabili e delle funzioni in C, abbiamo sottolineato come non fosse possibile associare ad una variabile una determianta parola riservata. Inoltre, dato che il C++ permette (ed anzi favorisce) la definizione di nuovi tipi, potremmo trovarci nella situazione in cui si creano delle ambiguit\u00e0, magari perch\u00e9 si sfruttano librerie di terzi che contengono alcuni tipi i cui nomi sono analoghi a quelli da noi definiti. Per ovviare a queste limitazioni, il C++ introduce il concetto di namespace , inteso come \"domini\" di nomi tra loro indipendenti ed in grado di coesistere, permettendo di conseguenza la definizione ed utilizzo di tipi con lo stesso nome (ma appartenenti a namespace differenti). Immaginiamo ad esempio di voler usare definire un metodo che restituisca le coordinate di un punto, e che queste debbano essere restituite in termini cartesiani e polari. Le strade percorribili potrebbero essere due. La prima prevede l'utilizzo di due funzioni, chiamate ad esempio restituisci_coordinate_cartesiane e restituisci_coordinate_polari : double * restituisci_coordinate_cartesiane ( double x , double y ) { double coordinate [ 2 ] = { x , y }; return coordinate ; } double * restituisci_coordiante_polari ( double r , double theta ) { double coordinate [ 2 ] = { r , theta }; return coordinate ; } Questa soluzione ha uno svantaggio nel lungo periodo: man mano che aggiungiamo delle funzioni che operano su un sistema cartesiano o polare, infatti, il codice diverr\u00e0 sempre pi\u00f9 prolisso, con la conseguenza di essere sempre pi\u00f9 \"prono\" ad eventuali errori. La seconda soluzione sta quindi nell'utilizzo dei namespace: namespace cartesiano { double * restituisci_coordinate ( double x , double y ) { // ... } } namespace polare { double * restituisci_coordinate ( double r , double theta ) { // ... } } Abbiamo quindi definito due \"domini\", all'interno di ciascuno dei quali viene definita una funzione restituisci coordinate che, per\u00f2, non sar\u00e0 ambigua, perch\u00e9 univoca all'interno del suo namespace. Il vantaggio \u00e8 chiaro quando ad esempio andiamo a definire altre funzioni, come ad esempio trova_coeff_retta e trova_coeff_circonferenza : namespace cartesiano { double * restituisci_coordinate ( double x , double y ) { // ... } double * trova_coeff_retta () { // ... } double * trova_coeff_circonferenza () { // ... } } namespace polare { double * restituisci_coordinate ( double r , double theta ) { // ... } double * trova_coeff_retta () { // ... } double * trova_coeff_circonferenza () { // ... } } Se avessimo optato per la soluzione precedente, avremmo dovuto scrivere sempre sei funzioni, ma postponendo (o anteponendo) un indicatore del tipo di coordinate, il che avrebbe peggiorato la leggibilit\u00e0 del nostro codice (ed aumentato la possibilit\u00e0 di fare errori). Utilizzare un namespace \u00b6 Abbiamo due possibilit\u00e0 per utilizzare un namespace. La prima \u00e8 quella di utilizzare la clausola using namespace : // ... using namespace cartesiano ; La seconda \u00e8 quella di anteporre il namespace direttamente al membro che utilizzeremo: // ... cartesiano :: restituisci_coordinate ( 2.0 , 3.0 ); In generale, il consiglio \u00e8, quando possibile, quello di scegliere la prima soluzione. Infatti, se nel nostro programma dovessimo utilizzare (ad esempio) soltanto le coordinate cartesiane, mediante la clausola using namespace ridurremmo di molto la prolissit\u00e0 del nostro codice. Ovviamente, ci sono delle situazioni nelle quali non ci si pu\u00f2 limitare ad usare la suddetta clausola, per cui in quei casi \u00e8 bene ricorrere anche alla seconda soluzione. Il namespace std Il namespace maggiormente usato in C++ \u00e8 chiamato std (che, ovviamente, \u00e8 una crasi di standard). Come buona prassi, specie nei programmi che fanno largo uso delle librerie standard, sarebbe bene importarlo in modo da ottenere un codice meno \"prolisso\". I/O in C++ (da riga di comando) \u00b6 Quando abbiamo parlato del C, abbiamo visto che vi sono alcune funzioni, incluse nella libreria stdio , dedicate espressamente all'interazione con l'utente tramite il concetto di stream . Il C++, nonostante possa agevolmente usare le funzioni printf() o scanf() , offre un'interfaccia evoluta verso gli stream mediante la libreria iostream . Output su riga di comando \u00b6 L'output su riga di comando \u00e8 ottenuto usando delle istanze di una classe base, chiamata ostream , e definita all'interno del namespace std . In particolare, esistono tre tipi di canali di output: std::cout : questo \u00e8 il canale di output predefinito, usato alla stregua della funzione printf() ; a differenza di quest'ultima, per\u00f2, offre funzionalit\u00e0 pi\u00f9 sofisticate, ed \u00e8 in grado di riconoscere in maniera automatica il tipo della variabile passata, convertendolo sullo stream in uscita. E' importante sottolineare come il cout utilizzi un buffer di uscita: ci\u00f2 significa che, specialmente nelle applicazioni ad elevata intensita, ci sar\u00e0 una latenza tra l'immisione di un messaggio sul cout e la sua effettiva visualizzazione; std::cerr : questo \u00e8 un canale usato per trasmettere dei messaggi di errore. Vista la sua particolare funzione (e considerato che un messaggio di errore coincide di solito con il termine del programma), non \u00e8 provvisto di buffer come il cout ; std::clog : questo \u00e8 un canale accessorio, dedicato al logging , e mediante il quale possiamo tenere traccia del comportamento \"interno\" del programma, verificandone le condizioni nel caso ci siano dei bug. La sintassi standard dei diversi operatori \u00e8 la seguente: #include <iostream> using namespace std ; int main () { cout << \"Questo \u00e8 un messaggio in output\" << endl ; cerr << \"Questo \u00e8 un messaggio di errore\" << endl ; clog << \"Questo \u00e8 un messaggio di log\" << endl ; } L'operatore << \u00e8 detto di inserimento , e restituisce in realt\u00e0 un riferimento allo stream. Ci\u00f2 implica che \u00e8 possibile concatenare pi\u00f9 operazioni di output: cout << \"Concateno il numero: \" << 2 << endl ; Nell'istruzione precedente, notiamo l'uso di endl che, come suggerisce il nome, \u00e8 una crasi di end line , ed ha un comportamento equivalente all'escape sequence \\n . Input da riga di comando \u00b6 Anche per quello che riguarda la lettura degli input da riga di comando, C++ utilizza l'istanza cin della classe istream ; in questo caso, viene usato l'operatore di estrazione >> per leggere i dati dal canale di input. int a ; cin >> a ; Gestione dei diversi tipi base Avremo notato che sia ostream sia istream gestiscono in automatico diversi tipi di dati, come ad esempio le stringhe. Questo avviene mediante una tecnica chiamata overloading, che approfondiremo nel seguito. Inserimento di pi\u00f9 input \u00b6 Anche il canale cin gestisce i dati in input mediante un buffer, e riconosce lo spazio come input per separare i diversi elementi; questo permette quindi di concatenare pi\u00f9 estrazioni consecutivamente. Ad esempio: int a ; string s ; cin >> a >> s ; Verifica dei valori inseriti \u00b6 Un modo per verificare la correttezza dei tipi dei valori inseriti \u00e8 quello di usare il metodo good() , che restituisce false nel caso questi non siano stati ben interpretati. Tornando al nostro esempio: int a ; string s ; cin >> a >> s ; // Verifico la correttezza degli input if ( cin . good ()) { cout << \"Ok!\" ; } else { cerr << \"Errore!\" } Inserire stringhe composte da pi\u00f9 parole \u00b6 L'uso dello spazio come separatore di diversi input pu\u00f2 essere problematico nel caso si voglia inserire una stringa composta da pi\u00f9 parole (come il nostro caro vecchio Hello, World! , di cui verrebbe catturato soltanto l' Hello, ). La classe istream prevede quindi anche il metodo getline() , incluso nella libreria string , che abilita la lettura di tutti i dati inseriti nello stream fino alla pressione del tasto Enter. #include <string> string composed ; getline ( cin , composed ); if ( cin . good ()) { cout << \"Hai inserito \" << composed ; } else { cerr << \"Errore!\" ; } Variabili reference \u00b6 La funzione delle variabili reference \u00e8 quella di occupare la stessa area di memoria di una variabile gi\u00e0 esistente. In tal senso, vengono anche chiamate alias . Le variabili reference sono principalmente usate come notazione sostitutiva a quella dei puntatori: infatti, invece di accedere ad una variabile puntata da un puntatore mediante l'operazione di dereferenziazione, si pu\u00f2 direttamente usare una variabile reference per avere un risultato analogo. In altre parole: int a = 2 ; int * pa = & a ; int & ref_a = a ; cout << \"Accesso al valore di a mediante dereferenziazione: \" << * pa << endl ; cout << \"Accesso al valore di a mediante variabile reference: \" << ref_a << endl ; Notiamo che la dichiarazione della variabile reference \u00e8 preceduta dal simbolo & . Perch\u00e9 usare le variabili reference? \u00b6 Pu\u00f2 essere quindi utile preferire l'uso delle variabili reference ai puntatori per due motivi: migliore leggibilit\u00e0 del codice, legata ad una sintassi meno \"prolissa\"; se una variabile reference non viene inizializzata, si ha un errore in fase di compilazione (lo stesso non avviene con i puntatori). Tipo delle variabili reference \u00b6 Abbiamo visto che esiste una differenza tra il tipo associato ad un puntatore e quello della variabile cui punta. Ad esempio, un puntatore a float \u00e8 di tipo float* , mentre la variabile puntata rimane di tipo float . Questo non accade per\u00f2 con le variabili reference, per le quali la forma tipo& non \u00e8 associata ad nuovo tipo di dato: infatti, il tipo di una variabile reference \u00e8 lo stesso usato dalla variabile ordinaria cui \u00e8 associata . Nel nostro esempio, quindi, sia a sia ref_a saranno variabili intere. Come imbrogliare il compilatore Un modo per \"imbrogliare\" il compilatore C++ \u00e8 quello di usare una variabile reference come alias di un puntatore a null, contraddistinto in C++ dalla parola chiave nullptr (e che sostituisce NULL ). Concetti avanzati sulle funzioni \u00b6 Il C++ introduce alcuni concetti avanzati relativamente alle funzioni. Parametri opzionali \u00b6 Le funzioni normalmente utilizzano il concetto di argomento per dare la possibilit\u00e0 alla funzione chiamante (o al programmatore) di impostare tutti i parametri dell'algoritmo. Ad esempio, una funzione che calcola l'ordinata di una retta potrebbe accettare come parametri il coefficiente angolare, l'intercetta e l'ordinata. Alle volte, per\u00f2, \u00e8 possibile stabilire \"a priori\" i valori che meglio si adattano al nostro algoritmo; il C++ introduce quindi la possibilit\u00e0 (ripresa da molti altri linguaggi) di applicare tali valori predefiniti, includendoli nella dichiarazione del prototipo della funzione con una sintassi del tipo: tipo_ritorno nome_funzione ( tipo_argomento nome_argomento_opzionale = valore_default ) Vediamo, ad esempio, una funzione che permette di calcolare il voto medio degli esoneri, considerando un valore di default di quattro per il parametro numero_esoneri . #include <iostream> int calcola_voto_esame ( int * voto_esoneri , int numero_esoneri = 4 ) { int sum = 0 ; for ( int i = 0 ; i < numero_esoneri ; i ++ ) { sum += voto_esoneri [ i ]; } return int ( round ( sum / numero_esoneri )); } int main () { int voti_interi [ 4 ] = { 25 , 24 , 22 , 28 }; int voto_intero = calcola_voto_esame ( voti_interi ); cout << \"Voto approssimato: \" << voto_intero << endl ; } Sar\u00e0 ovviamente possibile variare il valore associato al parametro opzionale mantenendo \"intatto\" il funzionamento della funzione. Overloading \u00b6 L' overloading delle funzioni permette di mantenere lo stesso nome per diverse funzioni, a patto che il compilatore sia in grado di comprendere quale tra queste stia venendo di volta in volta utilizzata specificando diversi parametri di input. Ritornando al nostro esempio precedente, immaginiamo di voler considerare dei valori reali mantenendo una \"interfaccia comune\". Sfruttando l'overloading: #include <iostream> #include <math.h> using namespace std ; int calcola_voto_esame ( int * voto_esoneri , int numero_esoneri = 4 ) { int sum = 0 ; for ( int i = 0 ; i < numero_esoneri ; i ++ ) { sum += voto_esoneri [ i ]; } return int ( round ( sum / numero_esoneri )); } double calcola_voto_esame ( double * voto_esoneri , int numero_esoneri = 4 ) { double sum = 0 ; for ( int i = 0 ; i < numero_esoneri ; i ++ ) { sum += voto_esoneri [ i ]; } return ( sum / numero_esoneri ); } int main () { int voti_interi [ 4 ] = { 25 , 24 , 22 , 28 }; double voti_reali [ 4 ] = { 25.3 , 24.1 , 21.9 , 28.1 }; int voto_intero = calcola_voto_esame ( voti_interi ); double voto_reale = calcola_voto_esame ( voti_reali ); cout << \"Voto approssimato: \" << voto_intero << endl ; cout << \"Voto reale: \" << voto_reale << endl ; } E' importante sottolineare come il tipo restituito dalla funzione non influisca nella selezione della funzione in overload. Usare l'overload pu\u00f2 essere utile, e quando parleremo delle classi talvolta indispensabile, ma comporta anche dei rischi: \u00e8 necessario infatti evitare ambiguit\u00e0 nei parametri forniti, o sfruttare i meccanismi di cast per assicurarsi di stare chiamando la giusta funzione in overload. Ecco infatti un caso particolare: void promosso_o_bocciato ( bool esito ) { if ( esito ) { cout << \"Sei stato bocciato!\" << endl ; } } void promosso_o_bocciato ( string esito ) { cout << esito ; } int main () { promosso_o_bocciato ( \"Sei stato promosso!\" ); } Chiamare la funzione con un argomento di tipo stringa, infatti, si traduce in una chiamata all'overloading con il tipo booleano in ingresso! Questo avviene principalmente perch\u00e9 il compilatore applica i meccanismi di inferenza di tipo previsti dallo standard C++, e fa s\u00ec che ci sia prima una conversione ad un puntatore a tipo char , il quale viene poi convertito in booleano! Il motivo di questa scelta \u00e8, ovviamente, per motivi di retrocompatibilit\u00e0 con il C, ma ci deve comunque essere di lezione per evitare di usare l'overloading in maniera eccessivamente \"avventata\".","title":"02 - Alcune definizioni (in C++!)"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#alcune-definizioni","text":"","title":"Alcune definizioni"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#namespace","text":"Quando abbiamo parlato delle variabili e delle funzioni in C, abbiamo sottolineato come non fosse possibile associare ad una variabile una determianta parola riservata. Inoltre, dato che il C++ permette (ed anzi favorisce) la definizione di nuovi tipi, potremmo trovarci nella situazione in cui si creano delle ambiguit\u00e0, magari perch\u00e9 si sfruttano librerie di terzi che contengono alcuni tipi i cui nomi sono analoghi a quelli da noi definiti. Per ovviare a queste limitazioni, il C++ introduce il concetto di namespace , inteso come \"domini\" di nomi tra loro indipendenti ed in grado di coesistere, permettendo di conseguenza la definizione ed utilizzo di tipi con lo stesso nome (ma appartenenti a namespace differenti). Immaginiamo ad esempio di voler usare definire un metodo che restituisca le coordinate di un punto, e che queste debbano essere restituite in termini cartesiani e polari. Le strade percorribili potrebbero essere due. La prima prevede l'utilizzo di due funzioni, chiamate ad esempio restituisci_coordinate_cartesiane e restituisci_coordinate_polari : double * restituisci_coordinate_cartesiane ( double x , double y ) { double coordinate [ 2 ] = { x , y }; return coordinate ; } double * restituisci_coordiante_polari ( double r , double theta ) { double coordinate [ 2 ] = { r , theta }; return coordinate ; } Questa soluzione ha uno svantaggio nel lungo periodo: man mano che aggiungiamo delle funzioni che operano su un sistema cartesiano o polare, infatti, il codice diverr\u00e0 sempre pi\u00f9 prolisso, con la conseguenza di essere sempre pi\u00f9 \"prono\" ad eventuali errori. La seconda soluzione sta quindi nell'utilizzo dei namespace: namespace cartesiano { double * restituisci_coordinate ( double x , double y ) { // ... } } namespace polare { double * restituisci_coordinate ( double r , double theta ) { // ... } } Abbiamo quindi definito due \"domini\", all'interno di ciascuno dei quali viene definita una funzione restituisci coordinate che, per\u00f2, non sar\u00e0 ambigua, perch\u00e9 univoca all'interno del suo namespace. Il vantaggio \u00e8 chiaro quando ad esempio andiamo a definire altre funzioni, come ad esempio trova_coeff_retta e trova_coeff_circonferenza : namespace cartesiano { double * restituisci_coordinate ( double x , double y ) { // ... } double * trova_coeff_retta () { // ... } double * trova_coeff_circonferenza () { // ... } } namespace polare { double * restituisci_coordinate ( double r , double theta ) { // ... } double * trova_coeff_retta () { // ... } double * trova_coeff_circonferenza () { // ... } } Se avessimo optato per la soluzione precedente, avremmo dovuto scrivere sempre sei funzioni, ma postponendo (o anteponendo) un indicatore del tipo di coordinate, il che avrebbe peggiorato la leggibilit\u00e0 del nostro codice (ed aumentato la possibilit\u00e0 di fare errori).","title":"Namespace"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#utilizzare-un-namespace","text":"Abbiamo due possibilit\u00e0 per utilizzare un namespace. La prima \u00e8 quella di utilizzare la clausola using namespace : // ... using namespace cartesiano ; La seconda \u00e8 quella di anteporre il namespace direttamente al membro che utilizzeremo: // ... cartesiano :: restituisci_coordinate ( 2.0 , 3.0 ); In generale, il consiglio \u00e8, quando possibile, quello di scegliere la prima soluzione. Infatti, se nel nostro programma dovessimo utilizzare (ad esempio) soltanto le coordinate cartesiane, mediante la clausola using namespace ridurremmo di molto la prolissit\u00e0 del nostro codice. Ovviamente, ci sono delle situazioni nelle quali non ci si pu\u00f2 limitare ad usare la suddetta clausola, per cui in quei casi \u00e8 bene ricorrere anche alla seconda soluzione. Il namespace std Il namespace maggiormente usato in C++ \u00e8 chiamato std (che, ovviamente, \u00e8 una crasi di standard). Come buona prassi, specie nei programmi che fanno largo uso delle librerie standard, sarebbe bene importarlo in modo da ottenere un codice meno \"prolisso\".","title":"Utilizzare un namespace"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#io-in-c-da-riga-di-comando","text":"Quando abbiamo parlato del C, abbiamo visto che vi sono alcune funzioni, incluse nella libreria stdio , dedicate espressamente all'interazione con l'utente tramite il concetto di stream . Il C++, nonostante possa agevolmente usare le funzioni printf() o scanf() , offre un'interfaccia evoluta verso gli stream mediante la libreria iostream .","title":"I/O in C++ (da riga di comando)"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#output-su-riga-di-comando","text":"L'output su riga di comando \u00e8 ottenuto usando delle istanze di una classe base, chiamata ostream , e definita all'interno del namespace std . In particolare, esistono tre tipi di canali di output: std::cout : questo \u00e8 il canale di output predefinito, usato alla stregua della funzione printf() ; a differenza di quest'ultima, per\u00f2, offre funzionalit\u00e0 pi\u00f9 sofisticate, ed \u00e8 in grado di riconoscere in maniera automatica il tipo della variabile passata, convertendolo sullo stream in uscita. E' importante sottolineare come il cout utilizzi un buffer di uscita: ci\u00f2 significa che, specialmente nelle applicazioni ad elevata intensita, ci sar\u00e0 una latenza tra l'immisione di un messaggio sul cout e la sua effettiva visualizzazione; std::cerr : questo \u00e8 un canale usato per trasmettere dei messaggi di errore. Vista la sua particolare funzione (e considerato che un messaggio di errore coincide di solito con il termine del programma), non \u00e8 provvisto di buffer come il cout ; std::clog : questo \u00e8 un canale accessorio, dedicato al logging , e mediante il quale possiamo tenere traccia del comportamento \"interno\" del programma, verificandone le condizioni nel caso ci siano dei bug. La sintassi standard dei diversi operatori \u00e8 la seguente: #include <iostream> using namespace std ; int main () { cout << \"Questo \u00e8 un messaggio in output\" << endl ; cerr << \"Questo \u00e8 un messaggio di errore\" << endl ; clog << \"Questo \u00e8 un messaggio di log\" << endl ; } L'operatore << \u00e8 detto di inserimento , e restituisce in realt\u00e0 un riferimento allo stream. Ci\u00f2 implica che \u00e8 possibile concatenare pi\u00f9 operazioni di output: cout << \"Concateno il numero: \" << 2 << endl ; Nell'istruzione precedente, notiamo l'uso di endl che, come suggerisce il nome, \u00e8 una crasi di end line , ed ha un comportamento equivalente all'escape sequence \\n .","title":"Output su riga di comando"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#input-da-riga-di-comando","text":"Anche per quello che riguarda la lettura degli input da riga di comando, C++ utilizza l'istanza cin della classe istream ; in questo caso, viene usato l'operatore di estrazione >> per leggere i dati dal canale di input. int a ; cin >> a ; Gestione dei diversi tipi base Avremo notato che sia ostream sia istream gestiscono in automatico diversi tipi di dati, come ad esempio le stringhe. Questo avviene mediante una tecnica chiamata overloading, che approfondiremo nel seguito.","title":"Input da riga di comando"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#inserimento-di-piu-input","text":"Anche il canale cin gestisce i dati in input mediante un buffer, e riconosce lo spazio come input per separare i diversi elementi; questo permette quindi di concatenare pi\u00f9 estrazioni consecutivamente. Ad esempio: int a ; string s ; cin >> a >> s ;","title":"Inserimento di pi\u00f9 input"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#verifica-dei-valori-inseriti","text":"Un modo per verificare la correttezza dei tipi dei valori inseriti \u00e8 quello di usare il metodo good() , che restituisce false nel caso questi non siano stati ben interpretati. Tornando al nostro esempio: int a ; string s ; cin >> a >> s ; // Verifico la correttezza degli input if ( cin . good ()) { cout << \"Ok!\" ; } else { cerr << \"Errore!\" }","title":"Verifica dei valori inseriti"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#inserire-stringhe-composte-da-piu-parole","text":"L'uso dello spazio come separatore di diversi input pu\u00f2 essere problematico nel caso si voglia inserire una stringa composta da pi\u00f9 parole (come il nostro caro vecchio Hello, World! , di cui verrebbe catturato soltanto l' Hello, ). La classe istream prevede quindi anche il metodo getline() , incluso nella libreria string , che abilita la lettura di tutti i dati inseriti nello stream fino alla pressione del tasto Enter. #include <string> string composed ; getline ( cin , composed ); if ( cin . good ()) { cout << \"Hai inserito \" << composed ; } else { cerr << \"Errore!\" ; }","title":"Inserire stringhe composte da pi\u00f9 parole"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#variabili-reference","text":"La funzione delle variabili reference \u00e8 quella di occupare la stessa area di memoria di una variabile gi\u00e0 esistente. In tal senso, vengono anche chiamate alias . Le variabili reference sono principalmente usate come notazione sostitutiva a quella dei puntatori: infatti, invece di accedere ad una variabile puntata da un puntatore mediante l'operazione di dereferenziazione, si pu\u00f2 direttamente usare una variabile reference per avere un risultato analogo. In altre parole: int a = 2 ; int * pa = & a ; int & ref_a = a ; cout << \"Accesso al valore di a mediante dereferenziazione: \" << * pa << endl ; cout << \"Accesso al valore di a mediante variabile reference: \" << ref_a << endl ; Notiamo che la dichiarazione della variabile reference \u00e8 preceduta dal simbolo & .","title":"Variabili reference"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#perche-usare-le-variabili-reference","text":"Pu\u00f2 essere quindi utile preferire l'uso delle variabili reference ai puntatori per due motivi: migliore leggibilit\u00e0 del codice, legata ad una sintassi meno \"prolissa\"; se una variabile reference non viene inizializzata, si ha un errore in fase di compilazione (lo stesso non avviene con i puntatori).","title":"Perch\u00e9 usare le variabili reference?"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#tipo-delle-variabili-reference","text":"Abbiamo visto che esiste una differenza tra il tipo associato ad un puntatore e quello della variabile cui punta. Ad esempio, un puntatore a float \u00e8 di tipo float* , mentre la variabile puntata rimane di tipo float . Questo non accade per\u00f2 con le variabili reference, per le quali la forma tipo& non \u00e8 associata ad nuovo tipo di dato: infatti, il tipo di una variabile reference \u00e8 lo stesso usato dalla variabile ordinaria cui \u00e8 associata . Nel nostro esempio, quindi, sia a sia ref_a saranno variabili intere. Come imbrogliare il compilatore Un modo per \"imbrogliare\" il compilatore C++ \u00e8 quello di usare una variabile reference come alias di un puntatore a null, contraddistinto in C++ dalla parola chiave nullptr (e che sostituisce NULL ).","title":"Tipo delle variabili reference"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#concetti-avanzati-sulle-funzioni","text":"Il C++ introduce alcuni concetti avanzati relativamente alle funzioni.","title":"Concetti avanzati sulle funzioni"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#parametri-opzionali","text":"Le funzioni normalmente utilizzano il concetto di argomento per dare la possibilit\u00e0 alla funzione chiamante (o al programmatore) di impostare tutti i parametri dell'algoritmo. Ad esempio, una funzione che calcola l'ordinata di una retta potrebbe accettare come parametri il coefficiente angolare, l'intercetta e l'ordinata. Alle volte, per\u00f2, \u00e8 possibile stabilire \"a priori\" i valori che meglio si adattano al nostro algoritmo; il C++ introduce quindi la possibilit\u00e0 (ripresa da molti altri linguaggi) di applicare tali valori predefiniti, includendoli nella dichiarazione del prototipo della funzione con una sintassi del tipo: tipo_ritorno nome_funzione ( tipo_argomento nome_argomento_opzionale = valore_default ) Vediamo, ad esempio, una funzione che permette di calcolare il voto medio degli esoneri, considerando un valore di default di quattro per il parametro numero_esoneri . #include <iostream> int calcola_voto_esame ( int * voto_esoneri , int numero_esoneri = 4 ) { int sum = 0 ; for ( int i = 0 ; i < numero_esoneri ; i ++ ) { sum += voto_esoneri [ i ]; } return int ( round ( sum / numero_esoneri )); } int main () { int voti_interi [ 4 ] = { 25 , 24 , 22 , 28 }; int voto_intero = calcola_voto_esame ( voti_interi ); cout << \"Voto approssimato: \" << voto_intero << endl ; } Sar\u00e0 ovviamente possibile variare il valore associato al parametro opzionale mantenendo \"intatto\" il funzionamento della funzione.","title":"Parametri opzionali"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/02_definizioni/#overloading","text":"L' overloading delle funzioni permette di mantenere lo stesso nome per diverse funzioni, a patto che il compilatore sia in grado di comprendere quale tra queste stia venendo di volta in volta utilizzata specificando diversi parametri di input. Ritornando al nostro esempio precedente, immaginiamo di voler considerare dei valori reali mantenendo una \"interfaccia comune\". Sfruttando l'overloading: #include <iostream> #include <math.h> using namespace std ; int calcola_voto_esame ( int * voto_esoneri , int numero_esoneri = 4 ) { int sum = 0 ; for ( int i = 0 ; i < numero_esoneri ; i ++ ) { sum += voto_esoneri [ i ]; } return int ( round ( sum / numero_esoneri )); } double calcola_voto_esame ( double * voto_esoneri , int numero_esoneri = 4 ) { double sum = 0 ; for ( int i = 0 ; i < numero_esoneri ; i ++ ) { sum += voto_esoneri [ i ]; } return ( sum / numero_esoneri ); } int main () { int voti_interi [ 4 ] = { 25 , 24 , 22 , 28 }; double voti_reali [ 4 ] = { 25.3 , 24.1 , 21.9 , 28.1 }; int voto_intero = calcola_voto_esame ( voti_interi ); double voto_reale = calcola_voto_esame ( voti_reali ); cout << \"Voto approssimato: \" << voto_intero << endl ; cout << \"Voto reale: \" << voto_reale << endl ; } E' importante sottolineare come il tipo restituito dalla funzione non influisca nella selezione della funzione in overload. Usare l'overload pu\u00f2 essere utile, e quando parleremo delle classi talvolta indispensabile, ma comporta anche dei rischi: \u00e8 necessario infatti evitare ambiguit\u00e0 nei parametri forniti, o sfruttare i meccanismi di cast per assicurarsi di stare chiamando la giusta funzione in overload. Ecco infatti un caso particolare: void promosso_o_bocciato ( bool esito ) { if ( esito ) { cout << \"Sei stato bocciato!\" << endl ; } } void promosso_o_bocciato ( string esito ) { cout << esito ; } int main () { promosso_o_bocciato ( \"Sei stato promosso!\" ); } Chiamare la funzione con un argomento di tipo stringa, infatti, si traduce in una chiamata all'overloading con il tipo booleano in ingresso! Questo avviene principalmente perch\u00e9 il compilatore applica i meccanismi di inferenza di tipo previsti dallo standard C++, e fa s\u00ec che ci sia prima una conversione ad un puntatore a tipo char , il quale viene poi convertito in booleano! Il motivo di questa scelta \u00e8, ovviamente, per motivi di retrocompatibilit\u00e0 con il C, ma ci deve comunque essere di lezione per evitare di usare l'overloading in maniera eccessivamente \"avventata\".","title":"Overloading"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/","text":"Le Classi \u00b6 Il concetto di classe permette di espandere in maniera potenzialmente infinita l'insieme dei tipi a disposizione dello sviluppatore, dando la possibilit\u00e0 di comporre nuovi oggetti . Ogni oggetto avr\u00e0 al suo interno attributi (che a loro volta possono essere altri oggetti) e metodi da invocare su questi oggetti; a loro volta, attributi e metodi saranno dotati di un livello di accesso , che limiter\u00e0 l'accesso agli stessi da parte del mondo \"esterno\" (ovvero, altre classi e programmi). In tal senso, le classi sfruttano una tecnica chiamata incapsulamento , definendo una interfaccia verso il mondo esterno per manipolare i dati della classe mascherando le dinamiche di funzionamento interno. Questa tecnica \u00e8 anche chiamata information hiding . La sintassi per la definizione di una classe \u00e8 la seguente: class NomeClasse { public : // attributi o metodi accessibili all'esterno della classe private : // attributi o metodi accessibili solo dall'interno della classe protected : // attributi o metodi accessibili solo dalle classi \"figlie } Le tre sezioni di cui sopra servono a definire il livello di accesso (e, quindi, la visibilit\u00e0 ) di ciascun membro o attributo. Di default, membri ed attributi sono considerati privati. Definire ed implementare una classe \u00b6 Il concetto di information hiding si ripercuote sul modo di definire una classe. Normalmente, infatti, viene usato un file header per definire l'interfaccia della classe, ed un normale file con estensione .cpp per implementare effettivamente i metodi contenuti. Vediamo quindi un esempio pratico. Definizione della classe \u00b6 Creiamo un header chiamato persona.h con il seguente codice: // File persona.h #ifndef PERSONA_H #define PERSONA_H #include <string> using namespace std ; namespace Persona { class PersonaBase ; } class Persona :: PersonaBase { private : string nome ; string cognome ; int eta ; public : string getNome (); string getCognome (); int getEta (); void setNome ( string nuovoNome ); void setCognome ( string nuovoCognome ); void setEta ( int nuovaEta ); }; #endif // !PERSONA_H Notiamo subito tre cose: sfruttiamo il concetto di include guards , ovvero delle direttive da specificare al preprocessore per impedire che l'header sia incluso pi\u00f9 di una volta durante la compilazione; allo scopo di evitare collisioni, definiamo un namespace che contiene le definizioni delle classi che useremo (in questo caso, lo chiameremo Persona ); includiamo l'header <string> ed usiamo il namespace std onde includere il tipo string ed evitare un'eccessiva ripetitivit\u00e0 del codice. La classe PersonaBase (il motivo della scelta di questo nome sar\u00e0 chiaro pi\u00f9 avanti) conterr\u00e0 tre attributi, due di tipo string (ovvero nome e cognome ), ed uno di tipo intero (ovvero eta ). Notiamo come gli attributi siano dichiarati come privati, ed a ciascuno di essi sia associato un metodo pubblico per garantirne l'accesso rispettivamente in lettura (i metodi che iniziano con il suffisso get , detti anche getter o, in una tradizione \"passabile\", accessori ) ed in scrittura (i metodi che iniziano con il suffisso set , detti anche setter o modificatori ). Notiamo infine che l'intera definizione di classe \u00e8 seguita dal simbolo ; a causa di ragioni di retrocompatibilit\u00e0 con le struct mutuate dal linguaggio C. Implementazione della classe \u00b6 Creiamo ora un sorgente persona.cpp contenente il seguente codice: // File persona.cpp #include \"persona.h\" #include <iostream> using namespace std ; using namespace Persona ; string PersonaBase :: getNome () { return nome ; } string PersonaBase :: getCognome () { return cognome ; } int PersonaBase :: getEta () { return eta ; } void PersonaBase :: setNome ( string nuovoNome ) { if ( nuovoNome . length () > 2 ) { nome = nuovoNome ; } } void PersonaBase :: setCognome ( string nuovoCognome ) { if ( nuovoCognome . length () > 2 ) { cognome = nuovoCognome ; } } void PersonaBase :: setEta ( int nuovaEta ) { if ( nuovaEta >= 0 ) { eta = nuovaEta ; } } Notiamo innanzitutto l'inclusione dell'header persona.h , che va ovviamente incluso assieme a tutti gli altri necessari. Inoltre, usiamo il namespace std ed il namespace Persona per accedere in maniera non eccessivamente prolissa ai metodi di PersonaBase . Nota Avremmo potuto usare la clausola using Persona::PersonaBase per ridurre ulteriormente il codice utilizzato. Tuttavia, dato che in seguito aggiungeremo altre classi al nostro namespace, \u00e8 meglio usare la clausola using nel modo descritto in precedenza. Il motivo per cui gli attributi sono dichiarati privati ed i metodi getter e setter pubblici \u00e8 spiegato dall'implementazione. Notiamo infatti che i diversi metodi modificatori compiono delle verifiche sugli argomenti passati in ingresso; se accedessimo direttamente agli attributi, dovremmo implementare il codice necessario a questi controlli ogni volta. Inoltre, mantenere un'interfaccia comune permette di modificare l'implementazione dei propri metodi senza dover per questo alterare il programma chiamante. Esempio di utilizzo \u00b6 Proviamo ad utilizzare la nostra classe per creare una nuova istanza di PersonaBase all'interno del metodo main() : #include \"persona.h\" #include <iostream> using namespace Persona ; using namespace std ; int main () { PersonaBase truce ; truce . setNome ( \"Truce\" ); truce . setCognome ( \"Baldazzi\" ); truce . setEta ( 18 ); cout << \"Nome: \" << truce . getNome () << \" \\t Cognome: \" << truce . getCognome () << \" \\t Eta': \" << truce . getEta () << endl ; return 0 ; } Classi e struct Nel C++, le struct sono considerate equivalenti alle classi, dato che vengono tradotte in fase di compilazione in classi con soli membri public . L'unico motivo per utilizzarle risiede nella retrocompatibilit\u00e0 con codice scritto in linguaggio C. Utilizzare le istanze di una classe \u00b6 Costruttori \u00b6 Nell'esempio precedente, abbiamo visto come dichiarare un nuovo oggetto, ma non come inizializzarlo ed utilizzarlo . Per farlo, ci sono due operazioni preliminari da svolgere: allocare la memoria per attributi e metodi dell'oggetto; inizializzare ogni attributo. Queste operazioni sono svolte da una particolare funzione chiamata costruttore , il cui prototipo presenta due caratteristiche uniche: il nome del costruttore coincide con quello della classe ; un costruttore non ha alcun tipo o valore di ritorno. Per il resto, il costruttore \u00e8 una normalissima funzione, che pu\u00f2 accettare pi\u00f9 argomenti, anche opzionali. In particolare, un costruttore che non accetta argomenti (o che accetta soltanto argomenti opzionali) \u00e8 detto costruttore di default . Normalmente, il compilatore genera in automatico un costruttore di default, dato che in grado di dedurre autonomamente la quantit\u00e0 di spazio da riservare per un oggetto a compile time, definendo contestualmente un valore di default per ogni membro. Questa operazione ha tuttavia dei limiti, ed \u00e8 comunque preferibile definire manualmente un costruttore di default, specialmente nei casi \"limite\" in cui si ha a che fare con attributi sotto forma di puntatori. Modifichiamo quindi la nostra classe andando ad inserire due costruttori, uno di default ed uno che accetta tre parametri. // File persona.h #ifndef PERSONA_H #define PERSONA_H #include <string> using namespace std ; namespace Persona { class PersonaBase ; } class Persona :: PersonaBase { private : string nome ; string cognome ; int eta ; public : PersonaBase (); PersonaBase ( string nuovoNome , string nuovoCognome , int nuovaEta ); string getNome (); string getCognome (); int getEta (); void setNome ( string nuovoNome ); void setCognome ( string nuovoCognome ); void setEta ( int nuovaEta ); }; #endif // !PERSONA_H // File persona.cpp #include \"persona.h\" #include <iostream> using namespace std ; using namespace Persona ; PersonaBase :: PersonaBase () { setNome ( \"Non definito\" ); setCognome ( \"Non definito\" ); setEta ( 0 ); } PersonaBase :: PersonaBase ( string nuovoNome , string nuovoCognome , int nuovaEta ) { setNome ( nuovoNome ); setCognome ( nuovoCognome ); setEta ( nuovaEta ); } string PersonaBase :: getNome () { return nome ; } string PersonaBase :: getCognome () { return cognome ; } int PersonaBase :: getEta () { return eta ; } void PersonaBase :: setNome ( string nuovoNome ) { if ( nuovoNome . length () > 2 ) { nome = nuovoNome ; } } void PersonaBase :: setCognome ( string nuovoCognome ) { if ( nuovoCognome . length () > 2 ) { cognome = nuovoCognome ; } } void PersonaBase :: setEta ( int nuovaEta ) { if ( nuovaEta >= 0 ) { eta = nuovaEta ; } } Nota E' interessante sottolineare come all'interno del costruttore parametrizzato si usino i setter per modificare i valori degli attributi. Questa operazione \u00e8 consigliata per gli stessi motivi sottolineati in precedenza relativamente all'accesso degli attributi da variabili e metodi esterni alla classe. Distruttori \u00b6 Una volta terminato l'utilizzo di un oggetto, \u00e8 necessario rilasciare le risorse da questo utilizzate in memoria. Per far questo, si utilizza un opportuno metodo chiamato distruttore , che viene automaticamente invocato su ogni variabile una volta raggiunto il termine del suo ambito di visibilit\u00e0 (oppure mediante l'invocazione della parola chiave delete ). La firma di un distruttore ha anch'essa alcune particolarit\u00e0: infatti, il nome coincide s\u00ec con quello della classe invocante, ma \u00e8 preceduto dal carattere ~ (la tilde, ottenibile mediante il codice ASCII 0126). Come il costruttore, inoltre, il distruttore non ha alcun tipo o valore di ritorno, ed a differenza del costruttore non accetta alcun parametro in ingresso. Per il resto, il distruttore \u00e8 una funzione come le altre, il cui unico compito per\u00f2 rimane quello di rimuovere dalla memoria un oggetto e tutte le sue dipendenze . Molto spesso non \u00e8 necessario definire in maniera esplicita il distruttore, in quanto questo viene generato automaticamente. Tuttavia, qualora l'oggetto utilizzato includa delle reference (variabili alias o puntatori) o faccia uso di risorse esterne (ad esempio file), potrebbe essere necessario definirlo per svolgere le operazioni adegaute a \"concludere\" adeguatamente le operazioni. Nel nostro caso, ad esempio, non \u00e8 necessario specificare un distruttore. Immaginiamo per\u00f2 di associare alla nostra classe un riferimento ad un puntatore; dovremo quindi definire un adeguato distruttore: // persona.h // ... class Persona :: PersonaBase { private : // ... int * puntatoreEta ; // .. public : // ... ~ PersonaBase (); // ... } Il distruttore dovr\u00e0 poi essere implementato all'interno del file persona.cpp : // persona.cpp PersonaBase :: PersonaBase () { // ... puntatoreEta = & eta ; // ... } PersonaBase ::~ PersonaBase () { delete puntatoreEta ; } E' importante sottolineare il ruolo fondamentale giocato dal distruttore in queste situazioni. Trascurandolo, infatti, avremmo un memory leak (come in questo caso), oppure potremmo rendere inaccessibile uno stream (come ad esempio un file binario di logging).","title":"03 - Le classi (parte uno)"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#le-classi","text":"Il concetto di classe permette di espandere in maniera potenzialmente infinita l'insieme dei tipi a disposizione dello sviluppatore, dando la possibilit\u00e0 di comporre nuovi oggetti . Ogni oggetto avr\u00e0 al suo interno attributi (che a loro volta possono essere altri oggetti) e metodi da invocare su questi oggetti; a loro volta, attributi e metodi saranno dotati di un livello di accesso , che limiter\u00e0 l'accesso agli stessi da parte del mondo \"esterno\" (ovvero, altre classi e programmi). In tal senso, le classi sfruttano una tecnica chiamata incapsulamento , definendo una interfaccia verso il mondo esterno per manipolare i dati della classe mascherando le dinamiche di funzionamento interno. Questa tecnica \u00e8 anche chiamata information hiding . La sintassi per la definizione di una classe \u00e8 la seguente: class NomeClasse { public : // attributi o metodi accessibili all'esterno della classe private : // attributi o metodi accessibili solo dall'interno della classe protected : // attributi o metodi accessibili solo dalle classi \"figlie } Le tre sezioni di cui sopra servono a definire il livello di accesso (e, quindi, la visibilit\u00e0 ) di ciascun membro o attributo. Di default, membri ed attributi sono considerati privati.","title":"Le Classi"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#definire-ed-implementare-una-classe","text":"Il concetto di information hiding si ripercuote sul modo di definire una classe. Normalmente, infatti, viene usato un file header per definire l'interfaccia della classe, ed un normale file con estensione .cpp per implementare effettivamente i metodi contenuti. Vediamo quindi un esempio pratico.","title":"Definire ed implementare una classe"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#definizione-della-classe","text":"Creiamo un header chiamato persona.h con il seguente codice: // File persona.h #ifndef PERSONA_H #define PERSONA_H #include <string> using namespace std ; namespace Persona { class PersonaBase ; } class Persona :: PersonaBase { private : string nome ; string cognome ; int eta ; public : string getNome (); string getCognome (); int getEta (); void setNome ( string nuovoNome ); void setCognome ( string nuovoCognome ); void setEta ( int nuovaEta ); }; #endif // !PERSONA_H Notiamo subito tre cose: sfruttiamo il concetto di include guards , ovvero delle direttive da specificare al preprocessore per impedire che l'header sia incluso pi\u00f9 di una volta durante la compilazione; allo scopo di evitare collisioni, definiamo un namespace che contiene le definizioni delle classi che useremo (in questo caso, lo chiameremo Persona ); includiamo l'header <string> ed usiamo il namespace std onde includere il tipo string ed evitare un'eccessiva ripetitivit\u00e0 del codice. La classe PersonaBase (il motivo della scelta di questo nome sar\u00e0 chiaro pi\u00f9 avanti) conterr\u00e0 tre attributi, due di tipo string (ovvero nome e cognome ), ed uno di tipo intero (ovvero eta ). Notiamo come gli attributi siano dichiarati come privati, ed a ciascuno di essi sia associato un metodo pubblico per garantirne l'accesso rispettivamente in lettura (i metodi che iniziano con il suffisso get , detti anche getter o, in una tradizione \"passabile\", accessori ) ed in scrittura (i metodi che iniziano con il suffisso set , detti anche setter o modificatori ). Notiamo infine che l'intera definizione di classe \u00e8 seguita dal simbolo ; a causa di ragioni di retrocompatibilit\u00e0 con le struct mutuate dal linguaggio C.","title":"Definizione della classe"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#implementazione-della-classe","text":"Creiamo ora un sorgente persona.cpp contenente il seguente codice: // File persona.cpp #include \"persona.h\" #include <iostream> using namespace std ; using namespace Persona ; string PersonaBase :: getNome () { return nome ; } string PersonaBase :: getCognome () { return cognome ; } int PersonaBase :: getEta () { return eta ; } void PersonaBase :: setNome ( string nuovoNome ) { if ( nuovoNome . length () > 2 ) { nome = nuovoNome ; } } void PersonaBase :: setCognome ( string nuovoCognome ) { if ( nuovoCognome . length () > 2 ) { cognome = nuovoCognome ; } } void PersonaBase :: setEta ( int nuovaEta ) { if ( nuovaEta >= 0 ) { eta = nuovaEta ; } } Notiamo innanzitutto l'inclusione dell'header persona.h , che va ovviamente incluso assieme a tutti gli altri necessari. Inoltre, usiamo il namespace std ed il namespace Persona per accedere in maniera non eccessivamente prolissa ai metodi di PersonaBase . Nota Avremmo potuto usare la clausola using Persona::PersonaBase per ridurre ulteriormente il codice utilizzato. Tuttavia, dato che in seguito aggiungeremo altre classi al nostro namespace, \u00e8 meglio usare la clausola using nel modo descritto in precedenza. Il motivo per cui gli attributi sono dichiarati privati ed i metodi getter e setter pubblici \u00e8 spiegato dall'implementazione. Notiamo infatti che i diversi metodi modificatori compiono delle verifiche sugli argomenti passati in ingresso; se accedessimo direttamente agli attributi, dovremmo implementare il codice necessario a questi controlli ogni volta. Inoltre, mantenere un'interfaccia comune permette di modificare l'implementazione dei propri metodi senza dover per questo alterare il programma chiamante.","title":"Implementazione della classe"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#esempio-di-utilizzo","text":"Proviamo ad utilizzare la nostra classe per creare una nuova istanza di PersonaBase all'interno del metodo main() : #include \"persona.h\" #include <iostream> using namespace Persona ; using namespace std ; int main () { PersonaBase truce ; truce . setNome ( \"Truce\" ); truce . setCognome ( \"Baldazzi\" ); truce . setEta ( 18 ); cout << \"Nome: \" << truce . getNome () << \" \\t Cognome: \" << truce . getCognome () << \" \\t Eta': \" << truce . getEta () << endl ; return 0 ; } Classi e struct Nel C++, le struct sono considerate equivalenti alle classi, dato che vengono tradotte in fase di compilazione in classi con soli membri public . L'unico motivo per utilizzarle risiede nella retrocompatibilit\u00e0 con codice scritto in linguaggio C.","title":"Esempio di utilizzo"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#utilizzare-le-istanze-di-una-classe","text":"","title":"Utilizzare le istanze di una classe"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#costruttori","text":"Nell'esempio precedente, abbiamo visto come dichiarare un nuovo oggetto, ma non come inizializzarlo ed utilizzarlo . Per farlo, ci sono due operazioni preliminari da svolgere: allocare la memoria per attributi e metodi dell'oggetto; inizializzare ogni attributo. Queste operazioni sono svolte da una particolare funzione chiamata costruttore , il cui prototipo presenta due caratteristiche uniche: il nome del costruttore coincide con quello della classe ; un costruttore non ha alcun tipo o valore di ritorno. Per il resto, il costruttore \u00e8 una normalissima funzione, che pu\u00f2 accettare pi\u00f9 argomenti, anche opzionali. In particolare, un costruttore che non accetta argomenti (o che accetta soltanto argomenti opzionali) \u00e8 detto costruttore di default . Normalmente, il compilatore genera in automatico un costruttore di default, dato che in grado di dedurre autonomamente la quantit\u00e0 di spazio da riservare per un oggetto a compile time, definendo contestualmente un valore di default per ogni membro. Questa operazione ha tuttavia dei limiti, ed \u00e8 comunque preferibile definire manualmente un costruttore di default, specialmente nei casi \"limite\" in cui si ha a che fare con attributi sotto forma di puntatori. Modifichiamo quindi la nostra classe andando ad inserire due costruttori, uno di default ed uno che accetta tre parametri. // File persona.h #ifndef PERSONA_H #define PERSONA_H #include <string> using namespace std ; namespace Persona { class PersonaBase ; } class Persona :: PersonaBase { private : string nome ; string cognome ; int eta ; public : PersonaBase (); PersonaBase ( string nuovoNome , string nuovoCognome , int nuovaEta ); string getNome (); string getCognome (); int getEta (); void setNome ( string nuovoNome ); void setCognome ( string nuovoCognome ); void setEta ( int nuovaEta ); }; #endif // !PERSONA_H // File persona.cpp #include \"persona.h\" #include <iostream> using namespace std ; using namespace Persona ; PersonaBase :: PersonaBase () { setNome ( \"Non definito\" ); setCognome ( \"Non definito\" ); setEta ( 0 ); } PersonaBase :: PersonaBase ( string nuovoNome , string nuovoCognome , int nuovaEta ) { setNome ( nuovoNome ); setCognome ( nuovoCognome ); setEta ( nuovaEta ); } string PersonaBase :: getNome () { return nome ; } string PersonaBase :: getCognome () { return cognome ; } int PersonaBase :: getEta () { return eta ; } void PersonaBase :: setNome ( string nuovoNome ) { if ( nuovoNome . length () > 2 ) { nome = nuovoNome ; } } void PersonaBase :: setCognome ( string nuovoCognome ) { if ( nuovoCognome . length () > 2 ) { cognome = nuovoCognome ; } } void PersonaBase :: setEta ( int nuovaEta ) { if ( nuovaEta >= 0 ) { eta = nuovaEta ; } } Nota E' interessante sottolineare come all'interno del costruttore parametrizzato si usino i setter per modificare i valori degli attributi. Questa operazione \u00e8 consigliata per gli stessi motivi sottolineati in precedenza relativamente all'accesso degli attributi da variabili e metodi esterni alla classe.","title":"Costruttori"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/03_classi/#distruttori","text":"Una volta terminato l'utilizzo di un oggetto, \u00e8 necessario rilasciare le risorse da questo utilizzate in memoria. Per far questo, si utilizza un opportuno metodo chiamato distruttore , che viene automaticamente invocato su ogni variabile una volta raggiunto il termine del suo ambito di visibilit\u00e0 (oppure mediante l'invocazione della parola chiave delete ). La firma di un distruttore ha anch'essa alcune particolarit\u00e0: infatti, il nome coincide s\u00ec con quello della classe invocante, ma \u00e8 preceduto dal carattere ~ (la tilde, ottenibile mediante il codice ASCII 0126). Come il costruttore, inoltre, il distruttore non ha alcun tipo o valore di ritorno, ed a differenza del costruttore non accetta alcun parametro in ingresso. Per il resto, il distruttore \u00e8 una funzione come le altre, il cui unico compito per\u00f2 rimane quello di rimuovere dalla memoria un oggetto e tutte le sue dipendenze . Molto spesso non \u00e8 necessario definire in maniera esplicita il distruttore, in quanto questo viene generato automaticamente. Tuttavia, qualora l'oggetto utilizzato includa delle reference (variabili alias o puntatori) o faccia uso di risorse esterne (ad esempio file), potrebbe essere necessario definirlo per svolgere le operazioni adegaute a \"concludere\" adeguatamente le operazioni. Nel nostro caso, ad esempio, non \u00e8 necessario specificare un distruttore. Immaginiamo per\u00f2 di associare alla nostra classe un riferimento ad un puntatore; dovremo quindi definire un adeguato distruttore: // persona.h // ... class Persona :: PersonaBase { private : // ... int * puntatoreEta ; // .. public : // ... ~ PersonaBase (); // ... } Il distruttore dovr\u00e0 poi essere implementato all'interno del file persona.cpp : // persona.cpp PersonaBase :: PersonaBase () { // ... puntatoreEta = & eta ; // ... } PersonaBase ::~ PersonaBase () { delete puntatoreEta ; } E' importante sottolineare il ruolo fondamentale giocato dal distruttore in queste situazioni. Trascurandolo, infatti, avremmo un memory leak (come in questo caso), oppure potremmo rendere inaccessibile uno stream (come ad esempio un file binario di logging).","title":"Distruttori"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/","text":"Alcune definizioni (avanzate!) \u00b6 La parola riservata this \u00b6 Uno dei concetti pi\u00f9 importanti del C++ \u00e8 legato alla keyword this , la quale definisce uno speciale puntatore che contiene l'indirizzo della specifica istanza della classe cui \u00e8 associato. Questo viene inizializzato in maniera automatica, e passato come parametro implicito ad ogni funzione (ad eccezione dei metodi statici, come vedremo in seguito). Nota Va da s\u00e8 che il tipo associato al puntatore this \u00e8 quello di un puntatore alla classe stessa. Nel nostro esempio, this sar\u00e0 associato alla classe PersonaBase* . Il puntatore this gioca un ruolo fondamentale nella definizione di alcuni metodi, come ad esempio gli operatori di assegnazione, e pi\u00f9 in generale ogni volta che ci si vuole riferire ad una specifica istanza di un oggetto. In tal senso, un uso \"classico\" di this \u00e8 nei metodi setter: // persona.cpp void setNome ( string nome ) { this -> nome = nome ; } void setCognome ( string cognome ) { this -> cognome = cognome ; } void setEta ( int eta ) { this -> eta = eta ; } Questa particolare modalit\u00e0 di utilizzo di this serve a referenziare un membro di classe il cui nome \u00e8 oscurato da quello dell'argomento omonimo. L'uso di this E' comunque utile sottolineare che l'uso di this rimane perlopi\u00f9 opzionale, ancorch\u00e9 consigliato. Overloading degli operatori \u00b6 Il C++ tratta gli operatori come delle vere e proprie funzioni , il cui nome assume la forma operatorX , dove X contraddistingue uno tra gli operatori (ad esempio quelli aritmetici) che abbiamo discusso in precedenza parlando del C. In quanto funzioni, inoltre, sono caratterizzati da tipo restituito e parametri accettati. La conseguenza pi\u00f9 rilevante per i nostri scopi \u00e8 che \u00e8 possibile effettuarne l'overloading . Tuttavia, l'uso di questa pratica, seppur necessario, non \u00e8 banale. Infatti, l'overloading degli operatori implica la necessit\u00e0 di considerare la seguente sintassi: a . operatorX ( b ); al posto della classica: a X b ; con tutto ci\u00f2 che implica in termini di commutativit\u00e0 e simmetria dell'operatore. In tal senso, \u00e8 necessario distinguere tra due tipi di operatori, ovvero quelli per i quali l'overload pu\u00f2 avvenire all'interno della classe, e quelli per i quali l'overload deve avvenire all'esterno della stessa. Operatori in overloading come membri di classe \u00b6 Come detto in precedenza, l'overload di un operatore come membro della classe fa s\u00ec che il compilatore interpreti l'operazione come segue: // L'operatore binario X_bin passa da... a X_bin b ; // ...ad... a . operatorX_bin ( b ); // L'operatore unario X_un passa da... X_un a ; // ...ad... a . operatorX_un (); Immaginiamo quindi di avere una classe vettore, con attributi modulo ed angolo relativo rispetto all'asse delle ascisse, e voler implementare l'operatore somma (il + ) tra due oggetti di questa classe. Iniziamo quindi dichiarando un header ed il relativo sorgente. // geometria.h #ifndef GEOMETRIA_H #define GEOMETRIA_H namespace Geometria { class Vettore ; } class Geometria :: Vettore { private : double modulo ; double angolo ; public : Vettore (); Vettore ( double modulo , double angolo ); void setModulo ( double modulo ); void setAngolo ( double angolo ); double getModulo (); double getAngolo (); Vettore operator + ( const Vettore & op ); }; #endif // !GEOMETRIA_H // geometria.cpp #include \"geometria.h\" ; #include <cmath> using namespace Geometria ; Vettore :: Vettore () { setModulo ( 0 ); setAngolo ( 0 ); } Vettore :: Vettore ( double modulo , double angolo ) { setModulo ( modulo ); setAngolo ( angolo ); } double Vettore :: getModulo () { return this -> modulo ; } double Vettore :: getAngolo () { return this -> angolo ; } void Vettore :: setModulo ( double modulo ) { this -> modulo = modulo ; } void Vettore :: setAngolo ( double angolo ) { this -> angolo = angolo ; } Vettore Vettore :: operator + ( const Vettore & op ) { double res_angolo = abs ( this -> angolo - op . angolo ); double norma = ( this -> modulo * this -> modulo ) + ( op . modulo * op . modulo ) - ( 2 * this -> modulo * op . modulo * cos ( this -> angolo )); return Vettore ( sqrt ( norma ), ( this -> angolo + op . angolo ) / 2 ); } Proviamo ad invocare l'operatore somma usando la sintassi infissa: // main.cpp Vettore v1 ( 10.0 , 60.0 ); Vettore v2 ( 5.0 , 30.0 ); Vettore v3 = v1 + v2 ; Notiamo due cose: l'uso di una variabile reference per indicare l'operando op ; il fatto che, nonostante si stia usando la notazione infissa, l'operazione chiamata dal compilatore \u00e8 comunque v1.operator+(v2) . Quest'ultimo aspetto ha, in particolare, importanti implicazioni, che vediamo di seguito. Operatori in overloading come funzioni esterne alla classe \u00b6 Immaginiamo di voler semplicemente aggiungere un valore al modulo del vettore e, per qualche motivo, non voler usare la funzione setModulo() . L'opzione potrebbe essere quella di creare un altro operatore in overload: // geometria.h Vettore operator + ( double modulo ); // geometria.cpp Vettore operator + ( double modulo ) { return Vettore ( this -> modulo + modulo , this -> angolo ); } Provando a verificare la commutativit\u00e0 dell'operatore precedente, noteremo un errore a runtime: Vettore v1 ( 10.0 , 60.0 ); Vettore v2 = v1 + 5 ; // Ok Vettore v3 = 5 + v1 ; // Errore Per capire da dove deriva l'errore, dobbiamo ricordarci che gli operatori in overload come membri della classe sono considerati come funzioni chiamate su un'istanza della classe tipo a.operatorX(b) . Nel primo caso, quindi, andr\u00e0 tutto bene, perch\u00e9 il compilatore star\u00e0 chiamando una funzione del tipo v1.operator+(5) , mentre nel secondo caso star\u00e0 chiamando una funzione del tipo 5.operator+(v1) , che ovviamente non \u00e8 definita! E' quindi necessario dichiarare queste funzioni esternamente alla classe, in maniera tale che il loro funzionamento sia interpretato in questa maniera: // L'operatore binario X_bin passa da... a X_bin b ; // ...ad... operatorX_bin ( a , b ); // L'operatore unario X_un passa da... X_un a ; // ...ad... operatorX_un ( a ); Per farlo, possiamo usare due diversi approcci. Overload multipli \u00b6 Il primo, e pi\u00f9 semplice, \u00e8 utilizzare due overload, uno per ogni possibile commutazione degli operatori. Il codice diventerebbe quindi: // geometria.h Vettore operator + ( Vettore & right , double left ); Vettore operator + ( double right , Vettore & left ); // geometria.cpp Vettore Geometria :: operator + ( Vettore & right , double left ) { return Vettore ( right . getModulo () + left , right . getAngolo ()); } Vettore Geometria :: operator + ( double right , Vettore & left ) { return Vettore ( left . getModulo () + right , left . getAngolo ()); } Il problema principale \u00e8 che stiamo duplicando gli overload per ogni operatore, con tutto quello che ne consegue. Un modo pi\u00f9 \"elegante\" di procedere \u00e8 usare un apposito costruttore, che accetti soltanto il valore del modulo: // geometria.h Vettore :: Vettore ( double modulo ); Vettore operator + ( Vettore & right , Vettore & left ); // geometria.cpp Vettore :: Vettore ( double modulo ) { setModulo ( modulo ); setAngolo ( 0 ); } Vettore operator + ( Vettore & right , Vettore & left ) { return Vettore ( right . getModulo () + left . getModulo ()); } Nota Una ulteriore \"rifinitura\" potrebbe essere quella di modificare l'argomento angolo del costruttore di Vettore in maniera tale che esso, di default, sia pari a 0. Overloading degli operatori di inserimento ed estrazione da flusso \u00b6 Possiamo anche ridefinire gli operatori di inserimento ed estrazione da uno stream (rispettivamente << e >> ), in maniera tale da ottenere una modalit\u00e0 di visualizzazione ed acquisizione dati predefinita per gli oggetti della nostra classe. Ad esempio: // geometria.h ostream & operator << ( ostream & output , Vettore & v ); istream & operator >> ( istream & input , Vettore & v ); // geometria.cpp ostream & Geometria :: operator << ( ostream & output , Vettore & vettore ) { cout << \"Modulo: \" << vettore . getModulo () << \" Angolo: \" << vettore . getAngolo (); return output ; } istream & Geometria :: operator >> ( istream & input , Vettore & vettore ) { double modulo ; double angolo ; input >> modulo >> angolo ; vettore . setModulo ( modulo ); vettore . setAngolo ( angolo ); return input ; } Provando ad invocarli, otterremo: # rappresentazione Modulo: 15 Angolo: 60 # acquisizione Inserire modulo ed angolo per il nuovo vettore: # atteso input utente Allocazione dinamica delle risorse \u00b6 Abbiamo visto come il sistema operativo si occupa di assegnare una determinata area di memoria ad ogni variabile e funzione. Senza scomodare i concetti relativi alle architetture di von Neumann ed Harvard, per\u00f2, possiamo dire che le aree di memoria pi\u00f9 importanti per i nostri scopi sono due: lo stack e lo heap . Lo stack \u00e8 organizzato come una pila, i cui elementi sono accessibili con politica LIFO; normalmente, le variabili sono memorizzate nello stack per l'intera durata del loro ambito di visibilit\u00e0. Quindi, in un programma come il seguente, avremo un comportamento del tipo: int main () { int a = 0 ; // stack: {a} { int b = a ++ ; // stack: {b} {a} } // stack: {a} return 0 ; } Questo tipo di variabili \u00e8 detto automatica : l'allocazione e la deallocazione della memoria \u00e8 quindi gestita automaticamente dal compilatore. Lo stack risulta essere molto efficiente; tuttavia, dispone di uno spazio limitato, per cui spesso si ricorre allo heap, per gestire il quale \u00e8 necessario usare i puntatori, in modo da allocare o deallocare le corrispondenti aree di memoria. Per cui la sintassi generica che viene utilizzata prevede l'uso delle parole chiave new e delete . Ad esempio: int main () { int * puntatore ; // Dichiaro un puntatore puntatore = new int ; // Alloco memoria nello heap il puntatore con l'operatore new delete p ; // Dealloco la memoria riservata al puntatore mediante l'operatore delete return 0 ; }","title":"04 - Alcune definizioni (pi\u00f9 avanzate)"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#alcune-definizioni-avanzate","text":"","title":"Alcune definizioni (avanzate!)"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#la-parola-riservata-this","text":"Uno dei concetti pi\u00f9 importanti del C++ \u00e8 legato alla keyword this , la quale definisce uno speciale puntatore che contiene l'indirizzo della specifica istanza della classe cui \u00e8 associato. Questo viene inizializzato in maniera automatica, e passato come parametro implicito ad ogni funzione (ad eccezione dei metodi statici, come vedremo in seguito). Nota Va da s\u00e8 che il tipo associato al puntatore this \u00e8 quello di un puntatore alla classe stessa. Nel nostro esempio, this sar\u00e0 associato alla classe PersonaBase* . Il puntatore this gioca un ruolo fondamentale nella definizione di alcuni metodi, come ad esempio gli operatori di assegnazione, e pi\u00f9 in generale ogni volta che ci si vuole riferire ad una specifica istanza di un oggetto. In tal senso, un uso \"classico\" di this \u00e8 nei metodi setter: // persona.cpp void setNome ( string nome ) { this -> nome = nome ; } void setCognome ( string cognome ) { this -> cognome = cognome ; } void setEta ( int eta ) { this -> eta = eta ; } Questa particolare modalit\u00e0 di utilizzo di this serve a referenziare un membro di classe il cui nome \u00e8 oscurato da quello dell'argomento omonimo. L'uso di this E' comunque utile sottolineare che l'uso di this rimane perlopi\u00f9 opzionale, ancorch\u00e9 consigliato.","title":"La parola riservata this"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#overloading-degli-operatori","text":"Il C++ tratta gli operatori come delle vere e proprie funzioni , il cui nome assume la forma operatorX , dove X contraddistingue uno tra gli operatori (ad esempio quelli aritmetici) che abbiamo discusso in precedenza parlando del C. In quanto funzioni, inoltre, sono caratterizzati da tipo restituito e parametri accettati. La conseguenza pi\u00f9 rilevante per i nostri scopi \u00e8 che \u00e8 possibile effettuarne l'overloading . Tuttavia, l'uso di questa pratica, seppur necessario, non \u00e8 banale. Infatti, l'overloading degli operatori implica la necessit\u00e0 di considerare la seguente sintassi: a . operatorX ( b ); al posto della classica: a X b ; con tutto ci\u00f2 che implica in termini di commutativit\u00e0 e simmetria dell'operatore. In tal senso, \u00e8 necessario distinguere tra due tipi di operatori, ovvero quelli per i quali l'overload pu\u00f2 avvenire all'interno della classe, e quelli per i quali l'overload deve avvenire all'esterno della stessa.","title":"Overloading degli operatori"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#operatori-in-overloading-come-membri-di-classe","text":"Come detto in precedenza, l'overload di un operatore come membro della classe fa s\u00ec che il compilatore interpreti l'operazione come segue: // L'operatore binario X_bin passa da... a X_bin b ; // ...ad... a . operatorX_bin ( b ); // L'operatore unario X_un passa da... X_un a ; // ...ad... a . operatorX_un (); Immaginiamo quindi di avere una classe vettore, con attributi modulo ed angolo relativo rispetto all'asse delle ascisse, e voler implementare l'operatore somma (il + ) tra due oggetti di questa classe. Iniziamo quindi dichiarando un header ed il relativo sorgente. // geometria.h #ifndef GEOMETRIA_H #define GEOMETRIA_H namespace Geometria { class Vettore ; } class Geometria :: Vettore { private : double modulo ; double angolo ; public : Vettore (); Vettore ( double modulo , double angolo ); void setModulo ( double modulo ); void setAngolo ( double angolo ); double getModulo (); double getAngolo (); Vettore operator + ( const Vettore & op ); }; #endif // !GEOMETRIA_H // geometria.cpp #include \"geometria.h\" ; #include <cmath> using namespace Geometria ; Vettore :: Vettore () { setModulo ( 0 ); setAngolo ( 0 ); } Vettore :: Vettore ( double modulo , double angolo ) { setModulo ( modulo ); setAngolo ( angolo ); } double Vettore :: getModulo () { return this -> modulo ; } double Vettore :: getAngolo () { return this -> angolo ; } void Vettore :: setModulo ( double modulo ) { this -> modulo = modulo ; } void Vettore :: setAngolo ( double angolo ) { this -> angolo = angolo ; } Vettore Vettore :: operator + ( const Vettore & op ) { double res_angolo = abs ( this -> angolo - op . angolo ); double norma = ( this -> modulo * this -> modulo ) + ( op . modulo * op . modulo ) - ( 2 * this -> modulo * op . modulo * cos ( this -> angolo )); return Vettore ( sqrt ( norma ), ( this -> angolo + op . angolo ) / 2 ); } Proviamo ad invocare l'operatore somma usando la sintassi infissa: // main.cpp Vettore v1 ( 10.0 , 60.0 ); Vettore v2 ( 5.0 , 30.0 ); Vettore v3 = v1 + v2 ; Notiamo due cose: l'uso di una variabile reference per indicare l'operando op ; il fatto che, nonostante si stia usando la notazione infissa, l'operazione chiamata dal compilatore \u00e8 comunque v1.operator+(v2) . Quest'ultimo aspetto ha, in particolare, importanti implicazioni, che vediamo di seguito.","title":"Operatori in overloading come membri di classe"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#operatori-in-overloading-come-funzioni-esterne-alla-classe","text":"Immaginiamo di voler semplicemente aggiungere un valore al modulo del vettore e, per qualche motivo, non voler usare la funzione setModulo() . L'opzione potrebbe essere quella di creare un altro operatore in overload: // geometria.h Vettore operator + ( double modulo ); // geometria.cpp Vettore operator + ( double modulo ) { return Vettore ( this -> modulo + modulo , this -> angolo ); } Provando a verificare la commutativit\u00e0 dell'operatore precedente, noteremo un errore a runtime: Vettore v1 ( 10.0 , 60.0 ); Vettore v2 = v1 + 5 ; // Ok Vettore v3 = 5 + v1 ; // Errore Per capire da dove deriva l'errore, dobbiamo ricordarci che gli operatori in overload come membri della classe sono considerati come funzioni chiamate su un'istanza della classe tipo a.operatorX(b) . Nel primo caso, quindi, andr\u00e0 tutto bene, perch\u00e9 il compilatore star\u00e0 chiamando una funzione del tipo v1.operator+(5) , mentre nel secondo caso star\u00e0 chiamando una funzione del tipo 5.operator+(v1) , che ovviamente non \u00e8 definita! E' quindi necessario dichiarare queste funzioni esternamente alla classe, in maniera tale che il loro funzionamento sia interpretato in questa maniera: // L'operatore binario X_bin passa da... a X_bin b ; // ...ad... operatorX_bin ( a , b ); // L'operatore unario X_un passa da... X_un a ; // ...ad... operatorX_un ( a ); Per farlo, possiamo usare due diversi approcci.","title":"Operatori in overloading come funzioni esterne alla classe"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#overload-multipli","text":"Il primo, e pi\u00f9 semplice, \u00e8 utilizzare due overload, uno per ogni possibile commutazione degli operatori. Il codice diventerebbe quindi: // geometria.h Vettore operator + ( Vettore & right , double left ); Vettore operator + ( double right , Vettore & left ); // geometria.cpp Vettore Geometria :: operator + ( Vettore & right , double left ) { return Vettore ( right . getModulo () + left , right . getAngolo ()); } Vettore Geometria :: operator + ( double right , Vettore & left ) { return Vettore ( left . getModulo () + right , left . getAngolo ()); } Il problema principale \u00e8 che stiamo duplicando gli overload per ogni operatore, con tutto quello che ne consegue. Un modo pi\u00f9 \"elegante\" di procedere \u00e8 usare un apposito costruttore, che accetti soltanto il valore del modulo: // geometria.h Vettore :: Vettore ( double modulo ); Vettore operator + ( Vettore & right , Vettore & left ); // geometria.cpp Vettore :: Vettore ( double modulo ) { setModulo ( modulo ); setAngolo ( 0 ); } Vettore operator + ( Vettore & right , Vettore & left ) { return Vettore ( right . getModulo () + left . getModulo ()); } Nota Una ulteriore \"rifinitura\" potrebbe essere quella di modificare l'argomento angolo del costruttore di Vettore in maniera tale che esso, di default, sia pari a 0.","title":"Overload multipli"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#overloading-degli-operatori-di-inserimento-ed-estrazione-da-flusso","text":"Possiamo anche ridefinire gli operatori di inserimento ed estrazione da uno stream (rispettivamente << e >> ), in maniera tale da ottenere una modalit\u00e0 di visualizzazione ed acquisizione dati predefinita per gli oggetti della nostra classe. Ad esempio: // geometria.h ostream & operator << ( ostream & output , Vettore & v ); istream & operator >> ( istream & input , Vettore & v ); // geometria.cpp ostream & Geometria :: operator << ( ostream & output , Vettore & vettore ) { cout << \"Modulo: \" << vettore . getModulo () << \" Angolo: \" << vettore . getAngolo (); return output ; } istream & Geometria :: operator >> ( istream & input , Vettore & vettore ) { double modulo ; double angolo ; input >> modulo >> angolo ; vettore . setModulo ( modulo ); vettore . setAngolo ( angolo ); return input ; } Provando ad invocarli, otterremo: # rappresentazione Modulo: 15 Angolo: 60 # acquisizione Inserire modulo ed angolo per il nuovo vettore: # atteso input utente","title":"Overloading degli operatori di inserimento ed estrazione da flusso"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/04_definizioni_adv/#allocazione-dinamica-delle-risorse","text":"Abbiamo visto come il sistema operativo si occupa di assegnare una determinata area di memoria ad ogni variabile e funzione. Senza scomodare i concetti relativi alle architetture di von Neumann ed Harvard, per\u00f2, possiamo dire che le aree di memoria pi\u00f9 importanti per i nostri scopi sono due: lo stack e lo heap . Lo stack \u00e8 organizzato come una pila, i cui elementi sono accessibili con politica LIFO; normalmente, le variabili sono memorizzate nello stack per l'intera durata del loro ambito di visibilit\u00e0. Quindi, in un programma come il seguente, avremo un comportamento del tipo: int main () { int a = 0 ; // stack: {a} { int b = a ++ ; // stack: {b} {a} } // stack: {a} return 0 ; } Questo tipo di variabili \u00e8 detto automatica : l'allocazione e la deallocazione della memoria \u00e8 quindi gestita automaticamente dal compilatore. Lo stack risulta essere molto efficiente; tuttavia, dispone di uno spazio limitato, per cui spesso si ricorre allo heap, per gestire il quale \u00e8 necessario usare i puntatori, in modo da allocare o deallocare le corrispondenti aree di memoria. Per cui la sintassi generica che viene utilizzata prevede l'uso delle parole chiave new e delete . Ad esempio: int main () { int * puntatore ; // Dichiaro un puntatore puntatore = new int ; // Alloco memoria nello heap il puntatore con l'operatore new delete p ; // Dealloco la memoria riservata al puntatore mediante l'operatore delete return 0 ; }","title":"Allocazione dinamica delle risorse"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/05_classi_adv/","text":"Le classi (parte due) \u00b6 Copiare un oggetto \u00b6 Copiare un oggetto di un tipo non primitivo non \u00e8 un'operazione cos\u00ec semplice come copiarne uno di tipo primitivo. Di solito, infatti, per copiare un valore basta usare l'operatore di assegnamento; le classi, invece, necessitano della definizione di un apposito costruttore di copia , il quale condivide buona parte delle caratteristiche di un costruttore ordinario, a meno di due caratteristiche: il primo dei parametri (obbligatorio) \u00e8 una reference ad un'istanza della classe; la presenza di eventuali parametri aggiuntivi \u00e8 opzionale. Vediamo un esempio di costruttore di copia per le classi PersonaBase e Vettore: // persona.h PersonaBase ( const Persona & other ); // persona.cpp Persona :: PersonaBase ( const PersonaBase & other ) { setNome ( other .) nome = other . getNome (); cognome = other . getCognome (); eta = other . getEta (); } // vettore.h Vettore ( const Vettore & altro ); // vettore.cpp Vettore :: Vettore ( const Vettore & altro ) { setModulo ( altro . modulo ); setAngolo ( altro . angolo ); } E' importante sottolineare la presenza della parola chiave const . I motivi possono essere molteplici; i pi\u00f9 semplici hanno a che fare con il fatto che non ha molto senso modificare l'oggetto copiato, o anche che vogliamo essere in grado di copiare oggetti dichiarati come costanti; per i pi\u00f9 complessi, invece, possiamo rifarci ad un interessante articolo di Herb Sutter . Shallow copy e deep copy \u00b6 E' importante sottolineare come i due costruttori di copia che abbiamo specificato non siano differenti da quelli generati in maniera automatica dal compilatore; infatti, l'idea generale \u00e8 quella di effettuare una copia membro a membro , usando una tecnica chiamata shallow copy (copia superficiale). La shallow copy non pu\u00f2 per\u00f2 essere usata nel caso la classe contenga attributi come puntatori o reference. Infatti, in questo caso, creeremmo un legame tra le due istanze, in quanto una modifica all'attributo puntato dalla variabile copiata si ripercuterebbe sullo stesso attributo della variabile risultato della copia, e viceversa. Di conseguenza, in questi casi si utilizza una tecnica chiamata deep copy . Nel caso fosse presente il solito puntatore alla nostra et\u00e0: class Vettore { // ... private : double * puntatoreModulo ; } Vettore ( const Vettore & altro ) { // shallow copy modulo = altro . modulo ; angolo = altro . angolo ; // deep copy puntatoreModulo = new double ; if ( altro . puntatoreModulo != nullptr ) { * puntatoreModulo = * ( altro . puntatoreModulo ); } } La deep copy prevede quindi due step: nel primo step, viene allocata memoria per l'attributo da copiare; nel secondo step, viene copiato nella memoria allocata il valore puntato dall'oggetto da copiare. Operatore di assegnazione di copia \u00b6 La copia di un oggetto deve tener conto, oltre che del costruttore, anche dell'operatore di assegnazione, ovvero = , che entra in gioco ogni volta che ad un oggetto viene assegnato un valore successivamente alla sua inizializzazione, come in questo caso: PersonaBase piero ( \"piero\" , \"scamarcio\" , 18 ); PersonaBase tizio ( \"una\" , \"persona\" , 22 ); tizio = piero ; Vettore v1 ( 10.0 , 45.0 ); Vettore v2 ( 15.0 , 60.0 ); v2 = v1 ; Per definirlo, possiamo sfruttare il concetto di overload di operatore. Ad esempio: // persona.h PersonaBase & operator = ( const PersonaBase & other ); // persona.cpp PersonaBase & operator = ( const PersonaBase & other ) { nome = other . getNome (); cognome = other . getCognome (); eta = other . getEta (); return * this ; } // geometria.h Vettore & operator = ( const Vettore & altro ); // geometria.cpp Vettore & operator = ( const Vettore & altro ) { modulo = altro . modulo ; angolo = altro . angolo ; return * this ; } Notiamo la presenza di numerose analogie con il costruttore di copia, tra cui firma, sintassi e generazione automatica da parte del compilatore. L'unica differenza tangibile sta nel fatto che l'operatore di assegnazione restituisce il valore puntato dal puntatore this , ovvero l'istanza che abbiamo appena definito. Allocazione dinamica di nuovi oggetti \u00b6 In precedenza abbiamo visto come utilizzare costruttori e distruttori per inizializzare nuove istanze di una classe. Questo tipo di inizializzazione \u00e8 per\u00f2 statica; \u00e8 possibile definire un'allocazione dinamica degli oggetti utilizzando appositamente i puntatori e le keyword new e delete . Ad esempio: // main.cpp PersonaBase * pb = new PersonaBase ( \"Piero\" , \"Scamarcio\" , 21 ); delete pb ; Vettore * v = new Vettore ( 10.0 , 45.0 ); //... delete v ; Notiamo come l'inizializzazione dinamica della variabile preveda che alla keyword new segua uno dei costruttori in overload, assieme ad una lista di argomenti contenuti tra parentesi tonde. Per accedere ai membri ed alle funzioni dell'oggetto istanziato dinamicamente, dovremo usare l'operatore freccia -> , come avevamo gi\u00e0 visto quando abbiamo parlato delle struct Quindi: pb -> setNome ( \"Pietro\" );","title":"05 - Le classi (parte due)"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/05_classi_adv/#le-classi-parte-due","text":"","title":"Le classi (parte due)"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/05_classi_adv/#copiare-un-oggetto","text":"Copiare un oggetto di un tipo non primitivo non \u00e8 un'operazione cos\u00ec semplice come copiarne uno di tipo primitivo. Di solito, infatti, per copiare un valore basta usare l'operatore di assegnamento; le classi, invece, necessitano della definizione di un apposito costruttore di copia , il quale condivide buona parte delle caratteristiche di un costruttore ordinario, a meno di due caratteristiche: il primo dei parametri (obbligatorio) \u00e8 una reference ad un'istanza della classe; la presenza di eventuali parametri aggiuntivi \u00e8 opzionale. Vediamo un esempio di costruttore di copia per le classi PersonaBase e Vettore: // persona.h PersonaBase ( const Persona & other ); // persona.cpp Persona :: PersonaBase ( const PersonaBase & other ) { setNome ( other .) nome = other . getNome (); cognome = other . getCognome (); eta = other . getEta (); } // vettore.h Vettore ( const Vettore & altro ); // vettore.cpp Vettore :: Vettore ( const Vettore & altro ) { setModulo ( altro . modulo ); setAngolo ( altro . angolo ); } E' importante sottolineare la presenza della parola chiave const . I motivi possono essere molteplici; i pi\u00f9 semplici hanno a che fare con il fatto che non ha molto senso modificare l'oggetto copiato, o anche che vogliamo essere in grado di copiare oggetti dichiarati come costanti; per i pi\u00f9 complessi, invece, possiamo rifarci ad un interessante articolo di Herb Sutter .","title":"Copiare un oggetto"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/05_classi_adv/#shallow-copy-e-deep-copy","text":"E' importante sottolineare come i due costruttori di copia che abbiamo specificato non siano differenti da quelli generati in maniera automatica dal compilatore; infatti, l'idea generale \u00e8 quella di effettuare una copia membro a membro , usando una tecnica chiamata shallow copy (copia superficiale). La shallow copy non pu\u00f2 per\u00f2 essere usata nel caso la classe contenga attributi come puntatori o reference. Infatti, in questo caso, creeremmo un legame tra le due istanze, in quanto una modifica all'attributo puntato dalla variabile copiata si ripercuterebbe sullo stesso attributo della variabile risultato della copia, e viceversa. Di conseguenza, in questi casi si utilizza una tecnica chiamata deep copy . Nel caso fosse presente il solito puntatore alla nostra et\u00e0: class Vettore { // ... private : double * puntatoreModulo ; } Vettore ( const Vettore & altro ) { // shallow copy modulo = altro . modulo ; angolo = altro . angolo ; // deep copy puntatoreModulo = new double ; if ( altro . puntatoreModulo != nullptr ) { * puntatoreModulo = * ( altro . puntatoreModulo ); } } La deep copy prevede quindi due step: nel primo step, viene allocata memoria per l'attributo da copiare; nel secondo step, viene copiato nella memoria allocata il valore puntato dall'oggetto da copiare.","title":"Shallow copy e deep copy"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/05_classi_adv/#operatore-di-assegnazione-di-copia","text":"La copia di un oggetto deve tener conto, oltre che del costruttore, anche dell'operatore di assegnazione, ovvero = , che entra in gioco ogni volta che ad un oggetto viene assegnato un valore successivamente alla sua inizializzazione, come in questo caso: PersonaBase piero ( \"piero\" , \"scamarcio\" , 18 ); PersonaBase tizio ( \"una\" , \"persona\" , 22 ); tizio = piero ; Vettore v1 ( 10.0 , 45.0 ); Vettore v2 ( 15.0 , 60.0 ); v2 = v1 ; Per definirlo, possiamo sfruttare il concetto di overload di operatore. Ad esempio: // persona.h PersonaBase & operator = ( const PersonaBase & other ); // persona.cpp PersonaBase & operator = ( const PersonaBase & other ) { nome = other . getNome (); cognome = other . getCognome (); eta = other . getEta (); return * this ; } // geometria.h Vettore & operator = ( const Vettore & altro ); // geometria.cpp Vettore & operator = ( const Vettore & altro ) { modulo = altro . modulo ; angolo = altro . angolo ; return * this ; } Notiamo la presenza di numerose analogie con il costruttore di copia, tra cui firma, sintassi e generazione automatica da parte del compilatore. L'unica differenza tangibile sta nel fatto che l'operatore di assegnazione restituisce il valore puntato dal puntatore this , ovvero l'istanza che abbiamo appena definito.","title":"Operatore di assegnazione di copia"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/05_classi_adv/#allocazione-dinamica-di-nuovi-oggetti","text":"In precedenza abbiamo visto come utilizzare costruttori e distruttori per inizializzare nuove istanze di una classe. Questo tipo di inizializzazione \u00e8 per\u00f2 statica; \u00e8 possibile definire un'allocazione dinamica degli oggetti utilizzando appositamente i puntatori e le keyword new e delete . Ad esempio: // main.cpp PersonaBase * pb = new PersonaBase ( \"Piero\" , \"Scamarcio\" , 21 ); delete pb ; Vettore * v = new Vettore ( 10.0 , 45.0 ); //... delete v ; Notiamo come l'inizializzazione dinamica della variabile preveda che alla keyword new segua uno dei costruttori in overload, assieme ad una lista di argomenti contenuti tra parentesi tonde. Per accedere ai membri ed alle funzioni dell'oggetto istanziato dinamicamente, dovremo usare l'operatore freccia -> , come avevamo gi\u00e0 visto quando abbiamo parlato delle struct Quindi: pb -> setNome ( \"Pietro\" );","title":"Allocazione dinamica di nuovi oggetti"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/06_metodi/","text":"Classi e funzioni \u00b6 Funzioni membro \u00b6 Finora abbiamo parlato diverse volte del concetto di funzione membro : esempi sono costruttori, distruttori ed operatori, tutti dotati di una sintassi ben definita a causa delle peculiarit\u00e0 del loro compito. Tuttavia, le funzioni membro non hanno necessariamente delle caratteristiche particolari: in realt\u00e0, qualsiasi funzione pu\u00f2 essere definita come funzione membro. Ci\u00f2 non significa per\u00f2 che non vi siano differenze tra le funzioni generiche (quelle dichiarate all'esterno di una classe) e le funzioni membro: queste sussistono infatti soprattutto nell' ambito e visibilit\u00e0 , oltre che di capacit\u00e0 di accedere ai membri della classe (ricordiamo che ad ogni funzione membro viene implicitamente passato il puntatore this ). In particolare: una funzione membro non pu\u00f2 essere invocata se non su un'istanza della classe di appartenenza; grazie al puntatore this , la funzione membro ha accesso non solo ai parametri di input ed alle variabili dichiarate localmente, ma anche a tutti gli attributi e le funzioni della classe di appartenenza. E' inoltre importante una corretta gestione dei modificatori di accesso delle funzioni membro, soprattutto in sede di refactoring del codice. Infatti, le funzioni dichiarate con il modificatore public sono molto spesso invocate al di fuori della classe su specifiche istanze della stessa; in tal senso, bisogna tener presente che, modificando il nome della funzione membro, si influenzer\u00e0 il comportamento di tutto il codice chiamante . Immaginiamo ad esempio di usare in questo modo la nostra classe Vettore : // main.cpp int main () { Vettore v1 = new Vettore ( 10.0 , 45.0 ); Vettore v2 = new Vettore ( 5.0 , 45.0 ); if ( v1 . getAngolo () == v2 . getAngolo ()) { // I due vettori sono paralleli, la somma dei moduli \u00e8 pi\u00f9 semplice double sommaModuli = v1 . getModulo () + v2 . getModulo (); } } Immaginiamo quindi di decidere, per un motivo qualsiasi, di modificare le firme dei getter in questo modo: // vettore.h class Vettore { // ... public : double angolo (); // Precedentemente getAngolo() double modulo (); // Precedentemente getModulo() } Cosa accadrebbe al codice chiamante (ovvero al main.cpp )? Beh, chiaramente avremmo un errore in fase di compilazione! Adesso, come al solito, stiamo considerando casi abbastanza \"ristretti\"; qualora per\u00f2 dovessimo sviluppare delle grosse librerie, magari utilizzate da diversi sviluppatori (anche esterni), allora una qualsiasi modifica, anche di scarsa rilevanza come questa, potrebbe causare errori e problemi, con la conseguenza di richiedere tempo (e denaro) per la loro risoluzione. Ovviamente, ci sono casi in cui queste situazioni diventano inevitabili; tuttavia, \u00e8 sempre bene essere consapevoli di quelle che sono le proprie responsabilit\u00e0 nell'effettuare modifiche, ed attenersi quanto pi\u00f9 possibile alle best practices (che, in soldoni, ci chiedono di aderire il pi\u00f9 possibile al principio dell'incapsulamento)! Funzioni inline \u00b6 Una possibile forma di ottimizzazione del codice prevede l'applicazione alle funzioni della parola chiave inline , rappresentativa di una direttiva al compilatore che, se eseguita, permette di sostituire nel codice compilato la chiamata a funzione con il corpo della stessa. Se da un lato questo pu\u00f2 migliorare le prestazioni, dall'altro ovviamente influenza le dimensioni dell'eseguibile finale, per cui va usata con un certo giudizio; inoltre, l'effettivo impatto sulle prestazioni dipende anche dal compilatore, che potrebbe anche ignorare (totalmente o in parte) la direttiva, o applicarla a metodi che non l'abbiano esplicitamente definita. La sintassi per la definizione di una generica funzione inline \u00e8 la seguente: inline int somma ( int a , int b ) { return a + b ; } int main () { somma ( 2 , 3 ); return 0 ; } E' ovviamente possibile definire un metodo inline direttamente in una classe. Per farlo, possiamo specificarlo nell'header; ad esempio: // geometria.h class Vettore { // ... public : inline double getModulo () { return this -> modulo ; } } Un altro modo \u00e8 specificarlo nel file sorgente, ad esempio: // geometria.h class Vettore { // ... public : double getModulo (); } // geometria.cpp // Dovremo ridefinirlo in ogni sorgente in cui lo utilizziamo! inline double Vettore :: getModulo () { return this -> modulo ; } Tuttavia, quando si definisce una funzione inline, \u00e8 necessario che il corpo della stessa sia presente in ogni unit\u00e0 di compilazione . Questo implica la necessit\u00e0 di includere la definizione del metodo inline o direttamente nell'header, oppure in ognuno dei file sorgenti in cui la funzione viene invocata. Scegliendo il secondo metodo, quindi, il nostro main assumer\u00e0 una forma del tipo: #include <iostream> #include \"geometria.h\" using namespace std ; // Rimuovendo questa definizione, avremo un errore di compilazione inline double Vettore :: getModulo () { return this -> modulo ; } int main () { Vettore v1 = new Vettore ( 10.0 , 45.0 ); cout << v1 . getModulo () << endl ; return 0 ; } Nota E' chiaro come entrambe le opzioni non siano esattamente \"ottimali\". Nel primo caso, infatti, stiamo violando uno dei principi della OOP, ovvero quello di incapsulamento, in quanto esponiamo all'interno di un interfaccia i dettagli dell'implementazione. Nel secondo, invece, dovremo ripetere il sorgente della funzione inline in ogni sorgente che la usa, con tutto ci\u00f2 che ne consegue in termini di possibili errori e prolissit\u00e0 del codice. Di conseguenza, l'uso di questa particolare tecnica di ottimizzazione deve rimanere confinato al campo del \"soltanto se indispensabile\". Funzioni const \u00b6 Abbiamo visto gli effetti della parola chiave const quando applicata ad una variabile. Applicandola per\u00f2 alla firma di una funzione membro, avr\u00e0 l'effetto di inibire la modifica del membro stesso (ovviamente all'interno della funzione). In tal senso, l'esempio classico che \u00e8 possibile fare \u00e8 sui getter, che di solito vengono \"decorati\" con la keyword const per garantire che non vi siano effetti collaterali. Nel nostro caso: // geometria.h class Geometria :: Vettore { //... private : double modulo ; double angolo ; public : double getModulo () const ; double getAngolo () const ; // ... } // geometria.cpp double Vettore :: getModulo () const { return this -> modulo ; } double Vettore :: getAngolo () const { return this -> angolo ; } Funzioni static \u00b6 Le funzioni contrassegnate con la keyword static possono essere invocate senza la necessit\u00e0 di istanziare un oggetto della classe di appartenenza. Come conseguenza, si dice che i metodi statici sono relativi alla classe , e non alle singole istanze della stessa; ci\u00f2 comporta quindi che all'interno dei metodi statici ci si possa riferire esclusivamente agli attributi statici della classe. Supponiamo, ad esempio, di voler inserire un riferimento allo spazio cartesiano nel quale sono contenuti i nostri vettori; dato che questo risulta essere comune, potremo usare un attributo ed una funzione statici per ottenerli: // geometria.h class Punto { // ... } class Vettore { private : static Punto origine ; public : static Punto getOrigine (); } // geometria.cpp Punto Vettore :: getOrigine () { return origine ; } // main.cpp #include <iostream> #include \"geometria.h\" using namespace std ; int main () { cout << Vettore :: getOrigine () << endl ; return 0 ; } Alcune note: le funzioni membro static di una classe sono accessibili mediante l'uso dell'operatore di scope; il qualificatore static appare nella dichiarazione della funzione membro, ma non nella sua definizione; i metodi statici non possono essere contestualmente const . La parola chiave friend \u00b6 Chiudiamo questa carrellata introducendo il modificatore friend , che pu\u00f2 essere assegnato a funzioni o classi che, pur non facendo parte dell'ambito della classe presso la quale vengono dichiarati, possono accedere ai membri della stessa indipendentemente dal qualificatore di accesso. Immaginiamo ad esempio di definire una classe SpazioVettoriale , che per motivi implementativi deve poter accedere ai singoli vettori che compongono la sua base. Potremo quindi definirla come classe friend del singolo vettore: // geometria.h class Vettore { private : // ... friend class SpazioVettoriale ; } In questo modo, la classe SpazioVettoriale potr\u00e0 accedere ai membri private dei vettori. Nota Questo esempio apperentemente va in contrasto con le regole di incapsulamento dettate dalla OOP. Tuttavia, ed in situazioni complesse, l'utilizzo di una funzione o classe friend pu\u00f2 risolvere numerosi grattacapi imposti da un'interpretazione troppo \"rigida\" dei dettami imposti dalla programmazione orientata agli oggetti.","title":"06 - Dettagli sui metodi"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/06_metodi/#classi-e-funzioni","text":"","title":"Classi e funzioni"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/06_metodi/#funzioni-membro","text":"Finora abbiamo parlato diverse volte del concetto di funzione membro : esempi sono costruttori, distruttori ed operatori, tutti dotati di una sintassi ben definita a causa delle peculiarit\u00e0 del loro compito. Tuttavia, le funzioni membro non hanno necessariamente delle caratteristiche particolari: in realt\u00e0, qualsiasi funzione pu\u00f2 essere definita come funzione membro. Ci\u00f2 non significa per\u00f2 che non vi siano differenze tra le funzioni generiche (quelle dichiarate all'esterno di una classe) e le funzioni membro: queste sussistono infatti soprattutto nell' ambito e visibilit\u00e0 , oltre che di capacit\u00e0 di accedere ai membri della classe (ricordiamo che ad ogni funzione membro viene implicitamente passato il puntatore this ). In particolare: una funzione membro non pu\u00f2 essere invocata se non su un'istanza della classe di appartenenza; grazie al puntatore this , la funzione membro ha accesso non solo ai parametri di input ed alle variabili dichiarate localmente, ma anche a tutti gli attributi e le funzioni della classe di appartenenza. E' inoltre importante una corretta gestione dei modificatori di accesso delle funzioni membro, soprattutto in sede di refactoring del codice. Infatti, le funzioni dichiarate con il modificatore public sono molto spesso invocate al di fuori della classe su specifiche istanze della stessa; in tal senso, bisogna tener presente che, modificando il nome della funzione membro, si influenzer\u00e0 il comportamento di tutto il codice chiamante . Immaginiamo ad esempio di usare in questo modo la nostra classe Vettore : // main.cpp int main () { Vettore v1 = new Vettore ( 10.0 , 45.0 ); Vettore v2 = new Vettore ( 5.0 , 45.0 ); if ( v1 . getAngolo () == v2 . getAngolo ()) { // I due vettori sono paralleli, la somma dei moduli \u00e8 pi\u00f9 semplice double sommaModuli = v1 . getModulo () + v2 . getModulo (); } } Immaginiamo quindi di decidere, per un motivo qualsiasi, di modificare le firme dei getter in questo modo: // vettore.h class Vettore { // ... public : double angolo (); // Precedentemente getAngolo() double modulo (); // Precedentemente getModulo() } Cosa accadrebbe al codice chiamante (ovvero al main.cpp )? Beh, chiaramente avremmo un errore in fase di compilazione! Adesso, come al solito, stiamo considerando casi abbastanza \"ristretti\"; qualora per\u00f2 dovessimo sviluppare delle grosse librerie, magari utilizzate da diversi sviluppatori (anche esterni), allora una qualsiasi modifica, anche di scarsa rilevanza come questa, potrebbe causare errori e problemi, con la conseguenza di richiedere tempo (e denaro) per la loro risoluzione. Ovviamente, ci sono casi in cui queste situazioni diventano inevitabili; tuttavia, \u00e8 sempre bene essere consapevoli di quelle che sono le proprie responsabilit\u00e0 nell'effettuare modifiche, ed attenersi quanto pi\u00f9 possibile alle best practices (che, in soldoni, ci chiedono di aderire il pi\u00f9 possibile al principio dell'incapsulamento)!","title":"Funzioni membro"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/06_metodi/#funzioni-inline","text":"Una possibile forma di ottimizzazione del codice prevede l'applicazione alle funzioni della parola chiave inline , rappresentativa di una direttiva al compilatore che, se eseguita, permette di sostituire nel codice compilato la chiamata a funzione con il corpo della stessa. Se da un lato questo pu\u00f2 migliorare le prestazioni, dall'altro ovviamente influenza le dimensioni dell'eseguibile finale, per cui va usata con un certo giudizio; inoltre, l'effettivo impatto sulle prestazioni dipende anche dal compilatore, che potrebbe anche ignorare (totalmente o in parte) la direttiva, o applicarla a metodi che non l'abbiano esplicitamente definita. La sintassi per la definizione di una generica funzione inline \u00e8 la seguente: inline int somma ( int a , int b ) { return a + b ; } int main () { somma ( 2 , 3 ); return 0 ; } E' ovviamente possibile definire un metodo inline direttamente in una classe. Per farlo, possiamo specificarlo nell'header; ad esempio: // geometria.h class Vettore { // ... public : inline double getModulo () { return this -> modulo ; } } Un altro modo \u00e8 specificarlo nel file sorgente, ad esempio: // geometria.h class Vettore { // ... public : double getModulo (); } // geometria.cpp // Dovremo ridefinirlo in ogni sorgente in cui lo utilizziamo! inline double Vettore :: getModulo () { return this -> modulo ; } Tuttavia, quando si definisce una funzione inline, \u00e8 necessario che il corpo della stessa sia presente in ogni unit\u00e0 di compilazione . Questo implica la necessit\u00e0 di includere la definizione del metodo inline o direttamente nell'header, oppure in ognuno dei file sorgenti in cui la funzione viene invocata. Scegliendo il secondo metodo, quindi, il nostro main assumer\u00e0 una forma del tipo: #include <iostream> #include \"geometria.h\" using namespace std ; // Rimuovendo questa definizione, avremo un errore di compilazione inline double Vettore :: getModulo () { return this -> modulo ; } int main () { Vettore v1 = new Vettore ( 10.0 , 45.0 ); cout << v1 . getModulo () << endl ; return 0 ; } Nota E' chiaro come entrambe le opzioni non siano esattamente \"ottimali\". Nel primo caso, infatti, stiamo violando uno dei principi della OOP, ovvero quello di incapsulamento, in quanto esponiamo all'interno di un interfaccia i dettagli dell'implementazione. Nel secondo, invece, dovremo ripetere il sorgente della funzione inline in ogni sorgente che la usa, con tutto ci\u00f2 che ne consegue in termini di possibili errori e prolissit\u00e0 del codice. Di conseguenza, l'uso di questa particolare tecnica di ottimizzazione deve rimanere confinato al campo del \"soltanto se indispensabile\".","title":"Funzioni inline"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/06_metodi/#funzioni-const","text":"Abbiamo visto gli effetti della parola chiave const quando applicata ad una variabile. Applicandola per\u00f2 alla firma di una funzione membro, avr\u00e0 l'effetto di inibire la modifica del membro stesso (ovviamente all'interno della funzione). In tal senso, l'esempio classico che \u00e8 possibile fare \u00e8 sui getter, che di solito vengono \"decorati\" con la keyword const per garantire che non vi siano effetti collaterali. Nel nostro caso: // geometria.h class Geometria :: Vettore { //... private : double modulo ; double angolo ; public : double getModulo () const ; double getAngolo () const ; // ... } // geometria.cpp double Vettore :: getModulo () const { return this -> modulo ; } double Vettore :: getAngolo () const { return this -> angolo ; }","title":"Funzioni const"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/06_metodi/#funzioni-static","text":"Le funzioni contrassegnate con la keyword static possono essere invocate senza la necessit\u00e0 di istanziare un oggetto della classe di appartenenza. Come conseguenza, si dice che i metodi statici sono relativi alla classe , e non alle singole istanze della stessa; ci\u00f2 comporta quindi che all'interno dei metodi statici ci si possa riferire esclusivamente agli attributi statici della classe. Supponiamo, ad esempio, di voler inserire un riferimento allo spazio cartesiano nel quale sono contenuti i nostri vettori; dato che questo risulta essere comune, potremo usare un attributo ed una funzione statici per ottenerli: // geometria.h class Punto { // ... } class Vettore { private : static Punto origine ; public : static Punto getOrigine (); } // geometria.cpp Punto Vettore :: getOrigine () { return origine ; } // main.cpp #include <iostream> #include \"geometria.h\" using namespace std ; int main () { cout << Vettore :: getOrigine () << endl ; return 0 ; } Alcune note: le funzioni membro static di una classe sono accessibili mediante l'uso dell'operatore di scope; il qualificatore static appare nella dichiarazione della funzione membro, ma non nella sua definizione; i metodi statici non possono essere contestualmente const .","title":"Funzioni static"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/06_metodi/#la-parola-chiave-friend","text":"Chiudiamo questa carrellata introducendo il modificatore friend , che pu\u00f2 essere assegnato a funzioni o classi che, pur non facendo parte dell'ambito della classe presso la quale vengono dichiarati, possono accedere ai membri della stessa indipendentemente dal qualificatore di accesso. Immaginiamo ad esempio di definire una classe SpazioVettoriale , che per motivi implementativi deve poter accedere ai singoli vettori che compongono la sua base. Potremo quindi definirla come classe friend del singolo vettore: // geometria.h class Vettore { private : // ... friend class SpazioVettoriale ; } In questo modo, la classe SpazioVettoriale potr\u00e0 accedere ai membri private dei vettori. Nota Questo esempio apperentemente va in contrasto con le regole di incapsulamento dettate dalla OOP. Tuttavia, ed in situazioni complesse, l'utilizzo di una funzione o classe friend pu\u00f2 risolvere numerosi grattacapi imposti da un'interpretazione troppo \"rigida\" dei dettami imposti dalla programmazione orientata agli oggetti.","title":"La parola chiave friend"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/07_ereditarieta/","text":"L'ereditariet\u00e0 \u00b6 Il concetto di ereditariet\u00e0 ci permette di \"comporre\" i dati presenti nei nostri programmi attraverso una gerarchia di classi . Possiamo pensare a questa gerarchia come ad una sorta di albero genealogico, con una classe \"radice\" da cui partono una o pi\u00f9 classi \"figlie\", o per meglio dire derivate , le quali poi possono a loro volta avere una o pi\u00f9 derivate, e cos\u00ec via. Oltre a questi rapporti \"padre-figlio\", \u00e8 importante sottolineare i concetti di generalizzazione e specializzazione . Infatti, ogni classe eredita i propri metodi dalla classe padre, di cui offre una versione pi\u00f9 \"specializzata\" verso determinati comportamenti; viceversa, la classe padre \u00e8 giocoforza pi\u00f9 generica , in quanto \u00e8 ad un maggior livello di astrazione rispetto alle figlie. Vediamo un esempio nella seguente figura. Nel nostro namespace Persona abbiamo definito un tipo generico (appunto, Persona ) da associare a tutte le possibili persone. E' chiaro come questa classe sia volutamente generica, in quanto, come abbiamo visto, specifica soltanto nome, cognome ed et\u00e0 di una persona, ed \u00e8 quindi in grado di \"rispondere\" ad un numero maggiore di necessit\u00e0 ad una classe meno generica. Possiamo quindi specializzare la classe Persona , andando a definire due sottoclassi che definiscono i diversi tipi di persone che \u00e8 possibile trovare all'interno di un Ateneo; per semplicit\u00e0, parleremo esclusivamente di Studenti e Personale . Sicuramente, ogni studente sar\u00e0 dotato di una serie di caratteristiche comuni, che possono essere ad esempio il numero di matricola, la mail istituzionale ed il libretto; in ugual modo, il personale avr\u00e0 altre caratteristiche, differenti da quelle degli studenti, ma comuni a quelle pi\u00f9 \"generiche\" che definiscono una persona, come ad esempio tipo di contratto, settore scientifico di appartenenza, materie insegnate, e via dicendo. La classe Studenti pu\u00f2 essere ulteriormente specializzata andando a considerare le Matricole , che godono di uno status particolare rispetto agli studenti fuori corso e degli anni successivi, mentre specializziamo la classe Personale in Docente ed Amministrativo . Questo esempio, che abbiamo mostrato nella figura precedente, ci aiuta a definire la cosidetta regola is-a , che afferma che: Regola is-a Ogni classe derivata \u00e8 un tipo particolare della classe base. Tornando al nostro esempio, risulter\u00e0 che: una Matricola \u00e8 sicuramente uno Studente , ma non tutte le istanze di Studente sono un'istanza di Matricola ; un Docente fa sicuramente parte del Personale , cos\u00ec come un Amministrativo , ma non tutto il Personale \u00e8 Docente o Amministrativo ; tutti le istanze di Studente e Personale sono sicuramente delle istanze di Persona , ma non \u00e8 vero il contrario. Seguire questa regola ci permette quindi, nei fatti, di implementare i meccanismi di ereditariet\u00e0 di cui necessitiamo a definire la nostra gerarchia di classi. Definire una classe derivata \u00b6 Abbiamo definito la classe Persona come base della nostra gerarchia di classi. Per prima cosa, quindi, cambiamo il modificatore dei nostri attributi da private a protected , in modo da accedervi direttamente dalle classi derivate. // persona.h class Persona { //... protected : string nome ; string cognome ; int eta ; } Definiamo adesso due classi derivate: come abbiamo detto, in primis definiamo Studente , e poi Personale . Per ognuna delle classi avremo un file header ed un sorgente definiti a parte. // persone.h namespace Persone { class Persona ; class Studente ; class Personale ; } // ... class Persone :: Studente : public Persona { protected : int matricola ; int * libretto ; public : Studente (); Studente ( string nome , string cognome , int eta , int matricola , int * libretto ); ~ Studente (); void setMatricola ( int matricola ); void setLibretto ( int * libretto ); int getMatricola (); int * getLibretto (); } class Persone :: Personale : public Persona { protected : int matricola ; string tipoContratto ; public : Personale (); Studente ( string nome , string cognome , int eta , int matricola , string libretto ); void setMatricola ( int matricola ); void setTipoContratto ( string tipoContratto ); int getMatricola (); string getTipoContratto (); } // persone.cpp // Costruttore di Studente Studente :: Studente () : Persona () { // implementazione } // Invocazione del costruttore della classe base Studente :: Studente ( string nome , string cognome , int eta , int matricola , int * libretto ) : Persona ( nome , cognome , eta ) { setMatricola ( matricola ); setLibretto ( libretto ); } I vincoli di ereditariet\u00e0 e specializzazione fanno ovviamente s\u00ec che le classi derivate ( Studente e Personale ) ereditino i membri e le funzioni della classe padre ( Persona ), per cui avranno accesso a nome, cognome ed et\u00e0. E' importante sottolinare il ruolo che ha l'invocazione delle funzioni della classe padre, e soprattutto dei costruttori: infatti, notiamo come l'implementazione del costruttore parametrizzato di Studente invochi esplicitamente uno dei costruttori parametrizzati di Persona passandogli i parametri richiesti in ingresso. Ereditariet\u00e0 pubblica, privata e protetta \u00b6 E' interessante notare come si sia utilizzato un modificatore di accesso per definire la tipologia di ereditariet\u00e0. La sua utilit\u00e0 si ripercuote nel fatto che C++ prevede diverse forme di ereditariet\u00e0, alcune delle quali si discostano dalla regola is-a. Infatti, il qualificatore usato per definrie il vincolo di ereditariet\u00e0 altera il livello di accesso di ogni membro della classe base nelle sue derivate. Infatti, un'ereditariet\u00e0 pubblica render\u00e0 accessibili dalla classe derivata tutti i membri (pubblici, protetti e privati) della classe padre, mentre un'ereditariet\u00e0 protetta o privata renderanno accessibili esclusivamente i livelli fino al protected o al private , rispettivamente. Membri privati della classe base Indipendentemente dal qualificatore scelto , i membri dichiarati come privati nella classe base non sono accessibili dalle classi derivate; Classi astratte \u00b6 In arrivo... Ereditariet\u00e0 multipla \u00b6 In arrivo...","title":"07 - Ereditariet\u00e0"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/07_ereditarieta/#lereditarieta","text":"Il concetto di ereditariet\u00e0 ci permette di \"comporre\" i dati presenti nei nostri programmi attraverso una gerarchia di classi . Possiamo pensare a questa gerarchia come ad una sorta di albero genealogico, con una classe \"radice\" da cui partono una o pi\u00f9 classi \"figlie\", o per meglio dire derivate , le quali poi possono a loro volta avere una o pi\u00f9 derivate, e cos\u00ec via. Oltre a questi rapporti \"padre-figlio\", \u00e8 importante sottolineare i concetti di generalizzazione e specializzazione . Infatti, ogni classe eredita i propri metodi dalla classe padre, di cui offre una versione pi\u00f9 \"specializzata\" verso determinati comportamenti; viceversa, la classe padre \u00e8 giocoforza pi\u00f9 generica , in quanto \u00e8 ad un maggior livello di astrazione rispetto alle figlie. Vediamo un esempio nella seguente figura. Nel nostro namespace Persona abbiamo definito un tipo generico (appunto, Persona ) da associare a tutte le possibili persone. E' chiaro come questa classe sia volutamente generica, in quanto, come abbiamo visto, specifica soltanto nome, cognome ed et\u00e0 di una persona, ed \u00e8 quindi in grado di \"rispondere\" ad un numero maggiore di necessit\u00e0 ad una classe meno generica. Possiamo quindi specializzare la classe Persona , andando a definire due sottoclassi che definiscono i diversi tipi di persone che \u00e8 possibile trovare all'interno di un Ateneo; per semplicit\u00e0, parleremo esclusivamente di Studenti e Personale . Sicuramente, ogni studente sar\u00e0 dotato di una serie di caratteristiche comuni, che possono essere ad esempio il numero di matricola, la mail istituzionale ed il libretto; in ugual modo, il personale avr\u00e0 altre caratteristiche, differenti da quelle degli studenti, ma comuni a quelle pi\u00f9 \"generiche\" che definiscono una persona, come ad esempio tipo di contratto, settore scientifico di appartenenza, materie insegnate, e via dicendo. La classe Studenti pu\u00f2 essere ulteriormente specializzata andando a considerare le Matricole , che godono di uno status particolare rispetto agli studenti fuori corso e degli anni successivi, mentre specializziamo la classe Personale in Docente ed Amministrativo . Questo esempio, che abbiamo mostrato nella figura precedente, ci aiuta a definire la cosidetta regola is-a , che afferma che: Regola is-a Ogni classe derivata \u00e8 un tipo particolare della classe base. Tornando al nostro esempio, risulter\u00e0 che: una Matricola \u00e8 sicuramente uno Studente , ma non tutte le istanze di Studente sono un'istanza di Matricola ; un Docente fa sicuramente parte del Personale , cos\u00ec come un Amministrativo , ma non tutto il Personale \u00e8 Docente o Amministrativo ; tutti le istanze di Studente e Personale sono sicuramente delle istanze di Persona , ma non \u00e8 vero il contrario. Seguire questa regola ci permette quindi, nei fatti, di implementare i meccanismi di ereditariet\u00e0 di cui necessitiamo a definire la nostra gerarchia di classi.","title":"L'ereditariet\u00e0"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/07_ereditarieta/#definire-una-classe-derivata","text":"Abbiamo definito la classe Persona come base della nostra gerarchia di classi. Per prima cosa, quindi, cambiamo il modificatore dei nostri attributi da private a protected , in modo da accedervi direttamente dalle classi derivate. // persona.h class Persona { //... protected : string nome ; string cognome ; int eta ; } Definiamo adesso due classi derivate: come abbiamo detto, in primis definiamo Studente , e poi Personale . Per ognuna delle classi avremo un file header ed un sorgente definiti a parte. // persone.h namespace Persone { class Persona ; class Studente ; class Personale ; } // ... class Persone :: Studente : public Persona { protected : int matricola ; int * libretto ; public : Studente (); Studente ( string nome , string cognome , int eta , int matricola , int * libretto ); ~ Studente (); void setMatricola ( int matricola ); void setLibretto ( int * libretto ); int getMatricola (); int * getLibretto (); } class Persone :: Personale : public Persona { protected : int matricola ; string tipoContratto ; public : Personale (); Studente ( string nome , string cognome , int eta , int matricola , string libretto ); void setMatricola ( int matricola ); void setTipoContratto ( string tipoContratto ); int getMatricola (); string getTipoContratto (); } // persone.cpp // Costruttore di Studente Studente :: Studente () : Persona () { // implementazione } // Invocazione del costruttore della classe base Studente :: Studente ( string nome , string cognome , int eta , int matricola , int * libretto ) : Persona ( nome , cognome , eta ) { setMatricola ( matricola ); setLibretto ( libretto ); } I vincoli di ereditariet\u00e0 e specializzazione fanno ovviamente s\u00ec che le classi derivate ( Studente e Personale ) ereditino i membri e le funzioni della classe padre ( Persona ), per cui avranno accesso a nome, cognome ed et\u00e0. E' importante sottolinare il ruolo che ha l'invocazione delle funzioni della classe padre, e soprattutto dei costruttori: infatti, notiamo come l'implementazione del costruttore parametrizzato di Studente invochi esplicitamente uno dei costruttori parametrizzati di Persona passandogli i parametri richiesti in ingresso.","title":"Definire una classe derivata"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/07_ereditarieta/#ereditarieta-pubblica-privata-e-protetta","text":"E' interessante notare come si sia utilizzato un modificatore di accesso per definire la tipologia di ereditariet\u00e0. La sua utilit\u00e0 si ripercuote nel fatto che C++ prevede diverse forme di ereditariet\u00e0, alcune delle quali si discostano dalla regola is-a. Infatti, il qualificatore usato per definrie il vincolo di ereditariet\u00e0 altera il livello di accesso di ogni membro della classe base nelle sue derivate. Infatti, un'ereditariet\u00e0 pubblica render\u00e0 accessibili dalla classe derivata tutti i membri (pubblici, protetti e privati) della classe padre, mentre un'ereditariet\u00e0 protetta o privata renderanno accessibili esclusivamente i livelli fino al protected o al private , rispettivamente. Membri privati della classe base Indipendentemente dal qualificatore scelto , i membri dichiarati come privati nella classe base non sono accessibili dalle classi derivate;","title":"Ereditariet\u00e0 pubblica, privata e protetta"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/07_ereditarieta/#classi-astratte","text":"In arrivo...","title":"Classi astratte"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/07_ereditarieta/#ereditarieta-multipla","text":"In arrivo...","title":"Ereditariet\u00e0 multipla"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/08_polimorfismo/","text":"Il polimorfismo \u00b6 Concetto di polimorfismo \u00b6 In arrivo... Metodi veirtuali \u00b6 In arrivo...","title":"08 - Polimorfismo"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/08_polimorfismo/#il-polimorfismo","text":"","title":"Il polimorfismo"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/08_polimorfismo/#concetto-di-polimorfismo","text":"In arrivo...","title":"Concetto di polimorfismo"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/08_polimorfismo/#metodi-veirtuali","text":"In arrivo...","title":"Metodi veirtuali"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/","text":"Container \u00b6 I container sono uno tra i costrutti pi\u00f9 utilizzati nel C++. Non ne esiste un unico esempio; piuttosto, sono una serie di strutture dati che si prestano alla gestione di insiemi, o collezioni , di dati, offrendo funzionalit\u00e0 semplificate per inserimento , estrazione e cancellazione . Esistono container per praticamente ogni struttura dati che abbiamo visto finora, partendo dagli array, passando per le liste, fino ad arrivare a strutture pi\u00f9 complesse come le hashmap. Nota I container sono un esempio di template C++. Questo si traduce nel fatto che possono essere usati per memorizzare elementi di tipo arbitrario, a patto che questo tipo esista e sia specificato a priori. Tipi un container \u00b6 I container pi\u00f9 utilizzati sono contenuti nella Standard Template Library , e ne esistono tre tipi, a seconda del caso d'uso cui si riferiscono. Sequence container \u00b6 Questo tipo di container agisce su delle sequenze di dati, ordinandoli, inserendoli ed estraendoli in base agli indirizzi di memoria degli elementi contenuti nel container. E' importante sottolineare che questo tipo di container assicura un accesso sequenziale ai dati contenuti. I sequence container della STL sono: array , riconducibile al classico concetto di array visto finora, ovvero di vettore (non ridimensionabile); vector , che possiamo immaginare una versione \"migliorata\" dell'array, implementante tecniche di accesso casuale e ridimensionabile a seguito dell'aggiunta di elementi; deque , implementa una coda doppia; list , che implementa una doubly linked list , ovvero una linked list che incorpora un riferimento sia all'elemento precedente sia a quello successivo; forward_list , che implementa una linked list standard. Associative container \u00b6 I container associativi permettono di implementare delle strutture dati chiamate array associativi , conosciuti anche come dizionari . Come suggerisce il nome stesso, un dizionario \u00e8 una struttura dati estremamente utile per accedere al valore dei dati conoscendone la chiave . Pensiamo, ad esempio, ad un classico dizionario: per risalire al significato di una qualsiasi parola (il valore ricercato), baster\u00e0 conoscere la parola stessa (la chiave). Questo tipo di struttura \u00e8 molto utilizzato soprattutto in linguaggi come Python e JavaScript, nei quali \u00e8 direttamente associato alla definizione di oggetto. La STL offre quattro tipi di associative container: set viene usato nei casi in cui \u00e8 necessario memorizzare soltanto un valore, ovvero la chiave; map viene usato nei casi in cui \u00e8 necessario memorizzare una coppia di valori, ovvero la classica coppia chiave/valore; multiset \u00e8 una variante di set usata qualora ci siano delle chiavi ripetute; multimap \u00e8 una variante di map usata qualora ci siano coppie chiave-valore ripetute. E' importante notare che i container associativi seguono il concetto di strict weak ordering , che dice che: \\(\\forall(a, b)\\) , se \\(\\ a \\leq b\\) allora \\(\\ b \\leq a\\) non \u00e8 valida, e viceversa; se \\(a \\leq b\\) e \\(b \\leq a\\) , allora \\(a \\sim b\\) ; se \\(a \\leq b\\) , e \\(b \\leq c\\) , allora \\(a \\leq c\\) ; se \\(a \\sim b\\) , e \\(b \\sim c\\) , allora \\(a \\sim c\\) ; se \\(a \\leq b\\) , e \\(a \\not\\sim b\\) , allora \\(a\\) precede \\(b\\) , ovvero \\(a < b\\) . Nota clarificatrice In buona sostanza, i container associativi sono ordinati. Unordered associative container \u00b6 I container associativi non ordinati hanno delle applicazioni molto simili a quelle dei container associativi, ma non ordinano gli elementi memorizzati. Ve ne sono quattro tipi, del tutto equivalenti alle loro controparti ordinate, ovvero hash_set , hash_map , hash_multimap ed hash_multiset . Container associativi ordinati vs. non ordinati Apparentemente, sembrerebbe che non ci sia un motivo valido per preferire un container non ordinato, diciamo una hash_map , al suo equivalente ordinato. Dobbiamo per\u00f2 considerare il motivo per cui una hash_map non memorizza i dati in maniera ordinata: questo, infatti, avviene a causa del fatto che ne memorizza una rappresentazione compressa , chiamata hash . La scelta tra i due tipi dipende dalle performance richieste: una hash_map offre vantaggi in termini di performance, ma la map ha delle caratteristiche utili in caso di necessit\u00e0 di iterazione ordinata degli elementi, come ad esempio in certi algoritmi su grafi. Un esempio \u00b6 Vediamo un semplice esempio di definizione di un container di tipo vector su elementi interi. // main.cpp #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; cout << \"Itero usando la un valore massimo predefinito.\" << endl ; for ( int i = 0 ; i < 10 ; i ++ ) { cout << vettore [ i ] << endl ; } cout << \"Itero usando la funzione size.\" << endl ; for ( int i = 0 ; i < v . size (); i ++ ) { cout << vettore [ i ] << endl ; } return 0 ; } Iteratori \u00b6 Un iteratore \u00e8 un'entit\u00e0 preposta alla scansione degli elementi di un container. Ovviamente, il vantaggio dell'utilizzo di un iterator sta nel fatto che il programmatore non \u00e8 pi\u00f9 vincolato alla conoscenza dettagliata delle caratteristiche dello specifico container (uno tra tutti, la dimensione), ma pu\u00f2 piuttosto generalizzare i metodi definiti. Vediamo come si usano. Immaginiamo di partire da un normale array, acceduto con un classico ciclo for : int [ 10 ] vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; for ( int i = 0 ; i < 10 ; i ++ ) { cout << vettore [ i ] << endl ; } Abbiamo visto che usare un container come vector permette di astrarci dalla dimensione fissa dell'array: vector < int > vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; for ( int i = 0 ; i < vettore . size (); i ++ ) { cout << vettore [ i ] << endl ; } Un iterator si usa in modo molto simile: infatti, viene definito sul container di interesse, associato ad un elemento da cui inizia ad iterare, e prosegue fino al verificarsi di una condizione di arresto. Ad esempio: vector < int > vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; for ( vector < int >:: iterator it = vettore . begin (); it != vettore . end (); it ++ ) { cout << * it << endl ; } Notiamo come l'iterator it venga inizializzato sulla prima posizione del container vettore grazie al metodo begin() , mentre la condizione di terminazione si verifica quando l'iteratore si trova alla fine del container (metodo end() ); non facciamo in alcun modo riferimento al numero di elementi contenuti nel container . Quest'ultima considerazione \u00e8 critica soprattutto quando abbiamo a che fare con container associativi, in quanto \u00e8 estremamente pi\u00f9 comodo usare un iteratore per accedere sequenzialmente agli elementi contenuti. Notiamo infine come l'iteratore in realt\u00e0 punti all'area di memoria del singolo elemento, e supporti l'operazione di incremento ( it++ ); ovviamente, tale incremento fa s\u00ec che si passi all'elemento successivo del container. La potenza delle interfacce La STL \u00e8 dotata di un'interfaccia quanto pi\u00f9 omogenea, per cui \u00e8 possibile usare questi stessi metodi sulla maggior parte dei container disponibili. Ad esempio, potremo replicare questo codice \"as is\" passando da vector a list (passare a container associativi richiede qualche ulteriore modifica). La potenza delle interfacce - parte 2 Se invece volessimo adattare il codice che sfrutta un approccio pi\u00f9 \"classico\", senza iteratori per capirci, all'accesso ai membri di una lista, dovremmo innanzitutto considerare due criticit\u00e0: in primis, le liste non supportano l'operatore [] per l'accesso diretto, e poi il metodo size() risulta essere pi\u00f9 oneroso rispetto all'omonimo sul vector , in quanto nel primo caso occorre fare una scansione sequenziale preliminare dell'intera lista, mentre nel secondo basta conoscere la dimensione in memoria ed il tipo del vettore.","title":"09 - Container ed iteratori"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/#container","text":"I container sono uno tra i costrutti pi\u00f9 utilizzati nel C++. Non ne esiste un unico esempio; piuttosto, sono una serie di strutture dati che si prestano alla gestione di insiemi, o collezioni , di dati, offrendo funzionalit\u00e0 semplificate per inserimento , estrazione e cancellazione . Esistono container per praticamente ogni struttura dati che abbiamo visto finora, partendo dagli array, passando per le liste, fino ad arrivare a strutture pi\u00f9 complesse come le hashmap. Nota I container sono un esempio di template C++. Questo si traduce nel fatto che possono essere usati per memorizzare elementi di tipo arbitrario, a patto che questo tipo esista e sia specificato a priori.","title":"Container"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/#tipi-un-container","text":"I container pi\u00f9 utilizzati sono contenuti nella Standard Template Library , e ne esistono tre tipi, a seconda del caso d'uso cui si riferiscono.","title":"Tipi un container"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/#sequence-container","text":"Questo tipo di container agisce su delle sequenze di dati, ordinandoli, inserendoli ed estraendoli in base agli indirizzi di memoria degli elementi contenuti nel container. E' importante sottolineare che questo tipo di container assicura un accesso sequenziale ai dati contenuti. I sequence container della STL sono: array , riconducibile al classico concetto di array visto finora, ovvero di vettore (non ridimensionabile); vector , che possiamo immaginare una versione \"migliorata\" dell'array, implementante tecniche di accesso casuale e ridimensionabile a seguito dell'aggiunta di elementi; deque , implementa una coda doppia; list , che implementa una doubly linked list , ovvero una linked list che incorpora un riferimento sia all'elemento precedente sia a quello successivo; forward_list , che implementa una linked list standard.","title":"Sequence container"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/#associative-container","text":"I container associativi permettono di implementare delle strutture dati chiamate array associativi , conosciuti anche come dizionari . Come suggerisce il nome stesso, un dizionario \u00e8 una struttura dati estremamente utile per accedere al valore dei dati conoscendone la chiave . Pensiamo, ad esempio, ad un classico dizionario: per risalire al significato di una qualsiasi parola (il valore ricercato), baster\u00e0 conoscere la parola stessa (la chiave). Questo tipo di struttura \u00e8 molto utilizzato soprattutto in linguaggi come Python e JavaScript, nei quali \u00e8 direttamente associato alla definizione di oggetto. La STL offre quattro tipi di associative container: set viene usato nei casi in cui \u00e8 necessario memorizzare soltanto un valore, ovvero la chiave; map viene usato nei casi in cui \u00e8 necessario memorizzare una coppia di valori, ovvero la classica coppia chiave/valore; multiset \u00e8 una variante di set usata qualora ci siano delle chiavi ripetute; multimap \u00e8 una variante di map usata qualora ci siano coppie chiave-valore ripetute. E' importante notare che i container associativi seguono il concetto di strict weak ordering , che dice che: \\(\\forall(a, b)\\) , se \\(\\ a \\leq b\\) allora \\(\\ b \\leq a\\) non \u00e8 valida, e viceversa; se \\(a \\leq b\\) e \\(b \\leq a\\) , allora \\(a \\sim b\\) ; se \\(a \\leq b\\) , e \\(b \\leq c\\) , allora \\(a \\leq c\\) ; se \\(a \\sim b\\) , e \\(b \\sim c\\) , allora \\(a \\sim c\\) ; se \\(a \\leq b\\) , e \\(a \\not\\sim b\\) , allora \\(a\\) precede \\(b\\) , ovvero \\(a < b\\) . Nota clarificatrice In buona sostanza, i container associativi sono ordinati.","title":"Associative container"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/#unordered-associative-container","text":"I container associativi non ordinati hanno delle applicazioni molto simili a quelle dei container associativi, ma non ordinano gli elementi memorizzati. Ve ne sono quattro tipi, del tutto equivalenti alle loro controparti ordinate, ovvero hash_set , hash_map , hash_multimap ed hash_multiset . Container associativi ordinati vs. non ordinati Apparentemente, sembrerebbe che non ci sia un motivo valido per preferire un container non ordinato, diciamo una hash_map , al suo equivalente ordinato. Dobbiamo per\u00f2 considerare il motivo per cui una hash_map non memorizza i dati in maniera ordinata: questo, infatti, avviene a causa del fatto che ne memorizza una rappresentazione compressa , chiamata hash . La scelta tra i due tipi dipende dalle performance richieste: una hash_map offre vantaggi in termini di performance, ma la map ha delle caratteristiche utili in caso di necessit\u00e0 di iterazione ordinata degli elementi, come ad esempio in certi algoritmi su grafi.","title":"Unordered associative container"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/#un-esempio","text":"Vediamo un semplice esempio di definizione di un container di tipo vector su elementi interi. // main.cpp #include <iostream> #include <vector> using namespace std ; int main () { vector < int > vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; cout << \"Itero usando la un valore massimo predefinito.\" << endl ; for ( int i = 0 ; i < 10 ; i ++ ) { cout << vettore [ i ] << endl ; } cout << \"Itero usando la funzione size.\" << endl ; for ( int i = 0 ; i < v . size (); i ++ ) { cout << vettore [ i ] << endl ; } return 0 ; }","title":"Un esempio"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/09_container/#iteratori","text":"Un iteratore \u00e8 un'entit\u00e0 preposta alla scansione degli elementi di un container. Ovviamente, il vantaggio dell'utilizzo di un iterator sta nel fatto che il programmatore non \u00e8 pi\u00f9 vincolato alla conoscenza dettagliata delle caratteristiche dello specifico container (uno tra tutti, la dimensione), ma pu\u00f2 piuttosto generalizzare i metodi definiti. Vediamo come si usano. Immaginiamo di partire da un normale array, acceduto con un classico ciclo for : int [ 10 ] vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; for ( int i = 0 ; i < 10 ; i ++ ) { cout << vettore [ i ] << endl ; } Abbiamo visto che usare un container come vector permette di astrarci dalla dimensione fissa dell'array: vector < int > vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; for ( int i = 0 ; i < vettore . size (); i ++ ) { cout << vettore [ i ] << endl ; } Un iterator si usa in modo molto simile: infatti, viene definito sul container di interesse, associato ad un elemento da cui inizia ad iterare, e prosegue fino al verificarsi di una condizione di arresto. Ad esempio: vector < int > vettore = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; for ( vector < int >:: iterator it = vettore . begin (); it != vettore . end (); it ++ ) { cout << * it << endl ; } Notiamo come l'iterator it venga inizializzato sulla prima posizione del container vettore grazie al metodo begin() , mentre la condizione di terminazione si verifica quando l'iteratore si trova alla fine del container (metodo end() ); non facciamo in alcun modo riferimento al numero di elementi contenuti nel container . Quest'ultima considerazione \u00e8 critica soprattutto quando abbiamo a che fare con container associativi, in quanto \u00e8 estremamente pi\u00f9 comodo usare un iteratore per accedere sequenzialmente agli elementi contenuti. Notiamo infine come l'iteratore in realt\u00e0 punti all'area di memoria del singolo elemento, e supporti l'operazione di incremento ( it++ ); ovviamente, tale incremento fa s\u00ec che si passi all'elemento successivo del container. La potenza delle interfacce La STL \u00e8 dotata di un'interfaccia quanto pi\u00f9 omogenea, per cui \u00e8 possibile usare questi stessi metodi sulla maggior parte dei container disponibili. Ad esempio, potremo replicare questo codice \"as is\" passando da vector a list (passare a container associativi richiede qualche ulteriore modifica). La potenza delle interfacce - parte 2 Se invece volessimo adattare il codice che sfrutta un approccio pi\u00f9 \"classico\", senza iteratori per capirci, all'accesso ai membri di una lista, dovremmo innanzitutto considerare due criticit\u00e0: in primis, le liste non supportano l'operatore [] per l'accesso diretto, e poi il metodo size() risulta essere pi\u00f9 oneroso rispetto all'omonimo sul vector , in quanto nel primo caso occorre fare una scansione sequenziale preliminare dell'intera lista, mentre nel secondo basta conoscere la dimensione in memoria ed il tipo del vettore.","title":"Iteratori"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/","text":"La gestione dei file in C++ \u00b6 La gestione dei file in C++ (e, ovviamente, dei relativi stream di I/O) ricalca in parte il modello usato per il C, con delle classi specifiche per l'interazione con il file system, ovvero ofstream (usata per le operazioni di sola scrittura), ifstream (usata per le operazioni di sola lettura), ed fstream (usata per entrambi i tipi di operazioni). Proprio come nel C vi \u00e8 un'analogia tra, ad esempio, printf ed fprintf , nel C++ troviamo numerose analogie tra le classi prima citate e le classi ostream ed istream , che ricordiamo essere delegate alla gestione dell'I/O da riga di comando. Nota Queste \"analogie\" sono rese possibili dal fatto che in realt\u00e0 ofstream ed ifstream sono classi derivate da ostream ed istream , mentre fstream deriva da iostream , a sua volta classe derivata da istream ed ostream . Vediamo brevemente un paio di esempi. Esempio 1: Copia di file riga per riga \u00b6 Un caso comune \u00e8 quello che riguarda la copia di un file di testo riga per riga. Immaginiamo quindi di avere un file di testo in input (al solito, chiamiamolo input.txt ), e volerlo copiare (quindi, leggere riga per riga, e scrivere il contenuto su un altro file). Chiameremo il file di output output.txt . Per la prima parte, useremo la classe ifstream , mentre per la seconda parte la classe ostream . Header e namespace \u00b6 Per prima cosa, ricordiamoci di includere gli header necessari, e di specificare l'utilizzo del namespace std : #include <fstream> #include <iostream> #include <string> using namespace std ; Step 1: Apertura del file in input \u00b6 Fatto questo, dovremo istanziare un oggetto di classe ifstream . Utilizziamo la sintassi seguente: // Header int main () { ifstream input ( \"input.txt\" ) // ... } L'istruzione \u00e8 alquanto semplice da interpretare: stiamo infatti creando una variabile input associata ad un oggetto di classe ifstream che si occupa di leggere il contenuto del file input.txt . Step 2: Verifica dell'esistenza del file \u00b6 I pi\u00f9 attenti avranno notato che, a differenza del C, dove si usava una verifica del valore restituito dalla fopen per appurare che il file esistesse, qui non abbiamo effettuato alcun controllo. In realt\u00e0, questo non avrebbe molto senso: stiamo comunque creando una variabile di classe ifstream , e ci\u00f2 non dipende dal valore passato (sotto forma peraltro di stringa) al costruttore. Come fare, quindi? Una soluzione \u00e8 quella di verificare la possibilit\u00e0 di aprire il file mediante la funzione is_open() . Questa funzione infatti ci indica se il file \u00e8 stato correttamente aperto e, ovviamente, qualora questo non sia avvenuto, potremo tranquillamente desumere che il file non esiste, o che vi \u00e8 stato un qualche altro tipo di problema. Modifichiamo quindi il nostro codice come segue: // Header int main () { ifstream input ( \"input.txt\" ) if ( intput . is_open ()) { cout << \"Il file esiste!\" ; } else { cout << \"Il file non esiste!\" ; } // ... } Nota Effettueremo un controllo analogo anche sui file in apertura. Step 3: Apertura del file in output \u00b6 Possiamo quindi passare ad aprire il file su cui andremo a copiare i contenuti del file di input. Per farlo, creeremo una variabile di classe ofstream , che chiameremo output , e che creer\u00e0 (se non esiste) il file output.txt . Verificheremo anche che il file sia stato effettivamente creato richiamando il metodo is_open() : // Header int main () { // ... if ( input . is_open ()) { // ... ofstream output ( \"output.txt\" ); if ( output . is_open ()) { // ... } } // ... } Nota Di default, ofstream apre i file in modalit\u00e0 truncate , il che significa che il contenuto esistente del file sar\u00e0 sovrascritto. E' tuttavia possibile specificare, come nel C, la modalit\u00e0 di apertura del file, tra quelle definite nella libreria standard C++ . Step 4: Copia del file riga per riga \u00b6 Modifichiamo l'istruzione precedentemente alla riga 8 (ovvero, l'istruzione condizionale annidata) in questo modo: // Header int main () { // ... if ( output . is_open ()) { string line ; int row = 1 ; while ( getline ( input , line ) && output . good ()) { output << line << endl ; cout << \"Linea \" << row << \" copiata\" << endl ; row ++ ; } output . close (); } // ... } In primis, notiamo l'utilizzo della funzione getline() , che accetta in ingresso la variabile input ed una stringa, che chiameremo line , e che rappresenta un contenitore per il contenuto della riga specifica. Di norma, la getline() restituisce un riferimento allo stream passato come argomento (ovvero input ); tuttavia, nel nostro caso, lo useremo come valore booleano per valutare l'effettiva esistenza dello stream. Inoltre, usiamo il metodo good() sullo stream relativo all'oggetto output , in modo da verificarne lo stato. L'unico fattore di nota all'interno del ciclo while \u00e8 legato al fatto che utilizziamo lo stream relativo all'oggetto output esattamente allo stesso modo in cui usiamo lo stream relativo all'output su riga di comando. Nello specifico, dopo aver copiato l'i-ma riga del file input.txt in output.txt , manderemo su riga di comando un messaggio di conferma dell'avvenuta copia della riga. Notiamo infine il metodo close() , che serve per chiudere un file (e rilasciare le relative risorse occupate). Nota Il metodo close() va chiamato su ogni variabile associata ad uno stream su file . Ergo, anche sul file che sta venendo letto! Codice completo \u00b6 Il codice completo per la copia del file \u00e8 mostrato di seguito. #include <iostream> #include <fstream> #include <string> using namespace std ; int main () { ifstream input ( \"inpput.txt\" ); if ( input . is_open ()) { cout << \"File letto correttamente.\" << endl ; ofstream output ( \"output.txt\" ); if ( output . is_open ()) { string line ; int row = 1 ; while ( getline ( input , line ) && output . good ()) { output << line << endl ; cout << \"Linea \" << row << \" copiata\" << endl ; row ++ ; } output . close (); } input . close (); } else { cout << \"Errore nella lettura del file.\" ; exit ( EXIT_FAILURE ); } exit ( EXIT_SUCCESS ); } Esempio 2: Copia carattere per carattere \u00b6 Un altro esempio \u00e8 quello che vede la copia di un file carattere per carattere. Notiamo che gli step 1 - 3 di questo esempio sono analoghi a quelli dell'esempio precedente, a meno del mancato utilizzo dell'header string , questa volta non necessario. Di conseguenza, rivediamo esclusivamente lo step 4. Step 4: Copia del file carattere per carattere \u00b6 La parte interessata dalle modifiche \u00e8 quella evidenziata nel listato successivo. #include <fstream> #include <iostream> using namespace std ; int main () { ifstream input ( \"input.txt\" ); if ( input . is_open ()) { ofstream output ( \"output.txt\" ); if ( output . is_open ()) { char c = NULL ; while ( input . get ( c ) && output . good ()) { if ( output . put ( c )) { cout << \"Carattere \" << c << \" copiato\" << endl ; } else { cout << \"Impossibile copiare il carattere \" << c << endl ; exit ( EXIT_FAILURE ); } } output . close (); } else { cout << \"Errore di I/O sul file di output.\" << endl ; exit ( EXIT_FAILURE ); } input . close (); } else { cout << \"Errore di I/O sul file di input.\" << endl ; exit ( EXIT_FAILURE ); } exit ( EXIT_SUCCESS ); } Notiamo innanzitutto la funzione get() che, in maniera simile alla getline() , scandisce il file associato alla variabile input , questa volta carattere per carattere. Notiamo una differenza: laddove la getline() prende due parametri in ingresso, la get() viene chiamata direttamente sulla variabile associata al file di input, ed accetta come parametro esclusivamente il riferimento al carattere attualmente scandito. Dopo la get() , troviamo una chiamata alla funzione \"duale\", ovvero la put() , che (prevedibilmente) si occupa di scrivere il carattere passato in ingresso sul file di output. Bonus: combinare i due esempi \u00b6 Di seguito il codice per un possibile approccio alla combinazione dei due esempi precedenti. #include <iostream> #include <fstream> #include <string> using namespace std ; // Funzione per la copia carattere per carattere. Ricordare il passaggio per reference! void char_copy ( ifstream & input , ofstream & output ) { char c = NULL ; while ( input . get ( c ) && output . good ()) { if ( output . put ( c )) { cout << \"Carattere \" << c << \" copiato\" << endl ; } else { cout << \"Impossibile copiare il carattere \" << c << endl ; exit ( EXIT_FAILURE ); } } } // Funzione per la copia riga per riga. Ricordare il passaggio per reference! void row_copy ( ifstream & input , ofstream & output ) { string line ; int row = 1 ; while ( getline ( input , line ) && output . good ()) { output << line << endl ; cout << \"Linea \" << row << \" copiata\" << endl ; row ++ ; } } int main () { cout << \"Inserire 0 per lettura riga a riga, ed 1 per lettura carattere per carattere.\" << endl ; bool char_or_row = false ; cin >> char_or_row ; ifstream input ( \"input.txt\" ); if ( input . is_open ()) { ofstream output ( \"output.txt\" ); if ( output . is_open ()) { if ( char_or_row ) { char_copy ( input , output ); } else { row_copy ( input , output ); } } else { cout << \"Errore di I/O sul file di output.\" << endl ; exit ( EXIT_FAILURE ); } input . close (); } else { cout << \"Errore di I/O sul file di input.\" << endl ; exit ( EXIT_FAILURE ); } exit ( EXIT_SUCCESS ); }","title":"10 - File in C++"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#la-gestione-dei-file-in-c","text":"La gestione dei file in C++ (e, ovviamente, dei relativi stream di I/O) ricalca in parte il modello usato per il C, con delle classi specifiche per l'interazione con il file system, ovvero ofstream (usata per le operazioni di sola scrittura), ifstream (usata per le operazioni di sola lettura), ed fstream (usata per entrambi i tipi di operazioni). Proprio come nel C vi \u00e8 un'analogia tra, ad esempio, printf ed fprintf , nel C++ troviamo numerose analogie tra le classi prima citate e le classi ostream ed istream , che ricordiamo essere delegate alla gestione dell'I/O da riga di comando. Nota Queste \"analogie\" sono rese possibili dal fatto che in realt\u00e0 ofstream ed ifstream sono classi derivate da ostream ed istream , mentre fstream deriva da iostream , a sua volta classe derivata da istream ed ostream . Vediamo brevemente un paio di esempi.","title":"La gestione dei file in C++"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#esempio-1-copia-di-file-riga-per-riga","text":"Un caso comune \u00e8 quello che riguarda la copia di un file di testo riga per riga. Immaginiamo quindi di avere un file di testo in input (al solito, chiamiamolo input.txt ), e volerlo copiare (quindi, leggere riga per riga, e scrivere il contenuto su un altro file). Chiameremo il file di output output.txt . Per la prima parte, useremo la classe ifstream , mentre per la seconda parte la classe ostream .","title":"Esempio 1: Copia di file riga per riga"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#header-e-namespace","text":"Per prima cosa, ricordiamoci di includere gli header necessari, e di specificare l'utilizzo del namespace std : #include <fstream> #include <iostream> #include <string> using namespace std ;","title":"Header e namespace"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#step-1-apertura-del-file-in-input","text":"Fatto questo, dovremo istanziare un oggetto di classe ifstream . Utilizziamo la sintassi seguente: // Header int main () { ifstream input ( \"input.txt\" ) // ... } L'istruzione \u00e8 alquanto semplice da interpretare: stiamo infatti creando una variabile input associata ad un oggetto di classe ifstream che si occupa di leggere il contenuto del file input.txt .","title":"Step 1: Apertura del file in input"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#step-2-verifica-dellesistenza-del-file","text":"I pi\u00f9 attenti avranno notato che, a differenza del C, dove si usava una verifica del valore restituito dalla fopen per appurare che il file esistesse, qui non abbiamo effettuato alcun controllo. In realt\u00e0, questo non avrebbe molto senso: stiamo comunque creando una variabile di classe ifstream , e ci\u00f2 non dipende dal valore passato (sotto forma peraltro di stringa) al costruttore. Come fare, quindi? Una soluzione \u00e8 quella di verificare la possibilit\u00e0 di aprire il file mediante la funzione is_open() . Questa funzione infatti ci indica se il file \u00e8 stato correttamente aperto e, ovviamente, qualora questo non sia avvenuto, potremo tranquillamente desumere che il file non esiste, o che vi \u00e8 stato un qualche altro tipo di problema. Modifichiamo quindi il nostro codice come segue: // Header int main () { ifstream input ( \"input.txt\" ) if ( intput . is_open ()) { cout << \"Il file esiste!\" ; } else { cout << \"Il file non esiste!\" ; } // ... } Nota Effettueremo un controllo analogo anche sui file in apertura.","title":"Step 2: Verifica dell'esistenza del file"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#step-3-apertura-del-file-in-output","text":"Possiamo quindi passare ad aprire il file su cui andremo a copiare i contenuti del file di input. Per farlo, creeremo una variabile di classe ofstream , che chiameremo output , e che creer\u00e0 (se non esiste) il file output.txt . Verificheremo anche che il file sia stato effettivamente creato richiamando il metodo is_open() : // Header int main () { // ... if ( input . is_open ()) { // ... ofstream output ( \"output.txt\" ); if ( output . is_open ()) { // ... } } // ... } Nota Di default, ofstream apre i file in modalit\u00e0 truncate , il che significa che il contenuto esistente del file sar\u00e0 sovrascritto. E' tuttavia possibile specificare, come nel C, la modalit\u00e0 di apertura del file, tra quelle definite nella libreria standard C++ .","title":"Step 3: Apertura del file in output"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#step-4-copia-del-file-riga-per-riga","text":"Modifichiamo l'istruzione precedentemente alla riga 8 (ovvero, l'istruzione condizionale annidata) in questo modo: // Header int main () { // ... if ( output . is_open ()) { string line ; int row = 1 ; while ( getline ( input , line ) && output . good ()) { output << line << endl ; cout << \"Linea \" << row << \" copiata\" << endl ; row ++ ; } output . close (); } // ... } In primis, notiamo l'utilizzo della funzione getline() , che accetta in ingresso la variabile input ed una stringa, che chiameremo line , e che rappresenta un contenitore per il contenuto della riga specifica. Di norma, la getline() restituisce un riferimento allo stream passato come argomento (ovvero input ); tuttavia, nel nostro caso, lo useremo come valore booleano per valutare l'effettiva esistenza dello stream. Inoltre, usiamo il metodo good() sullo stream relativo all'oggetto output , in modo da verificarne lo stato. L'unico fattore di nota all'interno del ciclo while \u00e8 legato al fatto che utilizziamo lo stream relativo all'oggetto output esattamente allo stesso modo in cui usiamo lo stream relativo all'output su riga di comando. Nello specifico, dopo aver copiato l'i-ma riga del file input.txt in output.txt , manderemo su riga di comando un messaggio di conferma dell'avvenuta copia della riga. Notiamo infine il metodo close() , che serve per chiudere un file (e rilasciare le relative risorse occupate). Nota Il metodo close() va chiamato su ogni variabile associata ad uno stream su file . Ergo, anche sul file che sta venendo letto!","title":"Step 4: Copia del file riga per riga"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#codice-completo","text":"Il codice completo per la copia del file \u00e8 mostrato di seguito. #include <iostream> #include <fstream> #include <string> using namespace std ; int main () { ifstream input ( \"inpput.txt\" ); if ( input . is_open ()) { cout << \"File letto correttamente.\" << endl ; ofstream output ( \"output.txt\" ); if ( output . is_open ()) { string line ; int row = 1 ; while ( getline ( input , line ) && output . good ()) { output << line << endl ; cout << \"Linea \" << row << \" copiata\" << endl ; row ++ ; } output . close (); } input . close (); } else { cout << \"Errore nella lettura del file.\" ; exit ( EXIT_FAILURE ); } exit ( EXIT_SUCCESS ); }","title":"Codice completo"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#esempio-2-copia-carattere-per-carattere","text":"Un altro esempio \u00e8 quello che vede la copia di un file carattere per carattere. Notiamo che gli step 1 - 3 di questo esempio sono analoghi a quelli dell'esempio precedente, a meno del mancato utilizzo dell'header string , questa volta non necessario. Di conseguenza, rivediamo esclusivamente lo step 4.","title":"Esempio 2: Copia carattere per carattere"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#step-4-copia-del-file-carattere-per-carattere","text":"La parte interessata dalle modifiche \u00e8 quella evidenziata nel listato successivo. #include <fstream> #include <iostream> using namespace std ; int main () { ifstream input ( \"input.txt\" ); if ( input . is_open ()) { ofstream output ( \"output.txt\" ); if ( output . is_open ()) { char c = NULL ; while ( input . get ( c ) && output . good ()) { if ( output . put ( c )) { cout << \"Carattere \" << c << \" copiato\" << endl ; } else { cout << \"Impossibile copiare il carattere \" << c << endl ; exit ( EXIT_FAILURE ); } } output . close (); } else { cout << \"Errore di I/O sul file di output.\" << endl ; exit ( EXIT_FAILURE ); } input . close (); } else { cout << \"Errore di I/O sul file di input.\" << endl ; exit ( EXIT_FAILURE ); } exit ( EXIT_SUCCESS ); } Notiamo innanzitutto la funzione get() che, in maniera simile alla getline() , scandisce il file associato alla variabile input , questa volta carattere per carattere. Notiamo una differenza: laddove la getline() prende due parametri in ingresso, la get() viene chiamata direttamente sulla variabile associata al file di input, ed accetta come parametro esclusivamente il riferimento al carattere attualmente scandito. Dopo la get() , troviamo una chiamata alla funzione \"duale\", ovvero la put() , che (prevedibilmente) si occupa di scrivere il carattere passato in ingresso sul file di output.","title":"Step 4: Copia del file carattere per carattere"},{"location":"02_dispense/programmazione/02_linguaggio_cpp/10_file/#bonus-combinare-i-due-esempi","text":"Di seguito il codice per un possibile approccio alla combinazione dei due esempi precedenti. #include <iostream> #include <fstream> #include <string> using namespace std ; // Funzione per la copia carattere per carattere. Ricordare il passaggio per reference! void char_copy ( ifstream & input , ofstream & output ) { char c = NULL ; while ( input . get ( c ) && output . good ()) { if ( output . put ( c )) { cout << \"Carattere \" << c << \" copiato\" << endl ; } else { cout << \"Impossibile copiare il carattere \" << c << endl ; exit ( EXIT_FAILURE ); } } } // Funzione per la copia riga per riga. Ricordare il passaggio per reference! void row_copy ( ifstream & input , ofstream & output ) { string line ; int row = 1 ; while ( getline ( input , line ) && output . good ()) { output << line << endl ; cout << \"Linea \" << row << \" copiata\" << endl ; row ++ ; } } int main () { cout << \"Inserire 0 per lettura riga a riga, ed 1 per lettura carattere per carattere.\" << endl ; bool char_or_row = false ; cin >> char_or_row ; ifstream input ( \"input.txt\" ); if ( input . is_open ()) { ofstream output ( \"output.txt\" ); if ( output . is_open ()) { if ( char_or_row ) { char_copy ( input , output ); } else { row_copy ( input , output ); } } else { cout << \"Errore di I/O sul file di output.\" << endl ; exit ( EXIT_FAILURE ); } input . close (); } else { cout << \"Errore di I/O sul file di input.\" << endl ; exit ( EXIT_FAILURE ); } exit ( EXIT_SUCCESS ); }","title":"Bonus: combinare i due esempi"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/","text":"Introduzione a Python \u00b6 Nota Queste lezioni seguono il percorso tracciato dal tutorial ufficiale di Python. Di conseguenza, aderiscono alle licenze PSF e Zero-Clause BSD License . Premessa: Python e tipizzazione \u00b6 Tipizzazione dinamica \u00b6 Prima di partire con l'introduzione dei concetti fondamentali del linguaggio, \u00e8 opportuna una premessa. Infatti Python, a differenza dei linguaggi C e C++, implementa il concetto di tipizzazione dinamica , il che significa che l' interprete valuta il tipo di ogni variabile a runtime, e che questo pu\u00f2 cambiare nel corso dell'esecuzione del programma. Questo semplifica apparentemente la vita al programmatore, che non dovrebbe (in teoria) pi\u00f9 preoccuaprsi di concetti come il tipo della variabile, in quanto inferiti automaticamente dall'interprete. Tuttavia, questa \u00e8 un'arma a doppio taglio, in quanto l'interprete Python adotta il (pilatesco) principio chiamato duck typing . Duck Typing \u00b6 Il duck typing deriva dalla massima secondo cui: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. ( Se cammina come un papero, e starnazza come un papero, deve essere un papero. ) Traduciamo brevemente questa massima in informatichese. Immaginiamo di passare all'interprete Python una variabile che assume valore 1 . L'interprete si accorge che ha tutti i comportamenti assimilabili ad un numero di tipo intero: di conseguenza, inferir\u00e0 che si tratta proprio di una variabile di questo tipo. Se per\u00f2 poi sommiamo in seguito il valore 1.1 , il risultato sar\u00e0 un valore decimale, interpretato quindi come float , in quanto tutti i \"comportamenti\" sono assimilabili a quelli di una variabile di questo tipo. Questo concetto sar\u00e0 ancora pi\u00f9 \"forte\" (per non dire invadente ) quando parleremo delle classi: Python infatti non ci chieder\u00e0 mai di esplicitare nel codice delle eventuali procedure di casting, ma le inferir\u00e0 per noi, con tutte le comodit\u00e0 che questo comporta (oltre che i potenzialmente catrastrofici effetti). L'interprete Python \u00b6 A differenza dei compilatori presenti in altri linguaggi di programmazione, Python offre un interprete accessibile al programmatore direttamente dalla riga di comando. Dopo averlo installato, ed essersi assicurati che il launcher sia stato aggiunto al path di sistema, possiamo lanciare l'interprete da riga di comando. Per prima cosa, comunque, assicuriamoci che sia tutto a posto controllando la versione installata di Python: $ python --version python3.9.1 A questo punto, lanciamo l'interprete mediante il seguente comando: python Proviamo quindi ad usare Python per alcuni semplici comandi. Inizieremo a provare ad usarlo come calcolatrice; attendiamo che l'interprete ci chieda un input (sar\u00e0 visualizzato il simbolo >>> ). Calcoli e numeri \u00b6 Proviamo ad usare l'interprete come una semplice calcolatrice. >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2 >>> 2 / 2 2.0 Divisioni \u00b6 La cosa importante da notare \u00e8 che la divisione restituisce sempre un numero in virgola mobile. Notiamo che i primi tre risultati hanno tipo intero (int), mentre gli altri hanno tipo float. Ad ogni modo, possiamo ottenere il quoziente ed il resto della divisione usando rispettivamente gli operatori // e % . >>> 16 / 3 5.333333333333333 >>> 16 // 3 5 >>> 16 % 3 1 Calcolo di potenza \u00b6 Per calcolare la potenza di un numero, \u00e8 necessario usare l'operatore ** , che accetta a sinistra la base, ed a destra l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256 Tipi numerici supportati\" \u00b6 Abbiamo accennato al fatto che Python supporta interi e float. Oltre questi, Python supporta anche altri tipi numerici, come i Decimal ed i Fraction , ed ha un supporto integrato ai numeri complessi, espressi usando il suffisso j o J per la parte immaginaria. >>> from decimal import * >>> print ( Decimal ( 1 ) / Decimal ( 7 )) >>> from fractions import Fraction >>> Fraction ( 4 , 6 ) Fraction ( 2 , 3 ) >>> a = 1 + 4 j >>> b = 2 + 3 j >>> print ( a + b ) ( 3 + 7 j ) Stringhe \u00b6 Python ovviamente supporta anche le stringhe, che possono essere indifferentemente racchiuse tra singole o doppie virgolette. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Nella seconda espressione, notiamo l'uso del carattere di escape \\ che precede l'apostrofo. E' importante fare attenzione ad utilizzarlo, in quanto in caso contrario avremmo avuto un errore di sintassi da parte dell'interprete. >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota E' importante sottolineare come tutti i caratteri preceduti da un simbolo \\ saranno interpretati come escape character, a meno che non si aggiunga una r prima dell'inizio della stringa, come ad esempio: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella Stringhe su righe multiple \u00b6 Le stringhe possono articolarsi su pi\u00f9 righe. Un modo per farlo \u00e8 quello di usare le triple-quotes , ovvero tre virgolette di seguito (ovviamente sia in apertura, sia in chiusura): >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Notiamo anche qui la presenza del carattere \\ . In questo caso, il suo utilizzo \u00e8 quello di evitare che venga posto, al termine di ogni riga, un carattere \\n : infatti, si vede come il newline venga \"ignorato\" nelle righe evidenziate, ovvero la 1 e la 3, mentre non lo sia nella riga 2. Concatenazione di stringhe \u00b6 Python offre anche un modo molto semplice per concatenare due stringhe: per farlo, infatti, basta usare l'operatore + su due stringhe. >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota E' anche possibile concatenere diverse volte una stessa stringa usando l'operatore * : >>> 3 * 'co.' 'co.co.co.' Un altro modo per concatenare due stringhe \u00e8 semplicemente metterle l'una subito dopo l'altra, in questo modo: >>> \"Py\" \"thon\" 'Python' Attenzione E' importante non concatenare un literal (ovvero una stringa racchiusa tra virgolette, sia singole, sia doppie) ad una variabile di tipo stringa. Se provassimo a farlo, l'interprete ci restituirebbe il seguente errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax In questi casi \"ibridi\", \u00e8 opportuno usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli. Tuttavia, trattarli va oltre gli obiettivi di questo corso. Indicizzazione di stringhe \u00b6 In Python, le stringhe possono essere indicizzate esattamente allo stesso modo del C e del C++. Sono, quindi, anche qui considerati come array di char . Nota In realt\u00e0, sarebbe pi\u00f9 corretto dire che Python le considera come delle liste di char. >>> stringa = 'Python' >>> stringa [ 0 ] 'P' E' importante notare anche come un singolo char sia considerato una stringa, in questo caso di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python ammette anche degli indici negativi: in questo caso, l'indicizzazione andr\u00e0 da destra verso sinistra, piuttosto che da sinistra verso destra: >>> stringa [ - 1 ] 'n' Nota Dato che possiamo assumere, con un certo grado di sicurezza, che \\(-0 = 0\\) , l'indicizzazione negativa parte da \\(-1\\) . Slicing su stringhe (e liste) \u00b6 L'operazione di slicing semplifica (e di molto) l'estrazione di determinate parti di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j ] dove i \u00e8 l'indice iniziale, e j quello finale. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Nota Tutte le considerazioni su indicizzazione e slicing si applicano anche alle liste. Anzi, per essere corretti, derivano proprio dalle liste, in quanto, come gi\u00e0 detto, Python considera una stringa un particolare tipo di lista. Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Nota Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python' Lunghezza di una stringa (o di una lista) \u00b6 Per ottenere la lunghezza di una stringa (o di una lista) possiamo usare la funzione len() : >>> len ( stringa ) 6 Immutabilit\u00e0 di una stringa \u00b6 Le stringhe in Python si dicono immutabili . Ci\u00f2 significa che non possono essere cambiate: se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment Liste \u00b6 Abbiamo gi\u00e0 visto alcuni dei concetti fondamentali legati alle liste mentre parlando delle stringhe. Come gi\u00e0 detto, infatti, una stringa altro non \u00e8 che un caso particolare di lista. Le liste in Python hanno la stessa funzione degli array negli altri linguaggi di programmazione. E' importante sottolineare che Python non supporta nativamente gli array : per farlo, \u00e8 necessario utilizzare delle librerie esterne alla libreria standard, ma comunque ampiamente diffuse e supportate (una tra tutte, NumPy ). Definire una lista in Python \u00e8 estremamente semplice: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] # Dichiarazione di una lista di interi [ 1 , 2 , 3 , 4 , 5 ] Concatenazione, indicizzazione e slicing su liste \u00b6 Sulle liste sono possibili le operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] # Slicing ed indicizzazione 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] Mutabilit\u00e0 di una lista \u00b6 A differenza delle stringhe, le liste sono oggetti mutabili , e quindi possiamo cambiarne il contenuto: >>> lista [ 0 ] = 99 # Mutabilit\u00e0 >>> lista [ 99 , 2 , 3 , 4 , 5 ] Operazioni sulle liste \u00b6 Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] # Eliminazione di un elemento di una lista >>> lista [ 99 , 2 , 3 , 4 ] Nota I lettori pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo provvedere a \"pulire\" una lista (ovvero ad eliminarne tutti gli elementi) usando in maniera opportuna lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Le liste Python sono estremamente versatili, e ciascun elemento pu\u00f2 essere di ogni tipo consentito. E' addirittura possibile inserire delle liste all'interno di altre liste: >>> lista . append ([ 1 , 2 , 3 ]) # Aggiunta di elementi ad una lista >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare come questo elemento sia esso stesso una lista , e \"conviva\" tranquillamente con gli altri elementi presenti, questi ultimi di tipo numerico. Per enfatizzare questo concetto, vediamo cosa succede inserendo una stringa al primo elemento: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]]","title":"01 - Introduzione al Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#introduzione-a-python","text":"Nota Queste lezioni seguono il percorso tracciato dal tutorial ufficiale di Python. Di conseguenza, aderiscono alle licenze PSF e Zero-Clause BSD License .","title":"Introduzione a Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#premessa-python-e-tipizzazione","text":"","title":"Premessa: Python e tipizzazione"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#tipizzazione-dinamica","text":"Prima di partire con l'introduzione dei concetti fondamentali del linguaggio, \u00e8 opportuna una premessa. Infatti Python, a differenza dei linguaggi C e C++, implementa il concetto di tipizzazione dinamica , il che significa che l' interprete valuta il tipo di ogni variabile a runtime, e che questo pu\u00f2 cambiare nel corso dell'esecuzione del programma. Questo semplifica apparentemente la vita al programmatore, che non dovrebbe (in teoria) pi\u00f9 preoccuaprsi di concetti come il tipo della variabile, in quanto inferiti automaticamente dall'interprete. Tuttavia, questa \u00e8 un'arma a doppio taglio, in quanto l'interprete Python adotta il (pilatesco) principio chiamato duck typing .","title":"Tipizzazione dinamica"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#duck-typing","text":"Il duck typing deriva dalla massima secondo cui: Duck Typing If it walks like a duck and it quacks like a duck, then it must be a duck. ( Se cammina come un papero, e starnazza come un papero, deve essere un papero. ) Traduciamo brevemente questa massima in informatichese. Immaginiamo di passare all'interprete Python una variabile che assume valore 1 . L'interprete si accorge che ha tutti i comportamenti assimilabili ad un numero di tipo intero: di conseguenza, inferir\u00e0 che si tratta proprio di una variabile di questo tipo. Se per\u00f2 poi sommiamo in seguito il valore 1.1 , il risultato sar\u00e0 un valore decimale, interpretato quindi come float , in quanto tutti i \"comportamenti\" sono assimilabili a quelli di una variabile di questo tipo. Questo concetto sar\u00e0 ancora pi\u00f9 \"forte\" (per non dire invadente ) quando parleremo delle classi: Python infatti non ci chieder\u00e0 mai di esplicitare nel codice delle eventuali procedure di casting, ma le inferir\u00e0 per noi, con tutte le comodit\u00e0 che questo comporta (oltre che i potenzialmente catrastrofici effetti).","title":"Duck Typing"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#linterprete-python","text":"A differenza dei compilatori presenti in altri linguaggi di programmazione, Python offre un interprete accessibile al programmatore direttamente dalla riga di comando. Dopo averlo installato, ed essersi assicurati che il launcher sia stato aggiunto al path di sistema, possiamo lanciare l'interprete da riga di comando. Per prima cosa, comunque, assicuriamoci che sia tutto a posto controllando la versione installata di Python: $ python --version python3.9.1 A questo punto, lanciamo l'interprete mediante il seguente comando: python Proviamo quindi ad usare Python per alcuni semplici comandi. Inizieremo a provare ad usarlo come calcolatrice; attendiamo che l'interprete ci chieda un input (sar\u00e0 visualizzato il simbolo >>> ).","title":"L'interprete Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#calcoli-e-numeri","text":"Proviamo ad usare l'interprete come una semplice calcolatrice. >>> 2 + 2 4 >>> 3 * 5 15 >>> 10 - 2 * 4 2 >>> 2 / 2 2.0","title":"Calcoli e numeri"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#divisioni","text":"La cosa importante da notare \u00e8 che la divisione restituisce sempre un numero in virgola mobile. Notiamo che i primi tre risultati hanno tipo intero (int), mentre gli altri hanno tipo float. Ad ogni modo, possiamo ottenere il quoziente ed il resto della divisione usando rispettivamente gli operatori // e % . >>> 16 / 3 5.333333333333333 >>> 16 // 3 5 >>> 16 % 3 1","title":"Divisioni"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#calcolo-di-potenza","text":"Per calcolare la potenza di un numero, \u00e8 necessario usare l'operatore ** , che accetta a sinistra la base, ed a destra l'esponente: >>> 3 ** 2 9 >>> 2 ** 8 256","title":"Calcolo di potenza"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#tipi-numerici-supportati","text":"Abbiamo accennato al fatto che Python supporta interi e float. Oltre questi, Python supporta anche altri tipi numerici, come i Decimal ed i Fraction , ed ha un supporto integrato ai numeri complessi, espressi usando il suffisso j o J per la parte immaginaria. >>> from decimal import * >>> print ( Decimal ( 1 ) / Decimal ( 7 )) >>> from fractions import Fraction >>> Fraction ( 4 , 6 ) Fraction ( 2 , 3 ) >>> a = 1 + 4 j >>> b = 2 + 3 j >>> print ( a + b ) ( 3 + 7 j )","title":"Tipi numerici supportati\""},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#stringhe","text":"Python ovviamente supporta anche le stringhe, che possono essere indifferentemente racchiuse tra singole o doppie virgolette. >>> \"una stringa\" 'una stringa' >>> 'un \\' altra stringa' \"un'altra stringa\" Nella seconda espressione, notiamo l'uso del carattere di escape \\ che precede l'apostrofo. E' importante fare attenzione ad utilizzarlo, in quanto in caso contrario avremmo avuto un errore di sintassi da parte dell'interprete. >>> 'un' altra stringa ' File \"<stdin>\" , line 1 'un' altra stringa ^ SyntaxError : invalid syntax Nota E' importante sottolineare come tutti i caratteri preceduti da un simbolo \\ saranno interpretati come escape character, a meno che non si aggiunga una r prima dell'inizio della stringa, come ad esempio: >>> print ( 'C: \\n uova_cartella' ) C : uova_cartella >>> print ( r 'C:\\nuova_cartella' ) C : \\ nuova_cartella","title":"Stringhe"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#stringhe-su-righe-multiple","text":"Le stringhe possono articolarsi su pi\u00f9 righe. Un modo per farlo \u00e8 quello di usare le triple-quotes , ovvero tre virgolette di seguito (ovviamente sia in apertura, sia in chiusura): >>> print ( \"\"\"Questo \u00e8 un esempio \\ di riga multipla \\ \"\"\" ) Questo \u00e8 un esempio di riga multipla Notiamo anche qui la presenza del carattere \\ . In questo caso, il suo utilizzo \u00e8 quello di evitare che venga posto, al termine di ogni riga, un carattere \\n : infatti, si vede come il newline venga \"ignorato\" nelle righe evidenziate, ovvero la 1 e la 3, mentre non lo sia nella riga 2.","title":"Stringhe su righe multiple"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#concatenazione-di-stringhe","text":"Python offre anche un modo molto semplice per concatenare due stringhe: per farlo, infatti, basta usare l'operatore + su due stringhe. >>> stringa_a = \"Prima stringa\" >>> stringa_b = \"Seconda stringa\" >>> print ( stringa_a + \" - \" + stringa_b ) Prima stringa - Seconda stringa Nota E' anche possibile concatenere diverse volte una stessa stringa usando l'operatore * : >>> 3 * 'co.' 'co.co.co.' Un altro modo per concatenare due stringhe \u00e8 semplicemente metterle l'una subito dopo l'altra, in questo modo: >>> \"Py\" \"thon\" 'Python' Attenzione E' importante non concatenare un literal (ovvero una stringa racchiusa tra virgolette, sia singole, sia doppie) ad una variabile di tipo stringa. Se provassimo a farlo, l'interprete ci restituirebbe il seguente errore: >>> py = \"Py\" >>> py \"thon\" File \"<stdin>\" , line 1 py \"thon\" ^ SyntaxError : invalid syntax Lo stesso errore si presenterebbe se al posto della variabile py usassimo il risultato di una operazione di concatenazione: >>> ( 'p' + 'y' ) 'thon' File \"<stdin>\" , line 1 ( 'p' + 'y' ) 'thon' ^ SyntaxError : invalid syntax In questi casi \"ibridi\", \u00e8 opportuno usare l'operatore standard di concatenazione, ovvero il + . Nota Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli. Tuttavia, trattarli va oltre gli obiettivi di questo corso.","title":"Concatenazione di stringhe"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#indicizzazione-di-stringhe","text":"In Python, le stringhe possono essere indicizzate esattamente allo stesso modo del C e del C++. Sono, quindi, anche qui considerati come array di char . Nota In realt\u00e0, sarebbe pi\u00f9 corretto dire che Python le considera come delle liste di char. >>> stringa = 'Python' >>> stringa [ 0 ] 'P' E' importante notare anche come un singolo char sia considerato una stringa, in questo caso di lunghezza unitaria: >>> lettera = 'P' >>> lettera [ 0 ] 'P' Python ammette anche degli indici negativi: in questo caso, l'indicizzazione andr\u00e0 da destra verso sinistra, piuttosto che da sinistra verso destra: >>> stringa [ - 1 ] 'n' Nota Dato che possiamo assumere, con un certo grado di sicurezza, che \\(-0 = 0\\) , l'indicizzazione negativa parte da \\(-1\\) .","title":"Indicizzazione di stringhe"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#slicing-su-stringhe-e-liste","text":"L'operazione di slicing semplifica (e di molto) l'estrazione di determinate parti di una stringa. In generale, assume la seguente forma: >>> stringa [ i : j ] dove i \u00e8 l'indice iniziale, e j quello finale. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso . Nota Tutte le considerazioni su indicizzazione e slicing si applicano anche alle liste. Anzi, per essere corretti, derivano proprio dalle liste, in quanto, come gi\u00e0 detto, Python considera una stringa un particolare tipo di lista. Ad esempio: >>> stringa [ 0 : 2 ] 'Py' >>> stringa [ 2 : 5 ] 'tho' Se volessimo considerare tutti i caratteri fino a j (escluso), dovremmo usare la seguente notazione: >>> stringa [: j ] Se invece volessimo considerare tutti i caratteri a partire da i (incluso), dovremmo usare la seguente notazione: >>> stringa [ i :] Ad esempio: >>> stringa [ 1 :] 'ython' >>> stringa [: 5 ] 'Pytho' Nota Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere: >>> stringa [ - 3 :] 'hon' mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa): >>> stringa [: - 3 ] 'Pyt' Suggerimento E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo: >>> stringa [:] 'Python'","title":"Slicing su stringhe (e liste)"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#lunghezza-di-una-stringa-o-di-una-lista","text":"Per ottenere la lunghezza di una stringa (o di una lista) possiamo usare la funzione len() : >>> len ( stringa ) 6","title":"Lunghezza di una stringa (o di una lista)"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#immutabilita-di-una-stringa","text":"Le stringhe in Python si dicono immutabili . Ci\u00f2 significa che non possono essere cambiate: se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore. >>> stringa [ 0 ] = 'C' # Errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'str' object does not support item assignment","title":"Immutabilit\u00e0 di una stringa"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#liste","text":"Abbiamo gi\u00e0 visto alcuni dei concetti fondamentali legati alle liste mentre parlando delle stringhe. Come gi\u00e0 detto, infatti, una stringa altro non \u00e8 che un caso particolare di lista. Le liste in Python hanno la stessa funzione degli array negli altri linguaggi di programmazione. E' importante sottolineare che Python non supporta nativamente gli array : per farlo, \u00e8 necessario utilizzare delle librerie esterne alla libreria standard, ma comunque ampiamente diffuse e supportate (una tra tutte, NumPy ). Definire una lista in Python \u00e8 estremamente semplice: >>> lista = [ 1 , 2 , 3 , 4 , 5 ] # Dichiarazione di una lista di interi [ 1 , 2 , 3 , 4 , 5 ]","title":"Liste"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#concatenazione-indicizzazione-e-slicing-su-liste","text":"Sulle liste sono possibili le operazioni di indicizzazione, slicing e concatenazione: >>> lista [ 0 ] # Slicing ed indicizzazione 1 >>> lista [ 2 :] [ 3 , 4 , 5 ] >>> lista_due = [ 6 , 7 ] >>> lista + lista_due [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] >>> lista + [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ]","title":"Concatenazione, indicizzazione e slicing su liste"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#mutabilita-di-una-lista","text":"A differenza delle stringhe, le liste sono oggetti mutabili , e quindi possiamo cambiarne il contenuto: >>> lista [ 0 ] = 99 # Mutabilit\u00e0 >>> lista [ 99 , 2 , 3 , 4 , 5 ]","title":"Mutabilit\u00e0 di una lista"},{"location":"02_dispense/programmazione/03_linguaggio_python/01_intro/#operazioni-sulle-liste","text":"Possiamo anche eliminare elementi da una lista usando l'operatore [] combinato all'operazione di slicing: >>> lista [ 4 :] = [] # Eliminazione di un elemento di una lista >>> lista [ 99 , 2 , 3 , 4 ] Nota I lettori pi\u00f9 attenti avranno notato che l'operatore [] non fa altro che indicare una lista vuota. Suggerimento Possiamo provvedere a \"pulire\" una lista (ovvero ad eliminarne tutti gli elementi) usando in maniera opportuna lo slicing e l'operatore [] : >>> lista [:] = [] >>> lista [] Le liste Python sono estremamente versatili, e ciascun elemento pu\u00f2 essere di ogni tipo consentito. E' addirittura possibile inserire delle liste all'interno di altre liste: >>> lista . append ([ 1 , 2 , 3 ]) # Aggiunta di elementi ad una lista >>> lista [ 99 , 2 , 3 , 4 , [ 1 , 2 , 3 ]] Nell'esempio precedente, abbiamo usato la funzione append() per inserire un elemento in coda alla lista. E' interessante notare come questo elemento sia esso stesso una lista , e \"conviva\" tranquillamente con gli altri elementi presenti, questi ultimi di tipo numerico. Per enfatizzare questo concetto, vediamo cosa succede inserendo una stringa al primo elemento: >>> lista [ 0 ] = stringa >>> lista [ 'Python' , 2 , 3 , 4 , [ 1 , 2 , 3 ]]","title":"Operazioni sulle liste"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/","text":"Programmare in Python \u00b6 Note fondamentali sulla sintassi \u00b6 Abbiamo gi\u00e0 accennato al fatto che il linguaggio Python sfrutta ampiamente il concetto di duck typing. Ecco alcuni altri concetti da tenere in considerazione dal punto di vista sintattico. Uso delle parentesi \u00b6 In Python: le parentesi tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse; le parentesi quadre sono usate per la creazione e l'accesso agli elementi di una lista; le parentesi graffe sono usate per la creazione dei dizionari. Termine delle istruzioni \u00b6 In C e C++, il termine di un'istruzione \u00e8 contrassegnato dal carattere ; (il punto e virgola); in Python, invece, \u00e8 necessario andare a capo. Ambito del codice e tabulazione \u00b6 In C e C++, l'ambito era definito mediante le parentesi graffe. In Python, invece, \u00e8 definito mediante le tabulazioni; come regola generale, il codice indentato allo stesso livello di tabulazione appartiene allo stesso ambito. Programmazione strutturata \u00b6 Abbiamo visto che in C ed in C++ la sintassi per l'utilizzo delle strutture di controllo \u00e8 comune; questo ricordiamo essere un effetto legato al fatto che il C++ altro non \u00e8 se non un \"superset\" di istruzioni del C. Il linguaggio Python, invece, pur condividendo l'insieme fondamentale di istruzioni utilizzate dal C e dal C++, utilizza una sintassi differente. Strutture di controllo \u00b6 Partiamo dalla struttura di controllo if ; nel seguente blocco di codice, vediamo la differenza tra un'implementazione in C/C++ ed una in Python della stessa istruzione condizionale. Python >>> a = 5 >>> if a < 5 : ... print ( 'a \u00e8 minore di 5' ) ... elif a == 5 : ... print ( 'a \u00e8 uguale a 5' ) ... else : ... print ( 'a \u00e8 maggiore di 5' ) ... C/C++ #include <iostream> using namespace std ; int main () { int a = 5 ; if ( a < 5 ) { std :: cout << \"a \u00e8 minore di 5\" << std :: endl ; } else if ( a == 5 ) { std :: cout << \"a \u00e8 uguale a 5\" << std :: endl ; } else { std :: cout << \"a \u00e8 maggiore a 5\" << std :: endl ; } } L'output che riceveremo in entrambi i casi \u00e8 il seguente: a \u00e8 uguale a 5 Notiamo come la sintassi sia molto simile, anche se vi \u00e8 un ovvio adattamento alle regole sintattiche gi\u00e0 esplicitate in precedenza. Il costrutto switch Python non implementa il costrutto switch . Qualora questo si reputi necessario, deve essere implementato mediante una serie di if ed elif , o anche mediante un apposito dizionario; in quest'ultimo caso, per\u00f2, le applicazioni sono decisamente pi\u00f9 limitate, e l'implementazione pi\u00f9 complessa, anche se vi \u00e8 un vantaggio in termini di performance. Cicli \u00b6 Ciclo for \u00b6 Un ciclo for in Python differisce leggermente da quelli visti in C/C++; infatti, laddove questi ultimi sono delle una vera e propria progressioni aritmetiche, contraddistinte da un valore iniziale, un incremento ed un valore terminale, in Python un ciclo for itera su una sequenza, come una lista o una stringa. Ad esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: Python >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) C/C++ #include <iostream> using namespace std ; int main () { for ( int i = 0 ; i < 5 ; i ++ ) { cout << i << endl ; } return 0 ; } In entrambi i casi, il risultato che vedremo a schermo \u00e8 il seguente: 0 1 2 3 4 E' quindi necessario un \"cambio\" di mentalit\u00e0: infatti, per passare dal nostro codice C/C++ ad un equivalente Python, dovremo modificare tutti i nostri \"range di iterazione\" in liste o, in maniera pi\u00f9 generica, sequenze . Il costo di questo \"sforzo concettuale\" \u00e8 per\u00f2 ampiamente ripagato: infatti, nel seguente blocco di codice vediamo come \u00e8 possibile iterare su una stringa: Python >>> string = \"Python\" >>> for char in string : ... print ( char ) C/C++ #include <iostream> #include <string> using namespace std ; int main () { string str ( \"C/C++\" ); for ( int i = 0 ; i < str . size (); i ++ ) { cout << str [ i ] << endl ; } return 0 ; } Il risultato \u00e8 il seguente: P y t h o n E' quindi evidente come sia l'interprete Python a farsi carico dell'astrazione di molte delle complessit\u00e0 di implementazione che si riscontrano nel linguaggio C/C++. Nota Ovviamente, questa operazione non \u00e8 indolore . Infatti, un codice Python, per quanto ottimizzato, raramente sar\u00e0 in grado di offrire le stesse performance di un analogo codice (ottimizzato) C/C++. Tuttavia, nella maggior parte delle situazioni l'impatto in termini di performance \u00e8, ai nostri scopi, insignificante. Ciclo while \u00b6 Dal punto di vista semantico, il ciclo while \u00e8, a differenza del for , analogo alla controparte C/C++. Anche in questo caso, quello che cambia \u00e8 la sintassi, come mostrato nel seguente blocco di codice: Python >>> i = True >>> while ( i ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... else : ... print ( \"Esco!\" ) ... i = False C/C++ #include <iostream> #include <cstdlib> using namespace std ; int main () { bool i = true ; while ( i ) { int randn = -5 + ( rand () % ( 5 + 5 + 1 )); if ( randn > 0 ) { cout << \"Continuo!\" << endl ; } else { cout << \"Esco!\" << endl ; i = false ; } } } Il risultato che avremo \u00e8 (pressappoco) il seguente: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola. La funzione range() \u00b6 Ritorniamo per un attimo all'esempio che abbiamo fatto sul ciclo for in Python, che riportiamo di seguito per comodit\u00e0. >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) Gi\u00e0 in questa versione, il codice \u00e8 molto pi\u00f9 compatto della controparte C/C++; tuttavia, scrivere manualmente la sequenza per l'iterazione pu\u00f2 essere un'operazione tediosa (e facilmente suscettibile all'errore). Python ci viene in aiuto mediante la funzione range() , che ha la seguente sintassi: range ( i , j , s ) e genera la sequenza di tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4, possiamo scrivere: >>> r = range ( 0 , 5 , 1 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Per mandare a schermo la lista dei valori assunti dalla sequenza r , dovremo farne il cast in lista mediante l'operazione list(r) . Qualora omessi, i e di s assumono i valori di default, ovvero 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale facendo in modo che i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ] Iterare su tutti gli elementi di una lista \u00b6 Possiamo usare la funzione range() in accoppiata alla funzione len() per iterare sugli elementi di una lista: >>> l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] >>> for i in range ( len ( l )): ... print ( l [ i ]) Pippo Pluto 5 Paperino Istruzioni break e continue \u00b6 Le istruzioni break e continue sono analoghe a quelle implementate in linguaggio C/C++, e permettono, rispettivamente, di uscire dal ciclo o di saltare all'iterazione successiva. Ad esempio: Python >>> while ( True ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... continue ... else : ... print ( \"Esco!\" ) ... break C/C++ #include <iostream> #include <cstdlib> using namespace std ; int main () { while ( true ) { int randn = -5 + ( rand () % ( 5 + 5 + 1 )); if ( randn > 0 ) { cout << \"Continuo!\" << endl ; continue ; } else { cout << \"Esco!\" << endl ; break ; } } } Istruzione else \u00b6 Python permette di usare un else in uscita da un ciclo in accoppiata con la funzione break . Ad esempio: >>> for i in range ( 2 , 10 ): ... for j in range ( 2 , 5 ): ... if i % j == 0 : ... break ... else : ... print ( ' {} non \u00e8 divisibile per {} ' . format ( i , j )) ... 5 non \u00e8 divisibile per 4 7 non \u00e8 divisibile per 4 Come evidente dal codice precedente, ogni volta che il ciclo interno termina con un break , il controllo ritorna al ciclo esterno, ma l' else non viene chiamato; quest'ultimo sar\u00e0 chiamato soltanto quando il ciclo interno non viene interrotto. Nota L'utilizzo di questa particolare forma dell' else \u00e8 abbastanza poco comune, almeno nei casi standard, e pu\u00f2 comunque essere sempre riformulata in maniera pi\u00f9 semplice. Ai fini del corso, si consiglia l'adozione di un controllo di flusso e di una sintassi il pi\u00f9 semplificati possibile. Definizione di funzioni \u00b6 La sintassi usata per definire una funzione in Python \u00e8 la seguente: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo di ritorno, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, semplicemente si ometter\u00e0 l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri di default. Ad esempio, la seguente funzione calcola il quadrato: >>> def calcola_area_quadrato ( lato ): ... return lato * lato ... >>> calcola_area_quadrato ( 5 ) 25 La seguente funzione concatena ad una lista il doppio dei singoli valori nella lista stessa: >>> l = [ 1 , 2 ] >>> def raddoppia_lista ( valore ): ... for i in range ( len ( valore )): ... l . append ( l [ i ] * 2 ) ... >>> raddoppia_lista ( l ) >>> l [ 1 , 2 , 2 , 4 ] In questa funzione, invece, usiamo un parametro opzionale per specificare la lunghezza della lista generata in output: >>> def genera_lista_casuale ( lunghezza = 5 ): ... l = [] ... for i in range ( lunghezza ): ... l . append ( randint ( 0 , 10 )) ... return l ... >>> genera_lista_casuale () [ 3 , 1 , 2 , 0 , 6 ] >>> genera_lista_casuale ( 10 ) [ 7 , 9 , 1 , 10 , 2 , 4 , 9 , 1 , 4 , 8 ] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non sia posto alcun controllo sui parametri di ingresso. Ci\u00f2 per\u00f2 non significa che l'interprete Python ci impedisca di chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; tuttavia, ci\u00f2 comporter\u00e0, come prevedibile, un errore a runtime. Passaggio di parametri a funzione \u00b6 E' importante sottolineare come in Python i parametri siano passati ad una funzione esclusivamente per valore . Ad esempio: >>> def raddoppia ( valore ): ... valore = valore * 2 ... >>> val = 1 >>> raddoppia ( val ) >>> val 1 Notiamo come la funzione raddoppia() non abbia quindi avuto alcun effetto sulla variabile esterna! Ci\u00f2 avviene proprio perch\u00e9 questa non \u00e8 passata per reference, ma per valore. Questo \u00e8 il motivo per cui, qualora non si voglia avere un valore di ritorno in una ben determinata funzione, \u00e8 necessario usare dei tipi mutabili (come nel caso della funzione raddoppia_lista , che accetta una lista, ovvero un tipo mutabile), oppure utilizzare le funzioni nell'ambito di una classe (torneremo su questo in avanti). L'istruzione pass \u00b6 Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def passa (): ... pass ... >>> passa () Nota Anche se non scenderemo nei dettagli, l'istruzione pass \u00e8 utile nella definizione delle classi astratte.","title":"02 - Programmare in Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#programmare-in-python","text":"","title":"Programmare in Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#note-fondamentali-sulla-sintassi","text":"Abbiamo gi\u00e0 accennato al fatto che il linguaggio Python sfrutta ampiamente il concetto di duck typing. Ecco alcuni altri concetti da tenere in considerazione dal punto di vista sintattico.","title":"Note fondamentali sulla sintassi"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#uso-delle-parentesi","text":"In Python: le parentesi tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse; le parentesi quadre sono usate per la creazione e l'accesso agli elementi di una lista; le parentesi graffe sono usate per la creazione dei dizionari.","title":"Uso delle parentesi"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#termine-delle-istruzioni","text":"In C e C++, il termine di un'istruzione \u00e8 contrassegnato dal carattere ; (il punto e virgola); in Python, invece, \u00e8 necessario andare a capo.","title":"Termine delle istruzioni"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#ambito-del-codice-e-tabulazione","text":"In C e C++, l'ambito era definito mediante le parentesi graffe. In Python, invece, \u00e8 definito mediante le tabulazioni; come regola generale, il codice indentato allo stesso livello di tabulazione appartiene allo stesso ambito.","title":"Ambito del codice e tabulazione"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#programmazione-strutturata","text":"Abbiamo visto che in C ed in C++ la sintassi per l'utilizzo delle strutture di controllo \u00e8 comune; questo ricordiamo essere un effetto legato al fatto che il C++ altro non \u00e8 se non un \"superset\" di istruzioni del C. Il linguaggio Python, invece, pur condividendo l'insieme fondamentale di istruzioni utilizzate dal C e dal C++, utilizza una sintassi differente.","title":"Programmazione strutturata"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#strutture-di-controllo","text":"Partiamo dalla struttura di controllo if ; nel seguente blocco di codice, vediamo la differenza tra un'implementazione in C/C++ ed una in Python della stessa istruzione condizionale. Python >>> a = 5 >>> if a < 5 : ... print ( 'a \u00e8 minore di 5' ) ... elif a == 5 : ... print ( 'a \u00e8 uguale a 5' ) ... else : ... print ( 'a \u00e8 maggiore di 5' ) ... C/C++ #include <iostream> using namespace std ; int main () { int a = 5 ; if ( a < 5 ) { std :: cout << \"a \u00e8 minore di 5\" << std :: endl ; } else if ( a == 5 ) { std :: cout << \"a \u00e8 uguale a 5\" << std :: endl ; } else { std :: cout << \"a \u00e8 maggiore a 5\" << std :: endl ; } } L'output che riceveremo in entrambi i casi \u00e8 il seguente: a \u00e8 uguale a 5 Notiamo come la sintassi sia molto simile, anche se vi \u00e8 un ovvio adattamento alle regole sintattiche gi\u00e0 esplicitate in precedenza. Il costrutto switch Python non implementa il costrutto switch . Qualora questo si reputi necessario, deve essere implementato mediante una serie di if ed elif , o anche mediante un apposito dizionario; in quest'ultimo caso, per\u00f2, le applicazioni sono decisamente pi\u00f9 limitate, e l'implementazione pi\u00f9 complessa, anche se vi \u00e8 un vantaggio in termini di performance.","title":"Strutture di controllo"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#cicli","text":"","title":"Cicli"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#ciclo-for","text":"Un ciclo for in Python differisce leggermente da quelli visti in C/C++; infatti, laddove questi ultimi sono delle una vera e propria progressioni aritmetiche, contraddistinte da un valore iniziale, un incremento ed un valore terminale, in Python un ciclo for itera su una sequenza, come una lista o una stringa. Ad esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5: Python >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) C/C++ #include <iostream> using namespace std ; int main () { for ( int i = 0 ; i < 5 ; i ++ ) { cout << i << endl ; } return 0 ; } In entrambi i casi, il risultato che vedremo a schermo \u00e8 il seguente: 0 1 2 3 4 E' quindi necessario un \"cambio\" di mentalit\u00e0: infatti, per passare dal nostro codice C/C++ ad un equivalente Python, dovremo modificare tutti i nostri \"range di iterazione\" in liste o, in maniera pi\u00f9 generica, sequenze . Il costo di questo \"sforzo concettuale\" \u00e8 per\u00f2 ampiamente ripagato: infatti, nel seguente blocco di codice vediamo come \u00e8 possibile iterare su una stringa: Python >>> string = \"Python\" >>> for char in string : ... print ( char ) C/C++ #include <iostream> #include <string> using namespace std ; int main () { string str ( \"C/C++\" ); for ( int i = 0 ; i < str . size (); i ++ ) { cout << str [ i ] << endl ; } return 0 ; } Il risultato \u00e8 il seguente: P y t h o n E' quindi evidente come sia l'interprete Python a farsi carico dell'astrazione di molte delle complessit\u00e0 di implementazione che si riscontrano nel linguaggio C/C++. Nota Ovviamente, questa operazione non \u00e8 indolore . Infatti, un codice Python, per quanto ottimizzato, raramente sar\u00e0 in grado di offrire le stesse performance di un analogo codice (ottimizzato) C/C++. Tuttavia, nella maggior parte delle situazioni l'impatto in termini di performance \u00e8, ai nostri scopi, insignificante.","title":"Ciclo for"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#ciclo-while","text":"Dal punto di vista semantico, il ciclo while \u00e8, a differenza del for , analogo alla controparte C/C++. Anche in questo caso, quello che cambia \u00e8 la sintassi, come mostrato nel seguente blocco di codice: Python >>> i = True >>> while ( i ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... else : ... print ( \"Esco!\" ) ... i = False C/C++ #include <iostream> #include <cstdlib> using namespace std ; int main () { bool i = true ; while ( i ) { int randn = -5 + ( rand () % ( 5 + 5 + 1 )); if ( randn > 0 ) { cout << \"Continuo!\" << endl ; } else { cout << \"Esco!\" << endl ; i = false ; } } } Il risultato che avremo \u00e8 (pressappoco) il seguente: Continuo! Continuo! Esco! I valori booleani in Python I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come True e False . Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola.","title":"Ciclo while"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#la-funzione-range","text":"Ritorniamo per un attimo all'esempio che abbiamo fatto sul ciclo for in Python, che riportiamo di seguito per comodit\u00e0. >>> vals = [ 0 , 1 , 2 , 3 , 4 ] >>> for i in vals : ... print ( i ) Gi\u00e0 in questa versione, il codice \u00e8 molto pi\u00f9 compatto della controparte C/C++; tuttavia, scrivere manualmente la sequenza per l'iterazione pu\u00f2 essere un'operazione tediosa (e facilmente suscettibile all'errore). Python ci viene in aiuto mediante la funzione range() , che ha la seguente sintassi: range ( i , j , s ) e genera la sequenza di tutti i numeri compresi tra i (incluso) e j (escluso) a passo s . Ad esempio, per generare i numeri compresi tra 0 e 4, possiamo scrivere: >>> r = range ( 0 , 5 , 1 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] Nota Per mandare a schermo la lista dei valori assunti dalla sequenza r , dovremo farne il cast in lista mediante l'operazione list(r) . Qualora omessi, i e di s assumono i valori di default, ovvero 0 ed 1: >>> r = range ( 5 ) >>> print ( list ( r )) [ 0 , 1 , 2 , 3 , 4 ] E' anche possibile specificare una sequenza decrementale facendo in modo che i > j ed s < 0 : >>> r = range ( 5 , 1 , - 1 ) >>> print ( list ( r )) [ 5 , 4 , 3 , 2 ]","title":"La funzione range()"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#iterare-su-tutti-gli-elementi-di-una-lista","text":"Possiamo usare la funzione range() in accoppiata alla funzione len() per iterare sugli elementi di una lista: >>> l = [ 'Pippo' , 'Pluto' , 5 , 'Paperino' ] >>> for i in range ( len ( l )): ... print ( l [ i ]) Pippo Pluto 5 Paperino","title":"Iterare su tutti gli elementi di una lista"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#istruzioni-break-e-continue","text":"Le istruzioni break e continue sono analoghe a quelle implementate in linguaggio C/C++, e permettono, rispettivamente, di uscire dal ciclo o di saltare all'iterazione successiva. Ad esempio: Python >>> while ( True ): ... if randint ( - 5 , 5 ) > 0 : ... print ( \"Continuo!\" ) ... continue ... else : ... print ( \"Esco!\" ) ... break C/C++ #include <iostream> #include <cstdlib> using namespace std ; int main () { while ( true ) { int randn = -5 + ( rand () % ( 5 + 5 + 1 )); if ( randn > 0 ) { cout << \"Continuo!\" << endl ; continue ; } else { cout << \"Esco!\" << endl ; break ; } } }","title":"Istruzioni break e continue"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#istruzione-else","text":"Python permette di usare un else in uscita da un ciclo in accoppiata con la funzione break . Ad esempio: >>> for i in range ( 2 , 10 ): ... for j in range ( 2 , 5 ): ... if i % j == 0 : ... break ... else : ... print ( ' {} non \u00e8 divisibile per {} ' . format ( i , j )) ... 5 non \u00e8 divisibile per 4 7 non \u00e8 divisibile per 4 Come evidente dal codice precedente, ogni volta che il ciclo interno termina con un break , il controllo ritorna al ciclo esterno, ma l' else non viene chiamato; quest'ultimo sar\u00e0 chiamato soltanto quando il ciclo interno non viene interrotto. Nota L'utilizzo di questa particolare forma dell' else \u00e8 abbastanza poco comune, almeno nei casi standard, e pu\u00f2 comunque essere sempre riformulata in maniera pi\u00f9 semplice. Ai fini del corso, si consiglia l'adozione di un controllo di flusso e di una sintassi il pi\u00f9 semplificati possibile.","title":"Istruzione else"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#definizione-di-funzioni","text":"La sintassi usata per definire una funzione in Python \u00e8 la seguente: def nome_funzione ( parametri ): # istruzioni return valore_ritorno E' importante notare che: non \u00e8 necessario definire un tipo di ritorno, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, semplicemente si ometter\u00e0 l'istruzione return ; non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati; \u00e8 consentito inserire dei parametri di default. Ad esempio, la seguente funzione calcola il quadrato: >>> def calcola_area_quadrato ( lato ): ... return lato * lato ... >>> calcola_area_quadrato ( 5 ) 25 La seguente funzione concatena ad una lista il doppio dei singoli valori nella lista stessa: >>> l = [ 1 , 2 ] >>> def raddoppia_lista ( valore ): ... for i in range ( len ( valore )): ... l . append ( l [ i ] * 2 ) ... >>> raddoppia_lista ( l ) >>> l [ 1 , 2 , 2 , 4 ] In questa funzione, invece, usiamo un parametro opzionale per specificare la lunghezza della lista generata in output: >>> def genera_lista_casuale ( lunghezza = 5 ): ... l = [] ... for i in range ( lunghezza ): ... l . append ( randint ( 0 , 10 )) ... return l ... >>> genera_lista_casuale () [ 3 , 1 , 2 , 0 , 6 ] >>> genera_lista_casuale ( 10 ) [ 7 , 9 , 1 , 10 , 2 , 4 , 9 , 1 , 4 , 8 ] Tipo dei parametri di ingresso Il duck typing fa s\u00ec che non sia posto alcun controllo sui parametri di ingresso. Ci\u00f2 per\u00f2 non significa che l'interprete Python ci impedisca di chiamare (ad esempio) la funzione genera_lista_casuale() passando come parametro una stringa; tuttavia, ci\u00f2 comporter\u00e0, come prevedibile, un errore a runtime.","title":"Definizione di funzioni"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#passaggio-di-parametri-a-funzione","text":"E' importante sottolineare come in Python i parametri siano passati ad una funzione esclusivamente per valore . Ad esempio: >>> def raddoppia ( valore ): ... valore = valore * 2 ... >>> val = 1 >>> raddoppia ( val ) >>> val 1 Notiamo come la funzione raddoppia() non abbia quindi avuto alcun effetto sulla variabile esterna! Ci\u00f2 avviene proprio perch\u00e9 questa non \u00e8 passata per reference, ma per valore. Questo \u00e8 il motivo per cui, qualora non si voglia avere un valore di ritorno in una ben determinata funzione, \u00e8 necessario usare dei tipi mutabili (come nel caso della funzione raddoppia_lista , che accetta una lista, ovvero un tipo mutabile), oppure utilizzare le funzioni nell'ambito di una classe (torneremo su questo in avanti).","title":"Passaggio di parametri a funzione"},{"location":"02_dispense/programmazione/03_linguaggio_python/02_programmare/#listruzione-pass","text":"Chiudiamo accennando all'istruzione pass . Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito: >>> def passa (): ... pass ... >>> passa () Nota Anche se non scenderemo nei dettagli, l'istruzione pass \u00e8 utile nella definizione delle classi astratte.","title":"L'istruzione pass"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/","text":"Ancora sulle strutture dati in Python \u00b6 Liste come stack e code \u00b6 Python mette a disposione un'estesa serie di metodi di accesso, inserimento e gestione delle liste, disponibili a questo indirizzo . E' interessante quindi notare come sia possibile costruire uno stack o una coda in maniera estremamente semplice; vediamo come. Stack \u00b6 Ricordiamo che uno stack adotta una strategia di accesso del tipo LIFO; ci\u00f2 significa quindi che il primo elemento ad essere servito sar\u00e0 quello in cima allo stack. Potremo quindi usare il metodo append() per inserire l'elemento in cima alla lista, ed il metodo pop() per recuperarlo. >>> s = [ 1 , 2 , 3 ] >>> s . append ( 4 ) >>> s [ 1 , 2 , 3 , 4 ] >>> e = s . pop () >>> e 4 >>> s [ 1 , 2 , 3 ] Coda \u00b6 Per le code, che ricordiamo adottare una strategia del tipo FIFO, abbiamo due possibilit\u00e0. La prima \u00e8 quella di usare i metodi insert() e pop() come segue: from time import time def queue_classica ( queue , pushed = 1 ): t1 = time () queue . insert ( 0 , pushed ) queue . pop ( 0 ) t2 = time () print ( t2 - t1 ) Notiamo che stiamo usando insert(0, pushed) per inserire l'elemento pushed in cima alla coda, ed il metodo pop(0) per estrarre detto elemento. Lo svantaggio principale di questo approccio sta nel fatto che le operazioni di insert() e di pop() possono essere rallentate dalla necessit\u00e0 di riallocare lo spazio occupato dagli elementi della lista. Un altro modo \u00e8 quello di usare una deque , definita nella libreria collections , ovvero una struttura Python progettata specificamente per \"velocizzare\" le operazioni di append() e pop() da entrambi i capi della struttura dati: from collections import deque def queue_con_deque ( queue , pushed = 1 ): t1 = time () queue . append ( pushed ) queue . popleft () t2 = time () print ( t2 - t1 ) Proviamo a chiamare le due funzioni (abbiamo gi\u00e0 integrato nel corpo ci\u00f2 che serve a cronometrarle): queue = list ( range ( 1000000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) >>> Tempo necessario con queue classica : 0.016004323959350586 >>> Tempo necessario con deque : 0.0 Notiamo quindi che l'uso di una lista classica richiede un tempo maggiore rispetto all'uso di una deque. Nota E' importante notare che stiamo considerando soltanto le operazioni su coda. Qualora considerassimo anche il cast di tipo, potremmo avere risultati differenti; \u00e8 per questo consigliabile usare una struttura di tipo deque soltanto qualora ci siano numerose operazioni di push() e pop() dalla coda. List comprehension \u00b6 Un modo \"rapido\" ed efficace per la creazione di una lista \u00e8 dato dalla tecnica chiamata list comprehension , permettendo di sostituire (quasi completamente) l'uso del classico ciclo for . La list comprehension \"base\" assume questa forma: lista_output = [ f ( elemento ) for elemento in lista_input ] In pratica, la lista di uscita ( lista_output ) sar\u00e0 ottenuta applicando ad ogni elemento della lista di ingresso ( lista_input ) la funzione f() . La sintassi pu\u00f2 essere estesa incorporando un'istruzione condizionale. Ad esempio, l'istruzione nella forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] far\u00e0 in modo che f() sia chiamata esclusivamente sugli elementi che soddisfano condizione . Invece: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] invocher\u00e0 f() sugli elementi che soddisfano condizione , e la funzione g() su tutti gli elementi che non la soddisfano. Nota Per essere precisi, pi\u00f9 che lista_input , sarebbe opportuno parlare di sequenza , o iterabile , di input. Facciamo qualche esempio. Esempio 1: estrazione dei nomi \u00b6 Supponiamo di voler selezionare tutti i nomi che iniziano con la lettera \"B\". Vediamo come farlo con un classico ciclo for : # Estrazione dei nomi che iniziano con \"B\" mediante ciclo for lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] output = [] for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output . append ( nome ) print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ] Vediamo ora una notazione pi\u00f9 compatta usando una list comprehension: # Estrazione dei nomi che iniziano con \"B\" mediante list comprehension output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ] print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ] Esempio 2: calcolo dei quadrati \u00b6 Possiamo usare una list comprehension anche per calcolare una lista di numeri passando una funzione precedentemente definita. Ad esempio, se volessimo calcolare una successione di quadrati, potremmo usare un ciclo for : # Estrazione dei quadrati mediante ciclo for def quadrato ( numero ): return numero ** 2 output = [] for i in range ( 10 ): output . append ( quadrato ( i )) print ( output ) [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] # Estrazione dei quadrati mediante list comprehension output = [ quadrato ( i ) for i in range ( 10 )] print ( output ) [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] Esempio 3: lista dei numeri pari e dispari \u00b6 Vediamo infine come usare la list comprehension per caratterizzare tutti i numeri pari e dispari fino a 10. Partiamo, al solito, con il risultato ottenuto usando un ciclo for : # Lista dei pari e dispari mediante ciclo for output = [] for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \" {} \u00e8 pari\" . format ( i )) else : output . append ( \" {} \u00e8 dispari\" . format ( i )) print ( output ) [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ] # Lista dei pari e dispari mediante list comprehension output = [ \" {} \u00e8 pari\" . format ( i ) if i % 2 == 0 else \" {} \u00e8 dispari\" . format ( i ) for i in range ( 1 , 10 )] print ( output ) [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ] Assignment expression \u00b6 Le list comprehension sono pensate per favorire approcci puramente iterativi . E' pertanto abbastanza complesso (seppur non impossibile) implementare delle forme di ricorsione. Per ovviare a questo, \u00e8 possibile usare una nuova funzionalit\u00e0, introdotta a paritre da Python 3.8, e chiamata assignment expression . Formalmente, l'assignment expression permette di assegnare e restituire un valore all'interno di una singola istruzione, mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Usando in maniera opportuna questo operatore, possiamo usare una sorta di \"approccio ricorsivo\" alla list comprehension. Partiamo definendo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci: >>> fib = [ 0 , 1 ] Vediamo adesso cosa accade se proviamo ad usare una assignment expression, mediante la quale restituiamo una lista che ha come primo valore quello al secondo indice della precedente, ed al secondo la somma espressa da Fibonacci: >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> # Fibonacci ha cambiato valore! >>> fib [ 1 , 1 ] A questo punto, possiamo selezionare soltanto il secondo valore della lista ottenuta mediante assignment expression. Per farlo, usiamo la condizione booleana and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Possiamo quindi combinare tutto usando una list comprehension e concatenando i risultati che abbiamo ottenuto: >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] Nota Esistono ovviamente altri approcci, alcuni dei quali sfruttano un modulo estremamente utile chiamato itertools . Tuple \u00b6 Le tuple sono il terzo tipo di sequenze \"standard\" disponibile in Python, e consistono di una serie di valori separati da una lettera. Ad esempio: >>> tupla = ( 'hello' , 'world' , 12 ) >>> tupla ( 'hello' , 'world' , 12 ) Cos\u00ec come per le liste, uno dei valori della tupla pu\u00f2 essere a sua volta una tupla: >>> tupla = ( 'hello' , 'world' , ( 1 , 2 )) >>> tupla ( 'hello' , 'world' , ( 1 , 2 )) E' per\u00f2 importante sottolineare che, a differenza delle liste (e come le stringhe), le tuple sono immutabili . Nota Il fatto che le tuple siano immutabili non implica che non possano contenere al loro interno oggetti mutabili. Ad esempio: >>> tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) >>> tupla [ 2 ] [ 1 , 2 , 3 ] >>> tupla [ 2 ] = [ 1 , 2 , 3 , 4 ] # errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment >>> tupla [ 2 ][ 0 ] = 2 # ok >>> tupla ( 'hello' , 'world' , [ 2 , 2 , 3 ]) Tuple e liste E' facile osservare come tuple e liste siano tra loro molto simili a livello sintattico, e differiscano principalmente per il fatto che le prime sono immutabili, mentre le seconde no. Idealmente, \u00e8 bene usare le tuple per elementi di tipo eterogeneo, che devono essere esclusivamente acceduti, mentre le liste vanno usate per elementi omogenei, che devono essere modificati all'occorrenza. Dizionari \u00b6 L'ultimo tipo di dati che vale la pena affrontare in Python sono i dizionari , che abbiamo gi\u00e0 visto in C e C++ con il nome di array associativi . I dizionari sono quindi indicizzati non mediante un classico indice numerico, ma mediante delle chiavi , che devono necessariamente essere immutabili (ovvero stringhe, numeri e tuple, che per\u00f2 al loro interno non possono contenere elementi mutabili come liste). Ad ogni chiave, come negli array associativi, corrisponde un determinato valore , che \u00e8 arbitrario e pu\u00f2 essere di qualsiasi tipo. Di conseguenza, un concetto comunemente associato ai dizionari \u00e8 quello di coppie chiave - valore . Vediamo come creare un dizionario: >>> dizionario = {} # creo un dizionario vuoto >>> dizionario {} Possiamo quindi inserire una serie di chiavi, associandovi un determinato valore: >>> dizionario [ 'k' ] = 'v' # aggiungo la chiave \"k\" a cui \u00e8 associato il valore \"v\" >>> dizionario { 'k' : 'v' } >>> dizionario [ 1 ] = 'n' # aggiungo la chiave 1 a cui \u00e8 associato il valore \"n\" >>> dizionario { 'k' : 'v' , 1 : 'n' } Per accedere al valore associato ad una chiave: >>> dizionario [ 1 ] 'n' Accedere a chiavi e valori \u00b6 E' possibile avere la lista delle chiavi di un dizionario mediante il metodo keys() , che restituisce un oggetto di tipo dict_keys , convertibile in lista: >>> chiavi = dizionario . keys () >>> chiavi dict_keys ([ 'k' , 1 ]) # non \u00e8 una lista! >>> list ( chiavi ) [ 'k' , 1 ] # \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: >>> valori = dizionario . values () >>> valori dict_values ([ 'k' , 'n' ]) # non \u00e8 una lista! >>> list ( valori ) [ 'k' , 'n' ] # \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: >>> coppie = dizionario . items () >>> coppie dict_items ([( 'k' , 'v' ), ( 1 , 'n' )]) # non \u00e8 una lista! >>> list ( coppie ) [( 'k' , 'v' ), ( 1 , 'n' )] # lista di tuple! >>> Creare un dizionario non vuoto \u00b6 Abbiamo diversi modi per creare un dizionario non vuoto. Il primo, pi\u00f9 semplice, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 } Uso della funzione zip \u00b6 Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: >>> chiavi = [ 'k1' , 'k2' ] >>> valori = [ 1 , 2 ] >>> dizionario = dict ( zip ( chiavi , valori )) >>> dizionario { 'k1' : 1 , 'k2' : 2 } Dict comprehension \u00b6 Possiamo ottenere un dizionario a partire da un altro oggetto iterabile (sia esso una sequenza o un altro dizionario) usando la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: >>> quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} >>> quadrati { '1' : 1 , '2' : 4 , '3' : 9 , '4' : 16 , '5' : 25 , '6' : 36 , '7' : 49 , '8' : 64 , '9' : 81 } Oppure, possiamo creare un dizionario a partire da un altro dizionario, usando le stesse regole condizionali viste con la list comprehension: >>> dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } >>> vecchio_o_giovane = { k : 'vecchio' if v > 50 else 'giovane' for ( k , v ) in dizionario . items () } >>> vecchio_o_giovane { 'Jax Teller' : 'giovane' , 'Walter White' : 'vecchio' , 'Billy Butcher' : 'giovane' , 'Luke Skywalker' : 'vecchio' , 'Bobby Singer' : 'vecchio' , 'Johnny Lawrence' : 'giovane' } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"03 - Strutture Dati"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#ancora-sulle-strutture-dati-in-python","text":"","title":"Ancora sulle strutture dati in Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#liste-come-stack-e-code","text":"Python mette a disposione un'estesa serie di metodi di accesso, inserimento e gestione delle liste, disponibili a questo indirizzo . E' interessante quindi notare come sia possibile costruire uno stack o una coda in maniera estremamente semplice; vediamo come.","title":"Liste come stack e code"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#stack","text":"Ricordiamo che uno stack adotta una strategia di accesso del tipo LIFO; ci\u00f2 significa quindi che il primo elemento ad essere servito sar\u00e0 quello in cima allo stack. Potremo quindi usare il metodo append() per inserire l'elemento in cima alla lista, ed il metodo pop() per recuperarlo. >>> s = [ 1 , 2 , 3 ] >>> s . append ( 4 ) >>> s [ 1 , 2 , 3 , 4 ] >>> e = s . pop () >>> e 4 >>> s [ 1 , 2 , 3 ]","title":"Stack"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#coda","text":"Per le code, che ricordiamo adottare una strategia del tipo FIFO, abbiamo due possibilit\u00e0. La prima \u00e8 quella di usare i metodi insert() e pop() come segue: from time import time def queue_classica ( queue , pushed = 1 ): t1 = time () queue . insert ( 0 , pushed ) queue . pop ( 0 ) t2 = time () print ( t2 - t1 ) Notiamo che stiamo usando insert(0, pushed) per inserire l'elemento pushed in cima alla coda, ed il metodo pop(0) per estrarre detto elemento. Lo svantaggio principale di questo approccio sta nel fatto che le operazioni di insert() e di pop() possono essere rallentate dalla necessit\u00e0 di riallocare lo spazio occupato dagli elementi della lista. Un altro modo \u00e8 quello di usare una deque , definita nella libreria collections , ovvero una struttura Python progettata specificamente per \"velocizzare\" le operazioni di append() e pop() da entrambi i capi della struttura dati: from collections import deque def queue_con_deque ( queue , pushed = 1 ): t1 = time () queue . append ( pushed ) queue . popleft () t2 = time () print ( t2 - t1 ) Proviamo a chiamare le due funzioni (abbiamo gi\u00e0 integrato nel corpo ci\u00f2 che serve a cronometrarle): queue = list ( range ( 1000000000 )) queue_d = deque ( queue ) queue_classica ( queue ) queue_con_deque ( queue_d ) >>> Tempo necessario con queue classica : 0.016004323959350586 >>> Tempo necessario con deque : 0.0 Notiamo quindi che l'uso di una lista classica richiede un tempo maggiore rispetto all'uso di una deque. Nota E' importante notare che stiamo considerando soltanto le operazioni su coda. Qualora considerassimo anche il cast di tipo, potremmo avere risultati differenti; \u00e8 per questo consigliabile usare una struttura di tipo deque soltanto qualora ci siano numerose operazioni di push() e pop() dalla coda.","title":"Coda"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#list-comprehension","text":"Un modo \"rapido\" ed efficace per la creazione di una lista \u00e8 dato dalla tecnica chiamata list comprehension , permettendo di sostituire (quasi completamente) l'uso del classico ciclo for . La list comprehension \"base\" assume questa forma: lista_output = [ f ( elemento ) for elemento in lista_input ] In pratica, la lista di uscita ( lista_output ) sar\u00e0 ottenuta applicando ad ogni elemento della lista di ingresso ( lista_input ) la funzione f() . La sintassi pu\u00f2 essere estesa incorporando un'istruzione condizionale. Ad esempio, l'istruzione nella forma: lista_output_if = [ f ( elemento ) for elemento in lista_input if condizione ] far\u00e0 in modo che f() sia chiamata esclusivamente sugli elementi che soddisfano condizione . Invece: lista_output_if_else = [ f ( elemento ) if condizione else g ( elemento ) for elemento in lista_input ] invocher\u00e0 f() sugli elementi che soddisfano condizione , e la funzione g() su tutti gli elementi che non la soddisfano. Nota Per essere precisi, pi\u00f9 che lista_input , sarebbe opportuno parlare di sequenza , o iterabile , di input. Facciamo qualche esempio.","title":"List comprehension"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#esempio-1-estrazione-dei-nomi","text":"Supponiamo di voler selezionare tutti i nomi che iniziano con la lettera \"B\". Vediamo come farlo con un classico ciclo for : # Estrazione dei nomi che iniziano con \"B\" mediante ciclo for lista_nomi = [ \"Jax Teller\" , \"Walter White\" , \"Billy Butcher\" , \"Luke Skywalker\" , \"Bobby Singer\" , \"Johnny Lawrence\" ] output = [] for nome in lista_nomi : if nomi [ 0 ] == \"B\" : output . append ( nome ) print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ] Vediamo ora una notazione pi\u00f9 compatta usando una list comprehension: # Estrazione dei nomi che iniziano con \"B\" mediante list comprehension output = [ nome for nome in lista_nomi if nome [ 0 ] == \"B\" ] print ( output ) [ 'Billy Butcher' , 'Bobby Singer' ]","title":"Esempio 1: estrazione dei nomi"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#esempio-2-calcolo-dei-quadrati","text":"Possiamo usare una list comprehension anche per calcolare una lista di numeri passando una funzione precedentemente definita. Ad esempio, se volessimo calcolare una successione di quadrati, potremmo usare un ciclo for : # Estrazione dei quadrati mediante ciclo for def quadrato ( numero ): return numero ** 2 output = [] for i in range ( 10 ): output . append ( quadrato ( i )) print ( output ) [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] # Estrazione dei quadrati mediante list comprehension output = [ quadrato ( i ) for i in range ( 10 )] print ( output ) [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ]","title":"Esempio 2: calcolo dei quadrati"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#esempio-3-lista-dei-numeri-pari-e-dispari","text":"Vediamo infine come usare la list comprehension per caratterizzare tutti i numeri pari e dispari fino a 10. Partiamo, al solito, con il risultato ottenuto usando un ciclo for : # Lista dei pari e dispari mediante ciclo for output = [] for i in range ( 1 , 10 ): if i % 2 == 0 : output . append ( \" {} \u00e8 pari\" . format ( i )) else : output . append ( \" {} \u00e8 dispari\" . format ( i )) print ( output ) [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ] # Lista dei pari e dispari mediante list comprehension output = [ \" {} \u00e8 pari\" . format ( i ) if i % 2 == 0 else \" {} \u00e8 dispari\" . format ( i ) for i in range ( 1 , 10 )] print ( output ) [ '1 \u00e8 dispari' , '2 \u00e8 pari' , '3 \u00e8 dispari' , '4 \u00e8 pari' , '5 \u00e8 dispari' , '6 \u00e8 pari' , '7 \u00e8 dispari' , '8 \u00e8 pari' , '9 \u00e8 dispari' ]","title":"Esempio 3: lista dei numeri pari e dispari"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#assignment-expression","text":"Le list comprehension sono pensate per favorire approcci puramente iterativi . E' pertanto abbastanza complesso (seppur non impossibile) implementare delle forme di ricorsione. Per ovviare a questo, \u00e8 possibile usare una nuova funzionalit\u00e0, introdotta a paritre da Python 3.8, e chiamata assignment expression . Formalmente, l'assignment expression permette di assegnare e restituire un valore all'interno di una singola istruzione, mediante il cosiddetto walrus operator : >>> print ( enjoy := True ) True Usando in maniera opportuna questo operatore, possiamo usare una sorta di \"approccio ricorsivo\" alla list comprehension. Partiamo definendo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci: >>> fib = [ 0 , 1 ] Vediamo adesso cosa accade se proviamo ad usare una assignment expression, mediante la quale restituiamo una lista che ha come primo valore quello al secondo indice della precedente, ed al secondo la somma espressa da Fibonacci: >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) >>> # Fibonacci ha cambiato valore! >>> fib [ 1 , 1 ] A questo punto, possiamo selezionare soltanto il secondo valore della lista ottenuta mediante assignment expression. Per farlo, usiamo la condizione booleana and : >>> ( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] 1 Possiamo quindi combinare tutto usando una list comprehension e concatenando i risultati che abbiamo ottenuto: >>> fib = [ 0 , 1 ] >>> fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( 10 )] >>> fib [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] Nota Esistono ovviamente altri approcci, alcuni dei quali sfruttano un modulo estremamente utile chiamato itertools .","title":"Assignment expression"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#tuple","text":"Le tuple sono il terzo tipo di sequenze \"standard\" disponibile in Python, e consistono di una serie di valori separati da una lettera. Ad esempio: >>> tupla = ( 'hello' , 'world' , 12 ) >>> tupla ( 'hello' , 'world' , 12 ) Cos\u00ec come per le liste, uno dei valori della tupla pu\u00f2 essere a sua volta una tupla: >>> tupla = ( 'hello' , 'world' , ( 1 , 2 )) >>> tupla ( 'hello' , 'world' , ( 1 , 2 )) E' per\u00f2 importante sottolineare che, a differenza delle liste (e come le stringhe), le tuple sono immutabili . Nota Il fatto che le tuple siano immutabili non implica che non possano contenere al loro interno oggetti mutabili. Ad esempio: >>> tupla = ( 'hello' , 'world' , [ 1 , 2 , 3 ]) >>> tupla [ 2 ] [ 1 , 2 , 3 ] >>> tupla [ 2 ] = [ 1 , 2 , 3 , 4 ] # errore! Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment >>> tupla [ 2 ][ 0 ] = 2 # ok >>> tupla ( 'hello' , 'world' , [ 2 , 2 , 3 ]) Tuple e liste E' facile osservare come tuple e liste siano tra loro molto simili a livello sintattico, e differiscano principalmente per il fatto che le prime sono immutabili, mentre le seconde no. Idealmente, \u00e8 bene usare le tuple per elementi di tipo eterogeneo, che devono essere esclusivamente acceduti, mentre le liste vanno usate per elementi omogenei, che devono essere modificati all'occorrenza.","title":"Tuple"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#dizionari","text":"L'ultimo tipo di dati che vale la pena affrontare in Python sono i dizionari , che abbiamo gi\u00e0 visto in C e C++ con il nome di array associativi . I dizionari sono quindi indicizzati non mediante un classico indice numerico, ma mediante delle chiavi , che devono necessariamente essere immutabili (ovvero stringhe, numeri e tuple, che per\u00f2 al loro interno non possono contenere elementi mutabili come liste). Ad ogni chiave, come negli array associativi, corrisponde un determinato valore , che \u00e8 arbitrario e pu\u00f2 essere di qualsiasi tipo. Di conseguenza, un concetto comunemente associato ai dizionari \u00e8 quello di coppie chiave - valore . Vediamo come creare un dizionario: >>> dizionario = {} # creo un dizionario vuoto >>> dizionario {} Possiamo quindi inserire una serie di chiavi, associandovi un determinato valore: >>> dizionario [ 'k' ] = 'v' # aggiungo la chiave \"k\" a cui \u00e8 associato il valore \"v\" >>> dizionario { 'k' : 'v' } >>> dizionario [ 1 ] = 'n' # aggiungo la chiave 1 a cui \u00e8 associato il valore \"n\" >>> dizionario { 'k' : 'v' , 1 : 'n' } Per accedere al valore associato ad una chiave: >>> dizionario [ 1 ] 'n'","title":"Dizionari"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#accedere-a-chiavi-e-valori","text":"E' possibile avere la lista delle chiavi di un dizionario mediante il metodo keys() , che restituisce un oggetto di tipo dict_keys , convertibile in lista: >>> chiavi = dizionario . keys () >>> chiavi dict_keys ([ 'k' , 1 ]) # non \u00e8 una lista! >>> list ( chiavi ) [ 'k' , 1 ] # \u00e8 una lista! In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo values() , che restituir\u00e0 un oggetto di tipo dict_values , da convertire anch'esso in lista: >>> valori = dizionario . values () >>> valori dict_values ([ 'k' , 'n' ]) # non \u00e8 una lista! >>> list ( valori ) [ 'k' , 'n' ] # \u00e8 una lista! Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo items() , che ci restituisce un oggetto di tipo dict_items , il quale pu\u00f2 essere convertito in una lista di tuple: >>> coppie = dizionario . items () >>> coppie dict_items ([( 'k' , 'v' ), ( 1 , 'n' )]) # non \u00e8 una lista! >>> list ( coppie ) [( 'k' , 'v' ), ( 1 , 'n' )] # lista di tuple! >>>","title":"Accedere a chiavi e valori"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#creare-un-dizionario-non-vuoto","text":"Abbiamo diversi modi per creare un dizionario non vuoto. Il primo, pi\u00f9 semplice, \u00e8 quello di dichiarare nell'operatore {} le coppie chiave - valore iniziali: >>> dizionario = { 'k1' : 1 , 'k2' : 2 } >>> dizionario { 'k1' : 1 , 'k2' : 2 }","title":"Creare un dizionario non vuoto"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#uso-della-funzione-zip","text":"Possiamo poi usare la funzione zip per creare un dizionario a partire da due liste: >>> chiavi = [ 'k1' , 'k2' ] >>> valori = [ 1 , 2 ] >>> dizionario = dict ( zip ( chiavi , valori )) >>> dizionario { 'k1' : 1 , 'k2' : 2 }","title":"Uso della funzione zip"},{"location":"02_dispense/programmazione/03_linguaggio_python/03_strutture/#dict-comprehension","text":"Possiamo ottenere un dizionario a partire da un altro oggetto iterabile (sia esso una sequenza o un altro dizionario) usando la dict comprehension , che ha una forma del tipo: output = { chiave : valore for valore in iterabile } Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi: >>> quadrati = { str ( i ): i ** 2 for i in range ( 1 , 10 )} >>> quadrati { '1' : 1 , '2' : 4 , '3' : 9 , '4' : 16 , '5' : 25 , '6' : 36 , '7' : 49 , '8' : 64 , '9' : 81 } Oppure, possiamo creare un dizionario a partire da un altro dizionario, usando le stesse regole condizionali viste con la list comprehension: >>> dizionario = { 'Jax Teller' : 27 , 'Walter White' : 52 , 'Billy Butcher' : 41 , 'Luke Skywalker' : 79 , 'Bobby Singer' : 68 , 'Johnny Lawrence' : 49 } >>> vecchio_o_giovane = { k : 'vecchio' if v > 50 else 'giovane' for ( k , v ) in dizionario . items () } >>> vecchio_o_giovane { 'Jax Teller' : 'giovane' , 'Walter White' : 'vecchio' , 'Billy Butcher' : 'giovane' , 'Luke Skywalker' : 'vecchio' , 'Bobby Singer' : 'vecchio' , 'Johnny Lawrence' : 'giovane' } Nota Per iterare sul dizionario originale, usiamo il metodo items() che, come visto in precedenza, ci restituisce un oggetto di tipo dict_items il quale \u00e8, per l'appunto, iterabile.","title":"Dict comprehension"},{"location":"02_dispense/programmazione/03_linguaggio_python/04_moduli/","text":"Moduli \u00b6 Possiamo interagire con l'interprete Python in diversi modi. Finora, quello che abbiamo maggiormente usato \u00e8 stata l'interazione diretta con l'interprete, lanciandolo da terminale ed invocando di volta in volta le istruzioni necessarie. Ovviamente, questo presenta numerosi svantaggi: non abbiamo infatti syntax highlighting, non siamo in grado di recuperare le istruzioni una volta chiuso l'interprete, ed in generale non \u00e8 un modo ottimale di programmare. Possiamo quindi definire degli script , che saranno salvati sotto forma di file con estensione py , e conterranno tutte le istruzioni che vogliamo siano eseguite a runtime. Esiste per\u00f2 un modo per replicare l'approccio che avevamo adottato in C e C++, ovvero quello di suddividere il codice in base alle funzionalit\u00e0 offerte; per farlo, occorre usare i moduli , ovvero dei file, sempre con estensione py , che contengono le definizioni alle classi o ai metodi da noi creati, che potranno quindi essere richiamati esternamente. Nota La linea che contraddistingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile confondersi utilizzandoli in maniera \"intercambiabile\". Ricordiamo per\u00f2 che, almeno in teoria, gli script dovrebbero essere esclusivamente eseguiti , mentre i moduli soltanto invocati . Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file matematica.py , l'interprete associer\u00e0 a quel modulo il nome matematica . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ . Facciamo un esempio. Il modulo matematica \u00b6 Creiamo un modulo matematica all'interno del file matematica.py ; nel modulo, definiremo delle funzioni per il calcolo matematico. Ad esempio: # matematica.py def somma ( a , b ): return a + b def moltiplica ( a , b ): return a * b def fibonacci ( val_max ): fib = [ 0 , 1 ] fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( val_max )] return fib Definiamo ora, nella stessa cartella, uno script, e chiamiamolo run.py : # run.py import matematica if __name__ == \"__main__\" : print ( matematica . fibonacci ( 20 )) Notiamo due cose: stiamo richiamando la funzione fibonacci() definita nel modulo matematica ; per farlo, usiamo la direttiva import (potete pensarla come analoga alla direttiva #include del C/C++); alle righe 4-5, quella \"strana\" sintassi ci serve a dichiarare il main . Tuttavia, Python ci permette di ometterla, ed \u00e8 utile soprattutto nel caso ci siano programmi complessi con passaggio di parametri multipli. Proviamo quindi a lanciare lo script digitando l'istruzione python run.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i primi dodici elementi della sequenza di Fibonacci. Import di funzioni Nel nostro script, abbiamo usato esclusivamente la funzione fibonacci() ; tuttavia, la direttiva import utilizzata fa s\u00ec che vengano importante anche le funzioni somma e moltiplica, che non utilizziamo. E' quindi buona regola, qualora non servano tutte le classi e funzioni definite all'interno di un modulo, usare una versione modificata della direttiva, che prende la forma di: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from matematica import fibonacci Alias L' import permette anche di definire degli alias, che risultano particolarmente utili nel caso di nomi di package complessi. Ad esempio: import matematica as mate print ( mate . fibonacci ( 20 )) La funzione dir() \u00b6 La funzione dir() ci permette di vedere tutti i nomi (sia di funzione, sia di classe) definiti da un modulo, e li restituisce sotto forma di lista. Ad esempio: >>> dir ( matematica ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'fibonacci' , 'moltiplica' , 'somma' ] Nota Oltre alle funzioni, classi e costanti da noi definite, nel modulo matematica sono definite in modo automatico tutta una serie di variabili, le quali saranno importate assieme alle definizioni necessarie nel caso si usi la direttiva import in maniera \"approssimativa\". Ad esempio: import matematica if __name__ == \"__main__\" : print ( matematica . __file__ ) print ( matematica . fibonacci ( 20 )) In questo caso, saremo in grado di accedere alla variabile __file__ del modulo matematica , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non ci serve (quasi mai), per cui \u00e8 evidente l'importanza dell'uso della direttiva from ! Moduli della libreria standard \u00b6 Python ha diversi moduli appartenenti ad una libreria standard, analogamente a quanto visto per C e C++. In particolare, alcuni moduli meritano una menzione: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Ovviamente, fare una lista esaustiva \u00e8 pressoch\u00e9 inutile, oltre che ridondante, per cui si rimanda alla Python Library Reference . Package \u00b6 Chiudiamo con un accenno ad un ulteriore livello possibile nella struttura dei file di un programma (o libreria) Python, ovvero quello definito mediante i package . In breve, questi sono dei veri e propri \"contenitori\" di moduli, che permettono di raggruppare moduli tra loro coerenti, di modo da facilitarne successivamente l'accesso ed il recupero; nella pratica, i package sono delle cartelle sul file system, contenenti al loro interno una serie di moduli ed un file (spesso lasciato vuoto) chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package. L'accesso ad un modulo interno ad un package avviene modificando la direttiva import come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"04 - Moduli"},{"location":"02_dispense/programmazione/03_linguaggio_python/04_moduli/#moduli","text":"Possiamo interagire con l'interprete Python in diversi modi. Finora, quello che abbiamo maggiormente usato \u00e8 stata l'interazione diretta con l'interprete, lanciandolo da terminale ed invocando di volta in volta le istruzioni necessarie. Ovviamente, questo presenta numerosi svantaggi: non abbiamo infatti syntax highlighting, non siamo in grado di recuperare le istruzioni una volta chiuso l'interprete, ed in generale non \u00e8 un modo ottimale di programmare. Possiamo quindi definire degli script , che saranno salvati sotto forma di file con estensione py , e conterranno tutte le istruzioni che vogliamo siano eseguite a runtime. Esiste per\u00f2 un modo per replicare l'approccio che avevamo adottato in C e C++, ovvero quello di suddividere il codice in base alle funzionalit\u00e0 offerte; per farlo, occorre usare i moduli , ovvero dei file, sempre con estensione py , che contengono le definizioni alle classi o ai metodi da noi creati, che potranno quindi essere richiamati esternamente. Nota La linea che contraddistingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile confondersi utilizzandoli in maniera \"intercambiabile\". Ricordiamo per\u00f2 che, almeno in teoria, gli script dovrebbero essere esclusivamente eseguiti , mentre i moduli soltanto invocati . Interprete e nome di un modulo L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file matematica.py , l'interprete associer\u00e0 a quel modulo il nome matematica . Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale __name__ . Facciamo un esempio.","title":"Moduli"},{"location":"02_dispense/programmazione/03_linguaggio_python/04_moduli/#il-modulo-matematica","text":"Creiamo un modulo matematica all'interno del file matematica.py ; nel modulo, definiremo delle funzioni per il calcolo matematico. Ad esempio: # matematica.py def somma ( a , b ): return a + b def moltiplica ( a , b ): return a * b def fibonacci ( val_max ): fib = [ 0 , 1 ] fib += [( fib := [ fib [ 1 ], fib [ 0 ] + fib [ 1 ]]) and fib [ 1 ] for i in range ( val_max )] return fib Definiamo ora, nella stessa cartella, uno script, e chiamiamolo run.py : # run.py import matematica if __name__ == \"__main__\" : print ( matematica . fibonacci ( 20 )) Notiamo due cose: stiamo richiamando la funzione fibonacci() definita nel modulo matematica ; per farlo, usiamo la direttiva import (potete pensarla come analoga alla direttiva #include del C/C++); alle righe 4-5, quella \"strana\" sintassi ci serve a dichiarare il main . Tuttavia, Python ci permette di ometterla, ed \u00e8 utile soprattutto nel caso ci siano programmi complessi con passaggio di parametri multipli. Proviamo quindi a lanciare lo script digitando l'istruzione python run.py da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i primi dodici elementi della sequenza di Fibonacci. Import di funzioni Nel nostro script, abbiamo usato esclusivamente la funzione fibonacci() ; tuttavia, la direttiva import utilizzata fa s\u00ec che vengano importante anche le funzioni somma e moltiplica, che non utilizziamo. E' quindi buona regola, qualora non servano tutte le classi e funzioni definite all'interno di un modulo, usare una versione modificata della direttiva, che prende la forma di: from modulo import funzione_o_classe il che, nel nostro caso specifico, diventa: from matematica import fibonacci Alias L' import permette anche di definire degli alias, che risultano particolarmente utili nel caso di nomi di package complessi. Ad esempio: import matematica as mate print ( mate . fibonacci ( 20 ))","title":"Il modulo matematica"},{"location":"02_dispense/programmazione/03_linguaggio_python/04_moduli/#la-funzione-dir","text":"La funzione dir() ci permette di vedere tutti i nomi (sia di funzione, sia di classe) definiti da un modulo, e li restituisce sotto forma di lista. Ad esempio: >>> dir ( matematica ) [ '__builtins__' , '__cached__' , '__doc__' , '__file__' , '__loader__' , '__name__' , '__package__' , '__spec__' , 'fibonacci' , 'moltiplica' , 'somma' ] Nota Oltre alle funzioni, classi e costanti da noi definite, nel modulo matematica sono definite in modo automatico tutta una serie di variabili, le quali saranno importate assieme alle definizioni necessarie nel caso si usi la direttiva import in maniera \"approssimativa\". Ad esempio: import matematica if __name__ == \"__main__\" : print ( matematica . __file__ ) print ( matematica . fibonacci ( 20 )) In questo caso, saremo in grado di accedere alla variabile __file__ del modulo matematica , che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non ci serve (quasi mai), per cui \u00e8 evidente l'importanza dell'uso della direttiva from !","title":"La funzione dir()"},{"location":"02_dispense/programmazione/03_linguaggio_python/04_moduli/#moduli-della-libreria-standard","text":"Python ha diversi moduli appartenenti ad una libreria standard, analogamente a quanto visto per C e C++. In particolare, alcuni moduli meritano una menzione: sys : \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento; os : modulo delegato all'interazione con il sistema operativo su cui gira l'interprete; time : modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione; datetime : modulo usato per le funzionalit\u00e0 di data ed ora; copy : modulo usato per gestire, tra le altre cose, la deep copy di un oggetto. Ovviamente, fare una lista esaustiva \u00e8 pressoch\u00e9 inutile, oltre che ridondante, per cui si rimanda alla Python Library Reference .","title":"Moduli della libreria standard"},{"location":"02_dispense/programmazione/03_linguaggio_python/04_moduli/#package","text":"Chiudiamo con un accenno ad un ulteriore livello possibile nella struttura dei file di un programma (o libreria) Python, ovvero quello definito mediante i package . In breve, questi sono dei veri e propri \"contenitori\" di moduli, che permettono di raggruppare moduli tra loro coerenti, di modo da facilitarne successivamente l'accesso ed il recupero; nella pratica, i package sono delle cartelle sul file system, contenenti al loro interno una serie di moduli ed un file (spesso lasciato vuoto) chiamato __init__.py , che permette all'interprete di riconoscere quella cartella come package. L'accesso ad un modulo interno ad un package avviene modificando la direttiva import come segue: import nome_package.nome_modulo # oppure... from nome_package.nome_modulo import nome_funzione","title":"Package"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/","text":"Classi in Python \u00b6 Cos\u00ec come il C++, Python ha un esteso supporto per la programmazione orientata agli oggetti. La definizione di una classe in Python avviene come segue: class ClassName ( BaseClass ): # Class body Notiamo che, a differenza del C++, nel quale la classe viene definita all'interno di un header, qui la definizione avviene contestualmente alla dichiarazione della firma della classe. Costruttori \u00b6 Il linguaggio Python non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione degli attributi della classe. Questo metodo assume lo stesso nome per ogni classe, ovvero __init__ : class ClassName ( BaseClass ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Nota La sintassi *args e **kwargs rappresenta, rispettivamente, l' unpacking di liste e dizionari. Ci\u00f2 significa che come argomento non si passa la lista o il dizionario, ma i valori (o le coppie chiave/valore) ivi contenuti. Notiamo l'uso della parola chiave self . Questa, in qualche modo, richiama il this del C++: infatti, si riferisce alla specifica istanza della classe. Ad esempio: class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota In Python, tutte le classi derivano da una classe generica object . Modificatori di accesso \u00b6 Python prevede, come il C++, l'uso di modificatori di accesso ai dati; nello specifico, ritroviamo public , protected e private . Per contraddistinguere i tre tipi di variabili, si utilizzano gli underscore come suffisso al nome della stessa; in particolare, un unico underscore indica un membro protected , mentre un doppio underscore indica un membro private . class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota I membri protetti sono facilmente accessibili dall'esterno della classe. Infatti: p = Person ( 'Jax' , 'Teller' ) print ( p . first_name ) print ( p . _last_name ) try : print ( p . __age ) except AttributeError : print ( 'Age is private!' ) risulter\u00e0 in: Jax Teller Et\u00e0 \u00e8 privato! Contestualmente, \u00e8 possibile usare la stessa convenzione definire metodi per l'accesso a variabili protected e private . Classi e metodi \u00b6 I metodi di una classe sono definiti in questo modo: def metodo ( self , * args , ** kwargs ): pass E' importante notare come il primo attributo di un normale metodo di classe sia sempre la parola self . Questa non deve per\u00f2 essere specificata quando lo si chiama dall'esterno: basta infatti chiamarlo usando l'operatore . da un'istanza della classe: # ... p = Person () p . metodo ( * args , ** kwargs ) # ... I decorator \u00b6 Prima di continuare a parlare dei metodi che \u00e8 possibile definire all'interno di una classe Python, \u00e8 necessario introdurre il concetto di decorator , ovvero una particolare notazione che viene usata in Python (ed in altri linguaggi di programmazione) per indicare una funzione che \"decora\" un'altra funzione. Funzioni come oggetti \u00b6 Python tratta le funzioni come degli oggetti . E' quindi possiible che una funzione restituisca una funzione : def main_character ( series ): def supernatural (): return \"Sam Winchester\" def breaking_bad (): return \"Walter White\" if series == \"Supernatural\" : return supernatural elif series == \"Breaking Bad\" : return breaking_bad Il valore di ritorno \u00e8 quindi un oggetto. Possiamo provare a chiamarlo dal nostro script: >>> mc = main_character ( \"Supernatural\" ) Se provassimo a mandarlo a schermo trattandolo come una variabile, avremmo in uscita una reference a funzione: >>> print ( \"Function reference: {} \" . format ( mc )) Function reference : < function main_character .< locals >. supernatural at 0x00000170C448BA60 > Per visualizzare il risultato, trattiamolo come se fosse una chiamata a funzione: >>> print ( \"Function outcoming value: {} \" . format ( mc ())) Function outcoming value : Sam Winchester Funzioni come argomenti di altre funzioni \u00b6 Possiamo passare una fuzione come argomento ad un'altra funzione: def favorite_series ( func ): def internal_check (): print ( \"Checking my favorite series...\" ) func () print ( \"Got it!\" ) return internal_check def check (): print ( 'Sons of Anarchy' ) Dal nostro script: >>> print_fav_series = favorite_series ( check ) >>> print_fav_series () Checking my favorite series ... Sons of Anarchy Got it ! Vediamo quindi come la funzione passata come argomento sar\u00e0 correttamente chiamata internamente al metodo favorite_series . Definizione ed uso di decorator \u00b6 La sintassi che abbiamo usato \u00e8, per dirla con Manzoni, ampollosa . Python ci offre quindi una sintassi equivalente, ma molto pi\u00f9 accessibile, per usare una funzione come argomento di un'altra funzione, ovvero i decorator. Infatti: @favorite_series def print_fav_series_decorated (): print ( 'Breaking Bad' ) >>> print_fav_series_decorated () Checking my favorite series ... Breaking Bad Got it ! @classmethod \u00b6 E' possibile definire i cosiddetti metodi di classe mediante il decorator @classmethod : @classmethod def from_string ( cls , person_string : str ): fn , ln , age = person_string . split ( ' ' ) return Person ( fn , ln , age ) A differenza dei normali metodi definiti all'interno di una classe, i metodi di classe passano implicitamente un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi pensati per applicarsi all'intera classe, e non alla singola istanza; normalmente, vengono usati per creare dei costruttori alternativi, come nel caso precedente, nel quale creiamo una persona a partire da una stringa. Per chiamare un metodo di classe, ci riferiamo al nome della classe stessa, e non alla singola istanza: pb = Person . from_string ( 'Bobby Munson 58' ) print ( \" {} {} \" . format ( pb . first_name , pb . _last_name )) @staticmethod \u00b6 Cos\u00ec come in C e C++, \u00e8 possibile definire metodi statici, che in questo caso sono maggiormente assimilabili alla loro concezione del C++. Infatti, nell'ambito della classe, un metodo statico non accetta n\u00e9 la classe, n\u00e9 una specifica istanza, ma si comporta come una funzione \"semplice\", che per\u00f2 \u00e8 possibile chiamare dall'interno della classe. Ad esempio: @staticmethod def check_is_valid ( first_name ): # return False if len(first_name) < 2 else True # return len(first_name) < 2 return False or len ( first_name ) >= 2 Nota In questo metodo, abbiamo usato una sintassi chiamata shorthand ternary operator , mentre commentato troviamo il classico operatore ternario, o una versione pi\u00f9 semplice. >>> print ( pb . check_is_valid ( 'Li' )) True >>> print ( Person . check_is_valid ( 'X' )) False @abstractmethod \u00b6 I metodi astratti sono definibili nel caso si stiano implementando delle classi astratte (ovvero classi in cui alcuni metodi non sono implementati) o, nel caso estremo, interfacce (ovvero classi in cui nessun metodo \u00e8 implementato). Per usarli, la nostra classe deve discendere da un particolare tipo di classe Python chiamato Abstract Base Class , abbreviato in ABC , e contenuto nel package abc : from abc import ABC class BaseClass ( ABC ): # some methods... @abstractmethod def method_to_override ( self ): pass I metodi contrassegnati con il decorator @abstractmethod andranno implementati nelle classi derivate (operazione di override ): class DerivedClass ( BaseClass ): # some methods... def method_to_override ( self ): do_something () Propriet\u00e0 \u00b6 A differenza delle classi implementate in C++, finora non abbiamo usato i getter ed i setter. Per farlo, possiamo usare sia degli opportuni metodi (nel nostro caso, ad esempio, potremmo usare un metodo get_first_name(self) , un metodo set_first_name(self, fn) , e via dicendo), o, in maniera pi\u00f9 pythonic , il decorator @property , che ci offre un modo integrato per definire ogni attributo della classe. Note In realt\u00e0, il decorator @property si riferisce ad una funzione con quattro parametri: python property(fget=None, fset=None, fdel=None, doc=None) che rappresentano: * fget funzione per ottenere il valore dell'attributo; * fset funzione per impostare il valore dell'attributo; * fdel funzione per cancellare l'attributo; * doc funzione per la documentazione dell'attributo. Le best practice ci dicono di adattare i nostri attributi, rendendoli privati, ed accedendovi soltanto mediante il decorator @property : class PersonProperty (): def __init__ ( self , first_name , last_name , age ): self . first_name = first_name self . last_name = last_name self . age = age @property def first_name ( self ): return self . __first_name @first_name . setter def first_name ( self , value ): if len ( value ) < 2 : raise ValueError ( 'Name must be longer than two characters' ) else : self . __first_name = value # ... >>> pp = PersonProperty ( 'Draco' , 'Malfoy' , 12 ) >>> print ( pp . first_name ) Draco >>> pp = PersonProperty ( '' , 'Granger' , 18 ) ValueError : Name must be longer than two characters","title":"05 - Classi e concetti avanzati"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#classi-in-python","text":"Cos\u00ec come il C++, Python ha un esteso supporto per la programmazione orientata agli oggetti. La definizione di una classe in Python avviene come segue: class ClassName ( BaseClass ): # Class body Notiamo che, a differenza del C++, nel quale la classe viene definita all'interno di un header, qui la definizione avviene contestualmente alla dichiarazione della firma della classe.","title":"Classi in Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#costruttori","text":"Il linguaggio Python non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione degli attributi della classe. Questo metodo assume lo stesso nome per ogni classe, ovvero __init__ : class ClassName ( BaseClass ): def __init__ ( self , * args , ** kwargs ): # ... self . arg_1 = arg_1 # ... Nota La sintassi *args e **kwargs rappresenta, rispettivamente, l' unpacking di liste e dizionari. Ci\u00f2 significa che come argomento non si passa la lista o il dizionario, ma i valori (o le coppie chiave/valore) ivi contenuti. Notiamo l'uso della parola chiave self . Questa, in qualche modo, richiama il this del C++: infatti, si riferisce alla specifica istanza della classe. Ad esempio: class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota In Python, tutte le classi derivano da una classe generica object .","title":"Costruttori"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#modificatori-di-accesso","text":"Python prevede, come il C++, l'uso di modificatori di accesso ai dati; nello specifico, ritroviamo public , protected e private . Per contraddistinguere i tre tipi di variabili, si utilizzano gli underscore come suffisso al nome della stessa; in particolare, un unico underscore indica un membro protected , mentre un doppio underscore indica un membro private . class Person ( object ): def __init__ ( self , first_name , last_name , age = 18 ): self . first_name = first_name self . _last_name = last_name self . __age = age Nota I membri protetti sono facilmente accessibili dall'esterno della classe. Infatti: p = Person ( 'Jax' , 'Teller' ) print ( p . first_name ) print ( p . _last_name ) try : print ( p . __age ) except AttributeError : print ( 'Age is private!' ) risulter\u00e0 in: Jax Teller Et\u00e0 \u00e8 privato! Contestualmente, \u00e8 possibile usare la stessa convenzione definire metodi per l'accesso a variabili protected e private .","title":"Modificatori di accesso"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#classi-e-metodi","text":"I metodi di una classe sono definiti in questo modo: def metodo ( self , * args , ** kwargs ): pass E' importante notare come il primo attributo di un normale metodo di classe sia sempre la parola self . Questa non deve per\u00f2 essere specificata quando lo si chiama dall'esterno: basta infatti chiamarlo usando l'operatore . da un'istanza della classe: # ... p = Person () p . metodo ( * args , ** kwargs ) # ...","title":"Classi e metodi"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#i-decorator","text":"Prima di continuare a parlare dei metodi che \u00e8 possibile definire all'interno di una classe Python, \u00e8 necessario introdurre il concetto di decorator , ovvero una particolare notazione che viene usata in Python (ed in altri linguaggi di programmazione) per indicare una funzione che \"decora\" un'altra funzione.","title":"I decorator"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#funzioni-come-oggetti","text":"Python tratta le funzioni come degli oggetti . E' quindi possiible che una funzione restituisca una funzione : def main_character ( series ): def supernatural (): return \"Sam Winchester\" def breaking_bad (): return \"Walter White\" if series == \"Supernatural\" : return supernatural elif series == \"Breaking Bad\" : return breaking_bad Il valore di ritorno \u00e8 quindi un oggetto. Possiamo provare a chiamarlo dal nostro script: >>> mc = main_character ( \"Supernatural\" ) Se provassimo a mandarlo a schermo trattandolo come una variabile, avremmo in uscita una reference a funzione: >>> print ( \"Function reference: {} \" . format ( mc )) Function reference : < function main_character .< locals >. supernatural at 0x00000170C448BA60 > Per visualizzare il risultato, trattiamolo come se fosse una chiamata a funzione: >>> print ( \"Function outcoming value: {} \" . format ( mc ())) Function outcoming value : Sam Winchester","title":"Funzioni come oggetti"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#funzioni-come-argomenti-di-altre-funzioni","text":"Possiamo passare una fuzione come argomento ad un'altra funzione: def favorite_series ( func ): def internal_check (): print ( \"Checking my favorite series...\" ) func () print ( \"Got it!\" ) return internal_check def check (): print ( 'Sons of Anarchy' ) Dal nostro script: >>> print_fav_series = favorite_series ( check ) >>> print_fav_series () Checking my favorite series ... Sons of Anarchy Got it ! Vediamo quindi come la funzione passata come argomento sar\u00e0 correttamente chiamata internamente al metodo favorite_series .","title":"Funzioni come argomenti di altre funzioni"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#definizione-ed-uso-di-decorator","text":"La sintassi che abbiamo usato \u00e8, per dirla con Manzoni, ampollosa . Python ci offre quindi una sintassi equivalente, ma molto pi\u00f9 accessibile, per usare una funzione come argomento di un'altra funzione, ovvero i decorator. Infatti: @favorite_series def print_fav_series_decorated (): print ( 'Breaking Bad' ) >>> print_fav_series_decorated () Checking my favorite series ... Breaking Bad Got it !","title":"Definizione ed uso di decorator"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#classmethod","text":"E' possibile definire i cosiddetti metodi di classe mediante il decorator @classmethod : @classmethod def from_string ( cls , person_string : str ): fn , ln , age = person_string . split ( ' ' ) return Person ( fn , ln , age ) A differenza dei normali metodi definiti all'interno di una classe, i metodi di classe passano implicitamente un riferimento alla classe ( cls ) e non all'istanza ( self ). Questo significa che sono dei metodi pensati per applicarsi all'intera classe, e non alla singola istanza; normalmente, vengono usati per creare dei costruttori alternativi, come nel caso precedente, nel quale creiamo una persona a partire da una stringa. Per chiamare un metodo di classe, ci riferiamo al nome della classe stessa, e non alla singola istanza: pb = Person . from_string ( 'Bobby Munson 58' ) print ( \" {} {} \" . format ( pb . first_name , pb . _last_name ))","title":"@classmethod"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#staticmethod","text":"Cos\u00ec come in C e C++, \u00e8 possibile definire metodi statici, che in questo caso sono maggiormente assimilabili alla loro concezione del C++. Infatti, nell'ambito della classe, un metodo statico non accetta n\u00e9 la classe, n\u00e9 una specifica istanza, ma si comporta come una funzione \"semplice\", che per\u00f2 \u00e8 possibile chiamare dall'interno della classe. Ad esempio: @staticmethod def check_is_valid ( first_name ): # return False if len(first_name) < 2 else True # return len(first_name) < 2 return False or len ( first_name ) >= 2 Nota In questo metodo, abbiamo usato una sintassi chiamata shorthand ternary operator , mentre commentato troviamo il classico operatore ternario, o una versione pi\u00f9 semplice. >>> print ( pb . check_is_valid ( 'Li' )) True >>> print ( Person . check_is_valid ( 'X' )) False","title":"@staticmethod"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#abstractmethod","text":"I metodi astratti sono definibili nel caso si stiano implementando delle classi astratte (ovvero classi in cui alcuni metodi non sono implementati) o, nel caso estremo, interfacce (ovvero classi in cui nessun metodo \u00e8 implementato). Per usarli, la nostra classe deve discendere da un particolare tipo di classe Python chiamato Abstract Base Class , abbreviato in ABC , e contenuto nel package abc : from abc import ABC class BaseClass ( ABC ): # some methods... @abstractmethod def method_to_override ( self ): pass I metodi contrassegnati con il decorator @abstractmethod andranno implementati nelle classi derivate (operazione di override ): class DerivedClass ( BaseClass ): # some methods... def method_to_override ( self ): do_something ()","title":"@abstractmethod"},{"location":"02_dispense/programmazione/03_linguaggio_python/05_classi/#proprieta","text":"A differenza delle classi implementate in C++, finora non abbiamo usato i getter ed i setter. Per farlo, possiamo usare sia degli opportuni metodi (nel nostro caso, ad esempio, potremmo usare un metodo get_first_name(self) , un metodo set_first_name(self, fn) , e via dicendo), o, in maniera pi\u00f9 pythonic , il decorator @property , che ci offre un modo integrato per definire ogni attributo della classe. Note In realt\u00e0, il decorator @property si riferisce ad una funzione con quattro parametri: python property(fget=None, fset=None, fdel=None, doc=None) che rappresentano: * fget funzione per ottenere il valore dell'attributo; * fset funzione per impostare il valore dell'attributo; * fdel funzione per cancellare l'attributo; * doc funzione per la documentazione dell'attributo. Le best practice ci dicono di adattare i nostri attributi, rendendoli privati, ed accedendovi soltanto mediante il decorator @property : class PersonProperty (): def __init__ ( self , first_name , last_name , age ): self . first_name = first_name self . last_name = last_name self . age = age @property def first_name ( self ): return self . __first_name @first_name . setter def first_name ( self , value ): if len ( value ) < 2 : raise ValueError ( 'Name must be longer than two characters' ) else : self . __first_name = value # ... >>> pp = PersonProperty ( 'Draco' , 'Malfoy' , 12 ) >>> print ( pp . first_name ) Draco >>> pp = PersonProperty ( '' , 'Granger' , 18 ) ValueError : Name must be longer than two characters","title":"Propriet\u00e0"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/","text":"I/O in Python \u00b6 Input ed output da riga di comando \u00b6 Input da riga di comando \u00b6 >>> a = input ( 'Insert a value: ' ) Insert a value : 12 >>> a '12' >>> l = input ( 'Insert a value: ' ) Insert a value : [ 'Fox' , 'Mulder' ] >>> l \"['Fox', 'Mulder']\" Output su riga di comando \u00b6 >>> print ( a ) 12 >>> print ( 'Jax Teller' ) Jax Teller >>> print ( ' {} {} ' . format ( 'Hermione' , 'Granger' )) Hermione Granger File \u00b6 Lettura \u00b6 with open ( file_name , 'r' ) as f : f . read () Nota Il metodo read() accetta come parametro il numero di caratteri da leggere. Di default, legge l'intero file; per leggere un carattere alla volta, specificare il valore -1 . Lettura riga per riga Per leggere riga per riga, usare il metodo readlines() . Scrittura \u00b6 with open ( file_name , 'w' ) as f : f . write ( 'some line' ) Nota Il metodo write() pu\u00f2 essere sostituito dal metodo writelines() per scrivere una riga alla volta. Ricordiamoci sempre di chiudere il file: f . close ()","title":"06 - I/O in Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/#io-in-python","text":"","title":"I/O in Python"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/#input-ed-output-da-riga-di-comando","text":"","title":"Input ed output da riga di comando"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/#input-da-riga-di-comando","text":">>> a = input ( 'Insert a value: ' ) Insert a value : 12 >>> a '12' >>> l = input ( 'Insert a value: ' ) Insert a value : [ 'Fox' , 'Mulder' ] >>> l \"['Fox', 'Mulder']\"","title":"Input da riga di comando"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/#output-su-riga-di-comando","text":">>> print ( a ) 12 >>> print ( 'Jax Teller' ) Jax Teller >>> print ( ' {} {} ' . format ( 'Hermione' , 'Granger' )) Hermione Granger","title":"Output su riga di comando"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/#file","text":"","title":"File"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/#lettura","text":"with open ( file_name , 'r' ) as f : f . read () Nota Il metodo read() accetta come parametro il numero di caratteri da leggere. Di default, legge l'intero file; per leggere un carattere alla volta, specificare il valore -1 . Lettura riga per riga Per leggere riga per riga, usare il metodo readlines() .","title":"Lettura"},{"location":"02_dispense/programmazione/03_linguaggio_python/06_file/#scrittura","text":"with open ( file_name , 'w' ) as f : f . write ( 'some line' ) Nota Il metodo write() pu\u00f2 essere sostituito dal metodo writelines() per scrivere una riga alla volta. Ricordiamoci sempre di chiudere il file: f . close ()","title":"Scrittura"},{"location":"02_dispense/programmazione/03_linguaggio_python/07_test/","text":"Cenni ai test \u00b6 I test vanno effettuati a livello di ogni singola funzione, per verificarne il funzionamento ( unit test ), oppure a livello dell'intero programma, per verificare le funzionalit\u00e0 complessivi ( integration test ). I test inoltre non devono essere invasivi : se, ad esempio, creiamo un file durante i nostri test, dobbiamo assicurarci di cancellarlo al termine. Istruzione assert \u00b6 L'istruzione assert restituisce True se la condizione passata \u00e8 verificata, False altrimenti. Se assert \u00e8 True , inoltre, l'esecuzione prosegue: >>> assert True # nothing happens... mentre se \u00e8 False , viene lanciata un'eccezione di tipo AssertionError : >>> assert False Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AssertionError >>>","title":"07 - Cenni ai test"},{"location":"02_dispense/programmazione/03_linguaggio_python/07_test/#cenni-ai-test","text":"I test vanno effettuati a livello di ogni singola funzione, per verificarne il funzionamento ( unit test ), oppure a livello dell'intero programma, per verificare le funzionalit\u00e0 complessivi ( integration test ). I test inoltre non devono essere invasivi : se, ad esempio, creiamo un file durante i nostri test, dobbiamo assicurarci di cancellarlo al termine.","title":"Cenni ai test"},{"location":"02_dispense/programmazione/03_linguaggio_python/07_test/#istruzione-assert","text":"L'istruzione assert restituisce True se la condizione passata \u00e8 verificata, False altrimenti. Se assert \u00e8 True , inoltre, l'esecuzione prosegue: >>> assert True # nothing happens... mentre se \u00e8 False , viene lanciata un'eccezione di tipo AssertionError : >>> assert False Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > AssertionError >>>","title":"Istruzione assert"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/","text":"NumPy e manipolazione di array \u00b6 Cosa \u00e8 NumPy? \u00b6 NumPy \u00e8 una libreria per la manipolazione di array in Python. Installazione di NumPy \u00b6 Iniziamo installandola mediante il package manager integrato di Python da riga di comando, chiamato pip : pip install numpy Nota In questa maniera, Numpy sar\u00e0 installato globalmente. Una volta completata l'installazione, potremo accedere alle variabili, classi e funzioni definite dalla libreria. Uso di NumPy \u00b6 Importazione di NumPy \u00b6 Iniziamo importando numpy : >>> import numpy as np Nota Notiamo l'utilizzo del modulo sotto forma di alias. Creazione di un array \u00b6 Esistono diversi modi per creare un array. Creazione diretta \u00b6 Il primo \u00e8 crearlo direttamente come oggetto di tipo array : >>> a = np . array ([ 1 , 2 , 3 ]) >>> a array ([ 1 , 2 , 3 ]) Nota Si utilizza la notazione np a causa del fatto che numpy \u00e8 stato importato con suddetto alias. Se questo non fosse avvenuto, sarebbe stato necessario usare numpy.array . Uso di ndarray \u00b6 Gli array NumPy sono un'istanza della classe ndarray . Possiamo quindi crearne uno richiamandola direttamente: >>> f = np . ndarray ( shape = ( 2 , 2 ), dtype = float ) >>> f array ([[ 5.e-324 , 5.e-324 ], [ 0.e+000 , 0.e+000 ]]) Funzione arange \u00b6 La funzione arange \u00e8 analoga alla funzione range di Python, ma restituisce un array NumPy invece di una lista. >>> a = np . arange ( 1 , 4 ) >>> a array ([ 1 , 2 , 3 ]) Dimensioni dell'array \u00b6 Un array in NumPy pu\u00f2 essere ad \\(n\\) dimensioni: >>> one_d = np . arange ( 5 ) >>> one_d array ([ 0 , 1 , 2 , 3 , 4 ]) >>> two_d = np . arange ( 9 ) . reshape ( 3 , 3 ) >>> two_d array ([[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]]) >>> three_d = np . arange ( 27 ) . reshape ( 3 , 3 , 3 ) >>> three_d array ([[[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]], [[ 9 , 10 , 11 ], [ 12 , 13 , 14 ], [ 15 , 16 , 17 ]], [[ 18 , 19 , 20 ], [ 21 , 22 , 23 ], [ 24 , 25 , 26 ]]]) Nell'esempio precedente, one_d \u00e8 un esempio di array monodimensionale, two_d bidimensionale (matrice) e three_d tridimensionale (tensore). Notiamo l'uso della funzione reshape che accetta come parametri una serie di interi, dove l'i-mo intero rappresenta il numero di elementi della i-ma dimensione dell'array. Quest'ultima \u00e8 facilmente verificabile mediante l'attributo shape , ovvero una tupla che restituisce il numero di dimensioni dell'array: >>> three_d . shape ( 3 , 3 , 3 ) Operazioni elementari \u00b6 Somma di array \u00b6 >>> a = np . arange ( 6 , 15 ) . reshape ( 3 , 3 ) >>> b = np . arange ( 30 , 21 , - 1 ) . reshape ( 3 , 3 ) >>> a + b array ([[ 36 , 36 , 36 ], [ 36 , 36 , 36 ], [ 36 , 36 , 36 ]]) Prodotto di array \u00b6 Prodotto elemento per elemento: >>> a * b array ([[ 180 , 203 , 224 ], [ 243 , 260 , 275 ], [ 288 , 299 , 308 ]]) Prodotto matriciale: >>> a @ b array ([[ 561 , 540 , 519 ], [ 804 , 774 , 744 ], [ 1047 , 1008 , 969 ]]) Indexing e slicing \u00b6 Le operazioni di indexing e slicing sono analoghe a quelle viste per le liste: >>> b [ 0 : 2 ,:] array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ]]) >>> b [ 0 , 0 ] 30 >>> b [ 0 , 0 ] = 60 Notiamo che gli array NumPy sono mutabili. Tipo di un array \u00b6 A differenza delle liste, gli array NumPy sono tipizzati: >>> b [ 0 , 0 ] = 'stringa' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : invalid literal for int () with base 10 : 'stringa' >>> b [ 0 , 0 ] = 1.1 >>> b array ([[ 1 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> type ( b [ 0 , 0 ]) < class ' numpy . int32 '> Viene per\u00f2 effettuato un cast automatico nel tipo assegnato agli elementi dell'array: >>> b [ 0 , 0 ] = '1' >>> b array ([[ 1 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) Copia di array \u00b6 La copia di un array con l'operatore di assegnazione la creazione di un alias: >>> c = b >>> c array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> b [ 0 , 0 ] = 60 >>> b array ([[ 60 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> c array ([[ 60 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) Notiamo quindi come b e c siano due alias per gli stessi dati. Shallow copy \u00b6 La shallow copy (ovvero la copia per reference) produce effetti analoghi ed avviene mediante il metodo view() : >>> d = b . view () >>> d array ([[ 60 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> b [ 0 , 0 ] = 30 >>> d array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) Deep copy \u00b6 La deep copy (ovvero la copia per valore) avviene mediante il metodo copy() : >>> e = b . copy () >>> b [ 0 , 0 ] = 120 >>> e array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) Algebra matriciale \u00b6 NumPy offre diverse operazioni di algebra matriciale. Ad esempio, \u00e8 possibile invertire una matrice: >>> from numpy.linalg import inv >>> inv ( b ) array ([[ - 0.03448276 , 0.06896552 , - 0.03448276 ], [ 0.06896552 , - 7.47126437 , 8.40229885 ], [ - 0.03448276 , 7.73563218 , - 8.70114943 ]]) oppure calcolarne la norma di Frobenius: >>> from numpy.linalg import norm >>> norm ( b ) 72.42237223399962 Per un elenco completo delle funzioni, si rimanda alla reference di NumPy .","title":"08 - Cenni a NumPy"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#numpy-e-manipolazione-di-array","text":"","title":"NumPy e manipolazione di array"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#cosa-e-numpy","text":"NumPy \u00e8 una libreria per la manipolazione di array in Python.","title":"Cosa \u00e8 NumPy?"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#installazione-di-numpy","text":"Iniziamo installandola mediante il package manager integrato di Python da riga di comando, chiamato pip : pip install numpy Nota In questa maniera, Numpy sar\u00e0 installato globalmente. Una volta completata l'installazione, potremo accedere alle variabili, classi e funzioni definite dalla libreria.","title":"Installazione di NumPy"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#uso-di-numpy","text":"","title":"Uso di NumPy"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#importazione-di-numpy","text":"Iniziamo importando numpy : >>> import numpy as np Nota Notiamo l'utilizzo del modulo sotto forma di alias.","title":"Importazione di NumPy"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#creazione-di-un-array","text":"Esistono diversi modi per creare un array.","title":"Creazione di un array"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#creazione-diretta","text":"Il primo \u00e8 crearlo direttamente come oggetto di tipo array : >>> a = np . array ([ 1 , 2 , 3 ]) >>> a array ([ 1 , 2 , 3 ]) Nota Si utilizza la notazione np a causa del fatto che numpy \u00e8 stato importato con suddetto alias. Se questo non fosse avvenuto, sarebbe stato necessario usare numpy.array .","title":"Creazione diretta"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#uso-di-ndarray","text":"Gli array NumPy sono un'istanza della classe ndarray . Possiamo quindi crearne uno richiamandola direttamente: >>> f = np . ndarray ( shape = ( 2 , 2 ), dtype = float ) >>> f array ([[ 5.e-324 , 5.e-324 ], [ 0.e+000 , 0.e+000 ]])","title":"Uso di ndarray"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#funzione-arange","text":"La funzione arange \u00e8 analoga alla funzione range di Python, ma restituisce un array NumPy invece di una lista. >>> a = np . arange ( 1 , 4 ) >>> a array ([ 1 , 2 , 3 ])","title":"Funzione arange"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#dimensioni-dellarray","text":"Un array in NumPy pu\u00f2 essere ad \\(n\\) dimensioni: >>> one_d = np . arange ( 5 ) >>> one_d array ([ 0 , 1 , 2 , 3 , 4 ]) >>> two_d = np . arange ( 9 ) . reshape ( 3 , 3 ) >>> two_d array ([[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]]) >>> three_d = np . arange ( 27 ) . reshape ( 3 , 3 , 3 ) >>> three_d array ([[[ 0 , 1 , 2 ], [ 3 , 4 , 5 ], [ 6 , 7 , 8 ]], [[ 9 , 10 , 11 ], [ 12 , 13 , 14 ], [ 15 , 16 , 17 ]], [[ 18 , 19 , 20 ], [ 21 , 22 , 23 ], [ 24 , 25 , 26 ]]]) Nell'esempio precedente, one_d \u00e8 un esempio di array monodimensionale, two_d bidimensionale (matrice) e three_d tridimensionale (tensore). Notiamo l'uso della funzione reshape che accetta come parametri una serie di interi, dove l'i-mo intero rappresenta il numero di elementi della i-ma dimensione dell'array. Quest'ultima \u00e8 facilmente verificabile mediante l'attributo shape , ovvero una tupla che restituisce il numero di dimensioni dell'array: >>> three_d . shape ( 3 , 3 , 3 )","title":"Dimensioni dell'array"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#operazioni-elementari","text":"","title":"Operazioni elementari"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#somma-di-array","text":">>> a = np . arange ( 6 , 15 ) . reshape ( 3 , 3 ) >>> b = np . arange ( 30 , 21 , - 1 ) . reshape ( 3 , 3 ) >>> a + b array ([[ 36 , 36 , 36 ], [ 36 , 36 , 36 ], [ 36 , 36 , 36 ]])","title":"Somma di array"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#prodotto-di-array","text":"Prodotto elemento per elemento: >>> a * b array ([[ 180 , 203 , 224 ], [ 243 , 260 , 275 ], [ 288 , 299 , 308 ]]) Prodotto matriciale: >>> a @ b array ([[ 561 , 540 , 519 ], [ 804 , 774 , 744 ], [ 1047 , 1008 , 969 ]])","title":"Prodotto di array"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#indexing-e-slicing","text":"Le operazioni di indexing e slicing sono analoghe a quelle viste per le liste: >>> b [ 0 : 2 ,:] array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ]]) >>> b [ 0 , 0 ] 30 >>> b [ 0 , 0 ] = 60 Notiamo che gli array NumPy sono mutabili.","title":"Indexing e slicing"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#tipo-di-un-array","text":"A differenza delle liste, gli array NumPy sono tipizzati: >>> b [ 0 , 0 ] = 'stringa' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ValueError : invalid literal for int () with base 10 : 'stringa' >>> b [ 0 , 0 ] = 1.1 >>> b array ([[ 1 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> type ( b [ 0 , 0 ]) < class ' numpy . int32 '> Viene per\u00f2 effettuato un cast automatico nel tipo assegnato agli elementi dell'array: >>> b [ 0 , 0 ] = '1' >>> b array ([[ 1 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]])","title":"Tipo di un array"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#copia-di-array","text":"La copia di un array con l'operatore di assegnazione la creazione di un alias: >>> c = b >>> c array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> b [ 0 , 0 ] = 60 >>> b array ([[ 60 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> c array ([[ 60 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) Notiamo quindi come b e c siano due alias per gli stessi dati.","title":"Copia di array"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#shallow-copy","text":"La shallow copy (ovvero la copia per reference) produce effetti analoghi ed avviene mediante il metodo view() : >>> d = b . view () >>> d array ([[ 60 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]]) >>> b [ 0 , 0 ] = 30 >>> d array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]])","title":"Shallow copy"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#deep-copy","text":"La deep copy (ovvero la copia per valore) avviene mediante il metodo copy() : >>> e = b . copy () >>> b [ 0 , 0 ] = 120 >>> e array ([[ 30 , 29 , 28 ], [ 27 , 26 , 25 ], [ 24 , 23 , 22 ]])","title":"Deep copy"},{"location":"02_dispense/programmazione/03_linguaggio_python/08_numpy/#algebra-matriciale","text":"NumPy offre diverse operazioni di algebra matriciale. Ad esempio, \u00e8 possibile invertire una matrice: >>> from numpy.linalg import inv >>> inv ( b ) array ([[ - 0.03448276 , 0.06896552 , - 0.03448276 ], [ 0.06896552 , - 7.47126437 , 8.40229885 ], [ - 0.03448276 , 7.73563218 , - 8.70114943 ]]) oppure calcolarne la norma di Frobenius: >>> from numpy.linalg import norm >>> norm ( b ) 72.42237223399962 Per un elenco completo delle funzioni, si rimanda alla reference di NumPy .","title":"Algebra matriciale"},{"location":"03_appendici/algoritmi/selection_sort/","text":"C void swap ( int vector [], int swap_l_idx , int swap_r_idx , int swap_val ) { vector [ swap_l_idx ] = vector [ swap_r_idx ]; vector [ swap_r_idx ] = swap_val ; } C++ void swap ( vector & vect , int swap_l_idx , int swap_r_idx , int swap_val ) { vect . at ( swap_l_idx ) = vect . at ( swap_r_idx ); vect . swap_r_idx = swap_val ; } Python def swap ( vect , left , right , val ): vect [ left ] = vect [ right ] vect [ right ] = val pippo pippa C void selection_sort ( int vector [], int length ) { for ( int i = 0 ; i < length ; i ++ ) { int current = vector [ i ]; int swap_index = i + 1 ; bool swapped = false ; for ( int j = i + 1 ; j < length ; j ++ ) { if ( vector [ j ] < current ) { current = vector [ j ]; swap_index = j ; swapped = true ; } } if ( swapped ) { swap ( vector , swap_index , i , current ); } } } void selection_sort ( vector & vect ) { vector < int > l_vect ; vector < int > r_vect ; // Init left vector l_vect . assign ( vect . at ( 0 )); // Init right vector vector < int >:: iterator it ; it = l_vect . begin () + 1 ; r_vect . assign ( it , r_vect . end ()); while ( r_vect . size () == 0 ) { int current = l_vect . end () - 1 ; int swap_idx = -1 ; for ( vector < int >:: iterator it = r_vect . begin (); it != r_vect . end (); ++ it ) { if ( * it < current ) { current = * it ; swap_idx = it - r_vect . begin (); } } if ( swap_idx > -1 ) { swap ( vect , swap_index , current , * current ); } } } def selection_sort ( vect ): l_vect = vect [ 0 ] r_vect = vect [ 1 :] for i in range l_vect . len ():","title":"Selection sort"},{"location":"03_appendici/configurazioni/a_vs_code_guide/","text":"Installazione e configurazione di C/C++ \u00b6 Una volta installato il software Visual Studio Code (VS Code), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni. Installazione del supporto \u00b6 Per prima cosa, installiamo l'estensione C/C++. Per farlo, selezioniamo da VS Code il menu \"Estensioni\", oppure premiamo la combinazione Ctrl + Maiusc + X , e quindi scriviamo c/c++ nella barra di ricerca. Selezioniamo quella ufficiale di Microsoft ed installiamola seguendo la procedura guidata. Useremo il compilatore ufficiale fornito da Microsoft per Visual Studio. Per scaricarlo, usiamo questo link . In alternativa, qualora questo link non fosse funzionante, dobbiamo andare dalla pagina di download per Visual Studio, e cercare nella pagina Strumenti per Visual Studio > Build Tools for Visual Studio . Installiamo il programma scaricato al passo precedente. Una volta terminata l'installazione, eseguiamo il programma Visual Studio Installer . Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica . Verifica dell'installazione \u00b6 Apriamo la Developer Command Prompt for VS , cercandola dal menu Start, come mostrato in figura. Verifichiamo che il compilatore sia installato digitando cl da riga di comando e premendo Invio . Creazione di un progetto di esempio \u00b6 Creiamo ora un progetto di esempio. Navighiamo in una cartella a nostra scelta (ad esempio C:\\progetti\\informatica ) digitando, da shell, il seguente comando: cd C:/progetti/informatica A questo punto, creiamo una cartella helloworld , spostiamoci all'interno di essa, e lanciamo Visual Studio Code: mkdir helloworld cd helloworld code . Si aprir\u00e0 una nuova schermata di Visual Studio Code. Creiamo un file chiamato helloworld.c e scriviamo il seguente codice. #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; } Compilazione del progetto \u00b6 Per compilare il progetto, scegliamo dal menu principale l'opzione Terminal > Configure Default Build Task (l'ultima opzione). Apparir\u00e0 un men\u00f9 a scorrimento; scegliamo l'opzione cl.exe build active file , come mostrato in figura. A questo punto, sar\u00e0 creato un file tasks.json all'interno di una cartella .vscode . Possiamo configurarlo come meglio ci aggrada; per i nostri scopi, per\u00f2, potremo lasciare la configurazione di default. Torniamo al nostro file helloworld.c , e compiliamo premendo la combinaziont Ctrl + Maiusc + B . Se escono a schermo i messaggi mostrati nella seguente figura, avremo completato correttamente la configurazione. Attenzione! Potremmo ricevere un errore che ci comunica che non \u00e8 stato possibile trovare cl.exe . In questo caso, basta riavviare Visual Studio Code dal prompt degli sviluppatori che abbiamo aperto in precedenza, recandoci all'interno della cartella di progetto e scrivendo l'istruzione code .","title":"Visual Studio Code"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#installazione-e-configurazione-di-cc","text":"Una volta installato il software Visual Studio Code (VS Code), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni.","title":"Installazione e configurazione di C/C++"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#installazione-del-supporto","text":"Per prima cosa, installiamo l'estensione C/C++. Per farlo, selezioniamo da VS Code il menu \"Estensioni\", oppure premiamo la combinazione Ctrl + Maiusc + X , e quindi scriviamo c/c++ nella barra di ricerca. Selezioniamo quella ufficiale di Microsoft ed installiamola seguendo la procedura guidata. Useremo il compilatore ufficiale fornito da Microsoft per Visual Studio. Per scaricarlo, usiamo questo link . In alternativa, qualora questo link non fosse funzionante, dobbiamo andare dalla pagina di download per Visual Studio, e cercare nella pagina Strumenti per Visual Studio > Build Tools for Visual Studio . Installiamo il programma scaricato al passo precedente. Una volta terminata l'installazione, eseguiamo il programma Visual Studio Installer . Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica .","title":"Installazione del supporto"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#verifica-dellinstallazione","text":"Apriamo la Developer Command Prompt for VS , cercandola dal menu Start, come mostrato in figura. Verifichiamo che il compilatore sia installato digitando cl da riga di comando e premendo Invio .","title":"Verifica dell'installazione"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#creazione-di-un-progetto-di-esempio","text":"Creiamo ora un progetto di esempio. Navighiamo in una cartella a nostra scelta (ad esempio C:\\progetti\\informatica ) digitando, da shell, il seguente comando: cd C:/progetti/informatica A questo punto, creiamo una cartella helloworld , spostiamoci all'interno di essa, e lanciamo Visual Studio Code: mkdir helloworld cd helloworld code . Si aprir\u00e0 una nuova schermata di Visual Studio Code. Creiamo un file chiamato helloworld.c e scriviamo il seguente codice. #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; }","title":"Creazione di un progetto di esempio"},{"location":"03_appendici/configurazioni/a_vs_code_guide/#compilazione-del-progetto","text":"Per compilare il progetto, scegliamo dal menu principale l'opzione Terminal > Configure Default Build Task (l'ultima opzione). Apparir\u00e0 un men\u00f9 a scorrimento; scegliamo l'opzione cl.exe build active file , come mostrato in figura. A questo punto, sar\u00e0 creato un file tasks.json all'interno di una cartella .vscode . Possiamo configurarlo come meglio ci aggrada; per i nostri scopi, per\u00f2, potremo lasciare la configurazione di default. Torniamo al nostro file helloworld.c , e compiliamo premendo la combinaziont Ctrl + Maiusc + B . Se escono a schermo i messaggi mostrati nella seguente figura, avremo completato correttamente la configurazione. Attenzione! Potremmo ricevere un errore che ci comunica che non \u00e8 stato possibile trovare cl.exe . In questo caso, basta riavviare Visual Studio Code dal prompt degli sviluppatori che abbiamo aperto in precedenza, recandoci all'interno della cartella di progetto e scrivendo l'istruzione code .","title":"Compilazione del progetto"},{"location":"03_appendici/configurazioni/b_vs_community_guide/","text":"Installazione e configurazione di C/C++ \u00b6 Una volta installato il software Visual Studio Community (VS), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni. Installazione del supporto \u00b6 Per prima cosa, installiamo gli strumenti per lo sviluppo di applicazioni in C e C++. Eseguiamo il programma Visual Studio Installer dal menu Start. Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica . Creazione di un progetto \u00b6 Una volta installati i tool per lo sviluppo, eseguiamo il programma Visual Studio 2019 dal menu Start. Si aprir\u00e0 la seguente schermata: Selezioniamo l'opzione Crea un nuovo progetto . Apparir\u00e0 la seguente schermata: Selezioniamo prima App console C++ a sinistra, e poi Progetto vuoto o App Console a destra. Scegliamo quindi l'opzione Avanti . Diamo un nome al progetto (ad esempio, Primo progetto ) ed alla soluzione (ad esempio, Prima soluzione ), scegliamo la cartella in cui salvare il tutto, e scegliamo l'opzione Crea . Se abbiamo scelto App Console , apparir\u00e0 gi\u00e0 un progetto di esempio. Qualora scegliessimo Progetto vuoto , apparir\u00e0 la seguente schermata. In quest'ultimo caso, selezioniamo clicchiamo con il destro sulla cartella (mostrata nel menu a destra) chiamata File di origine e selezioniamo dal menu che appare Aggiungi > Nuovo Elemento . Da qui possiamo creare direttamente un file C++, oppure un file C modificandone manualmente l'estensione. Creiamo un file chiamato HelloWorld.c ed aggiungiamolo al nostro progetto. Aggiungiamo il seguente codice: #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; } Eseguiamo il nostro programma premendo Ctrl + F5, oppure scegliendo l'opzione Avvia senza eseguire Debug dal menu Debug . Se tutto \u00e8 andato a buon fine, apparir\u00e0 la seguente finestra:","title":"Visual Studio Community"},{"location":"03_appendici/configurazioni/b_vs_community_guide/#installazione-e-configurazione-di-cc","text":"Una volta installato il software Visual Studio Community (VS), reperibile al seguente link , dovremo configurarlo per poter lanciare il compilatore nei diversi linguaggi che utilizzeremo durante le esercitazioni.","title":"Installazione e configurazione di C/C++"},{"location":"03_appendici/configurazioni/b_vs_community_guide/#installazione-del-supporto","text":"Per prima cosa, installiamo gli strumenti per lo sviluppo di applicazioni in C e C++. Eseguiamo il programma Visual Studio Installer dal menu Start. Si aprir\u00e0 una schermata come la seguente: Dal menu che si apre, selezioniamo l'opzione Sviluppo di applicazioni desktop con C++ mediante il segno di spunta. Nota Qualora non dovesse aprirsi la schermata precedente, ma una schermata in cui sono mostrate tutte le possibili installazioni di Visual Studio, selezioniamo l'opzione Modifica .","title":"Installazione del supporto"},{"location":"03_appendici/configurazioni/b_vs_community_guide/#creazione-di-un-progetto","text":"Una volta installati i tool per lo sviluppo, eseguiamo il programma Visual Studio 2019 dal menu Start. Si aprir\u00e0 la seguente schermata: Selezioniamo l'opzione Crea un nuovo progetto . Apparir\u00e0 la seguente schermata: Selezioniamo prima App console C++ a sinistra, e poi Progetto vuoto o App Console a destra. Scegliamo quindi l'opzione Avanti . Diamo un nome al progetto (ad esempio, Primo progetto ) ed alla soluzione (ad esempio, Prima soluzione ), scegliamo la cartella in cui salvare il tutto, e scegliamo l'opzione Crea . Se abbiamo scelto App Console , apparir\u00e0 gi\u00e0 un progetto di esempio. Qualora scegliessimo Progetto vuoto , apparir\u00e0 la seguente schermata. In quest'ultimo caso, selezioniamo clicchiamo con il destro sulla cartella (mostrata nel menu a destra) chiamata File di origine e selezioniamo dal menu che appare Aggiungi > Nuovo Elemento . Da qui possiamo creare direttamente un file C++, oppure un file C modificandone manualmente l'estensione. Creiamo un file chiamato HelloWorld.c ed aggiungiamolo al nostro progetto. Aggiungiamo il seguente codice: #include <stdio.h> int main () { printf ( \"Hello, World! \\n \" ); return 0 ; } Eseguiamo il nostro programma premendo Ctrl + F5, oppure scegliendo l'opzione Avvia senza eseguire Debug dal menu Debug . Se tutto \u00e8 andato a buon fine, apparir\u00e0 la seguente finestra:","title":"Creazione di un progetto"}]}