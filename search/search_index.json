{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvenuti nella pagina del Corso di Informatica per il CdL Triennale in Matematica per l'A.A. 2020/2021. Indirizzi utili \u00b6 E-mail del docente: angelo.cardellicchio@uniba.it Contatto Skype: angelo_cardellicchio Orari del corso \u00b6 Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 . Ricevimento \u00b6 Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Nota A causa dell'emergenza COVID-19, il ricevimento deve essere necessariamente concordato a mezzo e-mail; \u00e8 inoltre preferibile evitare il ricevimento in presenza, optando per comunicazioni telematiche a mezzo e-mail, Skype o Microsoft Teams. Modalit\u00e0 di svolgimento delle lezioni \u00b6 Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica. Prerequisiti \u00b6 Non sono necessari particolari prerequisiti per l'accesso al Corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il Corso. Modalit\u00e0 di valutazione \u00b6 Modalit\u00e0 Standard \u00b6 Il corso prevede una prova scritta ed una prova orale . Qualora lo studente sostenga la prova scritta con un risultato maggiore od uguale ai 18 trentesimi, la prova orale risulta essere opzionale . Qualora lo studente sostenga la prova scritta con un risultato compreso tra 15 e 17 trentesimi, dovr\u00e0 obbligatoriamente sostenere la prova orale . Qualora lo studente sostenga la prova scritta con un risultato inferiore ai 15 trentesimi, dovr\u00e0 ripetere l'esame per intero al successivo appello utile . Qualora lo studente sostenga la prova scritta e la prova orale, e non totalizzi a seguito di entrambe un risultato maggiore od uguale ai 18 trentesimi, dovr\u00e0 ripetere l'esame per intero al successivo appello utile . In particolare, il punto 4 implica che non conseguire un punteggio maggiore od uguale ai 18 trentesimi comporti l'automatica \"perdita\" della valutazione scritta precedentemente conseguita, anche se questa \u00e8 superiore ai 18 trentesimi. Modalit\u00e0 Alternativa con Esoneri \u00b6 Durante il Corso, saranno assegnati a ciascuno studente tre diversi esercizi, da sostenere in maniera autonoma durante le ore di studio personale . Ogni esercizio sar\u00e0 valutato in maniera autonoma con un voto compreso tra 0 e 30 trentesimi . Lo studente si ritiene esonerato qualora sostenga i tre esercizi con una media complessiva maggiore od uguale a 18 trentesimi. Potr\u00e0 opzionalmente sostenere la prova orale . Lo studente si ritiene esonerato esclusivamente dalla prova scritta qualora sostenga i tre esercizi con una media complessiva compresa tra 15 e 17 trentesimi. In tal caso, dovr\u00e0 obbligatoriamente sostenere la prova orale, o sostenere l'esame secondo la Modalit\u00e0 Standard a partire dal primo appello utile . Lo studente che non sostenga anche uno solo dei tre esercizi, o che li sostenga tutti e tre con una media complessiva inferiore ai 15 trentesimi, dovr\u00e0 sostenere l'esame secondo la Modalit\u00e0 Standard a partire dal primo appello utile . Programma del Corso \u00b6 Il programma del Corso si articola come segue: Argomento Dispense Slide Introduzione al corso Introduzione all'Informatica Introduzione agli Algoritmi Introduzione all'Architettura degli Elaboratori Introduzione ai Linguaggi di Programmazione Rappresentazione degli Algoritmi e Programmazione Strutturata Diagrammi di Flusso Costrutti di Programmazione Il linguaggio C Dal C al C++: la programmazione orientata agli oggetti Il linguaggio Python Macchine di Turing Complessit\u00e0 Computazionale","title":"Home"},{"location":"#indirizzi-utili","text":"E-mail del docente: angelo.cardellicchio@uniba.it Contatto Skype: angelo_cardellicchio","title":"Indirizzi utili"},{"location":"#orari-del-corso","text":"Il corso si terr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 12:00 alle 14:00 .","title":"Orari del corso"},{"location":"#ricevimento","text":"Il ricevimento avverr\u00e0 il luned\u00ec ed il mercoled\u00ec dalle 16:30 alle 17:30 nell'ufficio del docente, sito presso la sede di Ex-Architettura del Dipartimento di Ingegneria Elettronica e dell'Informazione, stanza 4.12. Nota A causa dell'emergenza COVID-19, il ricevimento deve essere necessariamente concordato a mezzo e-mail; \u00e8 inoltre preferibile evitare il ricevimento in presenza, optando per comunicazioni telematiche a mezzo e-mail, Skype o Microsoft Teams.","title":"Ricevimento"},{"location":"#modalita-di-svolgimento-delle-lezioni","text":"Le lezioni sono svolte in modalit\u00e0 mista (50% degli studenti in Aula, 50% collegati da remoto). Il Corso sar\u00e0 tenuto in Aula I del Dipartimento di Matematica.","title":"Modalit\u00e0 di svolgimento delle lezioni"},{"location":"#prerequisiti","text":"Non sono necessari particolari prerequisiti per l'accesso al Corso. E' comunque previsto l'utilizzo di un computer personale per lo svolgimento degli esercizi assegnati durante il Corso.","title":"Prerequisiti"},{"location":"#modalita-di-valutazione","text":"","title":"Modalit\u00e0 di valutazione"},{"location":"#modalita-standard","text":"Il corso prevede una prova scritta ed una prova orale . Qualora lo studente sostenga la prova scritta con un risultato maggiore od uguale ai 18 trentesimi, la prova orale risulta essere opzionale . Qualora lo studente sostenga la prova scritta con un risultato compreso tra 15 e 17 trentesimi, dovr\u00e0 obbligatoriamente sostenere la prova orale . Qualora lo studente sostenga la prova scritta con un risultato inferiore ai 15 trentesimi, dovr\u00e0 ripetere l'esame per intero al successivo appello utile . Qualora lo studente sostenga la prova scritta e la prova orale, e non totalizzi a seguito di entrambe un risultato maggiore od uguale ai 18 trentesimi, dovr\u00e0 ripetere l'esame per intero al successivo appello utile . In particolare, il punto 4 implica che non conseguire un punteggio maggiore od uguale ai 18 trentesimi comporti l'automatica \"perdita\" della valutazione scritta precedentemente conseguita, anche se questa \u00e8 superiore ai 18 trentesimi.","title":"Modalit\u00e0 Standard"},{"location":"#modalita-alternativa-con-esoneri","text":"Durante il Corso, saranno assegnati a ciascuno studente tre diversi esercizi, da sostenere in maniera autonoma durante le ore di studio personale . Ogni esercizio sar\u00e0 valutato in maniera autonoma con un voto compreso tra 0 e 30 trentesimi . Lo studente si ritiene esonerato qualora sostenga i tre esercizi con una media complessiva maggiore od uguale a 18 trentesimi. Potr\u00e0 opzionalmente sostenere la prova orale . Lo studente si ritiene esonerato esclusivamente dalla prova scritta qualora sostenga i tre esercizi con una media complessiva compresa tra 15 e 17 trentesimi. In tal caso, dovr\u00e0 obbligatoriamente sostenere la prova orale, o sostenere l'esame secondo la Modalit\u00e0 Standard a partire dal primo appello utile . Lo studente che non sostenga anche uno solo dei tre esercizi, o che li sostenga tutti e tre con una media complessiva inferiore ai 15 trentesimi, dovr\u00e0 sostenere l'esame secondo la Modalit\u00e0 Standard a partire dal primo appello utile .","title":"Modalit\u00e0 Alternativa con Esoneri"},{"location":"#programma-del-corso","text":"Il programma del Corso si articola come segue: Argomento Dispense Slide Introduzione al corso Introduzione all'Informatica Introduzione agli Algoritmi Introduzione all'Architettura degli Elaboratori Introduzione ai Linguaggi di Programmazione Rappresentazione degli Algoritmi e Programmazione Strutturata Diagrammi di Flusso Costrutti di Programmazione Il linguaggio C Dal C al C++: la programmazione orientata agli oggetti Il linguaggio Python Macchine di Turing Complessit\u00e0 Computazionale","title":"Programma del Corso"},{"location":"01_intro/","text":"Una definizione di Informatica \u00b6 Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico. Il concetto di Informazione \u00b6 L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca. I sistemi Informatici \u00b6 Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0. Il ruolo dell'Informatico \u00b6 Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"Introduzione all'Informatica"},{"location":"01_intro/#una-definizione-di-informatica","text":"Di solito, trovare una definizione per un argomento pu\u00f2 aiutare a comprenderne al meglio la natura. Possiamo quindi partire da una breve analisi dell'etimologia del termine informatica . Questo \u00e8 infatti il corrispettivo italiano del francese informatique , derivante dalla contrazione delle parole informa(tion) ed (automa)tique . Da questo, quindi, possiamo dedurre in maniera abbastanza intuitiva una prima, informale definizione. Definizione (prima versione) L'informatica \u00e8 quella disciplina che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica dell'informazioni. Appare chiaro come questa definizione sia un po' generica: proviamo quindi a rifinirla ulteriormente. Ci viene in aiuto in tal senso il termine inglese associato all'informatica, ovvero computer science , che ne \"nobilita\", in un certo senso, la natura. L'informatica \u00e8 infatti una vera e proria disciplina scientifica , basata su solide fondamenta matematiche, gettate in buona parte dai padri della materia, uno fra tutti il celebre matematico inglese Alan Turing. Arricchiamo quindi la nostra definizione come segue: Definizione (seconda versione) L'informatica \u00e8 la disciplina scientifica che si occupa di tutto ci\u00f2 che concerne l'elaborazione automatica delle informazioni. Va gi\u00e0 meglio, vero? Potrebbe essere per\u00f2 sensato includere il ruolo dell'informatica all'interno della societ\u00e0 moderna, di cui rappresenta un vero e proprio pilastro . Tutto ci\u00f2 che rappresenta le basi del nostro stile di vita odierno, dai social network al machine learning in ambito biomedicale, passando per la gestione automatica della supply chain e, ultimamente, dai mezzi digitali per lo smart working, non sarebbe stato possibile senza le enormi evoluzioni ed applicazioni, sia informatiche sia elettroniche , avute a partire dagli anni '50 del secolo scorso. Ecco quindi che la definizione finale che daremo di informatica, derivante dall' Oxford Languages (e facilmente reperibile mediante Google), \u00e8 la seguente: Definizione (versione finale) L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico.","title":"Una definizione di Informatica"},{"location":"01_intro/#il-concetto-di-informazione","text":"L'Informazione \u00e8, in generale, associata ai concetti di conoscenza ed esperienza e, secondo il matematico Claude Shannon, \u00e8 alla base del processo comunicativo . Esempi di informazione sono i seguenti: il contenuto di questo Corso, in cui \u00e8 racchiusa la conoscenza relativa ai concetti informatici di base; il contributo apportato da un progettista al design di un'auto da corsa; lo storico del nostro account Amazon, che sembra offrirci prodotti sempre allettanti con i quali sperperare i nostri guadagni; i racconti di infanzia dei nostri genitori. Da questi pochi esempi, appare evidente come la mole e l'eterogeneit\u00e0 delle informazioni che ci circondano siano tali da risultare difficilmente trattabili da un essere umano, per quanto capace ed istruito; nonostante talune audaci dichiarazioni susseguitesi soprattutto nel corso degli ultimi anni sui social network, infatti, \u00e8 estremamente improbabile che tra noi ci sia un nuovo Leonardo Da Vinci, o che emerga nel prossimo futuro. E' quindi evidente la necessit\u00e0 di automatizzare, per quanto possibile, la gestione ed il flusso delle informazioni stesse. Teoria dell'Informazione Abbiamo fatto brevemente cenno a Claude Shannon, noto anche come il padre della cosiddetta Teoria dell'Informazione . Questa disciplina \u00e8 una \"cugina\" dell'Informatica, ed il suo sviluppo ha avuto profonde implicazioni sullo sviluppo delle reti di telecomunicazioni che collegano i singoli apparati informatici. In particolare, la Teoria dell'Informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione delle informazioni su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia , intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca.","title":"Il concetto di Informazione"},{"location":"01_intro/#i-sistemi-informatici","text":"Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer , delegato all'elaborazione e gestione delle nostre informazioni personali. Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell' Internet of Things , i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0. Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l' hardware , che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software , il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware. Adagio comune Un adagio comune nel mondo dell'informatica dice che l' hardware \u00e8 la parte che \u00e8 possibile prendere a calci , mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare . Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0.","title":"I sistemi Informatici"},{"location":"01_intro/#il-ruolo-dellinformatico","text":"Come abbiamo gi\u00e0 accennato in precedenza, i primi \"informatici\" erano in realt\u00e0 prevalentemente matematici e fisici: basti pensare che, oltre ad Alan Turing e Claude Shannon, anche l'ideatore dell'architettura dei calcolatori, John von Neumann, era un matematico. Nel tempo, la figura dell'informatico vero e proprio si \u00e8 andata definendo come a s\u00e9 stante: ci\u00f2 \u00e8 avvenuto tra gli anni '60 e '70, dove i primi hacker approfondivano lo studio dei primordiali, e mastodontici, computer, esplorando nuove frontiere della conoscenza. Tuttavia, nonostante la presenza di informatici veri e propri, come ad esempio Steve Russell, Andrew Tanenbaum o Richard Stallman, la differenza tra \"informatico\", \"matematico\" e \"fisico\" \u00e8 stata sfumata fino agli anni '90: basti pensare infatti che il creatore del World Wide Web e del protocollo HTTP (ovvero di Internet come lo intendiamo oggi) \u00e8 un fisico che operava al CERN di Ginevra, ovvero Tim Barners Lee. L'Informatico moderno, visto come figura romanzata che, immerso in un ambiente praticamente buio, illuminato solo dalla fredda luce dei monitor, duella agilmente con le agenzie di controspionaggio, digitando a velocit\u00e0 inumana codici incomprensibili ed apparentemente casuali sulla sua tastiera, al solito, non esiste. L'evoluzione dell'Informatica \u00e8 avvenuta in cos\u00ec tanti rami e sotto un numero di aspetti cos\u00ec numeroso che, al giorno d'oggi, per creare sistemi anche banali sono necessarie diverse figure, tra cui sistemisti, esperti di cybersecurity, system architects, data scientists, UI/UX designers, ed ovviamente coloro che incarnano il male pi\u00f9 assoluto: i programmatori . L'insieme di questi ruoli, in team di opportune dimensioni, ci permette di compiere tutte le azioni \"quotidiane\" dal nostro smartphone o computer. Una nota Potrebbe sembrare che il ruolo \"classico\" dell'Informatico, quello prettamente teorico per intenderci, sia in qualche modo scomparso nella sua accezione originaria. Ci\u00f2 non \u00e8 completamente vero: anche questo ruolo si \u00e8 evoluto, e possiamo trovarne dei lasciti in figure come i moderni data scientists o i teorici dell'ingegneria del software.","title":"Il ruolo dell'Informatico"},{"location":"02_algoritmi/","text":"Formulare un problema \u00b6 Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio. Il problema come compito \u00b6 Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo . L' ente risolutore \u00b6 La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann. Gli elementi noti e le condizioni fissate \u00b6 La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore. Risolvere un problema \u00b6 La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi. Problemi e soluzioni \u00b6 Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: INSERIRE DIAGRAMMA DI EULERO-VENN Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione . Costruire la soluzione \u00b6 Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse. Operazioni atomiche \u00b6 Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.). Combinare operazioni atomiche \u00b6 Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori. Determinare l'insieme di operatori \u00b6 Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema. Da soluzione ad algoritmo \u00b6 La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema. Un esempio \u00b6 Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo. Formulazione del problema \u00b6 Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) . Dati \u00b6 Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo. Algoritmo risolutivo (in operazioni atomiche, o quasi) \u00b6 Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 . Esempio numerico \u00b6 Dati \u00b6 \\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\] Step 1 \u00b6 \\[ {c_1}^2 = 9 \\] Step 2 \u00b6 \\[ {c_2}^2 = 16 \\] Step 3 \u00b6 \\[ {c_1}^2 + {c_2}^2 = 25 \\] Step 1 \u00b6 \\[ \\sqrt{{c_1}^2 + {c_2}^2} = 5 = i \\] Caratteristiche degli algoritmi risolutivi \u00b6 Le cinque caratteristiche principali \u00b6 Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico. Determinismo \u00b6 Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso. Input, Output e Variabili \u00b6 Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"Gli Algoritmi"},{"location":"02_algoritmi/#formulare-un-problema","text":"Per comprendere gli algoritmi, partiamo definendo il concetto di problema . In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come: Definizione di problema ...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza. Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio.","title":"Formulare un problema"},{"location":"02_algoritmi/#il-problema-come-compito","text":"Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito ) che necessita di una risoluzione (o svolgimento ). Esempi concreti di problema sono: \"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\" \"Come calcolare l'ipotenusa di un triangolo rettangolo?\" \"Come dimostrare l'ipotesi di Riemann?\" Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili , per farlo \u00e8 necessario adoperare un algoritmo .","title":"Il problema come compito"},{"location":"02_algoritmi/#lente-risolutore","text":"La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti , propriamente intesi come esecutori di una serie di step necessari a risolvere il problema. Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann.","title":"L'ente risolutore"},{"location":"02_algoritmi/#gli-elementi-noti-e-le-condizioni-fissate","text":"La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema. Torniamo ai nostri esempi. In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali: collocazione desiderata del mobile; numero e tipo di pezzi nella confezione del mobile; attrezzi di cui abbiamo bisogno. Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla. Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base. Nota La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore.","title":"Gli elementi noti e le condizioni fissate"},{"location":"02_algoritmi/#risolvere-un-problema","text":"La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati : i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni , o stati , e le differenze tra di essi.","title":"Risolvere un problema"},{"location":"02_algoritmi/#problemi-e-soluzioni","text":"Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come . Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema. Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi , come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\) . Questo \u00e8 rappresentato dal seguente diagramma di Eulero-Venn: INSERIRE DIAGRAMMA DI EULERO-VENN Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione .","title":"Problemi e soluzioni"},{"location":"02_algoritmi/#costruire-la-soluzione","text":"Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero: le operazioni atomiche disponibili; il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse.","title":"Costruire la soluzione"},{"location":"02_algoritmi/#operazioni-atomiche","text":"Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere: sommare due numeri; fare un passo in avanti; finalizzare una transazione sul proprio conto corrente bancario. Esempi di operazioni non atomiche sono invece: risolvere un'equazione di secondo grado; correre per dieci metri; effettuare un versamento ed un prelievo sul proprio conto corrente bancario. Nota sulla somma Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una Nota sul conto corrente bancario La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.).","title":"Operazioni atomiche"},{"location":"02_algoritmi/#combinare-operazioni-atomiche","text":"Le operazioni atomiche possono essere combinate in due modi: effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario); effettuandole in parallelo . Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero: mantenere indipendenti le singole operazioni ; coordinare pi\u00f9 esecutori , o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo . Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino? Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori.","title":"Combinare operazioni atomiche"},{"location":"02_algoritmi/#determinare-linsieme-di-operatori","text":"Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema.","title":"Determinare l'insieme di operatori"},{"location":"02_algoritmi/#da-soluzione-ad-algoritmo","text":"La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto). L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema.","title":"Da soluzione ad algoritmo"},{"location":"02_algoritmi/#un-esempio","text":"Facciamo un esempio. Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo.","title":"Un esempio"},{"location":"02_algoritmi/#formulazione-del-problema","text":"Dati due numeri interi \\(c_1\\) e \\(c_2\\) , rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\) , calcolarne l'ipotenusa \\(i\\) .","title":"Formulazione del problema"},{"location":"02_algoritmi/#dati","text":"Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo.","title":"Dati"},{"location":"02_algoritmi/#algoritmo-risolutivo-in-operazioni-atomiche-o-quasi","text":"Calcolare il quadrato di \\(c_1\\) . Calcolare il quadrato di \\(c_2\\) . Sommare i quadrati calcolati ai punti 1 e 2 . Calcolare la radice quadrata della somma ottenuta al punto 3 .","title":"Algoritmo risolutivo (in operazioni atomiche, o quasi)"},{"location":"02_algoritmi/#esempio-numerico","text":"","title":"Esempio numerico"},{"location":"02_algoritmi/#dati_1","text":"\\[ \\begin{eqnarray} c_1 &= 3 \\\\ c_2 &= 4 \\\\ \\end{eqnarray} \\]","title":"Dati"},{"location":"02_algoritmi/#step-1","text":"\\[ {c_1}^2 = 9 \\]","title":"Step 1"},{"location":"02_algoritmi/#step-2","text":"\\[ {c_2}^2 = 16 \\]","title":"Step 2"},{"location":"02_algoritmi/#step-3","text":"\\[ {c_1}^2 + {c_2}^2 = 25 \\]","title":"Step 3"},{"location":"02_algoritmi/#step-1_1","text":"\\[ \\sqrt{{c_1}^2 + {c_2}^2} = 5 = i \\]","title":"Step 1"},{"location":"02_algoritmi/#caratteristiche-degli-algoritmi-risolutivi","text":"","title":"Caratteristiche degli algoritmi risolutivi"},{"location":"02_algoritmi/#le-cinque-caratteristiche-principali","text":"Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali. finitezza : gli algoritmi sono finiti , sia dal punto di vista spaziale , sia da quello temporale ; generalit\u00e0 : gli algoritmi sono generici , ovvero rappresentano una soluzione ad un'intera classe di problemi; completezza : gli algoritmi sono completi , e quindi possono risolvere tutte le istanze del problema; non ambiguit\u00e0 : gli algoritmi non sono ambigui , e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili; eseguibilit\u00e0 : gli algoritmi sono eseguibili , nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo. Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8: pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito; pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi); le istruzioni sono chiare e non equivocabili; le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata. In merito alla 4, \u00e8 interessante notare come, probabilmente, nessun manuale IKEA (o affini) sia algoritmico.","title":"Le cinque caratteristiche principali"},{"location":"02_algoritmi/#determinismo","text":"Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico. Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso.","title":"Determinismo"},{"location":"02_algoritmi/#input-output-e-variabili","text":"Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output . E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici . Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO). Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto , chiamati variabili . Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.","title":"Input, Output e Variabili"},{"location":"03_architettura/","text":"Architettura dei Calcolatori \u00b6 La conoscenza dell'architettura del calcolatore pu\u00f2 L'architettura di un calcolatore \u00e8 basata su Il modello di von Neumann \u00b6 L'architettura di un computer \u00e8 basata sul modlelo porposto da John von Neumann alla met\u00e0 degli anni '40 del secolo scorso. Questa architettura prevede tre entit\u00e0 logiche: memoria Centra Processing Unit, che comprende - control unit - ALU (Arithmetic Logic Unit) dispositivi di input/utput Le informazioni (dati) viaggiano tra le componenti mediante un bus cpu \u00b6 \u00e8 la componente che acquisisce, interpreta ed esegue le istruzioni dei programmi Si componea sua volta di: - control unit, responsabile del prelievo e della decodifica delle istruzioni, oltre che dell'invio dei segnali di controllo - arithmetic logic unit, per l'esecuzione delle operazioni aritmetiche e logiche - alcune varianti dle modello prevedono anche un clock Dal punto di vista operativo, la CPU fa uso di alcuni registri: elementi di memoria i cui valori possono essere aceduti in lettura e scrittura molto velocemente CIR: Current Instruction Register / contiene l'istruzione in corsodi esecuzione PC (Program Counter) - contiene l'indirizzo della prossima istruzioen del programma in esecuzione Memoria \u00b6 E' la memoria cenrale, di lavoro, da non confondersi con la memoria di massa in cui vengono immagazzinati dati e programmi quando non in uso. Contiene gli elementi che il computer sta usando nella corrente elaborazione, e precisamente le istruzioni del programma in corso di esecuzione i dati necessari all'esecuzione di quel programma si pu\u00f2 immaginare la memoria come costituita da tante celle, ognuna identificata univocamente dal proprio indirizzo I/O Sono i dispositivi con cui rispettivamente vengono forniti dati e programmi al computer vengono prododotti dal computer i risultati dell'elaborazione SUpporto \u00b6 La machcina di Von Neuman \u00e8 una macchina astratta, un modello per realizzare macchine reali. Per questo non vengono enfatizzati ulteriori elementi logici che pure osno necessari, come ad esempio - bus e clock di sistema memorie di massa interfacce di rete... Nel modello di von Neumann \u00e8 implicita la separazione della memoria dalla unit\u00e0 di elaborazione, definendo quello che viene chiamato stored-program computer. Inizialmente, infatti questi due blocchi erano unici ed avevano una memoria programma fissa. Ad esempio, un calcolatore desktop (in principio) si presentava come una macchina in grado di eseguire operazioni matematiche, ma sarebbe stato impossibile usare un word processor oppure eseguire dei video games. Tale macchina rappresent\u00f2 una grande innovazione; la possibilit\u00e0 di trattare le istruzioni come fossero dati permise lo sviluppo di assembler e compilatori. Era cos\u00ec possibile \u201cscrivere programmi che scrivono programmi\u201d. Chiaramente, la possibilit\u00e0 di modificare programmi \u00e8 anche uno svantaggio: se si sbaglia indirizzo di memoria si rischia di sovrascrivere il firmware e ci\u00f2 pu\u00f2 comportare anche il danneggiamento irreversibile della macchina. Un altro problema tipico di queste macchine \u00e8 rappresentato dal buffer overflow. Per risolvere il problema si pu\u00f2 pensare di implementare alcune forme di protezione della memoria. Il termine deriva dall\u2019articolo scritto dal matematico John von Neumann nel giugno del 1945, che trattava per primo una macchina stored-program gereral purpouse (denominata EDVAC). La separazione della CPU dalla memoria ha per\u00f2 portato a quello che \u00e8 oggi conosciuto come collo di bottiglia di von Neumann. Il throughput (cio\u00e8 la velocit\u00e0 di trasferimento dei dati) tra unit\u00e0 di elaborazione e memoria \u00e8 molto minore rispetto alla quantit\u00e0 di dati trasferiti. Inoltre, il throughput \u00e8 molto minore rispetto alla frequenza operativa della CPU. Queste considerazioni determinano una seria limitazione nella velocit\u00e0 effettiva di esecuzione delle istruzioni. In presenza di operazioni di accesso alla memoria la CPU deve continuamente attendere che tali dati arrivino. Attualmente le frequenze operative e la dimensione della memoria aumenta ad un tasso esponenziale, mentre il throughput avanza molto lentamente, rendendo sempre pi\u00f9 marcato questo collo di bottiglia. L'architettura Harvard \u00b6 Per superare i limiti imposti dal modello di von Neuman,, venne introdotta l'architettura Harvard, che presuppne la separazione della memoria programma da quella dati. Il termine deriva dalla macchina Harvard Mark I. PoicH\u00e9 nell'architettura di von Neumann il blocco di memoria ed il relativo percorso sono unici, non \u00e8 possibile leggere allo stesso tempo una istruzione ed un dato. In un computer con architettura Harvard questoo \u00e8 invece possibile. Questo rappresent\u00f2 uan rivoluzione, perch\u00e9 permise di superare i limiti imposti dall'archietttura di von Neumann. INfatti, la CPU \u00e8 in grado di effettuare il fetch dell'istruzione successiva contemporaneamente al completamento di quella corrente. Da qui allo sviluppo di sistemi basati su pipeline il passo \u00e8 breve. Ovviamente, rispetto ad una macchina di von Neumann, quella Harvard risulta pi\u00f9 complessa dal punto di vista implementativo e circuitale. Questo si traduce in un costo superiore. LE MODERNE CPU \u00b6 Non si deve pensare che l'architettura di von Neumann sia completamente scomparsa a favore di quella Harvard. le moderne CPU fanno spesso uso di memorie pi\u00f9 velici (cache) ma con dimensioni ridotte, allo scopo di bufferizzare i dati dalla memoria principale (off-chip). L'architettura implementata in questi casi \u00e8 una soluzione mista: per l'accesso della CPU alla cache \u00e8 usata l'architettura Harvard, mentre si usa la von Neumann per gli eventuali accessi alla memoria off-chip.","title":"Architettura dei Calcolatori"},{"location":"03_architettura/#architettura-dei-calcolatori","text":"La conoscenza dell'architettura del calcolatore pu\u00f2 L'architettura di un calcolatore \u00e8 basata su","title":"Architettura dei Calcolatori"},{"location":"03_architettura/#il-modello-di-von-neumann","text":"L'architettura di un computer \u00e8 basata sul modlelo porposto da John von Neumann alla met\u00e0 degli anni '40 del secolo scorso. Questa architettura prevede tre entit\u00e0 logiche: memoria Centra Processing Unit, che comprende - control unit - ALU (Arithmetic Logic Unit) dispositivi di input/utput Le informazioni (dati) viaggiano tra le componenti mediante un bus","title":"Il modello di von Neumann"},{"location":"03_architettura/#cpu","text":"\u00e8 la componente che acquisisce, interpreta ed esegue le istruzioni dei programmi Si componea sua volta di: - control unit, responsabile del prelievo e della decodifica delle istruzioni, oltre che dell'invio dei segnali di controllo - arithmetic logic unit, per l'esecuzione delle operazioni aritmetiche e logiche - alcune varianti dle modello prevedono anche un clock Dal punto di vista operativo, la CPU fa uso di alcuni registri: elementi di memoria i cui valori possono essere aceduti in lettura e scrittura molto velocemente CIR: Current Instruction Register / contiene l'istruzione in corsodi esecuzione PC (Program Counter) - contiene l'indirizzo della prossima istruzioen del programma in esecuzione","title":"cpu"},{"location":"03_architettura/#memoria","text":"E' la memoria cenrale, di lavoro, da non confondersi con la memoria di massa in cui vengono immagazzinati dati e programmi quando non in uso. Contiene gli elementi che il computer sta usando nella corrente elaborazione, e precisamente le istruzioni del programma in corso di esecuzione i dati necessari all'esecuzione di quel programma si pu\u00f2 immaginare la memoria come costituita da tante celle, ognuna identificata univocamente dal proprio indirizzo I/O Sono i dispositivi con cui rispettivamente vengono forniti dati e programmi al computer vengono prododotti dal computer i risultati dell'elaborazione","title":"Memoria"},{"location":"03_architettura/#supporto","text":"La machcina di Von Neuman \u00e8 una macchina astratta, un modello per realizzare macchine reali. Per questo non vengono enfatizzati ulteriori elementi logici che pure osno necessari, come ad esempio - bus e clock di sistema memorie di massa interfacce di rete... Nel modello di von Neumann \u00e8 implicita la separazione della memoria dalla unit\u00e0 di elaborazione, definendo quello che viene chiamato stored-program computer. Inizialmente, infatti questi due blocchi erano unici ed avevano una memoria programma fissa. Ad esempio, un calcolatore desktop (in principio) si presentava come una macchina in grado di eseguire operazioni matematiche, ma sarebbe stato impossibile usare un word processor oppure eseguire dei video games. Tale macchina rappresent\u00f2 una grande innovazione; la possibilit\u00e0 di trattare le istruzioni come fossero dati permise lo sviluppo di assembler e compilatori. Era cos\u00ec possibile \u201cscrivere programmi che scrivono programmi\u201d. Chiaramente, la possibilit\u00e0 di modificare programmi \u00e8 anche uno svantaggio: se si sbaglia indirizzo di memoria si rischia di sovrascrivere il firmware e ci\u00f2 pu\u00f2 comportare anche il danneggiamento irreversibile della macchina. Un altro problema tipico di queste macchine \u00e8 rappresentato dal buffer overflow. Per risolvere il problema si pu\u00f2 pensare di implementare alcune forme di protezione della memoria. Il termine deriva dall\u2019articolo scritto dal matematico John von Neumann nel giugno del 1945, che trattava per primo una macchina stored-program gereral purpouse (denominata EDVAC). La separazione della CPU dalla memoria ha per\u00f2 portato a quello che \u00e8 oggi conosciuto come collo di bottiglia di von Neumann. Il throughput (cio\u00e8 la velocit\u00e0 di trasferimento dei dati) tra unit\u00e0 di elaborazione e memoria \u00e8 molto minore rispetto alla quantit\u00e0 di dati trasferiti. Inoltre, il throughput \u00e8 molto minore rispetto alla frequenza operativa della CPU. Queste considerazioni determinano una seria limitazione nella velocit\u00e0 effettiva di esecuzione delle istruzioni. In presenza di operazioni di accesso alla memoria la CPU deve continuamente attendere che tali dati arrivino. Attualmente le frequenze operative e la dimensione della memoria aumenta ad un tasso esponenziale, mentre il throughput avanza molto lentamente, rendendo sempre pi\u00f9 marcato questo collo di bottiglia.","title":"SUpporto"},{"location":"03_architettura/#larchitettura-harvard","text":"Per superare i limiti imposti dal modello di von Neuman,, venne introdotta l'architettura Harvard, che presuppne la separazione della memoria programma da quella dati. Il termine deriva dalla macchina Harvard Mark I. PoicH\u00e9 nell'architettura di von Neumann il blocco di memoria ed il relativo percorso sono unici, non \u00e8 possibile leggere allo stesso tempo una istruzione ed un dato. In un computer con architettura Harvard questoo \u00e8 invece possibile. Questo rappresent\u00f2 uan rivoluzione, perch\u00e9 permise di superare i limiti imposti dall'archietttura di von Neumann. INfatti, la CPU \u00e8 in grado di effettuare il fetch dell'istruzione successiva contemporaneamente al completamento di quella corrente. Da qui allo sviluppo di sistemi basati su pipeline il passo \u00e8 breve. Ovviamente, rispetto ad una macchina di von Neumann, quella Harvard risulta pi\u00f9 complessa dal punto di vista implementativo e circuitale. Questo si traduce in un costo superiore.","title":"L'architettura Harvard"},{"location":"03_architettura/#le-moderne-cpu","text":"Non si deve pensare che l'architettura di von Neumann sia completamente scomparsa a favore di quella Harvard. le moderne CPU fanno spesso uso di memorie pi\u00f9 velici (cache) ma con dimensioni ridotte, allo scopo di bufferizzare i dati dalla memoria principale (off-chip). L'architettura implementata in questi casi \u00e8 una soluzione mista: per l'accesso della CPU alla cache \u00e8 usata l'architettura Harvard, mentre si usa la von Neumann per gli eventuali accessi alla memoria off-chip.","title":"LE MODERNE CPU"},{"location":"04_esecuzione/","text":"Esecuzione di programmi \u00b6 La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina - per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite Ciclo Fetch-Decode-Execute \u00b6 L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati","title":"Esecuzione di programmi"},{"location":"04_esecuzione/#esecuzione-di-programmi","text":"La macchina di von Neumann \u00e8 in grado di eseguire programmi espressi in un opportuno linguaggio macchina - per le macchine reali, il linguaggio macchina \u00e8 codificato secondo codici binari o esadecimali Si suppone che il programma da eseguiresia caricato in memoria prima dell'esecuzione. pu\u00f2 essere quindi caricato a partire da qualche memoria di massa su cui \u00e8 stato precedentemente registratot, fornito in input dal programmatore, etc Si suppone che il programma sia suddiviso logicamente in due parti. una parte di dati , di I/O e di supporto, calcolati e temporanei, su cui operano le istruzioni; ed una parte logica, rappresentativa dell'insieme delle istruzioni che devono essere eseguite","title":"Esecuzione di programmi"},{"location":"04_esecuzione/#ciclo-fetch-decode-execute","text":"L'esecuzione del programma avviene ripetendo iterativamente le fasi di Acquisizione (fetch) dell'istruzione da eseguire Interpretazione (DECODE) dell'istruzione Esecuzione (EXECUTE) In pratica: il contenuto del PC viene caricato nel CIR il PC viene aggiornato con l'indirizzo dell'istruzione successiva, l'istruzione del CIR viene decodificata ed eseguita, eventualmente accedendo ai dati","title":"Ciclo Fetch-Decode-Execute"},{"location":"05_rappresentazione/","text":"rappresentazione dei dati \u00b6 Tutte le informazioni (dati e istruzioni) in un computer sono rappresentate in forma binaria (ovvero come sequenza finita di simboli '0' ed '1') L'unit\u00e0 di informazione \u00e8 il bit , contrazione di binary digit . Un bit pu\u00f2 assumere solo i valori 0 oppure 1. Una sequenza di 8 bit costituisce un byte: un byte pu\u00f2 assumere uno tra 2^8 valori. Una parola (word) \u00e8 composta da N byte, con N dipendente dallo specifico contesto dati numerici \u00b6 Data la finitezza della macchina computer, tutte le informazioni che in essosi possono rappresentare sono necessariamente finite. Qando ad esempio si parla di insieme dei numeri interi, si intende un'approsismazione finita di N. Siamo abituati a pensare (e usare) i numeri interi in forma decimale e posizionale. Decimale, perch\u00e9 espressi in base 10, facendo usso di dieci simboli (0, 1, 2,3, etc.) posizionale perch\u00e9 la posizione in cui compare un simbolo \u00e8 fondamentale per la sua interpretazione. Ad esempio, il numero 12 ed il numero 21 sono rappresentati mediante gli stessi simboli 1 e 2, ma disposizioni in posizioni diverse. Sia \\(N\\) un generico numero intero ad \\(n\\) simboli. In forma decimale e posizionale \u00e8 possibile esprimerlo come: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n * b^n + a_{n-1} * b^{n-1} + ... + a_1 * b + a_0 \\] Ad esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\] Volendo rappresentare N in base 2: \\[ N = 485 \\] Per prima cosa, dividiamo il numero decimale per 2. \\[ N / 2 = 485 / 2 = 242 * 2 + 1 \\] Il risultato della divisione ha resto 1; questo sar\u00e0 il primo bit del nostro numero converito (chiamato anche Least Significant Bit, o LSB, o bit meno significativo). Continuiamo a dividere: \\[ 242 / 2 = 121 * 2 + 0 \\] Il secondo bit \u00e8 pari a 0. Reiterando la procedura: \\[ \\begin{eqnarray} 121 / 2 &= 60 * 2 + 1 \\\\ 60 / 2 &= 30 * 2 + 0 \\\\ 30 / 2 &= 15 * 2 + 0 \\\\ 15 / 2 &= 7 * 2 + 1 \\\\ 7 / 2 &= 3 * 2 + 1 \\\\ 3 / 2 &= 1 * 2 + 1 \\\\ 1 / 2 &= 0 * 2 + 1 \\end{eqnarray} \\] La rappresentazione risulta quindi essere data da: \\[ N_10 = 485_{10} = (111100101)_2 \\] Contrariamente all'LSB, la prima cifra \u00e8 chiamata Most Significant Bit (MSB). Rappresentazione di Interi \u00b6 Possiamo considerare due casi: interi senza segno - unsigned integer: si intendono solo i positivi interi con segno - signed ingteger: siintendono i positivi ed i negativi Immaginiamo che il computer possa utilizzare una word di N byte per rappresentare un intero (sia signed che unsigned) : N byte = N * 8 bit = Wbit Avendo a disposizione W bit \u00e8 possibile rappresentare i valori binari da 0 a 2^W-1 Nel caso si voglia rappresentare gli interi signed il bit pi\u00f9 significativo viene utilizzato per indicare il segno Convenzionalmente, 0 \u00e8 per il + ed 1 \u00e8er il meno. In tal caso, quindi, con W bit si possono rappresentare gli interi compresi tra (-2^W-1 - 1) e + (2 ^ W-1 - 1) Numeri rali \u00b6 Nell'ambito di un computer, l'approssimazione di \\(\\mathbb{R}\\) espressa da \"numeri reali\" indica pi\u00f9 precisamente un'approssimazione (finita) dei numeri razionali. Concettulamente, un numero \"reale\" \u00e8 rappresentato dalla giustapposizione di due numeri: se W bit sono disponibili, i primi W r indicano la parte intera, i rimanenti W f la parte frazionaria. Tale rappresentazione \u00e8 detta a virgola fissa (fixed point). La modalit\u00e0 di rappresentazione pi\u00f9 diffusa \u00e8 quella a virgola mobile (floating point), che utilizza due valori. Il primo \u00e8 la mantissa , interpretato come numero frazionario tra -1 ed 1, il secondo \u00e8 la caratteristica, usato come esponente. Si basa sulla notazione esponenziale, secondo cui \\[ r = m * b^c \\] Rappresentazione di Caratteri \u00b6 Anche i caratteri sono rappresentati mediante codici binari. Pi\u00f9 in generale si parla di \"simboli\" per specificare oltre agli usuali caratteri alfabetici, anche i simboli che idnicano: le cifre (decimali) la punteggiatura i simboli speciali (blank, carriage return, linefed, ...) Per poter codificare univocamente i caratteri \u00e8 necessaria una corrispondenza biunivoca tra questi e un opportuno sottoinieme degli interi: -standard ASCII - UNICODE UNICODE \u00b6 Codifica di tutti i caratteri possibili - delle lingue attualmente vive - di alcune lingue morte Pi\u00f9 di 110 k caratteri.","title":"rappresentazione dei dati"},{"location":"05_rappresentazione/#rappresentazione-dei-dati","text":"Tutte le informazioni (dati e istruzioni) in un computer sono rappresentate in forma binaria (ovvero come sequenza finita di simboli '0' ed '1') L'unit\u00e0 di informazione \u00e8 il bit , contrazione di binary digit . Un bit pu\u00f2 assumere solo i valori 0 oppure 1. Una sequenza di 8 bit costituisce un byte: un byte pu\u00f2 assumere uno tra 2^8 valori. Una parola (word) \u00e8 composta da N byte, con N dipendente dallo specifico contesto","title":"rappresentazione dei dati"},{"location":"05_rappresentazione/#dati-numerici","text":"Data la finitezza della macchina computer, tutte le informazioni che in essosi possono rappresentare sono necessariamente finite. Qando ad esempio si parla di insieme dei numeri interi, si intende un'approsismazione finita di N. Siamo abituati a pensare (e usare) i numeri interi in forma decimale e posizionale. Decimale, perch\u00e9 espressi in base 10, facendo usso di dieci simboli (0, 1, 2,3, etc.) posizionale perch\u00e9 la posizione in cui compare un simbolo \u00e8 fondamentale per la sua interpretazione. Ad esempio, il numero 12 ed il numero 21 sono rappresentati mediante gli stessi simboli 1 e 2, ma disposizioni in posizioni diverse. Sia \\(N\\) un generico numero intero ad \\(n\\) simboli. In forma decimale e posizionale \u00e8 possibile esprimerlo come: \\[ N = a_n a_{n-1} a_{n-2} ... a_2 a_1 a_0 \\] Esprimendo \\(N\\) in base \\(b\\) : \\[ N_b = a_n * b^n + a_{n-1} * b^{n-1} + ... + a_1 * b + a_0 \\] Ad esempio: \\[ N = 485_{10} = (4 * 10^2 + 8 * 10 + 5)_{10} \\] Volendo rappresentare N in base 2: \\[ N = 485 \\] Per prima cosa, dividiamo il numero decimale per 2. \\[ N / 2 = 485 / 2 = 242 * 2 + 1 \\] Il risultato della divisione ha resto 1; questo sar\u00e0 il primo bit del nostro numero converito (chiamato anche Least Significant Bit, o LSB, o bit meno significativo). Continuiamo a dividere: \\[ 242 / 2 = 121 * 2 + 0 \\] Il secondo bit \u00e8 pari a 0. Reiterando la procedura: \\[ \\begin{eqnarray} 121 / 2 &= 60 * 2 + 1 \\\\ 60 / 2 &= 30 * 2 + 0 \\\\ 30 / 2 &= 15 * 2 + 0 \\\\ 15 / 2 &= 7 * 2 + 1 \\\\ 7 / 2 &= 3 * 2 + 1 \\\\ 3 / 2 &= 1 * 2 + 1 \\\\ 1 / 2 &= 0 * 2 + 1 \\end{eqnarray} \\] La rappresentazione risulta quindi essere data da: \\[ N_10 = 485_{10} = (111100101)_2 \\] Contrariamente all'LSB, la prima cifra \u00e8 chiamata Most Significant Bit (MSB).","title":"dati numerici"},{"location":"05_rappresentazione/#rappresentazione-di-interi","text":"Possiamo considerare due casi: interi senza segno - unsigned integer: si intendono solo i positivi interi con segno - signed ingteger: siintendono i positivi ed i negativi Immaginiamo che il computer possa utilizzare una word di N byte per rappresentare un intero (sia signed che unsigned) : N byte = N * 8 bit = Wbit Avendo a disposizione W bit \u00e8 possibile rappresentare i valori binari da 0 a 2^W-1 Nel caso si voglia rappresentare gli interi signed il bit pi\u00f9 significativo viene utilizzato per indicare il segno Convenzionalmente, 0 \u00e8 per il + ed 1 \u00e8er il meno. In tal caso, quindi, con W bit si possono rappresentare gli interi compresi tra (-2^W-1 - 1) e + (2 ^ W-1 - 1)","title":"Rappresentazione di Interi"},{"location":"05_rappresentazione/#numeri-rali","text":"Nell'ambito di un computer, l'approssimazione di \\(\\mathbb{R}\\) espressa da \"numeri reali\" indica pi\u00f9 precisamente un'approssimazione (finita) dei numeri razionali. Concettulamente, un numero \"reale\" \u00e8 rappresentato dalla giustapposizione di due numeri: se W bit sono disponibili, i primi W r indicano la parte intera, i rimanenti W f la parte frazionaria. Tale rappresentazione \u00e8 detta a virgola fissa (fixed point). La modalit\u00e0 di rappresentazione pi\u00f9 diffusa \u00e8 quella a virgola mobile (floating point), che utilizza due valori. Il primo \u00e8 la mantissa , interpretato come numero frazionario tra -1 ed 1, il secondo \u00e8 la caratteristica, usato come esponente. Si basa sulla notazione esponenziale, secondo cui \\[ r = m * b^c \\]","title":"Numeri rali"},{"location":"05_rappresentazione/#rappresentazione-di-caratteri","text":"Anche i caratteri sono rappresentati mediante codici binari. Pi\u00f9 in generale si parla di \"simboli\" per specificare oltre agli usuali caratteri alfabetici, anche i simboli che idnicano: le cifre (decimali) la punteggiatura i simboli speciali (blank, carriage return, linefed, ...) Per poter codificare univocamente i caratteri \u00e8 necessaria una corrispondenza biunivoca tra questi e un opportuno sottoinieme degli interi: -standard ASCII - UNICODE","title":"Rappresentazione di Caratteri"},{"location":"05_rappresentazione/#unicode","text":"Codifica di tutti i caratteri possibili - delle lingue attualmente vive - di alcune lingue morte Pi\u00f9 di 110 k caratteri.","title":"UNICODE"},{"location":"06_linguaggi/","text":"Linguaggio \u00b6 Insieme di sequenze di simboli chiamati parole appartenenti ad un lessico definito giustapposti secondo un'opportuna grammatica (o sintassi) Per descriverlo \u00e8 necessario un meta-linguaggio In informatica un linguaggio \u00e8 pi\u00f9 precisamente definito come l'insieme di stringhe ottenute applicando le regole della relativa grammatica. Di conseguenza, una grammatica \u00e8 formalismo per definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle stringhe. Le stringhe ottenute possono essere anlizzate da un punto di vista: sintattico (siverifica la correttezza della forma linguistica in cui \u00e8 codificato) semantico (si individua il significato associato alla forma linguistica) pragmatico (si studiano gli usi e le utilit\u00e0 dei costrutti linguistici) Comunicazione diretta: \u00b6 Requisiti per i due interlocutori: l'estensore del messaggio (al momento della formulaizone) e il ricevitore (allar icezione) devono assegnare al messaggio uguale significato, ciascuno nel proprio contesto Programma \u00b6 E' un messaggio di comunicazione fra l'uomo e la macchinma. rappresenta un insiem di frasi costruite secondo regole molto rigide: elimina le ambiguit\u00e0 nell'interpretazione dei comandi da parte della macchina. Le istruzioni obbediscono a rigorose regole grammaticale. Comunicazione indiretta \u00b6 E' il caso della comunicazione tra il programmatore ed il computer. Il ricevitore non conosce il linguaggio usato per la stesura del messaggio. L'estensore ed il ricevitore hanno un diverso grado di conoscenza del linguaggio. Tra i due mancano adeugate convenzioni per un'interpretazione unica del messaggio Occorre un traduttore Il Linguaggio Naturale \u00b6 \u00e8 usato per la comunucazione verbale tra esseri umani Vi sono delle fonti di ambiguitp\u00e8, legati all'evoluzione (termini arcaici o neologismi), polisemia (parole con significati diversi a seconda del contesto), intrinseca (una vecchia porta la sbarra) E' inadatto alla comunicazione con la macchina : l'umano deve quindi adattarsi ad un linguaggio consono. linguaggi di programmazione \u00b6 a basso livello: pi\u00f9 vicini alla struttura reale della macchina ed al suo linguaggio ad alto livello: pi\u00f9 vicini al linguaggio dei rpoblemi pi\u00f9 facilid a comprendere per l'uomo portabili, utilizzabili, senza modifiche, su diversi tipi di macchine Ad alto livello \u00b6 procedurali: descrivono i passi necessari per ottenere i risultati desiderati (si concentrano sul come) basati sui concetti di variabile ed assegnamento Es. C, C++, Python non procedurali Esprimono le proprieot\u00e0 dei risultati che si vogliono ottenere, ovvero il cosa es. volendo ottenre la radice quadrata di y, ci interessa quel valore di x t.c. x*x = y ad esempio, abbiamo Lisp e Prolog Sintassi \u00b6 Pochi, semplici, rigide regole che indicano quali sono le istruzioni formali permesse Il programma va accuratamente controllato dal punto di vista formale per garantire la correttezza sintattica. La codifica \u00e8 solitamente ambigua o non interpretabile; il controllo \u00e8 delegato al traduttore. Semantica \u00b6 Riguarda il contenuto informativo ed il significato di una frase. Esistono metodi per trattare formalmente la semantica dei linguaggi di progammazione, al fine di capire il comportamento dei programmi. La semantica operazionale specifica come i costrutti del linguaggio sono eseguiti su una macchina astratta. La semantica denotazionale definisce come denotare il significato dei (costruitti del) linguaggio La semantica assiomatica determian il signficato dei (costrutti del) linguaggio usando regole di correttezza all'interno di una data logica esempio \u00b6 Io ho andato -> errore sintattico La penna sta mangiando -> corretta sintatticamente, ma errata sematnicametne Tutti i bimbi sono buoni e Tutti i buoni sono bimbi CORRETTE -> SEMANTICA DIVERSA NONONSTANTE ABBIANO GLI STESSI ELEMENTI","title":"Linguaggio"},{"location":"06_linguaggi/#linguaggio","text":"Insieme di sequenze di simboli chiamati parole appartenenti ad un lessico definito giustapposti secondo un'opportuna grammatica (o sintassi) Per descriverlo \u00e8 necessario un meta-linguaggio In informatica un linguaggio \u00e8 pi\u00f9 precisamente definito come l'insieme di stringhe ottenute applicando le regole della relativa grammatica. Di conseguenza, una grammatica \u00e8 formalismo per definire un linguaggio mediante l'imposizione di un metodo per la costruzione delle stringhe. Le stringhe ottenute possono essere anlizzate da un punto di vista: sintattico (siverifica la correttezza della forma linguistica in cui \u00e8 codificato) semantico (si individua il significato associato alla forma linguistica) pragmatico (si studiano gli usi e le utilit\u00e0 dei costrutti linguistici)","title":"Linguaggio"},{"location":"06_linguaggi/#comunicazione-diretta","text":"Requisiti per i due interlocutori: l'estensore del messaggio (al momento della formulaizone) e il ricevitore (allar icezione) devono assegnare al messaggio uguale significato, ciascuno nel proprio contesto","title":"Comunicazione diretta:"},{"location":"06_linguaggi/#programma","text":"E' un messaggio di comunicazione fra l'uomo e la macchinma. rappresenta un insiem di frasi costruite secondo regole molto rigide: elimina le ambiguit\u00e0 nell'interpretazione dei comandi da parte della macchina. Le istruzioni obbediscono a rigorose regole grammaticale.","title":"Programma"},{"location":"06_linguaggi/#comunicazione-indiretta","text":"E' il caso della comunicazione tra il programmatore ed il computer. Il ricevitore non conosce il linguaggio usato per la stesura del messaggio. L'estensore ed il ricevitore hanno un diverso grado di conoscenza del linguaggio. Tra i due mancano adeugate convenzioni per un'interpretazione unica del messaggio Occorre un traduttore","title":"Comunicazione indiretta"},{"location":"06_linguaggi/#il-linguaggio-naturale","text":"\u00e8 usato per la comunucazione verbale tra esseri umani Vi sono delle fonti di ambiguitp\u00e8, legati all'evoluzione (termini arcaici o neologismi), polisemia (parole con significati diversi a seconda del contesto), intrinseca (una vecchia porta la sbarra) E' inadatto alla comunicazione con la macchina : l'umano deve quindi adattarsi ad un linguaggio consono.","title":"Il Linguaggio Naturale"},{"location":"06_linguaggi/#linguaggi-di-programmazione","text":"a basso livello: pi\u00f9 vicini alla struttura reale della macchina ed al suo linguaggio ad alto livello: pi\u00f9 vicini al linguaggio dei rpoblemi pi\u00f9 facilid a comprendere per l'uomo portabili, utilizzabili, senza modifiche, su diversi tipi di macchine","title":"linguaggi di programmazione"},{"location":"06_linguaggi/#ad-alto-livello","text":"procedurali: descrivono i passi necessari per ottenere i risultati desiderati (si concentrano sul come) basati sui concetti di variabile ed assegnamento Es. C, C++, Python non procedurali Esprimono le proprieot\u00e0 dei risultati che si vogliono ottenere, ovvero il cosa es. volendo ottenre la radice quadrata di y, ci interessa quel valore di x t.c. x*x = y ad esempio, abbiamo Lisp e Prolog","title":"Ad alto livello"},{"location":"06_linguaggi/#sintassi","text":"Pochi, semplici, rigide regole che indicano quali sono le istruzioni formali permesse Il programma va accuratamente controllato dal punto di vista formale per garantire la correttezza sintattica. La codifica \u00e8 solitamente ambigua o non interpretabile; il controllo \u00e8 delegato al traduttore.","title":"Sintassi"},{"location":"06_linguaggi/#semantica","text":"Riguarda il contenuto informativo ed il significato di una frase. Esistono metodi per trattare formalmente la semantica dei linguaggi di progammazione, al fine di capire il comportamento dei programmi. La semantica operazionale specifica come i costrutti del linguaggio sono eseguiti su una macchina astratta. La semantica denotazionale definisce come denotare il significato dei (costruitti del) linguaggio La semantica assiomatica determian il signficato dei (costrutti del) linguaggio usando regole di correttezza all'interno di una data logica","title":"Semantica"},{"location":"06_linguaggi/#esempio","text":"Io ho andato -> errore sintattico La penna sta mangiando -> corretta sintatticamente, ma errata sematnicametne Tutti i bimbi sono buoni e Tutti i buoni sono bimbi CORRETTE -> SEMANTICA DIVERSA NONONSTANTE ABBIANO GLI STESSI ELEMENTI","title":"esempio"},{"location":"07_traduttori/","text":"TRADUTORE \u00b6 Programma che traduce in linguaggio macchina programmi in un linguaggio di livello superiore \u2013 Analizza i messaggi (comandi) e verifica che siano scritti scritti (codificati) (codificati) in un linguaggio linguaggio noto \u2022 Correttezza sintattica \u2013 Attribuisce alle sequenze di simb l o i l\u2019opportuno significato in modo da eseguire le giuste azioni \u2022 Interpretazione unica di ogni istruzione \u2013 Fa parte del software di sistema \u2022 Livello intermedio della gerarchia software\u2010hardware Nei p og a r r mmi ad a tol live oll ope a o r n su due tipi di entit\u00e0: \u2013 Istruzioni \u2022 Molto pi\u00f9 potenti che nel linguaggio macchina \u2013 Strutture di dati (sequenze, insiemi, alberi, ecc.) \u2022 Non direttamente disponibili al livello di linguaggio macchina \u2022 Devono essere rappresentate in termini di bit, indirizzi e legami tra locazioni Interpreti \u2022 Compilatori \u2013 Specifici per ogni linguaggio \u2013 Forniti entrambi dai sistemi di sviluppo del software per i linguaggi supportati \u2022 Dopo l\u2019analisi sintattica, la traduzione procede passo passo con l\u2019esecuzione \u2013 Traduzione ed esecuzione istruzione per istruzione \u2022 Ogni istruzione istruzione tradotta tradotta tante volte quante viene eseguita PROGRAMMA -> INTERPRETE -> RISULTATI DATI -> COMPILAZIONE Il programma originale (Sorgente) \u00e8 analizzato sintatticamente e tradotto in codice oggetto, quindi eseguito \u2013 Traduzione Traduzione completamente completamente effettuata effettuata prima che cominci l\u2019esecuzione \u2022 Ogni istruzione istruzione \u00e8 tradotta tradotta una sola volta PROGRAMMA -> COMPILATORE -> CODICE OGGETTO -> MACCHIAN FISICA -> RISULTATi DATI --------------------------------------> Interpreti Compilatori INTERPRETI programma sorgente residente in memoria, semplici, efficienti, tempo e spazio, interattivi, erorri comprensibili riferiti al sorgente COMPILATORI programma sorgente non residente in memoria, ottimizzabili, efficienti, tempo e spazio, interattivi, errori scoperti prima ma riferiti al codice oggetto Processo di compilazione \u00b6 Analisi Lessicale (Scanning) \u2013 Lettura Lettura in sequenza sequenza di tutti i caratteri caratteri che costituiscono il programma (il programma \u00e8 visto come un unica \u2019 stringa stringa di caratteri) caratteri) \u2013 Divisione della stringa in token (segni di interpunzione interpunzione, nomi di dati, operatori operatori, parole riservate, ...) \u2013 Nessun cont ll ro o Analisi Sintattica (Parsing) \u2013 Definizione della struttura struttura sintattica sintattica del programma usando le regole del linguaggio \u2013 Un gruppo di token raggruppati raggruppati secondo secondo la strutturazione ottenua deve corrispondere a una frase sintatticamente sintatticamente corretta corretta secondo secondo il linguaggio adottato \u2013 Se la frase non \u00e8 si t tti t ntatticamente corretta viene segnalato un messaggio d\u2019errore Generazione del Codice \u2013 Creazione Creazione di istruzioni istruzioni in linguaggio linguaggio macchina macchina per ogni elemento sintattico del programma \u2022 L insieme \u2019insieme finale di queste istruzioni istruzioni \u00e8 il programma programma oggetto Le fasi sono tra loro interrelate \u2013 I moduli di p g ro ramma responsabili dell\u2019analisi sintattica possono utilizzare \u2022 I moduli dell analisi dell\u2019analisi lessicale lessicale per ottenere ottenere un token \u2022 I moduli di generazione del codice per produrre il codice oggetto dell\u2019istruzione analizzata \u2022 Per capire come vengono effettuate le analisi \u00e8 necessaria necessaria la teoria dei linguaggi linguaggi","title":"TRADUTORE"},{"location":"07_traduttori/#tradutore","text":"Programma che traduce in linguaggio macchina programmi in un linguaggio di livello superiore \u2013 Analizza i messaggi (comandi) e verifica che siano scritti scritti (codificati) (codificati) in un linguaggio linguaggio noto \u2022 Correttezza sintattica \u2013 Attribuisce alle sequenze di simb l o i l\u2019opportuno significato in modo da eseguire le giuste azioni \u2022 Interpretazione unica di ogni istruzione \u2013 Fa parte del software di sistema \u2022 Livello intermedio della gerarchia software\u2010hardware Nei p og a r r mmi ad a tol live oll ope a o r n su due tipi di entit\u00e0: \u2013 Istruzioni \u2022 Molto pi\u00f9 potenti che nel linguaggio macchina \u2013 Strutture di dati (sequenze, insiemi, alberi, ecc.) \u2022 Non direttamente disponibili al livello di linguaggio macchina \u2022 Devono essere rappresentate in termini di bit, indirizzi e legami tra locazioni Interpreti \u2022 Compilatori \u2013 Specifici per ogni linguaggio \u2013 Forniti entrambi dai sistemi di sviluppo del software per i linguaggi supportati \u2022 Dopo l\u2019analisi sintattica, la traduzione procede passo passo con l\u2019esecuzione \u2013 Traduzione ed esecuzione istruzione per istruzione \u2022 Ogni istruzione istruzione tradotta tradotta tante volte quante viene eseguita PROGRAMMA -> INTERPRETE -> RISULTATI DATI -> COMPILAZIONE Il programma originale (Sorgente) \u00e8 analizzato sintatticamente e tradotto in codice oggetto, quindi eseguito \u2013 Traduzione Traduzione completamente completamente effettuata effettuata prima che cominci l\u2019esecuzione \u2022 Ogni istruzione istruzione \u00e8 tradotta tradotta una sola volta PROGRAMMA -> COMPILATORE -> CODICE OGGETTO -> MACCHIAN FISICA -> RISULTATi DATI --------------------------------------> Interpreti Compilatori INTERPRETI programma sorgente residente in memoria, semplici, efficienti, tempo e spazio, interattivi, erorri comprensibili riferiti al sorgente COMPILATORI programma sorgente non residente in memoria, ottimizzabili, efficienti, tempo e spazio, interattivi, errori scoperti prima ma riferiti al codice oggetto","title":"TRADUTORE"},{"location":"07_traduttori/#processo-di-compilazione","text":"Analisi Lessicale (Scanning) \u2013 Lettura Lettura in sequenza sequenza di tutti i caratteri caratteri che costituiscono il programma (il programma \u00e8 visto come un unica \u2019 stringa stringa di caratteri) caratteri) \u2013 Divisione della stringa in token (segni di interpunzione interpunzione, nomi di dati, operatori operatori, parole riservate, ...) \u2013 Nessun cont ll ro o Analisi Sintattica (Parsing) \u2013 Definizione della struttura struttura sintattica sintattica del programma usando le regole del linguaggio \u2013 Un gruppo di token raggruppati raggruppati secondo secondo la strutturazione ottenua deve corrispondere a una frase sintatticamente sintatticamente corretta corretta secondo secondo il linguaggio adottato \u2013 Se la frase non \u00e8 si t tti t ntatticamente corretta viene segnalato un messaggio d\u2019errore Generazione del Codice \u2013 Creazione Creazione di istruzioni istruzioni in linguaggio linguaggio macchina macchina per ogni elemento sintattico del programma \u2022 L insieme \u2019insieme finale di queste istruzioni istruzioni \u00e8 il programma programma oggetto Le fasi sono tra loro interrelate \u2013 I moduli di p g ro ramma responsabili dell\u2019analisi sintattica possono utilizzare \u2022 I moduli dell analisi dell\u2019analisi lessicale lessicale per ottenere ottenere un token \u2022 I moduli di generazione del codice per produrre il codice oggetto dell\u2019istruzione analizzata \u2022 Per capire come vengono effettuate le analisi \u00e8 necessaria necessaria la teoria dei linguaggi linguaggi","title":"Processo di compilazione"}]}