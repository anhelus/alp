{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Corso di Informatica per l'Ingegneria - Politecnico di Bari","text":"<p>Questa \u00e8 la bacheca per il corso di Informatica per l'Ingegneria (sezione N) tenuto presso il Politecnico di Bari nell'A.A. 2023/2024.</p>"},{"location":"#modalita-di-esame","title":"Modalit\u00e0 di esame","text":"<p>L'esame \u00e8 esclusivamente scritto, e si articola in tre diverse parti:</p> <ul> <li>un esercizio da svolgere in Algobuild;</li> <li>un esercizio da svolgere in MATLAB;</li> <li>dieci domande a risposta multipla.</li> </ul>"},{"location":"#ricevimento","title":"Ricevimento","text":"<p>E' possibile concordare un ricevimento inviando una e-mail all'indirizzo angelo.cardellicchio@poliba.it.</p>"},{"location":"#materiale-didattico","title":"Materiale didattico","text":"<p>Il materiale didattico \u00e8 disponibile a questi indirizzi:</p> <ul> <li>slides per l'A.A. 2023/2024;</li> <li>diagrammi AlgoBuild;</li> <li>codice sorgente MATLAB.</li> </ul> <p>Nota</p> <p>In questo sito \u00e8 presente del materiale didattico supplementare, sotto forma di dispense scritte, in fase di aggiornamento. Pertanto \u00e8 fortemente sconsigliato utilizzare tale materiale per la preparazione dell'esame.</p>"},{"location":"#iscrizione-al-team-del-corso","title":"Iscrizione al Team del corso","text":"<p>E' possibile iscriversi al team del corso:</p> <ul> <li>con un account guest, compilando il form reperibile a questo indirizzo entro e non oltre luned\u00ec 02 ottobre 2023;</li> <li>con l'account istituzionale, utilizzando il codice Teams prg8ubi.</li> </ul>"},{"location":"02_info_repr/","title":"2 - Rappresentazione dell'informazione","text":"<p>Uno dei possibili sinonimi del concetto di informazione \u00e8 quello di messaggio, che altro non \u00e8 se non una combinazione dei simboli dell'alfabeto del linguaggio che stiamo utilizzando.</p>"},{"location":"material/02_boole/","title":"Algebra Booleana","text":"<p>I circuiti elettronici digitali sono costruiti con elementi caratterizzati soltanto da due possibili stati di funzionamento, ovvero alto e basso.</p> <p>I dispositivi elettronici a due stati di funzionamento sono giustificati da due fattori:</p> <ul> <li>facilit\u00e0 di realizzazione da un lato</li> <li>dall'altro, qualsiasi informazione pu\u00f2 essere rappresentata mediante una successione di valori alti e bassi o, equivalentemente, 1 e 0</li> </ul> <p>I segnali binari, corrispondenti ai due livelli di funzionaemnto degli elementi costitutivi del calcolatori, vengono trattati mediante l'algebra di Boole, introdotta da George Boole.</p> <p>L'algebra di Boole venne introdotta nel XIX secolo da Boole per analizzare algebricamente problemi di calcolo proposizionale, al fine di studiare le leggi del pensiero.</p> <p>L'algebra di Boole \u00e8 fondata su un insieme di teoremi e regole che goveranon le operazioni logiche e che ne consentono una rappresentazione matematica.</p> <p>Sull'algebra di Boole si basa l'elettronica digitale ed il suo sviluppo.</p> <p>L'algebra di Boole contempla due costanti 0 e 1, rispettivamente falso e vero. I due stati sono mutualmente esclusivi: ci\u00f2 significa che si escludono a vicenda.</p> <p>In pratica, possono descrivere lo stato di apertura (0) o chiusura di un generico contatto, o di un circuito a pi\u00f9 contatti.</p> <p>Sui valori booleani si definiscono diverse operazioni, tra cui le pi\u00f9 importanti sono AND, OR, NOT e XOR.</p> <p>Le operazioni AND ed OR sono di tipo binario, assieme alla XOR, mentre l'operazione NOT \u00e8 unaria.</p> <p>Nella valutazione delle espressioni booleane esiste una relazione di precedenza tra gli oepratori NOT, AND e OR, nell'ordine in cui sono stati elencati.</p> <p>Gli operatori dell'algebra booleana possono essere rappresentati in vari modi.</p> <p>Spesso sono descritti semplicemente come AND, OR e NOT. Nella descrizione dei circuiti appaiono sotto forma di porte logiche. In matematica si usa + per OR e x per AND, mentre si rappresenta il NOT con una barra posta sopra l'espressione che viene negata.</p> <p>TODO: RAPPRESENTAZIONE, SIMBOLO ALGEBRICO E TABELLA DELLA VERITA</p>"},{"location":"material/02_boole/#loperazione-di-and","title":"L'operazione di AND","text":"<p>Si definisc el'operazione di prodotto logico (AND) il valore del prodotto logico \u00e8 il simbolo 1 se il valore di tutti gli operandi \u00e8 dato dal simbolo 1.</p> <p>Operazione di somma logica (OR) se il valore della somma logica \u00e8 il simbolo 1 se il valore di almeno uno degli altri operandi \u00e8 il simbolo 1.</p> <p>Si definisce l'operazione di negazione (NOT) come l'operatore che inverte il valroe della costante su cui opera.</p> <p>VARIABILI BINARIE</p> <p>Una variabile binaria indipendente pu\u00f2 assumere uno tra due valori 0 ed 1.</p> <p>Date n variabili binarie indipendenti, la loro somma logica \u00e8 1 se almeno una vale 1, 0 altrimenti.</p> <p>DA SLLIDE 12</p> <p>Il valore della </p>"},{"location":"material/11_pseudocodifica/","title":"Pseudocodifica","text":"<p>La pseudocodifica \u00e8 un linguaggio per descrivere gli algoritmi strutturati. Per farlo, dobbiamo codificare l'algoritmo in due parti:</p> <ul> <li>la prima \u00e8 quella della dichiarazione delle variabili;</li> <li>la seconda \u00e8 la descrizione delle azioni dell'algoritmo.</li> </ul>"},{"location":"material/11_pseudocodifica/#tipo-delle-variabili","title":"Tipo delle variabili","text":"<p>Sappiamo che il tipo di una variabile rappresenta l'insieme dei valori che possono essere ad essa assegnati.</p> <p>SOno permessi quattro tipi, ovvero integer, real, boolean e string-q. In particoalre:</p> <ul> <li>gli integer rappresentano i numeri interi;</li> <li>i real rappresentano i numeri decimali, rappresentabili sia in notazione decmiale che in notazione scientifica;</li> <li>i boolean rappresetano un valore booleano che pu\u00f2 assumere valore pari a vero o falso;</li> <li>le string-q sono parole (o stringhe) costituite da q caratteri.</li> </ul>"},{"location":"material/11_pseudocodifica/#la-dichiaraizone-delle-variabili","title":"La dichiaraizone delle variabili","text":"<p>La dichiarazione elel varaibili \u00e8 un elenco preceduto dalla parola chiave var.</p> <p>La dichiarazione prevede che queste siano suddivise per tipo. La forma \u00e8 del tipo:</p> <p>var nomevariabile1: tipo1;     nomevariabile2: tipo2;     nomevariabile3: tipo_3.</p>"},{"location":"material/11_pseudocodifica/#la-descrizione-delle-azioni","title":"La descrizione delle azioni","text":"<p>Regole fondamentali: 1. prima della prima azione vi \u00e8 un begin 2. dopo l'ultima vi \u00e8 un  end 3. la lettura \u00e8 read 4. la scrittura \u00e8 write</p>"},{"location":"material/11_pseudocodifica/#schema-sequenziale","title":"Schema sequenziale","text":"<p>Le istruzioni in una sequenza sono rappresentate secondo uno schema sequenziale. In altre parole, supponendo una sequenza del tipo...</p> <p>le istruzioni sono fatte in modo sequenziale</p>"},{"location":"material/11_pseudocodifica/#schema-di-selezione","title":"Schema di selezione","text":"<p>Gli schemi di selezione sono rappresentati mediante la struttura if then else, con un endif finale.</p>"},{"location":"material/11_pseudocodifica/#schemi-di-iterazione","title":"Schemi di iterazione","text":"<p>Gli schemi di iterazione sono rappresentati mediante la struttura while Cond Do S, con S sequenza nel caso di controllo in coda, mentre con contro0llo in testa abbiamo un repeat S until C.</p>"},{"location":"material/11_pseudocodifica/#schema-enumerativo","title":"Schema enumerativo","text":"<p>Esistonod elle situaizoni particolari nei quali ci sono detrerminate schemi linguistici. Ad esempio, nel caso di un for </p> <p><pre><code>for idx from val_in to val_fin step incr do\n    S\nendfor\n</code></pre> Esistono anche delle rappresentazioni</p>"},{"location":"material/01_intro/01_introduction/lecture/","title":"1 - Introduzione: cosa \u00e8 l'Informatica?","text":"<p>Come per molti degli argomenti cui ci si approccia nel corso della vita, trovare una definizione per il concetto di informatica pu\u00f2 aiutare a comprenderne al meglio la natura.</p> <p>Partiamo quindi da una (breve) analisi etimologica del termine informatica. Questo, infatti, \u00e8 la traduzione italiana del francese informatique, crasi delle parole informa(tion) ed (automa)tique. Intuitivamente, possiamo dedurre che la disciplina tratti quindi di \"informazioni automatiche\" o, per meglio dire, automatizzazione delle informazioni.</p> <p>E, se ci pensiamo, \u00e8 proprio di quello che si occupa l'informatica, ovvero di gestire in maniera automatica una serie pi\u00f9 o meno rilevante di informazioni, correlate ad un qualsiasi aspetto della nostra vita, siano esse le nostre foto su Facebook, il nostro libretto universitario oppure i dati dei nostri conti corrente bancari: tutte queste informazioni vengono elaborate in maniera (pi\u00f9 o meno) automatica.</p> <p>Proviamo ad arricchire questa prima, un po' generica, definizione. Per farlo, sfruttiamo un'altra denominazione straniera, ovvero quella inglese, lingua nella quale l'informatica \u00e8 chiamata computer science. Quello che notiamo di questa definizione \u00e8 il termine science, che ci suggerisce come l'informatica, in realt\u00e0, sia basata su solide fondamenta scientifiche: per capirci, infatti, i \"padri fondatori\" della materia erano prevalentemente dei matematici, uno fra tutti il celebre Alan Turing.</p> <p>L'ultimo fattore da tenere in conto \u00e8 che l'informatica rappresenta uno vero e proprio pilastro della societ\u00e0 moderna. Tutto ci\u00f2 che utilizziamo al giorno d'oggi, dallo smartphone che stiamo usando per leggere questo documento, al computer mediante il quale \u00e8 stato scritto, fino ad arrivare alle nostre auto, o anche ai termostati nelle nostre caldaie, sono basati su tutte le evoluzioni informatiche (ed elettroniche) succedutesi a partire dal Secondo Dopoguerra.</p> <p>Ecco, quindi, che possiamo dare una definizione \"finale\" di informatica, presa direttamente dall'Oxford Languages:</p> <p>L'informatica</p> <p>L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico.</p> <p>Ora, non \u00e8 tanto importante memorizzare questa definizione, quanto piuttosto comprenderne la portata: l'informatica \u00e8 ovunque, e conoscerla ci d\u00e0 l'accesso alle porte di quello che \u00e8 il mondo odierno.</p>"},{"location":"material/01_intro/01_introduction/lecture/#11-approfondiamo-un-po","title":"1.1 - Approfondiamo un po'","text":"<p>Nel precedente paragrafo, abbiamo introdotto alcuni elementi legati alla disciplina dell'informatica. Approfondiamoli brevemente.</p>"},{"location":"material/01_intro/01_introduction/lecture/#111-linformazione","title":"1.1.1 - L'informazione","text":"<p>Pi\u00f9 volte in precedenza abbiamo parlato di \"informazione\". Intuitivamente, ognuno di noi sa cosa questo termine intenda, anche se pu\u00f2 essere un po' difficile spiegarlo. L'informazione \u00e8 comunemente associata ai concetti di conoscenza ed esperienza: la conoscenza di un teorema matematico rappresenta un'informazione su come la teoria analitica dimostri delle ipotesi a partire da delle tesi e dei processi logici; allo stesso modo, l'esperienza che accumuliamo provando a cucinare dei manicaretti rappresenta un'informazione su come mescolare al punto giusto dei cibi per ottenere un risultato.</p> <p>Seppur agli antipodi, i due precedenti esempi mostrano come vi sia una base comune alle diverse informazioni: infatti, queste possono essere comunicate, o trasmesse, ed il concetto formale di informazione, definito dall'omonima teoria elaborata da Claude Shannon, \u00e8 quello alla base del processo comunicativo.</p> <p>Teoria dell'Informazione</p> <p>La teoria dell'informazione, cui abbiamo brevemente accennato in precedenza, non deve essere confusa con l'informatica, di cui \u00e8 soltanto una \"cugina\". Brevemente, infatti, la teoria dell'informazione prova a caratterizzare in modo formale i fenomeni legati alla trasmissione dell'informazione su un canale di comunicazione, andando a ridefinire concetti \"classici\" come quello di entropia, intesa non come \"grado di disordine\" di un sistema fisico, ma come numero di bit necessari a trasmettere un'informazione in maniera chiara ed univoca.</p>"},{"location":"material/01_intro/01_introduction/lecture/#112-i-sistemi-informatici","title":"1.1.2 - I sistemi Informatici","text":"<p>Nell'immaginario comune, il concetto di sistema informatico \u00e8 normalmente associato al personal computer, delegato all'elaborazione e gestione delle nostre informazioni personali.</p> <p>Pensandoci bene, per\u00f2, i sistemi informatici pervadono ormai la nostra esistenza. Lo smartphone mediante cui pubblichiamo il nostro ultimo video \u00e8 un sistema informatico; il nostro smartwatch \u00e8 un sistema informatico; la nostra Smart TV \u00e8 un sistema informatico; la nostra auto \u00e8 un sistema informatico. In generale, e soprattutto con il diffondersi dell'Internet of Things, i sistemi informatici hanno conosciuto una diffusione talmente capillare da divenire ormai parte indispensabile ed integrante della nostra quotidianit\u00e0.</p> <p>Ognuno di questi oggetti \u00e8 composto da due componenti principali: da un lato, abbiamo l'hardware, che rappresenta le componenti elettroniche digitali che permettono all'informazione di fluire sotto forma di flusso di elettroni; dall'altro lato, abbiamo il software, il cui ruolo principale \u00e8 offrire un'interfaccia comprensibile all'utente umano che gli permetta di gestire il flusso di informazioni che scorrono nell'hardware.</p> <p>Adagio comune</p> <p>Un adagio comune nel mondo dell'informatica dice che l'hardware \u00e8 la parte che \u00e8 possibile prendere a calci, mentre il software \u00e8 quella contro cui si pu\u00f2 solo imprecare. Molto spesso, ovviamente, le nostre tribolazioni derivano dall'opera congiunta di entrambe le entit\u00e0.</p>"},{"location":"material/01_intro/02_algorithms/lecture/","title":"2 - Introduzione agli algoritmi","text":""},{"location":"material/01_intro/02_algorithms/lecture/#21-formulare-un-problema","title":"2.1 - Formulare un problema","text":"<p>Per comprendere gli algoritmi, partiamo definendo il concetto di problema.</p> <p>In tal senso, il dizionario De Mauro - Paravia ci viene in aiuto definendolo come:</p> <p>Definizione di problema</p> <p>...quesito da risolvere mediante la determinazione di uno o pi\u00f9 enti, partendo da elementi noti e condizioni fissate in precedenza.</p> <p>Questa definizione ci d\u00e0 gli elementi necessari alla formulazione compiuta di un problema. Analizziamoli pi\u00f9 nel dettaglio.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#211-il-problema-come-compito","title":"2.1.1 - Il problema come compito","text":"<p>Un problema \u00e8 dunque in primis un quesito (o, analogamente, un compito) che necessita di una risoluzione (o svolgimento). Esempi concreti di problema sono:</p> <ul> <li>\"Come montare il mobile che abbiamo appena acquistato dall'IKEA?\"</li> <li>\"Come calcolare l'ipotenusa di un triangolo rettangolo?\"</li> <li>\"Come dimostrare l'ipotesi di Riemann?\"</li> </ul> <p>Possiamo vedere che i problemi possono essere di ogni tipo e difficolt\u00e0; sono tutti accomunati per\u00f2 dal fatto che, qualora siano risolvibili, per farlo \u00e8 necessario adoperare un algoritmo.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#212-lente-risolutore","title":"2.1.2 - L'ente risolutore","text":"<p>La risoluzione del problema \u00e8 delegata ad un o pi\u00f9 enti, propriamente intesi come esecutori di una serie di step necessari a risolvere il problema.</p> <p>Rimanendo agli esempi precedenti, il risolutore del primo problema \u00e8 il montatore del mobile; quello per il secondo \u00e8 lo studente che calcola l'area del triangolo mediante il teorema di Pitagora; nel terzo caso invece abbiamo il matematico teorico, che dimostra (o confuta) l'ipotesi di Riemann.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#213-gli-elementi-noti-e-le-condizioni-fissate","title":"2.1.3 - Gli elementi noti e le condizioni fissate","text":"<p>La risoluzione del problema non pu\u00f2 prescindere dalla conoscenza degli elementi noti e delle condizioni fissate per lo stesso. Intuitivamente, questo significa conoscere lo stato del mondo a partire dal quale dovremo risolvere il problema.</p> <p>Torniamo ai nostri esempi.</p> <p>In primis, per montare il mobile IKEA, avremo bisogno della conoscenza di dettagli quali:</p> <ul> <li>collocazione desiderata del mobile;</li> <li>numero e tipo di pezzi nella confezione del mobile;</li> <li>attrezzi di cui abbiamo bisogno.</li> </ul> <p>Oltre questo, potrebbero esserci alcune condizioni da rispettare, come ad esempio cercare (invano) di montare il mobile prima che tramonti il sole, o il provare a non rompere nulla.</p> <p>Analogamente, per calcolare l'area di un triangolo rettangolo, dovremo conoscerne base ed altezza, e rispettare i vincoli imposti dalla geometria di base.</p> <p>Nota</p> <p>La determinazione degli elementi noti e delle condizioni fissate per la dimostrazione dell'ipotesi di Riemann \u00e8 lasciata come banale esercizio al lettore.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#22-risolvere-un-problema","title":"2.2 - Risolvere un problema","text":"<p>La formulazione di un problema implica quindi la determinazione del cosa (il quesito da risolvere), del chi (l'esecutore materiale della risoluzione) e del da dove (lo stato di partenza e le condizioni fissate). In particolare, diamo a questi ultimi il nome di dati: i dati caratterizzano, anche parzialmente, lo stato iniziale del mondo, e possono essere forniti in un linguaggio naturale che permetta di descrivere delle situazioni, o stati, e le differenze tra di essi.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#221-problemi-e-soluzioni","title":"2.2.1 Problemi e soluzioni","text":"<p>Il lettore pi\u00f9 attento noter\u00e0 che manca ancora un elemento fondamentale, ovvero il come. Questo \u00e8 definito individuando un apposito metodo di risoluzione o, pi\u00f9 semplicemente, una soluzione al problema.</p> <p>Dal punto di vista formale, l'individuazione del metodo di risoluzione pu\u00f2 essere espressa come una relazione univoca che associa ad ogni elemento dello spazio dei problemi (o meglio, delle classi di problemi, come sar\u00e0 pi\u00f9 chiaro in seguito) \\(\\mathbb{P}\\) uno o pi\u00f9 elementi dello spazio delle soluzioni \\(\\mathbb{S}\\).</p> <p>Informalmente, possiamo dire che per ogni problema (se risolvibile) esiste almeno una soluzione.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#222-costruire-la-soluzione","title":"2.2.2 - Costruire la soluzione","text":"<p>Il compito del risolutore \u00e8 quindi quello di \"costruire\", o \"individuare\", la soluzione. La possibilit\u00e0 di farlo \u00e8 legata ad alcune condizioni fondamentali, ovvero:</p> <ul> <li>le operazioni atomiche disponibili;</li> <li>il modo in cui le operazioni di cui sopra possono essere combinate per realizzare operazioni pi\u00f9 complesse.</li> </ul>"},{"location":"material/01_intro/02_algorithms/lecture/#2221-operazioni-atomiche","title":"2.2.2.1 Operazioni atomiche","text":"<p>Per operazione \"atomica\" intendiamo un'operazione che non \u00e8 possibile semplificare (ovvero suddividere) in alcun modo. Esempi di operazione atomica possono essere:</p> <ul> <li>sommare due numeri;</li> <li>fare un passo in avanti;</li> <li>finalizzare una transazione sul proprio conto corrente bancario.</li> </ul> <p>Esempi di operazioni non atomiche sono invece:</p> <ul> <li>risolvere un'equazione di secondo grado;</li> <li>correre per dieci metri;</li> <li>effettuare un versamento ed un prelievo sul proprio conto corrente bancario.</li> </ul> <p>Nota sulla somma</p> <p>Il lettore pi\u00f9 zelante potrebbe pensare che una somma \u00e8 suddivisibile usando l'inverso della propriet\u00e0 associativa. Ci\u00f2 porterebbe per\u00f2 a scomporre una somma in due somme, che potrebbero essere scomposte in tre somme, e via dicendo. Questa operazione risulta essere controproducente, oltre che contraria al senso comune; si invita quindi il lettore zelante ad adeguarsi al senso comune ed evitare una</p> <p>Nota sul conto corrente bancario</p> <p>La singola transazione sul proprio corrente bancario \u00e8 in realt\u00e0 scomponibile, dal punto di vista informatico, in un gran numero di operazioni atomiche: il correntista, infatti, effettua l'autenticazione, completa un form, finalizza la transazione e la esegue. Dato che tutte queste operazioni devono per\u00f2 essere necessariamente completate in un ordine ben definito, i sistemi bancari le vedono come un'unica operazione, che \u00e8 possibile annullare qualora sopravvenga un problema qualsiasi (problemi di autenticazione, rete non disponibile, mancanza di energia elettrica su uno dei sistemi, etc.).</p>"},{"location":"material/01_intro/02_algorithms/lecture/#2222-combinare-operazioni-atomiche","title":"2.2.2.2 Combinare operazioni atomiche","text":"<p>Le operazioni atomiche possono essere combinate in due modi:</p> <ul> <li>effettuandole in sequenza (come nel caso del versamento e del prelievo sul proprio conto corrente bancario);</li> <li>effettuandole in parallelo.</li> </ul> <p>Nel secondo caso, pi\u00f9 operazioni vengono eseguite contemporaneamente. Ci\u00f2 comporta per\u00f2 la necessit\u00e0 di due problemi principali, ovvero:</p> <ul> <li>mantenere indipendenti le singole operazioni;</li> <li>coordinare pi\u00f9 esecutori, o suddividere il tempo di un esecutore in modo che \"simuli\" il parallelismo.</li> </ul> <p>Il primo problema \u00e8 di importanza cruciale. Immaginate di voler montare assieme a vostro cugino due mobili IKEA allo stesso tempo, ma di avere a disposizione un unico cacciavite: cosa succede se usate il cacciavite e questo contestualmente serve al cugino? O, ancora peggio se, avendo a disposizione un cacciavite a punte intercambiabili, ne modificate la punta da stella a brucola senza avvertire il povero cugino?</p> <p>Il secondo \u00e8 meno evidente, ma altrettanto degno di attenzione. Infatti, voi e vostro cugino dovrete necessariamente coordinarvi per non urtarvi, usare gli stessi attrezzi, e via dicendo. L'alternativa sarebbe fare a meno del cugino, e simulare il parallelismo montando i due mobili da voi contemporaneamente; in questo caso, per\u00f2, il tempo che impieghereste \u00e8 sicuramente maggiore, ed avreste la necessit\u00e0 di ottimizzare le operazioni da fare cercando di minimizzare lo sforzo necessario a terminare i lavori.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#2223-determinare-linsieme-di-operatori","title":"2.2.2.3 Determinare l'insieme di operatori","text":"<p>Individuare le operazioni atomiche e trovare dei modi per combinarle permette quindi di definire un insieme di operatori che possono essere applicati ad un problema per modificarne lo stato (idealmente, da \"aperto\" a \"risolto\", considerando eventualmente gli step intermedi). Per essere comprensibili dal risolutore, questi operatori dovranno essere espressi in un linguaggio che faccia riferimento esplicito al contesto del problema.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#2224-da-soluzione-ad-algoritmo","title":"2.2.2.4 Da soluzione ad algoritmo","text":"<p>La soluzione sar\u00e0 quindi definita come un operatore composto nel linguaggio di processo, il cui compito \u00e8 trasformare lo stato iniziale del mondo (ovvero problema aperto) in quello che definisce la situazione desiderata (ovvero problema risolto).</p> <p>L'algoritmo \u00e8 la serie di istruzioni che specifica l'insieme delel azioni che \u00e8 necessario compiere per risolvere il problema.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#23-un-esempio","title":"2.3 - Un esempio","text":"<p>Proviamo a formulare e risolvere un semplice problema matematico, ovvero il calcolo dell'ipotenusa di un triangolo rettangolo.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#231-formulazione-del-problema","title":"2.3.1 - Formulazione del problema","text":"<p>Dati due numeri interi \\(c_1\\) e \\(c_2\\), rappresentanti le lunghezze dei due cateti di un triangolo rettangolo \\(T\\), calcolarne l'ipotenusa \\(i\\).</p>"},{"location":"material/01_intro/02_algorithms/lecture/#232-dati","title":"2.3.2 - Dati","text":"<p>Sia \\(c_1\\) la lunghezza del primo cateto, e \\(c_2\\) quella del secondo.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#233-algoritmo-risolutivo-in-operazioni-atomiche-o-quasi","title":"2.3.3 - Algoritmo risolutivo (in operazioni atomiche, o quasi)","text":"<ol> <li>Calcolare il quadrato di \\(c_1\\).</li> <li>Calcolare il quadrato di \\(c_2\\).</li> <li>Sommare i quadrati calcolati ai punti 1 e 2.</li> <li>Calcolare la radice quadrata della somma ottenuta al punto 3.</li> </ol>"},{"location":"material/01_intro/02_algorithms/lecture/#234-svolgimento-numerico","title":"2.3.4 Svolgimento numerico","text":""},{"location":"material/01_intro/02_algorithms/lecture/#dati","title":"Dati","text":"\\[ \\begin{eqnarray} c_1 &amp;= 3 \\\\ c_2 &amp;= 4 \\\\ \\end{eqnarray} \\]"},{"location":"material/01_intro/02_algorithms/lecture/#passi-dellalgoritmo","title":"Passi dell'algoritmo","text":"\\[ \\begin{eqnarray} \\text{Step 1} &amp; \\rightarrow &amp; {c_1}^2 = 9 = v_1 \\\\ \\text{Step 2} &amp; \\rightarrow &amp; {c_2}^2 = 16 = v_2 \\\\ \\text{Step 3} &amp; \\rightarrow &amp; v_1 + v_2 = 25 = v_3 \\\\ \\text{Step 4} &amp; \\rightarrow &amp; \\sqrt{v_3} = 5 = v_4 \\end{eqnarray} \\] <p>Il risultato \u00e8 \\(v_4 = 5\\).</p>"},{"location":"material/01_intro/02_algorithms/lecture/#24-caratteristiche-degli-algoritmi-risolutivi","title":"2.4 - Caratteristiche degli algoritmi risolutivi","text":"<p>Un algoritmo \u00e8 contraddistinto da cinque caratteristiche principali.</p> <ol> <li>finitezza: gli algoritmi sono finiti, sia dal punto di vista spaziale, sia da quello temporale;</li> <li>generalit\u00e0: gli algoritmi sono generici, ovvero rappresentano una soluzione ad un'intera classe di problemi;</li> <li>completezza: gli algoritmi sono completi, e quindi possono risolvere tutte le istanze del problema;</li> <li>non ambiguit\u00e0: gli algoritmi non sono ambigui, e ci\u00f2 comporta che tutte le istruzioni sono univoche e ben interpretabili;</li> <li>eseguibilit\u00e0: gli algoritmi sono eseguibili, nel senso che l'esecutore deve (potenzialmente) essere in grado di eseguire ogni singolo passo dell'algoritmo.</li> </ol> <p>Tornando al nostro esempio, il metodo di individuazione dell'ipotenusa rispetta le condizioni perch\u00e8:</p> <ol> <li>pu\u00f2 essere risolto in un numero di passi finito, che non occupa uno spazio (ad esempio su carta o nella memoria di un computer) infinito;</li> <li>pu\u00f2 risolvere ogni problema di determinazione dell'ipotenusa, anche cambiando i valori dei cateti (a patto ovviamente che si tratti sempre di un triangolo rettangolo, e che quindi si sia nell'ambito della stessa classe dei problemi);</li> <li>le istruzioni sono chiare e non equivocabili;</li> <li>le istruzioni possono essere eseguite da chiunque sia in grado di calcolare un quadrato ed una radice quadrata.</li> </ol>"},{"location":"material/01_intro/02_algorithms/lecture/#241-determinismo","title":"2.4.1 Determinismo","text":"<p>Un algoritmo si dice deterministico quando al momento dell'esecuzione di ogni istruzione \u00e8 nota l'istruzione successiva. Ci\u00f2 comporta che eseguire due volte un algoritmo deterministico sugli stessi dati produce gli stessi effetti. L'algoritmo di esempio \u00e8 a tutti gli effetti un algoritmo deterministico.</p> <p>Gli algoritmi non deterministici sono invece affetti da fenomeni di tipo casuale, o stocastico; sono in genere algoritmi avanzati, usati perlopi\u00f9 in applicazioni di statistica e machine learning, che non tratteremo durante questo corso.</p>"},{"location":"material/01_intro/02_algorithms/lecture/#242-input-output-e-variabili","title":"2.4.2 Input, Output e Variabili","text":"<p>Generalmente, i dati in ingresso ad un algoritmo sono anche chiamati input dell'algoritmo, mentre la \"risposta\" che restituisce l'algoritmo stesso \u00e8 chiamata output.</p> <p>E' importante sottolineare come gli algoritmi possano accettare sia input sia output anche non numerici.</p> <p>Un esempio \u00e8 dato dall'algoritmo per determinare se una stringa \u00e8 palindroma: questo accetta come dati una serie di caratteri, e d\u00e0 una risposta di tipo binario (VERO o FALSO).</p> <p>Oltre ad input ed output, gli algoritmi spesso utilizzano dei dati di supporto, chiamati variabili. Ne tratteremo molto pi\u00f9 estesamente durante il prosieguo del corso.</p>"},{"location":"material/01_intro/03_dec_bin/lecture/","title":"3 - Il mondo in forma binaria","text":""},{"location":"material/01_intro/03_dec_bin/lecture/#31-le-informazioni-nel-mondo-reale","title":"3.1 - Le informazioni nel mondo reale","text":"<p>Nel mondo reale, le informazioni fluiscono dalla sorgente al destinatario sotto forma di onde analogiche. Per capirci, pensiamo ad una conversazione tra due persone: entrambe produrranno, mediante il loro apparato fonatorio, delle onde sonore, continue sia nel tempo che nelle ampiezze, che arriveranno all'orecchio dell'altro interlocutore, il quale le passer\u00e0 al cervello che, a sua volta, le interpreter\u00e0.</p> <p>Di particolare importanza \u00e8 il concetto di continuit\u00e0 della forma d'onda utilizzata. Partiamo dall'analisi matematica: sappiamo che le funzioni continue sono definite nel dominio \\(\\mathbb{R}\\) dei numeri reali, per cui assumono, a meno dei punti di discontinuit\u00e0, un numero infinito di valori. Questo vale anche per le forme d'onda analogiche, che abbiamo detto essere continue: ogni onda sonora emessa nella conversazione di cui sopra potr\u00e0 assumere un numero \"infinito\" di valori all'interno degli intervalli temporali e di ampiezza nei quali \u00e8 emessa.</p> <p>Nota</p> <p>Ovviamente, non teniamo conto di effetti quantistici: stiamo parlando di fenomeni macroscopici.</p>"},{"location":"material/01_intro/03_dec_bin/lecture/#32-la-gestione-dellinformazione","title":"3.2 - La gestione dell'informazione","text":"<p>Chiarito il concetto di grandezza \"analogica\", pensiamo adesso a come uno strumento potrebbe in qualche modo caratterizzarla. In particolare, ragioniamo in termini di capacit\u00e0 dello strumento, ovvero:</p> <p>Quanti stati deve essere in grado di rappresentare contemporaneamente un sistema per caratterizzare completamente una forma d'onda analogica?</p> <p>Beh, la risposta a questa domanda \u00e8 semplice: infiniti. Ovviamente, una realizzazione pratica di questa macchina non esiste, n\u00e9 pu\u00f2 essere realizzata con le tecnologie attuali.</p> <p>Occorre quindi ridurre il numero di stati che devono essere rappresentati contemporaneamente. Per farlo, dobbiamo passare dal dominio analogico a quello digitale.</p>"},{"location":"material/01_intro/03_dec_bin/lecture/#33-la-rappresentazione-digitale-dellinformazione","title":"3.3 - La rappresentazione digitale dell'informazione","text":"<p>Il dominio digitale \u00e8 semplice da caratterizzare: infatti, l'informazione pu\u00f2 assumere soltanto due possibili valori, ovvero \\(0\\) ed \\(1\\) (chiamati alle volte anche basso ed alto, o anche spento ed acceso).</p>"},{"location":"material/01_intro/03_dec_bin/lecture/#331-il-bit","title":"3.3.1 - Il bit","text":"<p>Appare chiaro come una rappresentazione digitale, detta anche binaria, sia molto pi\u00f9 facile da gestire per un calcolatore rispetto ad una rappresentazione analogica. Ed \u00e8 per questo che \u00e8 importante definire la nozione fondamentale su cui \u00e8 basata l'intera informatica, ovvero bit, crasi di binary digit (traducibile dall'inglese come cifra binaria):</p> <p>Bit</p> <p>Il bit \u00e8 l'unit\u00e0 di informazione fondamentale interpretabile da un calcolatore, e pu\u00f2 assumere valori <code>0</code> (falso) o <code>1</code> (vero).</p>"},{"location":"material/01_intro/03_dec_bin/lecture/#332-il-byte","title":"3.3.2 - Il byte","text":"<p>Dalla definizione di bit segue quella, altrettanto importante, di byte, associata ad una sequenza arbitraria di otto bit.</p> <p>Quanti sono i possibili valori di un byte?</p> <p>Per rispondere a questa domanda, ricordiamoci che ogni bit pu\u00f2 assumere soltanto due valori; di conseguenza, due bit potranno assumere al massimo \\(2 \\times 2\\) valori, ovvero quattro, tre bit \\(2 \\times 2 \\times 2\\) valori, ovvero otto, e cos\u00ec via.</p> <p>E' semplice quindi constatare che una sequenza di \\(n\\) bit assume al pi\u00f9 \\(2^n\\) valori, per cui otto bit potranno assumere al massimo \\(2^8\\) valori. Ne consegue che, riportando il tutto in decimale, un byte potr\u00e0 assumere al massimo 256 valori.</p>"},{"location":"material/01_intro/03_dec_bin/lecture/#333-la-parola","title":"3.3.3 - La parola","text":"<p>Definiamo infine una parola, o word, una sequenza di \\(N\\) byte, con \\(N\\) dipendente dal contesto specifico (ad esempio, il tipo di processore in uso). Ad esempio, la maggior parte dei processori consumer odierni utilizza parole da otto byte, ovvero 64 bit, capaci quindi di rappresentare fino a \\(2^{64}\\) valori.</p>"},{"location":"material/01_intro/03_dec_bin/lecture/#34-da-decimale-a-binario","title":"3.4 - Da decimale a binario","text":"<p>Nel mondo reale, siamo abituati ad utilizzare i numeri seguendo una notazione di tipo decimale e posizionale. Detto in altri termini:</p> <ul> <li>utilizziamo i simboli compresi tra \\(0\\) e \\(9\\) per rappresentare ogni numero intero;</li> <li>sfruttiamo la posizione in cui compare ciascun simbolo per interpretare il valore finale del numero.</li> </ul> <p>Per fare un esempio, i numeri \\(12\\) e \\(21\\) sono rappresentati usando gli stessi simboli decimali, ovvero \\(1\\) e \\(2\\); tuttavia, la loro disposizione \u00e8 differente, per cui non hanno lo stesso significato.</p>"},{"location":"material/01_intro/03_dec_bin/lecture/#341-espressione-formale-di-un-numero-in-base-decimale","title":"3.4.1 - Espressione formale di un numero in base decimale","text":"<p>Formalmente, se \\(N \\in \\mathbb{i}\\) \u00e8 un numero intero composto da \\(k\\) simboli, \u00e8 possibile esprimerlo come:</p> \\[ N = a_k a_{k-1} a_{k-2} \\ldots a_2 a_1 a_0 \\] <p>dove \\(a_i\\) \u00e8 l'\\(i\\)-mo simbolo, con \\(i \\in [1, \\ldots, k]\\).</p> <p>Possiamo esprimere \\(N\\) anche in base \\(10\\):</p> \\[ N = a_k * 10^k + a_{k-1} * 10^{k-1} + \\ldots + a_1 * 10^1 + a_0 * 10^0 \\] <p>Per fare un semplice esempio:</p> \\[ N = 485 = 4 * 10^2 + 8 * 10 + 5 \\]"},{"location":"material/01_intro/03_dec_bin/lecture/#342-da-base-decimale-a-base-binaria","title":"3.4.2 - Da base decimale a base binaria","text":"<p>Ovviamente, l'espressione formale di un numero in base decimale \u00e8 facilmente adattabile ad altre basi, per cui, in generale, vale che un numero \\(B\\) a \\(l\\) simboli \u00e8 esprimibile in base \\(b\\) mediante un'espressione del tipo:</p> \\[ B_{b} = a_l * b^l + a_{l-1} * b^{l-1} + \\ldots + a_1 * b^1 + a_0 * b^0 \\] <p>Supponiamo adesso di voler convertire un numero \\(N\\) dalla forma decimale a quella binaria. Per farlo, dovremo procedere dividendo \\(N\\) per la base \\(2\\), valutando il resto \\(r\\), e reiterare l'operazione usando il quoziente \\(q\\).</p> <p>Facciamo un esempio usando \\(N = 485\\).</p> \\[ \\begin{eqnarray} \\frac{485}{2} &amp;\\Rightarrow q = 242 &amp; r = 1 &amp; \\Rightarrow LSB\\\\ \\frac{242}{2} &amp;\\Rightarrow q = 121 &amp; r = 0 \\\\ \\frac{121}{2} &amp;\\Rightarrow q = 60 &amp; r = 1 \\\\ \\frac{60}{2} &amp;\\Rightarrow q = 30 &amp; r = 0 \\\\ \\frac{30}{2} &amp;\\Rightarrow q = 15 &amp; r = 0 \\\\ \\frac{15}{2} &amp;\\Rightarrow q = 7 &amp; r = 1 \\\\ \\frac{7}{2} &amp;\\Rightarrow q = 3 &amp; r = 1 \\\\ \\frac{3}{2} &amp;\\Rightarrow q = 1 &amp; r = 1 \\\\ \\frac{1}{2} &amp;\\Rightarrow q = 0 &amp; r = 1 &amp; \\Rightarrow MSB \\end{eqnarray} \\] <p>Il valore di \\(N\\) in forma binaria \u00e8 quindi dato da:</p> \\[ N_{2} = (111100101)_2 \\] <p>Notiamo che la prima cifra che otteniamo \u00e8 indicata con il termine LSB, acronimo che sta per Least Significant Bit; questo \u00e8 il bit meno significativo, ovvero quello \"meno rilevante\" rispetto al valore finale, ed \u00e8 posizionato pi\u00f9 a destra nella rappresentazione. Di converso, il primo valore \u00e8 chiamato MSB, acronimo che sta per Most Significant Bit (e che \u00e8 ovviamente il bit pi\u00f9 significativo).</p>"},{"location":"material/01_intro/04_data_type/lecture/","title":"4 - I tipi di dato","text":"<p>Nel capitolo precedente abbiamo accennato al fatto che i calcolatori hanno a disposizione una determinata parola, la cui dimensione dipende dall'architettura, che determina il numero massimo di bit che possono essere rappresentati nei dati gestiti in fase di elaborazione. Questo, ovviamente, comporta un limite: vediamone in breve le implicazioni, approfittando per introdurre i diversi tipi di dato.</p>"},{"location":"material/01_intro/04_data_type/lecture/#41-dati-numerici","title":"4.1 - Dati numerici","text":"<p>Il primo tipo di dati che vediamo \u00e8 quello numerico, che comprende, in linea generale, i numeri interi e reali.</p> <p>I numeri complessi</p> <p>I pi\u00f9 attenti potrebbero chiedersi perch\u00e9 i numeri complessi non sono stati menzionati in precedenza. Infatti, i numeri complessi non sono contemplati come dati primitivi in numerosi linguaggi di programmazione, anche se, come vedremo, Python prevede un'apposita struttura dedicata allo scopo.</p>"},{"location":"material/01_intro/04_data_type/lecture/#411-numeri-interi","title":"4.1.1 - Numeri interi","text":"<p>Il limite imposto alla lunghezza della parola comporta che il valore numerico massimo trattabile da un calcolatore sia finito: ad esempio, nel caso di un'architettura con parola a 64 bit (come la maggior parte dei processori odierni), sar\u00e0 possibile rappresentare \"soltanto\" \\(2^{64}\\) possibili valori.</p> <p>Nota</p> <p>Ricordiamo che \\(2^{64} = 18.446.743.073.709.551.616\\). Il limite appare quindi abbastanza permissivo.</p> <p>Cosa accade, quindi, se dovessimo raggiungere \\(2^{64}\\)? Molto semplice: il conteggio ricomincia da zero (o il programma va in errore).</p> <p>Altrettanto importante \u00e8 il notare come i numeri possano essere dotati di segno. Questo, ovviamente, va ad influenzare gli estremi dell'intervallo dei valori rappresentabili, ma non la cardinalit\u00e0 dello stesso. Infatti, se si considera il segno anteposto al numero, potremo trattare valori che vanno nell'intervallo da \\(-2^{63}\\) a \\(2^{63}\\).</p> <p>Facciamo un breve esempio pratico, con una lunghezza della parola di otto bit. In questo caso:</p> <ul> <li>considerando solo lo zero ed i valori strettamente positivi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(0\\) e \\(255 = 2^{8-1}\\);</li> <li>considerando anche i valori negativi, sar\u00e0 possibile rappresentare tutti i numeri interi compresi tra \\(-128 = -2^{8-1}\\) e \\(127 = -2^{8-1}-1\\).</li> </ul> <p>Nella seguente tabella, sono riassunti alcuni tra i tipi di valore intero pi\u00f9 comune, differenziati a seconda della loro lunghezza.</p> Tipo di dato Lunghezza Valore minimo assumibile Valore massimo assumibile <code>bit</code> 1 bit 0 1 <code>ubyte</code> 8 bit 0 255 <code>byte</code> 8 bit -128 127 <code>ushort</code> 16 bit 0 \\(2^{16} - 1\\) = 65535 <code>short</code> 16 bit -32768 32767 <code>uint</code> 32 bit 0 \\(2^{32} - 1\\) = 4294967295 <code>int</code> 32 bit \\(-2^{31}\\) = 2147483648 \\(2^{31} - 1\\) = 2147483647 <code>ulong</code> 64 bit 0 \\(2^{64} - 1\\) <code>long</code> 64 bit \\(-2^{63}\\) \\(2^{63} - 1\\) <p>Il <code>bit</code></p> <p>Il bit \u00e8 il tipo di dato numerico pi\u00f9 \"limitato\" rappresentabile, e viene spesso utilizzato come valore booleano.</p> <p>Il simbolo <code>u</code></p> <p>I pi\u00f9 attenti avranno notato la presenza del simbolo <code>u</code> nelle notazioni che includono solo i valori positivi. Intuitivamente, la <code>u</code> sta per unsigned, ovvero \"senza segno\".</p> <p>Tipi e lunghezza</p> <p>I tipi riportati nella tabella precedente, assieme alla loro lunghezza, sono quelli \"standard\", cui aderiscono la maggior parte dei linguaggi di programmazione (ma non tutti).</p>"},{"location":"material/01_intro/04_data_type/lecture/#412-rappresentazione-di-numeri-reali","title":"4.1.2 Rappresentazione di numeri reali","text":"<p>Cos\u00ec come per l'insieme dei numeri naturali, anche quello dei numeri reali \\(\\mathbb{R}\\) deve essere rappresentato mediante un'approssimazione finita. Ricordiamo che ogni numero reale \u00e8 composto da una parte intera ed una razionale; di conseguenza, considerato che il numero di bit per la rappresentazione \u00e8 sempre lo stesso, occorre trovare un modo per conciliare la presenza di queste due parti.</p> <p>In tal senso, esistono due possibili rappresentazioni che \u00e8 possibile utilizzare.</p> <p>Nella rappresentazione a virgola fissa, o fixed point, si usa un numero fisso di bit per la parte intera del numero da rappresentare, con i rimanenti usati per la parte decimale. Pi\u00f9 interessante \u00e8 invece la rappresentazione a virgola mobile, o floating point, basata sui concetti di mantissa (ovvero, parte decimale) ed esponente.</p> <p>Formalmente, definiamo la mantissa di un numero reale \\(n\\) \u00e8 pari al valore del numero diminuito della sua parte intera \\(n_{int}\\):</p> \\[ M = n - n_{int} \\] <p>E' facile verificare che la mantissa \\(M\\) \u00e8 sempre compresa tra \\(-1\\) ed \\(1\\).</p> <p>La rappresentazione in virgola mobile di \\(n\\) \u00e8 definita quindi come:</p> \\[ n = M * b^e \\] <p>con \\(b\\) base scelta, ed \\(e\\) esponente.</p> <p>Ad esempio, per rappresentare il numero \\(5.2\\) in virgola mobile, potremo scrivere:</p> \\[ n = 0.52 * 10^1 \\] <p>da cui \\(M = 0.52\\) ed \\(e = 1\\). Questa notazione, detta normalizzata, prevede che la parte razionale sia sempre minore di uno, mentre quella intera sia pari a zero. Equivalentemente, potremmo scrivere:</p> \\[ n = 0.052 * 10^2 \\] <p>cos\u00ec come:</p> \\[ n = 52 * 10^{-1} \\] <p>Tuttavia, \u00e8 la notazione normalizzata ad essere usata per convenzione.</p> <p>Il vantaggio legato all'utilizzo della rappresentazione in virgola mobile sta nel fatto che \u00e8 possibile rappresentare un range di numeri molto pi\u00f9 ampio rispetto a quello a virgola fissa. Ad esempio, immaginiamo di voler utilizzare quattro simboli (notate che non stiamo utilizzando la rappresentazione binaria, quindi non parliamo di bit) per rappresentare il numero \\(63500\\). Se usassimo una rappresentazione a virgola fissa, cos\u00ec come una intera, non potremmo in alcun modo rappresentarlo; invece, con la rappresentazione a virgola mobile, avremmo:</p> \\[ M = 635 \\\\ e = 5 \\\\ n = 0.635 * 10^5 \\] <p>e, dovendo memorizzare esclusivamente la mantissa (che richiede tre simboli) e l'esponente (che ne richiede uno), riusciremmo nel nostro intento.</p>"},{"location":"material/01_intro/04_data_type/lecture/#42-caratteri","title":"4.2 - Caratteri","text":"<p>Anche i caratteri che troviamo normalmente sulle nostre tastiere devono essere rappresentati in binario. In generale, il concetto di carattere deve essere assimilato a quello di simbolo, in quanto i calcolatori devono poter rappresentare simboli \"speciali\" (ad esempio, la chiocciola @ o l'underscore _), cos\u00ec come caratteri in altri tipi di alfabeti (ad esempio, il cirillico o il mandarino).</p> <p>L'enorme variet\u00e0 di caratteri ha portato alla necessit\u00e0 di uniformarne la rappresentazione, creando una corrispondenza biunivoca tra simboli e numeri interi. Questa corrispondenza \u00e8 stata codificata in standard ben precisi, tra i quali vale la pena citare l'ASCII e l'UNICODE. Quello che per\u00f2 questo comporta dal punto di vista pratico \u00e8 che, cos\u00ec come i dati di tipo numerico, anche il numero totale di caratteri rappresentabili sar\u00e0 limitato dalla lunghezza della parola utilizzata dall'architettura del calcolatore.</p> <p>Curiosit\u00e0</p> <p>Complessivamente, lo standard UNICODE \u00e8 in grado di rappresentare pi\u00f9 di diecimila caratteri; essendo per\u00f2 codificato a sedici bit, vi \u00e8 spazio ancora per un bel po' di lingue morte.</p>"},{"location":"material/01_intro/05_flow_chart/lecture/","title":"5 - I diagrammi di flusso","text":"<p>In una delle lezioni precedenti, abbiamo visto come un algoritmo pu\u00f2 essere espresso come una sequenza arbitrariamente complessa di operazioni atomiche.</p> <p>Detta sequenza, ovviamente, deve essere in qualche modo \"fissata\", di modo da indirizzare il funzionamento dell'algoritmo secondo le modalit\u00e0 desiderate. In tal senso, la tentazione potrebbe essere quella di limitarsi a tenere a mente i passi della sequenza di istruzioni, ed implementarle di getto. Tuttavia, questo non \u00e8 il modo migliore per farlo, in quanto risulta essere abbastanza complesso gestire tali informazioni all'aumentare della complessit\u00e0 dell'algoritmo.</p> <p>Un'altra soluzione potrebbe essere quella di scrivere le istruzioni su un qualche tipo di supporto o documento; tuttavia, la soluzione migliore \u00e8 quella di affidarsi a degli strumenti appositamente predisposti in tal senso, ovvero i diagrammi di flusso.</p>"},{"location":"material/01_intro/05_flow_chart/lecture/#51-cosa-sono-i-diagrammi-di-flusso","title":"5.1 - Cosa sono i diagrammi di flusso?","text":"<p>I diagrammi di flusso (in inglese flow charts) sono uno strumento utile a gestire il flusso delle istruzioni.</p> <p>Un flow chart \u00e8 uno strumento prettamente visivo, atto a schematizzare il flusso delle singole istruzioni di un algoritmo. In tal modo, diventa estremamente pi\u00f9 semplice scrivere l'algoritmo, e valutare come i dati cambiano all'interno dello stesso.</p>"},{"location":"material/01_intro/05_flow_chart/lecture/#52-quali-sono-le-componenti-fondamentali","title":"5.2 - Quali sono le componenti fondamentali?","text":"<p>Un diagramma di flusso pu\u00f2 avere al suo interno diverse componenti, le pi\u00f9 importanti delle quali sono visualizzate nella tabella successiva.</p> <p></p> <p>In particolare:</p> <ul> <li>una ellisse indica l'inizio o la fine dell'algoritmo, ed andrebbe sempre apposta;</li> <li>un rettangolo indica una singola istruzione (o anche un gruppo di istruzioni) da eseguire nel programma;</li> <li>un parallelogramma indica un input o un output;</li> <li>un rombo indica una ramificazione nel percorso dell'algoritmo, legata prevalentemente alla verifica di una condizione;</li> <li>infine, le frecce sono usate per collegare tra loro diverse parti dello stesso algoritmo.</li> </ul>"},{"location":"material/01_intro/05_flow_chart/lecture/#53-un-esempio","title":"5.3 - Un esempio","text":"<p>Nella seguente figura mostriamo un esempio di diagramma di flusso.</p> <p></p> <p>Vediamo come il diagramma inizi con un'ellisse, che sar\u00e0 contrassegnata dalla scritta START (inserita arbitrariamente). Immediatamente dopo, vi sar\u00e0 la lettura di due variabili, ovvero \\(c_1\\) e \\(c_2\\); a quel punto, vi sar\u00e0 l'assegnazione di altre tre variabili, con infine la variabile \\(v_3\\) scritta su un dispositivo di output, seguita dal simbolo di fine algoritmo.</p> <p>E' estremamente importante notare come l'assegnazione e la lettura siano, in realt\u00e0, quasi \"ambigue\" dal punto di vista della notazione: occorre quindi in tal senso fare attenzione al fatto che si stia usando un parallelogramma o un rettangolo, seguendo le regole descritte nel paragrafo 5.2.</p>"},{"location":"material/01_intro/06_structured/lecture/","title":"6 - La Programmazione Strutturata","text":"<p>Ai pi\u00f9 \"esperti\" tra i lettori sar\u00e0 capitato di leggere del codice prodotto negli anni '70 ed '80, in linguaggi come il BASIC, simile a qualcosa di questo tipo:</p> <pre><code>10 dim i\n20 i = 0\n30 i = i + 1\n40 if i &lt;= 10 then goto 70\n50 print \"Programma terminato.\"\n60 end\n70 print i &amp; \" al quadrato = \" &amp; i * i\n80 goto 30\n</code></pre> <p>Un codice in questa forma (per la cronaca: il codice \u00e8 tratto direttamente da Wikipedia) \"intreccia\" le istruzioni tra loro: ad esempio, alla riga <code>80</code> notiamo come la presenza della (famigerata) istruzione <code>goto</code> imponga di tornare alla riga <code>30</code>, con la <code>70</code> richiamata dalla <code>40</code> qualora si verifichi una determinata condizione.</p> <p>Il codice appare quindi simile ad un \"piatto di spaghetti\", i quali si intrecciano ed ingarbugliano tra loro, confondendosi alla vista; ed \u00e8 proprio per questo che scrivere un codice com il precedente \u00e8 associato alla pratica, divenuta con tempo un antipattern (ovvero, una pratica da sconsigliare), dello spaghetti coding.</p> <p>Lo spaghetti coding rende il nostro programma difficile da interpretare, non solo da parte di altri, ma anche da noi stessi quando lo andiamo a riaprire dopo un po' di tempo. Per questo motivo, nel tempo, sono andati sempre pi\u00f9 diffondendosi nuovi e pi\u00f9 efficaci paradigmi di programmazione, come quella imperativa, orientata agli oggetti e, pi\u00f9 recentemente, funzionale. Tutti, per\u00f2, partivano da un presupposto: dare una struttura al codice. E, in tal senso, l'assunto da cui si parte \u00e8 sempre e solo uno, ovvero il teorema di Bohm e Jacopini.</p>"},{"location":"material/01_intro/06_structured/lecture/#62-il-teorema-di-bohm-jacopini","title":"6.2 - Il teorema di Bohm-Jacopini","text":"<p>Il teorema di Bohm - Jacopini venne enunciato nel 1966, ed afferma che qualsiasi algoritmo pu\u00f2 essere implementato (sia sotto forma di codice, sia sotto forma di flow chart) utilizzando esclusivamente le cosiddette tre strutture di controllo, ovvero sequenza, selezione e ciclo. Le implicazioni sono ovviamente importantissime, e ci permettono di semplificare enormemente il nostro lavoro.</p> <p>In tal senso, per\u00f2, \u00e8 necessario conoscere in maniera appropriata le diverse strutture di controllo, che saranno quindi illustrate di seguito.</p>"},{"location":"material/01_intro/06_structured/lecture/#631-sequenza","title":"6.3.1 - Sequenza","text":"<p>La sequenza prevede che una serie di istruzioni siano realizzate sequenzialmente, ovvero l'una in cascata all'altra. Immaginiamo ad esempio di dover calcolare la distanza euclidea tra due punti, ovvero <code>a</code> e <code>b</code>, di cui conosciamo le coordinate \\((x_a, y_a)\\) ed \\((x_b, y_b)\\). In pseudo-codice (ovvero, in un linguaggio simbolico usato per esprimere l'algoritmo senza per questo richiamare necessariamente un linguaggio di programmazione esistente) potremmo esprimere la sequenza come:</p> <pre><code>distanza_x = (x_a - x_b)^2;\ndistanza_y = (y_a - y_b)^2;\ndistanza = (distanza_x + distanza_y)^(1/2);\n</code></pre> <p>La sequenza di operazioni sar\u00e0 quella mostrata nella seguente figura:</p> <p></p> <p>Come si pu\u00f2 notare, il flusso delle istruzioni \u00e8 unico, e queste sono eseguite l'una di seguito all'altra, ovverosia in maniera sequenziale.</p>"},{"location":"material/01_intro/06_structured/lecture/#632-selezione","title":"6.3.2 - Selezione","text":"<p>La selezione prevede invece che il flusso delle istruzioni possa diramarsi tra due diversi rami, mutualmente esclusivi, al verificarsi o meno di una condizione.</p> <p>In particolare, la selezione \u00e8 rappresentata mediante il costrutto IF - THEN - ELSE, il cui funzionamento pu\u00f2 essere riassunto in linguaggio naturale come segue:</p> <p>L'IF - THEN - ELSE in linguaggio naturale</p> <p>IF (se) la condizione \u00e8 verificata, THEN (allora) esegui le istruzioni su di un ramo, ELSE (altrimenti) esegui le istruzioni sull'altro ramo.</p> <p>Per comprendere meglio il funzionamento della selezione, immaginiamo di voler comparare due numeri \\(a\\) e \\(b\\). Di nuovo, esprimiamo la selezione in pseudo-codice:</p> <pre><code>a = 1;\nb = 2;\nif (a &gt; b):\n    then scrivi \"a \u00e8 maggiore di b\"\nelse:\n    scrivi \"b \u00e8 maggiore di a\"\n</code></pre> <p>I due rami del programma sono quindi rappresentati dal THEN e dall'ELSE, mentre la condizione dall'IF. Graficamente:</p> <p></p>"},{"location":"material/01_intro/06_structured/lecture/#6321-i-costrutti-else-if-e-switch","title":"6.3.2.1 - I costrutti ELSE IF e SWITCH","text":"<p>Il costrutto IF - THEN - ELSE limita i rami in cui un programma pu\u00f2 derivare a due. Tuttavia, nella realt\u00e0, potrebbe essere necessario avere pi\u00f9 rami; in questi casi, ci viene in aiuto il costrutto ELSE IF, che permette di specificare ulteriori divergenze del programma. Ad esempio:</p> <pre><code>a = 1;\nb = 2;\nif (a &gt; b):\n    then scrivi \"a \u00e8 maggiore di b\"\nelse if (a uguale b):\n    then scrivi \"a \u00e8 uguale a b\"\nelse:\n    scrivi \"b \u00e8 maggiore di a\"\n</code></pre> <p>Vediamo subito come il costrutto ci permetta di ovviare ad una \"mancanza\" del programma precedente, gestendo anche il caso in cui \\(a\\) sia uguale a \\(b\\). Dal punto di vista del diagramma di flusso, l'ELSE IF \u00e8 rappresentabile mediante una \"cascata\" di selezioni:</p> <p></p> <p>Il costrutto SWITCH \u00e8 usato per verificare che una certa variabile assuma un dato valore, chiamato <code>case</code> (da cui il nome SWITCH-CASE con cui il costrutto \u00e8 anche conosciuto), normalmente non relativo ad un intervallo, quanto piuttosto ben specifico. Qualora la variabile di controllo rispetti il valore definito da un case, le istruzioni ivi contenute saranno eseguite fino all'uscita dal costrutto.</p> <p>Lo SWITCH ha inoltre un case di default, indicato con la parola chiave omonima, che sar\u00e0 eseguito qualora la variabile da verificare non rispetti alcuno dei case precedenti. Ad esempio:</p> <pre><code>a = 1;\nswitch (a)\n    case 1:\n        scrivi \"Uguale ad uno!\";\n    case 2:\n        scrivi \"Uguale a due!\"\n    case 3:\n        scrivi \"Uguale a tre!\";\n    default:\n        scrivi \"Non saprei!\";\n</code></pre>"},{"location":"material/01_intro/06_structured/lecture/#633-iterazione","title":"6.3.3 - Iterazione","text":"<p>L'ultimo tipo di struttura di controllo \u00e8 l'iterazione, chiamata anche ciclo; in questo caso, un'istruzione verr\u00e0 reiterata fino a che una certa condizione \u00e8 verificata.</p> <p>Nota</p> <p>In un certo senso, l'iterazione \u00e8 una \"summa\" di struttura e selezione.</p> <p>Per comprendere il funzionamento dell'iterazione, proviamo ad utilizzarla, sempre in pseudocodice, per scrivere i numeri che vanno da uno a dieci:</p> <pre><code>i = 1;\nfor (i che va da 1 a 10):\n    scrivi 'i';\nendfor\nscrivi 'fine';\n</code></pre> <p>Schematizziamo il funzionamento dell'iterazione nella figura successiva:</p> <p></p> <p>Risulta particolarmente interessante notare come l'iterazione (espressa in questo caso da un'istruzione FOR) non faccia altro che verificare una condizione su una variabile contatore (ovvero che i sia minore od uguale a 10), modificando la stessa ad ogni iterazione. Una volta che la condizione sul contatore non sar\u00e0 pi\u00f9 verificata, il programma continuer\u00e0 la sua esecuzione.</p> <p>Nota</p> <p>Modificare la variabile contatore ad ogni iterazione \u00e8 estremamente importante. Se il contatore non fosse mai modificato, infatti, il programma non potrebbe mai uscire dal ciclo.</p>"},{"location":"material/01_intro/06_structured/lecture/#6331-costrutti-for-e-while-do","title":"6.3.3.1 Costrutti FOR e WHILE-DO","text":"<p>Tradizionalmente, sono usati due costrutti per implementare una struttura iterativa, ovvero il costrutto FOR (che abbiamo visto in precedenza) ed il costrutto WHILE-DO.</p> <p>La differenza principale tra i due costrutti sta nel fatto che il FOR viene normalmente usato quando il numero di iterazioni \u00e8 conosciuto a priori, mentre il WHILE-DO quando non si conosce il numero di iterazioni, e si vuole semplicemente verificare una condizione. Ad esempio:</p> <pre><code>condizione = vero;\nwhile (condizione diverso da falso):\n    do [...] // istruzioni\n    aggiorna condizione;\nendwhile\n</code></pre> <p>In pratica, il costrutto WHILE-DO verifica ad ogni iterazione che la condizione sia vera; se ci\u00f2 avviene, sono eseguite le istruzioni specificate nel DO, ed \u00e8 aggiornata la condizione (che, prima o dopo, non dovr\u00e0 essere pi\u00f9 verificata).</p> <p>L'importanza di aggiornare la condizione</p> <p>Nel WHILE-DO, l'importanza dell'aggiornamento della condizione \u00e8 ancora pi\u00f9 evidente rispetto al FOR, ed \u00e8 molto spesso delegata al programmatore. Ci\u00f2 comporta maggiore libert\u00e0 nell'aggiornamento della condizione, ma anche maggiori responsabilit\u00e0 (semi-cit.).</p> <p>Il costrutto DO-WHILE</p> <p>Esiste una variante del costrutto WHILE-DO chiamata DO-WHILE, nella quale le istruzioni specificate nel DO vengono effettuate prima della verifica della condizione. Non tutti i linguaggi di programmazione supportano tale costrutto; inoltre, con pochi accorgimenti, \u00e8 possibile usare indifferentemente il WHILE-DO ed il DO-WHILE. Tuttavia, occorre tener presente che il DO-WHILE sar\u00e0 eseguito almeno una volta, dato che la condizione \u00e8 verificata dopo l'esecuzione delle istruzioni, mentre il WHILE-DO potrebbe non essere mai eseguito, dato che la condizione \u00e8 verificata prima dell'esecuzione delle istruzioni.</p>"},{"location":"material/01_intro/06_structured/lecture/#64-esercizi","title":"6.4 - Esercizi","text":"<ol> <li>Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto WHILE-DO.</li> <li>Schematizzare, sotto forma di diagramma di flusso, un programma che utilizzi il costrutto SWITCH.</li> </ol>"},{"location":"material/01_intro/07_variables/lecture/","title":"7 - Le variabili","text":"<p>Comprendere il concetto di variabile \u00e8 fondamentale (o, per meglio dire, propedeutico) all'acquisizione dei fondamentali della programmazione.</p> <p>Per capire di cosa si tratta, possiamo analizzare il significato della parola nella lingua italiana: intuitivamente, una variabile rappresenta una quantit\u00e0 (o, in maniera molto pi\u00f9 \"lasca\", un dato) a cui \u00e8 \"concesso\" di variare durante l'esecuzione del programma. Risulta importantissimo sottolineare come una variabile non sia quindi necessariamente un dato di ingresso o un risultato atteso: si tratta piuttosto di una rappresentazione (parziale) dello stato interno del programma ad un dato istante.</p> <p>Una variabile pu\u00f2 essere quindi qualsiasi dato contenuto nel nostro programma: ci sono variabili che contano il numero di operazioni eseguite, ad esempio, oppure ancora variabili di supporto, che ci permettono di memorizzare stati intermedi durante l'esecuzione di iterazioni complesse.</p> <p>Nota</p> <p>Non tutti i dati contenuti in un programma sono delle variabili: esistono anche delle costanti, che si differenziano dalle variabili per la caratteristica di non poter variare durante l'esecuzione del programma. Di solito, le costanti vengono utilizzate per modellare valori ben definiti, come ad esempio il \\(\\pi\\).</p>"},{"location":"material/01_intro/07_variables/lecture/#71-dichiarare-ed-inizializzare-una-variabile","title":"7.1 - Dichiarare ed inizializzare una variabile","text":"<p>Per poter utilizzare una variabile all'interno del nostro programma dovremo seguire due step fondamentali, indipendentemente dal linguaggio di programmazione scelto. In particolare:</p> <ul> <li>nel primo step, chiamato dichiarazione della variabile, dovremo \"informare\" il programma dell'esistenza della stessa, associandovi un identificatore (ovvero, un nome) ed il tipo di dato rappresentato dalla stessa;</li> <li>nel secondo step, chiamato inizializzazione, dovremo assegnare un valore iniziale alla nostra variabile, in accordo ovviamente al tipo di dato utilizzato.</li> </ul> <p>Ad esempio, per dichiarare una variabile di tipo <code>type</code> chiamata <code>identifier</code>, dovremo usare una sintassi di questo tipo:</p> <pre><code>type identifier;\n</code></pre> <p>Successivamente, potremo inizializzare la variabile <code>identifier</code> con il valore <code>value</code>:</p> <pre><code>identifier = value;\n</code></pre> <p>Le due operazioni non sono necessariamente separate, e possono essere combinate in un'unica istruzione.</p> <pre><code>type identifier = value;\n</code></pre> <p>Nota</p> <p>Vedremo un gran numero di esempi pratici di dichiarazione ed inizializzazione.</p>"},{"location":"material/01_intro/07_variables/lecture/#72-identificatore-della-variabile","title":"7.2 - Identificatore della variabile","text":"<p>In genere, la scelta dell'identificatore da associare ad una variabile lascia vasta libert\u00e0 di scelta al programmatore. Tuttavia, occorre tenere a mente che, indipendentemente dal linguaggio, non sar\u00e0 possibile usare come identificatore una keyword (ad esempio, non \u00e8 possibile chiamare una variabile <code>if</code> o <code>long</code>); inoltre, \u00e8 fortemente consigliato attenersi allo styling code del linguaggio.</p> <p>Facciamo un paio di esempi. Il linguaggio Java, che non tratteremo, adotta per convenzione uno styling code chiamato camel case, che prevede che parole consecutive siano unite tra di loro, con l'iniziale di ogni parola successiva alla prima in maiuscolo. Ad esempio:</p> <pre><code>int integerVariable = 1;\n</code></pre> <p>Python, invece, utilizza per convenzione lo stile snake case, che prevede che parole consecutive siano \"unite\" mediante un simbolo di underscore, lasciando tutte le lettere minuscole:</p> <pre><code>integer_variable = 1\n</code></pre> <p>Sulla scelta del nome</p> <p>La scelta del nome da assegnare ad una variabile non \u00e8 casuale. Il suggerimento \u00e8 quello di assegnare nomi esplicativi, oltre che univoci: ad esempio, un contatore chiamato <code>cnt</code> sar\u00e0 sicuramente pi\u00f9 riconoscibile di un contatore chiamato <code>pippo_joy</code>.</p>"},{"location":"material/01_intro/07_variables/lecture/#73-tipo-della-variabile","title":"7.3 - Tipo della variabile","text":"<p>Il tipo della variabile definisce il tipo di dato associato alla stessa; come abbiamo visto nella lezione 4, quindi, ci\u00f2 influenzer\u00e0 il range di valori che questa pu\u00f2 rappresentare. Ponderare adeguatamente il tipo di dato da usare per una variabile \u00e8 quindi estremamente importante, principalmente per due ragioni:</p> <ol> <li>flusso logico;</li> <li>complessit\u00e0 computazionale spaziale.</li> </ol> <p>Partiamo dal flusso logico. Immaginiamo di dover sommare tra loro due numeri reali<code>x</code> ed <code>y</code>, e di voler associare il valore risultante da questa operazione alla variabile <code>z</code>. Al momento della scrittura del codice, decidiamo di assegnare (correttamente) il tipo <code>float</code> ad <code>x</code> ed <code>y</code> ma, per una disattenzione, assegnamo il tipo <code>int</code> alla variabile <code>z</code>:</p> <pre><code>float x = 1.1;\nfloat y = 1.2; \nint z;\nz = x + y;\n</code></pre> <p>Cosa accadr\u00e0? Consideriamo che il valore che ci attendiamo che <code>z</code> assuma \u00e8 pari <code>2.3</code>: tuttavia, avremo come output <code>2</code>, principalmente a causa del tipo di <code>z</code>. Ci\u00f2 comporter\u00e0 quindi un errore di troncamento pari a <code>0.3</code>.</p> <p>Per quello che riguarda invece la complessit\u00e0 computazionale spaziale, ricordiamo, sempre dalla lezione 4, che ogni tipo di dato richiede una quantit\u00e0 di memoria differente, ma al tempo stesso permette di memorizzare un range di valori pi\u00f9 o meno ampio.</p> <p>Questa caratteristica pu\u00f2 e deve essere usata a nostro vantaggio: infatti, qualora fossimo sicuri che le nostre variabili intere assumono sempre valori compresi tra 0 e 100, potremmo utilizzare dati di tipo <code>byte</code>. Tuttavia, se per qualche motivo una variabile si trovasse ad assumere un valore superiore a 256, avremmo un errore di buffer overflow, che porterebbe la variabile a \"ritornare\" a zero, con conseguenze facilmente intuibili.</p> <p>Curiosit\u00e0</p> <p>Errori di questo tipo possono portare ad esiti catastrofici. Ad esempio, nel 1995, il razzo spaziale Ariane 5 esplose 39 secondi dopo il lancio perch\u00e9 nel software di controllo dell'altitudine era stato usato un intero a 16 bit piuttosto che a 64 bit.</p>"},{"location":"material/01_intro/08_functions/lecture/","title":"8 - Le funzioni","text":"<p>Immaginiamo di dover calcolare il nostro voto di accesso all'esame laurea. Supponendo che nel nostro corso di studi ci siano esattamente venti esami, le istruzioni necessarie a calcolarlo sono molto semplici:</p> <pre><code>numero_esami = 20;\nsomma_voti = 0;\nfor i che va da 1 a numero_esami:\n    somma_voti = somma_voti + voto_esame_i;\nendfor\nvoto_medio = somma_voti/numero_esami;\nvoto_accesso = voto_medio / 3 * 11;\n</code></pre> <p>Queste istruzioni accettano un solo \"insieme\" di esami, relativo quindi a noi; come potremmo fare quindi per calcolare la media di un nostro collega? La tentazione potrebbe essere quella di \"sdoppiare\" le istruzioni, cambiando leggermente il nome delle variabili e passando un insieme di esami diverso:</p> <pre><code>numero_esami = 20;\nsomma_voti_a = 0;\nfor i che va da 1 a numero_esami:\n    somma_voti_a = somma_voti_a + voto_esame_i_a;\nendfor\nvoto_medio_a = somma_voti_a / numero_esami;\nvoto_accesso_a = voto_medio_a / 3 * 11;\n\nsomma_voti_b = 0;\nfor i che va da 1 a numero_esami:\n    somma_voti_b = somma_voti_b + voto_esame_i;\nendfor\nvoto_medio_b = somma_voti_b / numero_esami;\nvoto_accesso_b = voto_medio / 3 * 11;\n</code></pre> <p>Cosa accadrebbe se volessimo aggiungere un altro studente? Ovviamente, dovremmo aggiungere altre righe di codice; \u00e8 facile quindi intuire che, in breve tempo, la situazione diventerebbe ingestibile.</p> <p>In nostro aiuto, quindi, giungono le funzioni, ovvero dei costrutti che ci permettono di raggruppare istruzioni eseguite un numero arbitrario di volte all'interno del nostro codice. Le funzioni (chiamate anche metodi) assumono quindi il ruolo di contenitore logico, utilizzabile per effettuare una serie ben definita di operazioni su un certo input, conseguendo un determinato output.</p> <p>Vediamo quindi come sono strutturate.</p>"},{"location":"material/01_intro/08_functions/lecture/#81-struttura-di-una-funzione","title":"8.1 - Struttura di una funzione","text":"<p>Una funzione consta di due parti: una firma ed un corpo.</p> <p>Nella firma, sono definiti:</p> <ul> <li>il nome della funzione, ovvero un identificativo utile a richiamarla in altre parti del programma (un po' come quello della variabile);</li> <li>il tipo di ritorno, ovvero il tipo del valore restituito (ovvero, mandato in output) dalla funzione;</li> <li>i parametri di ingresso, ovvero il tipo ed i nomi dei valori in ingresso (input) alla funzione.</li> </ul> <p>Nel corpo, invece, saranno indicate le istruzioni vere e proprie, oltre che l'eventuale valore restituito dalla funzione. Schematizzando:</p> <pre><code>tipo_ritorno nome_funzione(tipo_par_1 par_1, tipo_par_2 par_2):         // Questa \u00e8 la firma...\n    istr_1;                                                             // ...questo \u00e8 il corpo...\n    istr_2;\n    tipo_ritorno valore_ritorno = istr_3;\n    return valore_ritorno;                                              // ...e questo \u00e8 il valore restituito!\n</code></pre> <p>Da notare la presenza della parola chiave <code>return</code>, che serve ad indicare il valore (o, per meglio dire, la variabile) che sar\u00e0 \"restituita\" dalla funzione. </p> <p>Nota</p> <p>Quando la funzione trova la parola chiave <code>return</code>, si \"ferma\" immediatamente, e l'esecuzione del programma continua.</p> <p>Facciamo un esempio creando una pseudo-funzione per il calcolo del voto di accesso all'esame di laurea; chiamiamola, in maniera originale, <code>calcolo_voto_accesso_laurea</code>, e supponiamo restituisca un <code>float</code> (il voto di accesso non approssimato) a partire da un insieme di valori <code>interi</code> (i voti dei singoli esami). Allora:</p> <pre><code>numero_esami = 20;\n\nfloat calcolo_voto_accesso_laurea(int[] voti_esami):\n    somma_voti = 0;\n    for i che va da 1 a numero_esami:\n        somma_voti = somma_voti + voto_esame_i;\n    endfor\n    voto_medio = somma_voti / numero_esami;\n    voto_accesso = voto_medio / 3 * 11;\n    return voto_accesso;\n</code></pre> <p>Immaginiamo di voler chiamare la funzione per calcolare i nostri voti, oltre a quelli di un collega. Per farlo, useremo istruzioni simili a queste:</p> <pre><code>mio_voto_accesso = calcolo_voto_accesso_laurea(miei_voti);\nvoto_accesso_collega = calcolo_voto_accesso_laurea(voti_collega);\n</code></pre> <p>Come si pu\u00f2 notare, il numero di righe di codice scritte diminuisce in maniera tanto pi\u00f9 rilevante quanto pi\u00f9 si usa la funzione!</p> <p>Nota sulle parentesi quadre</p> <p>Abbiamo usato in precedenza le parentesi quadre (<code>[]</code>) per indicare un \"insieme\" di valori. In realt\u00e0, questa notazione indica spesso un array, o una lista, a seconda del linguaggio; ne parleremo pi\u00f9 diffusamente nel seguito.</p>"},{"location":"material/01_intro/08_functions/lecture/#82-il-concetto-di-modularita","title":"8.2 - Il concetto di modularit\u00e0","text":"<p>Abbiamo visto come una funzione serva ad evitare di dover ripetere numerose volte lo stesso insieme di istruzioni. Tuttavia, abbiamo accennato in precedenza anche al fatto che ogni funzione \u00e8 un contenitore logico di una sequena di istruzioni da utilizzare per risolvere un problema: ci\u00f2 ci conduce direttamente al concetto di modularit\u00e0, per il quale una funzione deve contenere esclusivamente le istruzioni necessarie ad eseguire lo scopo per cui \u00e8 stata concepita.</p> <p>Per fare un esempio, immaginiamo adesso di dover calcolare, oltre al voto medio di accesso all'esame di laurea, anche quello finale, tenendo conto della votazione della commissione e dell'eventuale lode. Sottolineamo comunque come sia sempre importante per noi (e, nello specifico, per la segreteria e la commissione) tenere traccia del voto medio, per cui le due cose andranno, in qualche modo, separate.</p> <p>L'approccio da utilizzare \u00e8 quindi quello di creare un'altra funzione che asserva allo scopo di calcolare il voto finale:</p> <p>```linenums=1\" int calcolovotofinalelaurea(float votoaccesso, int votoesame, float soglialode):     votocumulativo = votoaccesso + votoesame;     if (votocumulativo &gt; (110 + soglialode)):         return 110L     else:         return votocumulativo <pre><code>Da notare la presenza di due `return`: questo \u00e8 corretto perch\u00e9, essendo specificati nei due rami di un'istruzione condizionale, saranno mutualmente esclusivi, e quindi la funzione potr\u00e0 \"arrivare\" soltanto ad uno di essi.\n\n## 8.3 - Funzioni, variabili ed ambito\n\nIntroduciamo brevemente il concetto di *ambito* di una variabile. All'interno del nostro programma, infatti, ogni variabile ha una sorta di \"ciclo di vita\", nel quale viene creata, utilizzata, ed infine distrutta.\n\nL'intero programma ha un ambito chiamato *globale*: ci\u00f2 significa che tutte le variabili specificate nel corpo principale del programma, che vedremo in avanti essere chiamato spesso *main*, avranno validit\u00e0 in tutto il nostro codice. Le singole funzioni, invece, definiscono un ambito *locale*, che viene creato alla chiamata della funzione, e distrutto al termine della stessa.\n\nAd esempio:\n\n```linenums=\"1\"\nnumero_esami = 20;\nmiei_voti = lista_miei_voti;\n\nfloat calcolo_voto_accesso_laurea(int[] voti_esami):\n    somma_voti = 0;\n    for i che va da 1 a numero_esami:\n        somma_voti = somma_voti + voto_esame_i;\n    endfor\n    voto_medio = somma_voti / numero_esami;\n    voto_accesso = voto_medio / 3 * 11;\n    return voto_accesso;\n\nvoto_accesso_mio = calcolo_voto_accesso_laurea(miei_voti);\n</code></pre></p> <p>Nel codice precedente, dichiariamo le variabili <code>numero_esami</code> e <code>miei_voti</code> nel corpo principale del programma: ci\u00f2 significa che questa variabili hanno validit\u00e0 nell'intero codice, e sono quindi richiamabili (e potenzialmente modificabili) anche all'interno della funzione <code>calcolo_voto_accesso_laurea</code>. Dal canto suo, quest'ultima crea un ambito locale: ci\u00f2 comporta che le variabili create al suo interno, come <code>somma_voti</code>, <code>voto_medio</code> e <code>voto_accesso</code>, non potranno essere accedute all'esterno della funzione.</p> <p>Da ci\u00f2 seguono alcune considerazioni:</p> <ol> <li>parlando in maniera \"logica\", la parola chiave <code>return</code> serve a \"trasferire\" il valore di una variabile da un ambito locale ad uno globale;</li> <li>la variabile restituita cambia identificatore, ma il valore \u00e8 quello calcolato all'interno della funzione;</li> <li>occorre fare estrema attenzione alla modifica delle variabili globali in ambito locale, ovvero all'interno delle singole funzioni.</li> </ol> <p>Imparare ad utilizzare l'ambito delle variabili \u00e8 propedeutico al corretto utilizzo delle tecniche di programmazione, e tenere a mente queste tre semplici regole ci aiuter\u00e0 enormemente nella scrittura dle nsotro codice.</p>"},{"location":"material/01_intro/09_complexity/exercises/","title":"E9 - Esercizi sulla complessit\u00e0 computazionale","text":""},{"location":"material/01_intro/09_complexity/exercises/#esercizio-e91","title":"Esercizio E9.1","text":"<p>Calcolare la complessit\u00e0 di caso peggiore di una sequenza di \\(m\\) istruzioni; si tenga a mente che se la complessit\u00e0 \u00e8 costante, allora si ha un \\(O(1)\\).</p>"},{"location":"material/01_intro/09_complexity/exercises/#soluzione-s91","title":"Soluzione S9.1","text":"<p>Una sequenza di \\(m\\) istruzioni \u00e8 data da un diagramma di flusso simile a questo.</p> <p></p> <p>Di conseguenza, dato che la complessit\u00e0 legata a ciascuna istruzione \u00e8 unitaria, la complessit\u00e0 di caso peggiore sar\u00e0 approssimabile ad un \\(O(1)\\).</p>"},{"location":"material/01_intro/09_complexity/exercises/#esercizio-e92","title":"Esercizio E9.2","text":"<p>Calcolare la complessit\u00e0 di caso peggiore di un ciclo <code>while</code>.</p>"},{"location":"material/01_intro/09_complexity/exercises/#soluzione-s92","title":"Soluzione S9.2","text":"<p>Definiamo un ciclo <code>while</code> mediante un diagramma di flusso simile a questo, direttamente dall'esercizio 3 sulle strutture dati.</p> <p></p> <p>In questo caso, il numero di operazioni non \u00e8 deterministico, ma dipende dalla funzione <code>genera_magia</code>, che abbiamo definito essere randomica.</p> <p>Supponendo che la funzione generi un numero superiore a 10 con probabilit\u00e0 pari a \\(\\frac{1}{n}\\) (ovvero, che la funzione generi un numero superiore a 10 una volta su n), allora avremo che la complessit\u00e0 di caso peggiore sar\u00e0 pari a \\(O(n)\\): in altre parole, nel caso peggiore, ci attendiamo che ci servano \\(n\\) iterazioni per uscire dal ciclo.</p>"},{"location":"material/01_intro/09_complexity/exercises/#esercizio-e93","title":"Esercizio E9.3","text":"<p>Calcolare la complessit\u00e0 di caso peggiore del seguente algoritmo:</p> <pre><code>for i che va da 1 a 10:\n    for j che va da 1 a 10:\n        calcola i + j;\n    endfor\nendfor\n</code></pre>"},{"location":"material/01_intro/09_complexity/exercises/#soluzione-s93","title":"Soluzione S9.3","text":"<p>Partiamo dalla costruzione del diagramma di flusso dell'algoritmo, che \u00e8 quello riportato nella seguente figura.</p> <p></p> <p>Notiamo subito la presenza di due cicli <code>for</code> annidati l'uno dentro l'altro. Entrambi i cicli prevedono dieci iterazioni ciascuno; tuttavia, il ciclo interno sar\u00e0 eseguito dieci volte per ciascuna iterazione del ciclo esterno. Di conseguenza, il numero totale di iterazioni sar\u00e0 dato dalla moltiplicazione delle iterazioni previste per il ciclo interno (ovvero dieci) per quelle previste per il ciclo esterno (sempre dieci), ovvero 100.</p> <p>Aumentando il numero \\(n\\) di iterazioni, vedremo come il numero totale di operazioni aumenter\u00e0 secondo una legge quadratica:</p> <ul> <li>per \\(n=11\\), il numero di iterazioni sar\u00e0 pari a \\(11 \\cdot 11 = 121\\);</li> <li>per \\(n=12\\), il numero di iterazioni sar\u00e0 pari a \\(12 \\cdot 12 = 144\\);</li> <li>per \\(n=13\\), il numero di iterazioni sar\u00e0 pari a \\(13 \\cdot 13 = 169\\);</li> </ul> <p>e cos\u00ec via. Di conseguenza, la complessit\u00e0 computazionale dipende dal quadrato di \\(n\\), per cui quella di caso peggiore \u00e8 un \\(O(n^2)\\).</p>"},{"location":"material/01_intro/09_complexity/exercises/#esercizio-e94","title":"Esercizio E9.4","text":""},{"location":"material/01_intro/09_complexity/exercises/#parte-1","title":"Parte 1","text":"<p>Supponiamo di ricevere due prestiti. Il primo prestito, dell'importo totale di 1000 \u20ac, ci viene garantito dalla Banca di Paperopoli il 01/04/2022. Il secondo prestito, dell'importo di 100 \u20ac, ci viene garantito dalla Banca di Topolinia lo stesso giorno. Successivamente, apriamo un filone di credito presso la banca di Topolinia, e per i 99 giorni successivi al 01/04 riceviamo 100 \u20ac al giorno. Calcolare:</p> <ul> <li>il valore totale dei due prestiti al primo giorno e dopo 100 giorni;</li> <li>quanto incide (in percentuale) ciascun prestito sul totale al primo giorno;</li> <li>quanto incide (in percentuale) ciascun prestito sul totale al centesimo giorno.</li> </ul> <p>Spiegare questi concetti riconducendoli alle nozioni di complessit\u00e0 computazionale.</p>"},{"location":"material/01_intro/09_complexity/exercises/#parte-2","title":"Parte 2","text":"<p>Cosa accadrebbe se la Banca di Paperopoli ci facesse 100 bonifici al giorno per 100 giorni a partire dal primo aprile?</p>"},{"location":"material/01_intro/09_complexity/exercises/#soluzione-s94","title":"Soluzione S9.4","text":""},{"location":"material/01_intro/09_complexity/exercises/#parte-1_1","title":"Parte 1","text":"<p>Al primo aprile, la nostra situazione finanziaria sar\u00e0 la seguente:</p> \\[ P_{p_1} = 100 \u20ac \\\\ P_{t_1} = 100 \u20ac \\] <p>con \\(P_{p_1}\\) prestito ricevuto al primo aprile dalla Banca di Paperopoli, e \\(P_{t_1}\\) prestito ricevuto al primo aprile dalla Banca di Topolinia.</p> <p>Le percentuali del prestito relativo alle due banche, rispettivamente \\(P_{p_1}(\\%)\\) e \\(P_{t_1}(\\%)\\), saranno del \\(50(\\%)\\) ciascuna, dato che i prestiti incidono egualmente sull'intera cifra a debito.</p> <p>Vediamo cosa accade al 10 luglio, ovvero 100 giorni dopo.</p> <p>La cifra che dovremo alla Banca di Paperopoli sar\u00e0 sempre di 100 \u20ac, per cui \\(P_{p_{100}} = P_{p_1} = 100 \u20ac\\). Per quello che riguarda la Banca di Topolinia, invece:</p> \\[ P_{t_{100}} = P_{t_1} + g * p_g = 100 \u20ac + 99 * 100 \u20ac = 10.000 \u20ac \\] <p>dove \\(g\\) \u00e8 il numero di giorni (escluso il primo) in cui riceviamo un prestito di valore \\(p_g\\).</p> <p>A questo punto, il totale a debito \u00e8 dato da:</p> \\[ P_{TOT} = P_{p_{100}} + P_{t_{100}} = 100 \u20ac + 10.000 \u20ac = 10.100 \u20ac \\] <p>Calcoliamo le percentuali dovute (rispetto al totale) alle due banche:</p> \\[ P_{p_{100}}(\\%) = \\frac{P_{p_{100}}}{P_{TOT}} \\cdot 100 = \\frac{100}{10.100} \\cdot 100 \\sim 0.0099 \\cdot 100 \\sim 1 (\\%) \\] <p>per cui:</p> \\[ P_{t_{100}}(\\%) = 100 - P_{p_{100}}(\\%) \\sim 99 (\\%) \\] <p>Ovviamente, questo si pu\u00f2 rappresentare con uno pseudocodice del tipo:</p> <pre><code>tot_paperopoli = 100;\n\ntot_topolinia = 100;\nfor giorno da 1 a 99:\n    tot_topolinia = tot_topolinia + 100;\nendfor\n</code></pre> <p>Di conseguenza, \u00e8 possibile valutare empiricamente come il \"peso\" del <code>for</code>, che comporta una complessit\u00e0 pari ad \\(O(n)\\), incida maggiormente sull'operazione lineare, che ha una complessit\u00e0 pari ad \\(O(1)\\).</p>"},{"location":"material/01_intro/09_complexity/exercises/#parte-2_1","title":"Parte 2","text":"<p>Con la nuova modalit\u00e0 di finanziamento da parte della banca di Paperopoli, i valori mostrati in precedenza per questa cambiano come segue.</p> \\[ P_{p_1} = n_b * p_g = 100 \\cdot 100 \u20ac = 10.000 \u20ac \\] <p>con \\(n_b\\) numero di bonifici al giorno, ed \\(p_g\\) importo del singolo bonifico. Di conseguenza, al primo giorno avremo una situazione di questo tipo:</p> \\[ P_{p_1} = 10.000 \u20ac \\\\ P_{t_1} = 100 \u20ac \\] <p>Le percentuali cambiano come segue:</p> \\[ P_{p_1}(\\%) \\sim 99 (\\%) \\\\ P_{t_1}(\\%) \\sim 1 (\\%) \\] <p>Al centesimo giorno:</p> \\[ P_{p_{100}} = n_b \\cdot p_g \\cdot g = 100 \\cdot 100 \u20ac \\cdot 100 =  1.000.000 \u20ac \\] <p>Tenendo conto che P{t} \u00e8 costante, avremo che le nuove percentuali saranno pari a \\(P_{p_{100}}(\\%) \\sim 99 (\\%)\\), e di conseguenza \\(P_{t_{100}}(\\%) \\sim 1 (\\%)\\).</p> <p>Tutto ci\u00f2 \u00e8 correlato al fatto che il contributo della Banca di Paperopoli \u00e8 assimilabile a due cicli <code>for</code> annidati:</p> <pre><code>n = 100;\n\nfor giorno da 1 a n:\n    for bonifico da 1 a n:\n        tot_paperopoli = tot_paperopoli + 100;\n    endfor\nendfor\n</code></pre> <p>Provando ad aumentare il valore \\(n\\), portandolo magari a 200, \u00e8 facile constatare come le percentuali si spostino sempre pi\u00f9 verso \\(P_{p_{200}}(\\%)\\):</p> \\[ \\begin{align*}     &amp;\\begin{cases}         P_{p_{200}} = 200 \\cdot 200 \\cdot 100 = 4.000.000 \u20ac \\\\         P_{t_{200}} = 200 \\cdot 100 = 20.000 \u20ac     \\end{cases} \\Rightarrow \\\\     &amp;\\Rightarrow \\begin{cases}         P_{p_{200}}(\\%) = \\frac{4.000.000}{4.020.000} \\cdot 100 \\sim 99.5 (\\%) \\\\          P_{t_{200}} \\sim 0.5 (\\%)     \\end{cases} \\end{align*} \\]"},{"location":"material/01_intro/09_complexity/lecture/","title":"9 - La complessit\u00e0 computazionale degli algoritmi","text":"<p>Il concetto di complessit\u00e0 computazionale di un algoritmo \u00e8 direttamente correlato al numero di operazioni che occorre svolgere per portarlo a termine, oppure ancora alla quantit\u00e0 di memoria occupata nel sistema durante l'esecuzione dello stesso.</p> <p>In particolare, avremo due tipi di complessit\u00e0:</p> <ul> <li>la complessit\u00e0 temporale pu\u00f2 essere determinata a partire dal numero di operazioni effettuate dall'algoritmo;</li> <li>la complessit\u00e0 spaziale \u00e8 legata allo spazio massimo richiesto dall'algoritmo in fase di esecuzione nella memoria del calcolatore.</li> </ul> <p>Torneremo pi\u00f9 avanti su questi aspetti; per adesso, limitiamoci a fare un breve esempio a titolo meramente illustrativo.</p>"},{"location":"material/01_intro/09_complexity/lecture/#91-un-primo-rapido-esempio","title":"9.1 - Un primo, rapido, esempio","text":"<p>Facciamo un rapido esempio introduttivo (nel prosieguo, formalizzeremo al meglio i concetti espressi).</p> <p>Immaginiamo di dover calcolare la distanza euclidea tra due numeri, cos\u00ec come abbiamo visto nella lezione precedente; per comodit\u00e0, riportiamo di seguito lo stesso pseudo-codice:</p> <pre><code>distanza_x = (x_a - x_b)^2;\ndistanza_y = (y_a - y_b)^2;\ndistanza = (distanza_x + distanza_y)^(1/2);\n</code></pre> <p>La complessit\u00e0 computazionale va valutata a partire dalle operazioni atomiche. Nel caso precedente, notiamo subito che alcune operazioni sono raggruppate, per cui \u00e8 il caso di \"esplodere\" l'algoritmo per quanto possibile.</p> <pre><code>differenza_x = x_a - x_b\ndistanza_x = (differenza_x)^2;\ndifferenza_y = y_a - y_b\ndistanza_y = (differenza_y)^2;\ndistanza_quad = distanza_x + distanza_y\ndistanza = (distanza_quad)^(1/2);\n</code></pre> <p>Nota</p> <p>Per semplicit\u00e0, non teniamo conto dei singoli passaggi che un calcolatore potrebbe impiegare nell'effettuare un'elevazione a potenza, ma consideriamo la stessa un'operazione unitaria.</p> <p>Avremo quindi un totale di \\(N=6\\) operazioni; supponendo che ognuna di queste richieda esattamente un ciclo del nostro processore, e che questo effettui un ciclo al secondo, la complessit\u00e0 computazionale temporale sar\u00e0 proprio pari a 6.</p> <p>Per quello che riguarda la complessit\u00e0 computazionale spaziale, invece, dovremo contare il numero \\(K\\) di variabili create (e, di conseguenza, memorizzate) durante l'esecuzione dell'algoritmo, oltre che il numero \\(b\\) di bit con cui ciascuna variabile \u00e8 rappresentata (per semplicit\u00e0, riterremo costante questo valore). In particolare, notiamo che vengono create 6 variabili, a cui sono da aggiungere gli input <code>x_a</code> ed <code>x_b</code>; supponendo che \\(b\\) sia pari ad 8 bit, avremo:</p> \\[ K = 6 + 2 = 8, b = 8 \\Rightarrow \\\\ \\Rightarrow C_s = K \\cdot b = 8 \\cdot 8 = 64 \\] <p>La complessit\u00e0 computazionale spaziale sar\u00e0 quindi pari a 64 bit.</p> <p>Importantissimo comunque sottolineare come questo esempio sia puramente introduttivo. Nel seguito, forniremo una definizione formale di complessit\u00e0 spaziale e temporale; per adesso, concentriamoci brevemente su due tipi di analisi che \u00e8 possibile effettuare, ovvero quelle a priori ed a posteriori.</p>"},{"location":"material/01_intro/09_complexity/lecture/#92-tipi-di-analisi-computazionale","title":"9.2 - Tipi di analisi computazionale","text":""},{"location":"material/01_intro/09_complexity/lecture/#921-analisi-a-priori","title":"9.2.1 - Analisi a priori","text":"<p>L'analisi a priori \u00e8 un'analisi di tipo prettamente teorico dell'efficienza dell'algoritmo. Questa viene misurata assumendo che tutti i fattori contestuali, quali (ad esempio) la velocit\u00e0 del processore utilizzato e la quantit\u00e0 di memoria disponibile siano costanti e non abbiano alcun effetto tangibile sull'algoritmo stesso.</p>"},{"location":"material/01_intro/09_complexity/lecture/#922-analisi-a-posteriori","title":"9.2.2 - Analisi a posteriori","text":"<p>L'analisi a posteriori \u00e8 un'analisi di tipo prettamente empirico dell'efficienza dell'algoritmo. Ci\u00f2 significa che l'algoritmo viene valutato dopo essere stato eseguito su una macchina target, mediante indicazioni di tipo numerico come il tempo necessario all'esecuzione e la memoria occupata.</p> <p>Importanza del contesto</p> <p>Nel caso dell'analisi a posteriori, il contesto risulta essere estremamente importante. Infatti, i risultati dipendono anche da fattori come il linguaggio di programmazione utilizzato, l'hardware sottostante, la presenza contestuale di altri processi software in esecuzione, e, non ultimo, le abilit\u00e0 del programmatore. E' inoltre importante sottolineare come sia necessario effettuare pi\u00f9 misurazioni in un'analisi a posteriori, proprio per minimizzare l'impatto del contesto sulle performance rilevate. Ci\u00f2 comporta creare una rudimentale statistica dei valori ottenuti.</p> <p>Vediamo adesso come \u00e8 possibile formalizzare i due diversi tipi di analisi computazionale per la complessit\u00e0 spaziale e per quella temporale.</p>"},{"location":"material/01_intro/09_complexity/lecture/#93-complessita-spaziale-e-temporale","title":"9.3 - Complessit\u00e0 spaziale e temporale","text":""},{"location":"material/01_intro/09_complexity/lecture/#931-complessita-spaziale","title":"9.3.1 - Complessit\u00e0 spaziale","text":"<p>La complessit\u00e0 spaziale di un algoritmo indica il quantitativo di spazio che l'algoritmo occupa in memoria durante la sua esecuzione. Formalmente, questo \u00e8 pari alla somma di due componenti:</p> <ul> <li>una parte fissa, pari allo spazio richiesto per la memorizzazione di dati che non variano (in pratica, funzioni e costanti, che saranno trattati nel seguito);</li> <li>una parte variabile, data dallo spazio richiesto per la memorizzazione delle variabili.</li> </ul> <p>Ci\u00f2 significa che \u00e8 possibile esprimere la complessit\u00e0 spaziale \\(C_s(X)\\) di un algoritmo \\(X\\) come:</p> \\[ C_s(X) = C_{S_F}(C) + C_{S_V}(C) \\] <p>con \\(C_{S_F}\\) parte fissa e \\(C_{S_V}\\) parte variabile; entrambe possono essere influenzate dalle caratteristiche \\(C\\) come linguaggio di programmazione ed hardware sottostante.</p>"},{"location":"material/01_intro/09_complexity/lecture/#9311-un-esempio-piu-strutturato-parte-1","title":"9.3.1.1 - Un esempio pi\u00f9 strutturato - Parte 1","text":"<p>Consideriamo il seguente algoritmo (in pseudocodice):</p> <pre><code>leggi p, q\nr = p + q + 1\nscrivi r\n</code></pre> <p>Partiamo dall'analisi a priori. Vediamo subito come questo algoritmo consti di tre variabili, ovvero <code>p</code> e <code>q</code> (variabili di input) ed <code>r</code> (variabile di output). Abbiamo inoltre una costante (il valore <code>1</code>). La complessit\u00e0 spaziale (analizzata a priori) sar\u00e0 quindi pari a:</p> \\[ C_S(X) = C_{S_F} + C_{S_V} = 1 + 3 \\] <p>Notiamo che abbiamo omesso le caratteristiche \\(C\\), in quanto, come gi\u00e0 detto, non ne teniamo conto nell'analisi a priori. Ne consegue che l'algoritmo occuper\u00e0 quattro unit\u00e0 di memoria.</p> <p>Per quello che riguarda l'analisi a posteriori, immaginiamo che il tipo di dato associato a ciascuna variabile sia un intero ad 8 bit. La complessit\u00e0 analizzata a posteriori sar\u00e0:</p> \\[ b = 8 bit \\Rightarrow \\\\ \\Rightarrow C_S(X) = C_{S_F}(C) + C_{S_V}(C) = (1 + 3) \\cdot 8 = 32 bit \\]"},{"location":"material/01_intro/09_complexity/lecture/#932-complessita-temporale","title":"9.3.2 - Complessit\u00e0 temporale","text":"<p>Abbiamo gi\u00e0 visto come la complessit\u00e0 temporale di un algoritmo risulti essere associata alla quantit\u00e0 di tempo richiesto ad una completa esecuzione dello stesso. Anche questa complessit\u00e0 pu\u00f2 essere espressa da una funzione numerica del tipo:</p> \\[ C_T = \\sum_{i=1}^n t_i(C) \\] <p>con \\(t_i\\) tempo necessario all'esecuzione di uno step atomico dell'algoritmo, e \\(C\\) dipendendente anche stavolta dalle caratteristiche hardware del nostro dispositivo.</p>"},{"location":"material/01_intro/09_complexity/lecture/#9312-un-esempio-piu-strutturato-parte-2","title":"9.3.1.2 Un esempio pi\u00f9 strutturato - Parte 2","text":"<p>Torniamo all'algoritmo precedente, ed effettuiamone una valutazione a priori.</p> <p>Abbiamo elencato tre step, anche se, nei fatti, ci saranno soltanto due addizioni della cui esecuzione dovremo tenere conto. Di conseguenza, la complessit\u00e0 temporale analizzata a priori sar\u00e0 pari a \\(C_T = 2\\).</p> <p>Per quello che riguarda l'analisi a posteriori, invece, sar\u00e0 necessario anche stavolta fissare una condizione al contorno, ovvero la velocit\u00e0 con cui il nostro processore riesce ad eseguire una singola istruzione. Supponendo che questa sia pari ad un microsecondo, l'analisi a posteriori ci porter\u00e0 a stabilire che la complessit\u00e0 computazionale sar\u00e0 pari a 2 microsecondi.</p>"},{"location":"material/01_intro/09_complexity/lecture/#94-complessita-di-caso-peggiore","title":"9.4 - Complessit\u00e0 di caso peggiore","text":"<p>Nelle applicazioni reali, \u00e8 abbastanza difficile che si riesca a calcolare esattamente la complessit\u00e0 computazionale di un programma, in quanto il numero di ramificazioni e le variabili da tenere in considerazione sono tali da rendere un approccio deterministico realisticamente non percorribile. Di conseguenza, si ricorre ad approcci che ci permettano di avere un'idea veritiera della complessit\u00e0 dell'algoritmo, stimata assumendo la casistica peggiore, ovvero calcolando la quantit\u00e0 massima di tempo e memoria che, nel peggiore dei casi, il nostro algoritmo richieder\u00e0 per essere eseguito.</p> <p>Per far questo, si utilizza la cosiddetta O-big notation, che in matematica ci permette di descrivere il limite asintotico superiore di una funzione rispetto ad un'altra. In parole povere, un algoritmo che ha (ad esempio) una complessit\u00e0 temporale \\(C_T(n) = \\mathbb{O}(n^2)\\) richieder\u00e0 un tempo di esecuzione pari al massimo ad \\(n^2\\), mentre un algoritmo con una complessit\u00e0 \\(C_S(n) = O(n * log(n))\\) occuper\u00e0 al massimo \\(n*log(n)\\) unit\u00e0 di memoria.</p> <p>Nota</p> <p>Nella notazione precedente, <code>n</code> indica una variabile che pu\u00f2 influenzare il numero di operazioni eseguite dall'algoritmo. Il perch\u00e9 occorra specificarla sar\u00e0 pi\u00f9 chiaro grazie ai prossimi esempi.</p>"},{"location":"material/01_intro/09_complexity/lecture/#941-alcuni-esempi","title":"9.4.1 Alcuni esempi","text":""},{"location":"material/01_intro/09_complexity/lecture/#9411-ciclo-for-semplice","title":"9.4.1.1 Ciclo for (semplice)","text":"<p>Supponiamo di dover calcolare la complessit\u00e0 di questo semplice ciclo <code>for</code>:</p> <pre><code>n = 10;\nfor i da 1 a n:\n    scrivi i;\n    incrementa i;\nendfor\n</code></pre> <p>Notiamo innanzitutto che il valore del contatore <code>i</code> varia da 1 ad \\(n=10\\). Ci\u00f2 significa che, al pi\u00f9, saranno eseguite \\(n-1\\) operazioni. Ci\u00f2 implica che la complessit\u00e0 computazionale (nel tempo) sar\u00e0 nell'ordine di \\(O(n)\\).</p> <p>Per quello che riguarda quella nello spazio, supponendo che ad ogni iterazione le variabili create all'interno del corpo del ciclo (righe 3-4) siano anche cancellate, l'algoritmo avr\u00e0 una complessit\u00e0 spaziale di caso peggiore pari a 2; in questi casi, ovvero quando la complessit\u00e0 di caso peggiore \u00e8 costante, si dice che \\(C_S = O(1)\\)</p>"},{"location":"material/01_intro/09_complexity/lecture/#9412-cicli-for-annidati","title":"9.4.1.2 Cicli for annidati","text":"<p>Vediamo cosa accade nel caso si considerino due cicli <code>for</code> l'uno annidato all'interno dell'altro.</p> <pre><code>n = 10;\nfor i da 1 a n:\n    for j da 1 a n:\n        scrivi i;\n        scrivi j;\n    endfor\nendfor\n</code></pre> <p>Per ogni iterazione del ciclo esterno (quello che usa come contatore la variabile <code>i</code>) avremo n iterazioni del ciclo interno (quello che usa come contatore la variabile <code>j</code>). La complessit\u00e0 temporale di caso peggiore sar\u00e0 quindi \\(O(n^2)\\); per quello che riguarda invece la complessit\u00e0 spaziale, invece, assumendo un meccanismo analogo al precedente, avremo sempre \\(O(1)\\).V</p>"},{"location":"material/01_intro/10_data_structures/lecture/","title":"10 - Strutture dati","text":"<p>Nelle lezioni precedenti abbiamo ad un certo punto parlato di \"insieme\" dei voti relativi ai nostri esami, senza per\u00f2 ben specificare come rappresentarlo con i concetti a nostra disposizione. Se ci pensiamo, infatti, non abbiamo (apparentemente) strumenti per rappresentare degli insiemi: non possiamo certamente utilizzare un singolo dato numerico, cos\u00ec come neanche un dato booleano o un carattere.</p> <p>Per risolvere questo problema (e, in realt\u00e0, mille altri) dobbiamo utilizzare una serie di concetti che vanno sotto il nome collettivo di strutture dati, ovvero dei costrutti progettati per organizzare e gestire un insieme di valori nella maniera pi\u00f9 efficiente possibile.</p> <p>Esistono diversi tipi di struttura dati, ognuno dei quali adatto ad un determinato scopo. Vediamo quelli pi\u00f9 diffusi.</p>"},{"location":"material/01_intro/10_data_structures/lecture/#101-array","title":"10.1 - Array","text":"<p>La maniera pi\u00f9 rapida di rappresentare i nostri voti \u00e8 quella di immaginarli come un vettore di numeri interi; per far questo esiste una struttura dati apposita chiamata array.</p> <p>Un array contiene quindi una sequenza di elementi, tipicamente dello stesso tipo (anche se, come vedremo, ci\u00f2 dipende dal linguaggio di programmazione), ed organizzati seguendo un ordine specifico, \"esplorabile\" mediante il concetto di indice.</p> <p>La presenza dell'indice permette di definire la modalit\u00e0 di accesso ai dati dell'array, indicata come accesso diretto. Nella pratica, possiamo estrarre qualsiasi elemento nell'array mediante l'indice stesso, in maniera diretta, senza dover \"scorrere\" l'intero vettore; questo fa s\u00ec che l'accesso abbia sempre una complessit\u00e0 \\(O(1)\\), dato che \u00e8 richiesta un'unica operazione.</p> <p>Nota</p> <p>A far da contraltare all'efficienza in termini di accesso vi \u00e8 una certa laboriosit\u00e0 legata all'inserimento o rimozione di un elemento dall'array.</p> <p>Tipicamente, un array viene rappresentato come una serie di singole variabili racchiuse tra due parentesi quadre. Ad esempio:</p> <pre><code>array = [8, 5, 12, 7, 4]\n</code></pre> <p>In particolare, il precedente array \u00e8 composto da elementi di tipo intero, ed ha una lunghezza pari a cinque elementi. Da notare che nella maggior parte dei linguaggi di programmazione l'indice del primo elemento non \u00e8 pari ad uno, ma a zero. La figura successiva esplicita adeguatamente questo concetto.</p> <p></p>"},{"location":"material/01_intro/10_data_structures/lecture/#102-liste","title":"10.2 - Liste","text":"<p>Una lista, conosciuta anche con il nome di linked list, \u00e8 una struttura dati simile all'array, ma che consta di una differenza fondamentale. Nella lista, infatti, ogni elemento contiene un riferimento esplicito a quello successivo. Questo concetto \u00e8 esplicitato nella seguente figura:</p> <p></p> <p>In particolare, osserviamo che:</p> <ul> <li>il primo elemento nella lista, il cui valore \u00e8 <code>5</code>, ha un riferimento all'elemento successivo <code>R3</code>;</li> <li>il secondo elemento nella lista ha valore <code>3</code>, e conserva un riferimento all'elemento successivo <code>R2</code>;</li> <li>ci\u00f2 prosegue sino all'elemento <code>7</code>, che conserva un riferimento all'ultimo elemento <code>R12</code>.</li> </ul> <p>Il fatto che ogni elemento della lista contenga un riferimento al successivo ha due conseguenze:</p> <ol> <li>la prima consiste nel fatto che la lista \u00e8 una struttura dati ad accesso sequenziale, il che significa che occorrer\u00e0 \"scorrere\" tutti gli elementi della stessa fino ad arrivare a quello desiderato;</li> <li>la seconda sta nel fatto che risulta essere molto pi\u00f9 semplice aggiungere o rimuovere un elemento da una lista che da un array: infatti, baster\u00e0 semplicemente modificare i riferimenti dagli elementi contigui a quello che si sta aggiungendo o rimuovendo.</li> </ol>"},{"location":"material/01_intro/10_data_structures/lecture/#103-struct","title":"10.3 - Struct","text":"<p>Una struct contiene un insieme di valori tipicamente chiamati membri o campi, il cui numero, sequenza e tipo sono tipicamente prefissati. Le struct trovano ampia applicazione in linguaggi come il C, ed hanno una sintassi di questo tipo:</p> <pre><code>struct nome_struct {\n    tipo_campo_uno id_campo_uno;\n    tipo_campo_due id_campo_due;\n};\n</code></pre> <p>Questa sintassi ci permette di definire quindi un tipo di struct chiamato <code>nome_struct</code> ed avente, in questo caso, due campi, ovvero un primo campo di tipo <code>tipo_campo_uno</code> ed identificatore <code>id_campo_uno</code>, ed un secondo campo di tipo <code>tipo_campo_due</code> ed identificatore <code>id_campo_due</code>.</p>"},{"location":"material/01_intro/10_data_structures/lecture/#104-union","title":"10.4 - Union","text":"<p>Una union \u00e8 un tipo di struttura dati che permette di specificare il tipo del valore che pu\u00f2 essere memorizzato al suo interno tra un certo numero di tipi primitivi. Nonostante sia sintatticamente affine alla struct, ne differisce quindi dal punto di vista funzionale: non \u00e8 una \"struttura\", ma piuttosto un \"ventaglio di possibili tipi\" da cui selezionare. La sintassi di una union \u00e8 simile alla seguente:</p> <pre><code>union nome_union {\n    tipo_union_uno id_union_tipo_uno;\n    tipo_union_due id_union_tipo_due;\n};\n</code></pre> <p>In questo caso, la union di nome <code>nome_union</code> potr\u00e0 assumere uno tra due possibili valori, ovvero <code>id_union_tipo_uno</code> di tipo <code>tipo_union_uno</code> o <code>id_union_tipo_due</code> di tipo <code>id_union_tipo_due</code>.</p> <p>Nota</p> <p>Per adesso, non facciamo un esempio \"concreto\" di union; lo vedremo pi\u00f9 avanti, quando ritorneremo su queste due strutture dati in C.</p>"},{"location":"material/01_intro/10_data_structures/lecture/#105-pile-e-code","title":"10.5 - Pile e code","text":"<p>Abbiamo visto in precedenza due tipi di accesso ai dati, ovvero quello casuale, proprio degli array, e quello sequenziale, proprio dell eliste. Esiste un altro tipo di accesso ai dati, chiamato accesso limitato, usato da specifiche strutture dati come pile e code. Vediamo brevemente entrambi questi tipi di struttura dati.</p>"},{"location":"material/01_intro/10_data_structures/lecture/#1051-pile","title":"10.5.1 - Pile","text":"<p>Una pila (in inglese, stack) \u00e8 una struttura dati che contiene al suo interno variabili inserite e/o rimosse seguendo il principio Last-In, First-Out (LIFO). In altre parole, ci\u00f2 significa che l'ultimo elemento che accede ad una pila \u00e8 anche il primo ad uscirne.</p> <p>Una pila ha a disposizione quindi due diverse operazioni, ovvero quella di <code>push</code>, mediante la quale un oggetto viene inserito in cima allo stack, e quella di <code>pop</code>, che permette di estrarre l'oggetto dalla cima dello stesso.</p> <p>Il funzionamento della pila \u00e8 schematizzato all'interno della seguente figura.</p> <p></p> <p>Nota</p> <p>Il motivo alla base dell'aggettivo \"limitato\" \u00e8 da ricercarsi proprio nel fatto che sia il push sia il pop possono essere effettuati soltanto sugli elementi in cima alla pila.</p>"},{"location":"material/01_intro/10_data_structures/lecture/#1052-code","title":"10.5.2 - Code","text":"<p>Una coda (in inglese, queue) \u00e8 una struttura dati concettualmente simile alla pila, ma che segue il principio (First-In, First-Out) (FIFO); in questo caso, il primo ad uscire dalla coda sar\u00e0 il primo ad esservi entrato.</p> <p>Le operazioni definite sulla coda sono concettualmente simili a quelle definite sulla pila, e vengono chiamate <code>enqueue</code> (per mettere in coda un nuovo elemento) e <code>dequeue</code> (per togliere dalla coda l'elemento presente da pi\u00f9 tempo).</p> <p>Il funzionamento della coda \u00e8 schematizzato all'interno della seguente figura.</p> <p></p>"},{"location":"material/01_intro/11_recursion/lecture/","title":"11 - Ricorsione","text":"<p>Quella della ricorsione \u00e8 una tecnica di programmazione che permette di \"spezzare\" un problema in diverse piccole parti, da trattare una alla volta fino alla risoluzione completa dello stesso. E' quindi in qualche modo assimilabile al paradigma \"divide-et-impera\", tanto caro agli strateghi dell'antica Roma.</p> <p>Nella pratica, si tratta di riapplicare una serie di istruzioni (e, quindi, una funzione) ad istanze sempre pi\u00f9 piccole del problema originario, fino a che non \u00e8 possibile giungere ad una risoluzione diretta; tuttavia, per comprenderne appieno il funzionamento, \u00e8 opportuno procedere con un esempio pratico.</p>"},{"location":"material/01_intro/11_recursion/lecture/#111-calcolo-del-fattoriale","title":"11.1 - Calcolo del fattoriale","text":"<p>Il fattoriale di un numero \\(n\\) \u00e8 indicato con \\(n!\\) ed \u00e8 dato dal prodotto di tutti i numeri che vanno da \\(1\\) ad \\(n\\). Formalmente:</p> \\[ n! = 1 \\cdot 2 \\cdot \\ldots \\cdot (n-1) \\cdot (n) \\] <p>Ad esempio, \\(3! = 6\\), mentre \\(4! = 24\\), \\(5! = 120\\), e via dicendo. Il fattoriale \u00e8 definito per ogni numero intero strettamente positivo, oltre che per lo \\(0\\), per il quale vale \\(0!=1\\).</p> <p>Proviamo per prima cosa a calcolare il fattorale usando un ciclo.</p>"},{"location":"material/01_intro/11_recursion/lecture/#1111-calcolo-iterativo-del-fattoriale","title":"11.1.1 - Calcolo iterativo del fattoriale","text":"<p>Calcolare il fattoriale mediante un ciclo \u00e8 molto semplice. Infatti, basta usare la formulazione stessa di fattoriale:</p> <pre><code>fatt = 1;\nfor i che varia da 1 ad n:\n    fatt = fatt * i;\nendfor\nreturn fatt;\n</code></pre>"},{"location":"material/01_intro/11_recursion/lecture/#1112-calcolo-ricorsivo-del-fattoriale","title":"11.1.2 - Calcolo ricorsivo del fattoriale","text":"<p>\"Complichiamoci\" la vita, e vediamo come \u00e8 possibile calcolare il fattoriale in maniera ricorsiva. Riprendiamo la definizione di fattoriale, applicando la propriet\u00e0 commutativa:</p> \\[ n! = n \\cdot(n-1) \\ldots 2 \\cdot 1 \\] <p>Notiamo che \\((n - 1)! = (n - 1) \\cdot \\ldots \\cdot 2 \\cdot 1\\), per cui possiamo scrivere che:</p> \\[ n! = n \\cdot (n - 1)! \\] <p>Abbiamo quindi scomposto il problema del calcolo del fattoriale di \\(n\\) nel problema della moltiplicazione di \\(n\\) per il fattoriale di \\((n-1)\\); di conseguenza, \\((n-1)!\\) \u00e8 un sottoproblema di \\(n!\\). Se provassimo ad estendere il concetto, avremmo che:</p> \\[ n! = n \\cdot (n-1)! = n \\cdot (n-1) \\cdot (n-2)! = \\ldots = n \\cdot (n-1) \\cdot \\ldots \\cdot 1 \\cdot 0! \\] <p>da cui deriva che:</p> \\[ 0! * 1 = 1 = 1! \\Rightarrow \\\\ \\Rightarrow 1! * 2 = 2 = 2! \\Rightarrow \\\\ \\Rightarrow \\ldots \\Rightarrow \\\\ \\Rightarrow (n-1)! * n = n! \\Rightarrow \\\\ \\]"},{"location":"material/01_intro/11_recursion/lecture/#11121-caso-base-e-ricorsione","title":"11.1.2.1 - Caso base e ricorsione","text":"<p>Risulta quindi che:</p> <ul> <li>nel caso \\(n=0\\), allora \\(n! = 1\\);</li> <li>nel caso \\(n &gt; 0\\), allora dobbiamo moltiplicare \\(n\\) per il valore restituito dalla funzione \\((n-1)!\\).</li> </ul> <p>Il caso \\(n =0\\) assume il nome di caso base, ed \u00e8 la situazione che cerchiamo per \"terminare\" la ricorsione; alternativamente, dovremo procedere a richiamare ricorsivamente la funzione desiderata.</p>"},{"location":"material/01_intro/11_recursion/lecture/#11122-implementazione-della-ricorsione","title":"11.1.2.2 - Implementazione della ricorsione","text":"<p>Proviamo ad implementare la funzione ricorsiva in pseudocodice. Scriviamo:</p> <pre><code>int factorial(int n):\n    if n = 0:\n        return 1;\n    else:\n        return n * factorial(n - 1);\n    endif\n</code></pre> <p>Analizziamo il comportamento della funzione. Se <code>n</code> \u00e8 maggiore di zero, la funzione restituir\u00e0 il prodotto tra <code>n</code> ed il risultato della funzione <code>factorial</code> applicata ad <code>n - 1</code>. La funzione quindi \"chiama s\u00e8 stessa\", usando parametri differenti, fino a che non ci si ritrova nel caso base, e viene restituito <code>1</code>.</p> <p>Ci si potrebbe chiedere come faccia la funzione ricorsiva a restituire il valore complessivo di \\(n!\\). La risposta \u00e8 da ricercarsi nel modo in cui sono memorizzati i dati durante la ricorsione: infatti, questi vengono organizzati secondo un call stack (traducibile in \"stack di chiamate\"), che conserva al suo interno i risultati derivanti dalle precedenti chiamate a funzione. Questo concetto \u00e8 riassunto nella seguente figura, che mostra il call stack per il calcolo ricorsivo del fattoriale di 4.</p> <p></p>"},{"location":"material/01_intro/12_paradigms/lecture/","title":"12 - I paradigmi di programmazione","text":"<p>Nella lezione 6 abbiamo parlato del paradigma della programmazione strutturata riferendoci a tutte quelle tecniche volte ad imprimere una certa struttura nel nostro codice. Abbiamo per\u00f2 anche sottolineato come quello della programmazione strutturata non sia l'unico paradigma di programmazione presente al giorno d'oggi; esistono infatti diversi altri approcci, tutti per\u00f2 riconducibili a due macro-aree, ovvero quelle della programmazione imperativa da un lato, e della programmazione dichiarativa dall'altro.</p>"},{"location":"material/01_intro/12_paradigms/lecture/#121-la-programmazione-imperativa","title":"12.1 - La programmazione imperativa","text":"<p>Come suggerito dal termine stesso, il paradigma della programmazione imperativa prevede che il nostro programma espliciti una sequenza ben definita di istruzioni da seguire, integrate secondo le strutture che abbiamo visto quando abbiamo parlato della programmazione strutturata.</p> <p>In generale, questo approccio risulta essere decisamente comprensibile dal programmatore, che si limita ad indicare una sequenza pi\u00f9 o meno articolata di \"ordini\"; tuttavia, \u00e8 importante sottolineare come la maggior chiarezza del paradigma imperativo rispetto a quello dichiarativo comporti contestualmente una maggior verbosit\u00e0 del primo rispetto al secondo.</p> <p>Esempi di linguaggi di programmazione che adottano il paradigma imperativo sono C, C++, Java e Python.</p> <p>Tra i linguaggi di programmazione imperativa si annoverano tre distinti \"stili\" di programmazione, ovvero quello strutturato (che abbiamo gi\u00e0 trattato), quello procedurale e quello modulare.</p> <p>In particolare, nell'approccio procedurale il programma viene suddiviso in piccole task, ciascuna delle quali \u00e8 descritta nel codice mediante una procedura, concetto assimilabile al moderno \"metodo\" o \"funzione\". Il paradigma modulare fa un ulteriore passo in avanti in tal senso, e struttura il programma in una serie di moduli indipendenti combinati tra loro a formare il software definitivo.</p>"},{"location":"material/01_intro/12_paradigms/lecture/#122-la-programmazione-dichiarativa","title":"12.2 - La programmazione dichiarativa","text":"<p>Il paradigma di programmazione dichiarativa prevede che il risultato richiesto sia descritto, e che non siano invece specificate le singole istruzioni da parte dello sviluppatore.</p> <p>In pratica, a differenza del paradigma imperativo, che definisce come arrivare ad un risultato, il paradigma dichiarativo si limita a descrivere ci\u00e0 che si vuole ottenere, posizionandosi di conseguenza pi\u00f9 vicino all'essere umano che al calcolatore (ovvero ad un livello di astrazione pi\u00f9 elevato). Esempi di linguaggi di programmazione che seguono il paradigma imperativo sono Prolog, Lisp o SQL.</p> <p>In analogia al paradigma imperativo, anche quello dichiarativo vede due possibili stili di programmazione, ovvero quello funzionale e quello logico. In ogni caso, i paradigmi dichiarativi sono generalmente pi\u00f9 complessi da utilizzare rispetto a quelli imperativi, in quanto richiedono un elevato apporto logico da parte del programmatore, che invece nel paradigma imperativo deve \"limitarsi\" ad implementare correttamente una sequenza di istruzioni.</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/","title":"13 - Ancora sulle strutture dati","text":"<p>In questa lezione, vedremo prima come progettare una pila ed una coda come degli array, per poi passare a presentare un altro tipo di strutture dati estremamente utilizzate, ovvero grafi ed alberi.</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#131-pila-come-array","title":"13.1 - Pila come array","text":""},{"location":"material/01_intro/13_adv_data_structures/lecture/#1311-variabili-da-utilizzare","title":"13.1.1 - Variabili da utilizzare","text":"<p>Proviamo adesso ad implementare una pila utilizzando un array. Per farlo, avremo bisogno di tre elementi:</p> <ol> <li>un array, che chiameremo <code>stack</code>;</li> <li>una variabile che indica l'elemento in cima allo <code>stack</code>, che chiameremo <code>top</code>;</li> <li>una variabile che indica la lunghezza dello <code>stack</code>, che chiameremo <code>capacity</code>.</li> </ol> <p>Da qui consegue che:</p> <ul> <li>lo <code>stack</code> \u00e8 pieno quando <code>top</code> \u00e8 pari a <code>capacity</code>;</li> <li>lo <code>stack</code> \u00e8 vuoto quando <code>top</code> \u00e8 pari a <code>0</code>.</li> </ul>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#1312-operazioni-di-push-e-pop","title":"13.1.2 - Operazioni di <code>push</code> e <code>pop</code>","text":"<p>Ricordiamo che lo stack segue una strategia LIFO, per cui una <code>push</code> prevede che sia inserito un nuovo elemento nella parte superiore dell'array (ovvero, all'indice <code>top</code>). Quindi:</p> <pre><code>push(stack, top, capacity, element):\n\nSTEP 1 -&gt; top = top + 1;\nSTEP 2 -&gt; if (top &gt;= capacity)\n              return ERROR;\nSTEP 3 -&gt; top = element;\n</code></pre> <p>Ci\u00f2 implica che:</p> <ul> <li>allo <code>STEP 1</code> viene aumentato il valore attuale di <code>top</code>;</li> <li>allo <code>STEP 2</code> viene verificato che <code>top</code> non sia superiore a <code>capacity</code>, e che quindi la pila non sia gi\u00e0 piena;</li> <li>allo <code>STEP 3</code> l'elemento <code>element</code> viene inserito al posto <code>top</code> dello della pila.</li> </ul> <p>L'operazione di <code>pop</code> invece prevede che l'elemento al vertice dello stack sia rimosso:</p> <pre><code>pop(stack, top)\n\nSTEP 1 -&gt; if (top &lt;= 0):\n              return ERROR;\nSTEP 2 -&gt; element = top;\nSTEP 3 -&gt; top = top - 1;\nSTEP 4 -&gt; return element;\n</code></pre> <p>Ci\u00f2 implica che:</p> <ul> <li>allo <code>STEP 1</code> si verifica che lo <code>stack</code> non sia vuoto;</li> <li>allo <code>STEP 2</code> viene assegnato ad <code>element</code> il valore presente al <code>top</code> dello <code>stack</code>;</li> <li>allo <code>STEP 3</code> il valore di <code>top</code> viene ridotto di uno;</li> <li>allo <code>STEP 4</code> viene restituito il valore estratto dallo <code>stack</code>.</li> </ul>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#132-coda-come-array","title":"13.2 - Coda come array","text":""},{"location":"material/01_intro/13_adv_data_structures/lecture/#1321-variabili-da-utilizzare","title":"13.2.1 - Variabili da utilizzare","text":"<p>Anche in questo caso dovremo usare tre diversi elementi:</p> <ol> <li>un array, che chiameremo <code>queue</code>;</li> <li>una variabile che indica l'elemento da pi\u00f9 tempo in coda, chiamata <code>first</code>;</li> <li>una variabile che indica la lunghezza della <code>queue</code>, che chiameremo <code>capacity</code>.</li> </ol> <p>Ovviamente, come nel caso precedente, se <code>first</code> \u00e8 uguale a <code>capacity</code> allora la coda \u00e8 piena.</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#1322-operazioni-di-enqueue-e-dequeue","title":"13.2.2 - Operazioni di enqueue e dequeue","text":"<p>Ricordiamo che la strategia seguita da una coda \u00e8 di tipo FIFO, per cui dovremo definire i metodi <code>enqueue</code> e <code>dequeue</code>.</p> <p>In particolare, il metodo <code>enqueue</code> prevede che al primo posto nell'array sia inserito l'elemento che si vuole aggiungere.</p> <pre><code>enqueue(array, element)\n\nSTEP 1 -&gt; if (first &gt;= capacity):\n              return ERROR;\nSTEP 2 -&gt; for element in queue:\n              element = prev_element;\nSTEP 3 -&gt; last = new_element;\n</code></pre> <p>In pratica:</p> <ul> <li>allo <code>STEP 1</code>, controlliamo che la coda non sia gi\u00e0 satura;</li> <li>allo <code>STEP 2</code>, spostiamo ogni elemento della coda in avanti (in pratica, assegnamo a ciascun elemento il valore dell'elemento precedente nella coda);</li> <li>allo <code>STEP 3</code>, aggiungiamo il nuovo elemento in ultima posizione.</li> </ul> <p>La procedura di <code>dequeue</code>, di converso, comporta la semplice rimozione dell'ultimo elemento nell'array.</p> <pre><code>dequeue(array)\n\nSTEP 1 -&gt; remove first from queue;\nSTEP 2 -&gt; first = prev_element;\n</code></pre> <p>In altre parole:</p> <ul> <li>allo <code>STEP 1</code> viene rimosso il primo elemento dalla coda;</li> <li>allo <code>STEP 2</code> il valore di first viene aggiornato, assegnandovi quello associato all'elemento immediatamente precedente.</li> </ul>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#133-grafi","title":"13.3 - Grafi","text":"<p>Il concetto di grafo pu\u00f2 essere compreso in maniera intuitiva partendo da quelli che sono i nostri contatti sulle reti sociali (possiamo tranquillamente pensare a Facebook).</p> <p>Chiunque abbia un account su Facebook, infatti, ha una serie pi\u00f9 o meno estesa di \"collegamenti\", i quali a loro volta possono essere collegati tra loro, andando a creare una sorta di \"intreccio\" di relazioni. Rappresentando ciascun account con un punto, e tutti i collegamenti mediante delle linee, avremmo una situazione pi\u00f9 o meno simile a quella che vediamo nella figura seguente.</p> <p></p> <p>Notiamo anche che, nella maggior parte dei casi, la conoscenza tra due persone \u00e8 bidirezionale: ovvero, dato che noi conosciamo una certa persona, questa persona ci conoscer\u00e0 a sua volta.</p> <p>Questo modo di schematizzare una rete sociale avviene mediante una struttura nota come grafo.</p> <p>Formalmente, un grafo \u00e8 definito come una coppia \\(G=(V, E)\\), dove \\(V\\) \u00e8 l'insieme dei vertici, o nodi (quelli che abbiamo prima chiamato \"punti\"), mentre \\(E\\) \u00e8 l'insieme degli archi, o lati che connette detti vertici (le \"linee\"). Interessante notare come un arco possa essere rappresentato mediante i nodi che connette: infatti, si pu\u00f2 dire che l'arco che connette i vertici \\(u\\) e \\(v\\) \u00e8 descrivibile mediante la coppia \\((u, v)\\).</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#1331-grafi-diretti-e-non-diretti","title":"13.3.1 - Grafi diretti e non diretti","text":"<p>Nell'esempio precedente, abbiamo visto come le relazioni all'interno di un social network siano perlopi\u00f9 bidirezionali. Non \u00e8 quindi possibile individuare una direzione \"specifica\" nell'arco che collega due nodi: l'arco che collega i nodi \\(u\\) e \\(v\\) pu\u00f2 essere inteso sia come un collegamento che da \\(u\\) va verso \\(v\\), sia, al contrario, come un collegamento che va da \\(v\\) verso \\(u\\). Una situazione di questo tipo implica la presenza di un grafo non diretto. In un grafo non diretto l'arco \\((u, v)\\) coincide quindi con l'arco \\((v, u)\\).</p> <p>Per un grafo non diretto possiamo definire la condizione di adiacenza per due vertici \\(u\\) e \\(v\\):</p> <p>Vertici adiacenti</p> <p>Due vertici \\(u\\) e \\(v\\) sono definiti adiacenti o vicini quando vi \u00e8 un arco che li connette.</p> <p>Contestualmente, possiamo definire il concetto di grado di un vertice:</p> <p>Grado di un vertice</p> <p>Si definisce grado di un vertice \\(u\\) il numero di archi che vi incidono.</p> <p>Ad esempio, se abbiamo cento contatti su Facebook, il nostro \"grado\" all'interno del social network sar\u00e0 proprio pari a 100.</p> <p>Viceversa, se ad ogni arco \u00e8 associata una direzione, otterremo un grafo diretto, nel quale non sar\u00e0 sempre possibile andare indifferentemnete da \\(u\\) a \\(v\\), e viceversa. Per fare un esempio di grafo indiretto, immaginiamo che i nodi del nostro grafo siano gli incroci di una citt\u00e0, mentre i lati le vie che li connettono; in tal senso, ogni via a senso unico sar\u00e0 un esempio di arco diretto, e percorrobile (teoricamente) in un'unica direzione.</p> <p>Per un grafo diretto dovremo ridefinire il concetto di grado, separandolo in due concetti distinti.</p> <p>Grado esterno</p> <p>Si definisce grado esterno, o out-degree, di un vertice \\(u\\) il numero di archi in uscita da \\(u\\).</p> <p>Grado interno</p> <p>Si definisce grado interno, o in-degree, di un vertice \\(u\\) il numero di archi in ingresso su \\(u\\).</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#1332-cammini-e-cicli","title":"13.3.2 - Cammini e cicli","text":"<p>Prendendo una licenza ed usando un \"gioco di parole\", immaginiamo di voler contattare il contatto di un nostro contatto. Per farlo, potremmo semplicemente chiedere al nostro amico di presentarci il suo amico il quale, ovviamente, non ha un collegamento diretto con noi, ma che risulta essere in qualche modo \"raggiungibile\": esiste, quindi, un percorso o, pi\u00f9 propriamente, un cammino, che mette in relazione noi con la nostra conoscenza futura.</p> <p>Ovviamente, il numero di cammini esistenti tra due nodi \\(u\\) e \\(v\\) \u00e8 potenzialmente molto elevato, se non addirittura infinito: ad esempio, nel caso precedente, potremmo sicuramente costruire una rete di contatti indiretti con la quale arrivare al nostro obiettivo in maniera pi\u00f9 \"larga\". Tuttavia, \u00e8 opportuno sempre cercare il cammino minimo (shortest path), che rappresenta il modo pi\u00f9 diretto per arrivare al nostro obiettivo.</p> <p>Definiamo inoltre altre due condizioni.</p> <p>Cicli</p> <p>Un cammino che ha come punto di partenza e di arrivo lo stesso vertice \u00e8 chiamato ciclo.</p> <p>Connessione del grafo</p> <p>Un grafo si dice connesso quando esiste almeno un percorso che colleghi due nodi \\((u, v)\\), \\(\\forall (u, v) \\in V\\).</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#13321-un-esempio","title":"13.3.2.1 - Un esempio","text":"<p>Facciamo un esempio pratico. Immaginiamo che Bob voglia conoscere Eric; come \u00e8 possibile notare, non esiste alcun grafo che li collega. Tuttavia, Bob ha due strade: la prima \u00e8 quella di chiedere ad Alice di presentargli Charlie, che potrebbe a sua volta introdurgli Eric. La seconda, invece, prevede che Bob si metta in contatto con David, che potr\u00e0 direttamente introdurgli Eric.</p> <p></p> <p>Abbiamo quindi individuato due cammini tra Bob ed Eric, di cui uno (quello che passa per David) \u00e8 da considerarsi minimo, in quanto tiene conto del numero minimo di vertici e lati intercorrenti tra il nodo di partenza e quello di arrivo.</p> <p>Per quello che riguarda i cicli, quello che va da Alice verso Bob verso David e torna poi ad Alice \u00e8 da considerarsi appunto come tale.</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#1333-grafo-pesato","title":"13.3.3 - Grafo pesato","text":"<p>E' possibile che a tutti gli archi di un grafo sia associato un peso, ovvero un valore numerico. In uno degli esempi precedenti, ovvero quello delle vie e degli incroci, potremmo associare ad ogni strada un numero indicativo della sua lunghezza in metri:</p> <p></p> <p>Un grafo i cui archi hanno dei pesi \u00e8 chiamato grafo pesato. Ovviamente, per trovare il cammino minimo in un grafo di questo tipo, dovremo tenere conto del valore dei pesi: nella figura precedente, infatti, TODO: esempio</p>"},{"location":"material/01_intro/13_adv_data_structures/lecture/#134-alberi","title":"13.4 - Alberi","text":"<p>Un concetto cugino di quello di grafo \u00e8 quello di albero, struttura dati particolarmente usata soprattutto in ambito informatico, che permette di modellare una struttura gerarchica fatta di un nodo radice e di una serie di nodi figli, fino ai nodi foglia, ovvero quelli che non hanno ulteriori successori.</p> <p>Per comprendere al meglio la struttura di un albero, vediamo quella che \u00e8 la \"geneaologia\" della razza umana (in versione volutamente semplificata):</p> <p></p> <p>In particolare, notiamo come a partire da un \"antenato comune\" (il famoso \"anello mancante\") si siano evoluti diversi rami dell'albero, ognuno afferente ad un diverso genere, di cui gli ultimi esemplari rappresentano i nodi foglia; nel nostro caso, l'Homo sapiens \u00e8 la foglia del ramo rappresentativo del genere Homo.</p> <p>Nota</p> <p>L'albero \u00e8 un grafo, con delle particolari caratteristiche: infatti, \u00e8 non diretto, connesso ed aciclico (ovvero, non presenta alcun ciclo al suo interno).</p> <p>Concludiamo questo excursus citando infine gli alberi binari, caratterizzati dal fatto che ciascun nodo ha (al pi\u00f9) due figli.</p>"},{"location":"material/01_intro_new/01_intro/","title":"Introduzione all'informatica","text":"<p>Come per molti degli argomenti cui ci si approccia nel corso della vita, trovare una definizione per il concetto di informatica pu\u00f2 aiutare a comprenderne al meglio la natura.</p> <p>Partiamo quindi da una (breve) analisi etimologica del termine informatica. Questo, infatti, \u00e8 la traduzione italiana del francese informatique, crasi delle parole informa(tion) ed (automa)tique. Intuitivamente, possiamo dedurre che la disciplina tratti quindi di \"informazioni automatiche\" o, per meglio dire, automatizzazione delle informazioni.</p> <p>E, se ci pensiamo, \u00e8 proprio di quello che si occupa l'informatica, ovvero di gestire in maniera automatica una serie pi\u00f9 o meno rilevante di informazioni, correlate ad un qualsiasi aspetto della nostra vita, siano esse le nostre foto su Facebook, il nostro libretto universitario oppure i dati dei nostri conti corrente bancari: tutte queste informazioni vengono elaborate in maniera (pi\u00f9 o meno) automatica.</p> <p>Proviamo ad arricchire questa prima, un po' generica, definizione. Per farlo, sfruttiamo un'altra denominazione straniera, ovvero quella inglese, lingua nella quale l'informatica \u00e8 chiamata computer science. Quello che notiamo di questa definizione \u00e8 il termine science, che ci suggerisce come l'informatica, in realt\u00e0, sia basata su solide fondamenta scientifiche: per capirci, infatti, i \"padri fondatori\" della materia erano prevalentemente dei matematici, uno fra tutti il celebre Alan Turing.</p> <p>L'ultimo fattore da tenere in conto \u00e8 che l'informatica rappresenta uno vero e proprio pilastro della societ\u00e0 moderna. Tutto ci\u00f2 che utilizziamo al giorno d'oggi, dallo smartphone che stiamo usando per leggere questo documento, al computer mediante il quale \u00e8 stato scritto, fino ad arrivare alle nostre auto, o anche ai termostati nelle nostre caldaie, sono basati su tutte le evoluzioni informatiche (ed elettroniche) succedutesi a partire dal Secondo Dopoguerra.</p> <p>Ecco, quindi, che possiamo dare una definizione \"finale\" di informatica, presa direttamente dall'Oxford Languages:</p> <p>L'informatica</p> <p>L'informatica \u00e8 la scienza che si occupa dell'ordinamento, del trattamento e della trasmissione delle informazioni per mezzo dell'elaborazione elettronica, la quale rende possibile gestire e organizzare le ingenti masse di dati prodotte dal moderno sviluppo sociale, scientifico e tecnologico.</p> <p>Ora, non \u00e8 tanto importante memorizzare questa definizione, quanto piuttosto comprenderne la portata: l'informatica \u00e8 ovunque, e conoscerla ci d\u00e0 l'accesso alle porte di quello che \u00e8 il mondo odierno.</p>"},{"location":"material/01_intro_new/01_intro/#informatica-ed-informazione","title":"Informatica ed informazione","text":"<p>Vediamo altre definizioni.</p> <p>Definizione</p> <p>Studio degli algoritmi che descrivono e trasformano l'informazione: la loro teoria, analisi, progetto, efficienza, realizzazione ed applicazione.</p> <p>Definizione 2</p> <p>Scienza della rappresentazione e della elaborazione dell'informazione</p> <p>L'informazione \u00e8 costituota dal connubio di dati (rappresnetazioni di entit\u00e0 di interesse) ed interpretazione (regole per comprendere e manipolare i dati).</p>"},{"location":"material/01_intro_new/01_intro/#componenti-dellinformazione","title":"Componenti dell'informazione","text":"<p>L'informazione deve essere scritta su un qualche supporto fisico che funga da veicolo (ad esempio carta o disco magnetico).</p> <p>Il linguaggio \u00e8 un insieme di regole che permette di scrivere e leggere infomrazione, oltre che interpretarla.</p> <p>Un linguaggio \u00e8 tipicamente costituito da alfabeto (insieme di simboli appartenenti al linguaggio) e regole (insieme di regole che permettono di combinare tali simboli in costrutti del linguaggio ed interpretarli).</p> <p>Affinch\u00e9 ogni simbolo contribuisca con un minimo di infomrazione, un alfabeto deve avere almeno due simboli distinti.</p>"},{"location":"material/01_intro_new/01_intro/#sistemi-automatici","title":"Sistemi automatici","text":"<p>L'elaborazione automatica dell'infomraizone avviene grazie ad una rappresentazione gestibile. Esistono fonti di informazioni diverse, e il loro trattamento automatico richiede uniformit\u00e0 nella modalit\u00e0 con cui venogno rappresentate.</p> <p>L'infomrazione gestita da un calcolatore viene quindi mantenuta in forma numerica, con il pi\u00f9 semplice sistema di numerazione possibile, quello binario (due soli simboli).</p> <p>I dati vengono memorizzati mediante numeri interi finiti.</p>"},{"location":"material/01_intro_new/01_intro/#rappresentazione-dei-dati","title":"Rappresentazione dei dati","text":"<p>Un dato pu\u00f2 essere di vari tipo:</p> <ul> <li>categorico (ross, verede, blu)</li> <li>ordinale (orrendo, brutto, bello, fantastico)</li> <li>numerale discreto: 10, 159, -10</li> <li>numerale continuo: 10^13, \\sqrt(2)</li> </ul> <p>Ognuno di questi tipi pu\u00f2 essere rappresentato (anche in maniera approssimata) mediante un numero intero con unit\u00e0 frazionaria).</p> <p>Categorici come interi</p> <p>Per farlo, usiamo un metodo chiamato del dizionario. In pratica, ad ogni possibile valore \u00e8 associato un numero intero, con il quale questo sar\u00e0 rappresentato.</p> <p>Ad esempio:</p> <pre><code>{\n    rosso = 1\n    verde = 2\n    blu = 3\n}\n</code></pre> <p>L'unica operazione definita su un dato di questo tipo \u00e8 l'uguaglianza, e la codifica preserva questa operazione. In pratica, se rosso = rosso, allora 0 = 0.</p> <p>Ordinali come interi</p> <p>Per rpapresentare gli ordinali come interi si usa il metodo dell'enumerazione.</p> <p>I valori sono ordinati, e ad ognuno \u00e8 associato un valore intero cresscente.</p> <p>orrendo = 0 brutto = 1 bello = 2 Fantastico  = 3</p> <p>La codifica in questo caso rappresenta la relazione di ordine:</p> <p>orrendo &lt; bello  =&gt; 0 &lt; 2</p>"},{"location":"material/01_intro_new/01_intro/#codifica-analogica-e-digitali","title":"Codifica analogica e digitali","text":"<p>Una codifica si dice analogica se mantiene un'analogia tra la struttura dell'entit\u00e0 di informazione e la struttura della configurazione (possiamo parlare di codifica continua).</p> <p>Una codifica si dice digitale se impone un numero di configuraizone distinti ammissibili e converte un'entit\u00e0 di infomrazioe in una di queste configuraizoni mediante una regola di codifica (codifica discreta).</p> <p>Come \u00e8 meglio codificare l'informazione per la sua elaborazione automatica mediante un calcolatore?</p>"},{"location":"material/01_intro_new/01_intro/#vantaggi-della-codifica-digitale","title":"Vantaggi della codifica digitale","text":"<p>Qualsiasi sistema fisico (incluso il calcolatore) \u00e8 sottoposto all\u2019influenza dell\u2019ambiente circostante che ne perturba la configurazione introducendo rumore \u2022 E\u2019 necessario rendere il sistema fisico che elabora l\u2019informazione il pi\u00f9 immune possibile al rumore \u2022 La codifica analogica \u00e8 fortemente sensibile al rumore, poich\u00e9 tutte le configurazioni sono lecite e non si pu\u00f2 distinguere la componente di informazione dal contributo dovuto al rumore \u2022 Minore \u00e8 il numero di configurazioni possibili maggiore \u00e8 la possibilit\u00e0 di isolare l\u2019informazione dal rumore \u2022 E\u2019 questa la ragione principale del successo della codifica binaria nei calcolatori elettronici (la pi\u00f9 estrema codifica discreta due soli valori per ogni simbolo)</p>"},{"location":"material/01_intro_new/01_intro/#campionamento","title":"Campionamento","text":"<p>\u2022 Permette di approssimare in maniera arbitrariamente accurata informazione continua ( \u2022 Consiste nel \u2022 misurare il segnale ad intervalli regolari (di tempo se evolve nel tempo, come un suono di spazio se immagine entrambi se video) \u2022 approssimare ogni misura continua con un valore discreto</p> <p>Perch\u00e9 il sistema binario per gli elaboratori? \u2022 Oltre alla minore sensibilit\u00e0 al rumore \u2022 I calcolatori funzionano con l\u2019energia elettrica \u2022 L\u2019energia elettrica viene gestita da transistor (\u201d che hanno due posizioni acceso 1 e spento 0</p> <p>\u2022 Il termine informazione nel linguaggio comune \u00e8 spesso usato come sinonimo di messaggio \u2022 Def MESSAGGIO \u00e8 una combinazione di simboli \u2022 Def INFORMAZIONE \u00e8 la misura dell\u2019ampiezza della classe dei messaggi alla quale appartiene un dato messaggio \u2022 Prendiamo un messaggio XXXX dove X \u00e8 uno dei simboli dell\u2019alfabeto standard (A, B,......,J, K,......, composto da 26 simboli \u2022 L\u2019informazione \u00e8 data dalla cardinalit\u00e0 dell\u2019insieme di messaggi formati da 4 simboli X \u2022 XXXX \uf0e0 26 4</p> <p>\u2022 L\u2019informazione viene misurata in bit \u2022 Il numero di bit di informazione di ogni messaggio \u00e8 dato per convenzione dal log 2 della numerosit\u00e0 della classe di messaggi disponibili \u2022 Un\u2019 informazione di n bit pu\u00f2 essere rappresentata da uno fra 2 n simboli diversi o da un insieme ordinato di n simboli binari</p> <p>Ricordare:</p> \\[ log_a b = \\frac{log_c b}{log_c a} \\] \\[ log_2 b = \\frac{log_{10} b}{log_{10} 2} \\] <p>Esempio \u2022 Sia dato un messaggio XXYYY (X \u00e8 uno dei simboli dell\u2019alfabeto standard (A, B,......, Y \u00e8 uno dei simboli dell\u2019alfabeto binario 0 1 \u2022 L\u2019informazione \u00e8 26 2 x( 2 3 \u2022 L\u2019informazione misurata in bit \u00e8 log 2 26 2 x( 2 3</p> <p>Numero di cifre necessario per rappresentare una quantit\u00e0 \u2022 Con n bit il numero X pi\u00f9 grande rappresentabile \u00e8 2n-1, il numero pi\u00f9 piccolo \u00e8 2n-1</p> <p>\u2022 Il concetto di numero \u00e8 indipendente dalla sua rappresentazione ( \u2022 Un sistema di numerazione \u00e8 uno schema per codificare numeri \u2022 \u00e8 definito da \u2022 cifre \u2022 regole da applicare per costruire i numeri \u2022 Esistono due categorie di sistemi di numerazione \u2022 addizionali \u2022 posizionali</p> <p>Sistemi di Numerazione Addizionali \u2022 In un sistema di numerazione addizionale ogni simbolo ha un valore fisso indipendente dalla posizione che occupa \u2022 Il sistema pi\u00f9 semplice \u00e8 quello in cui si usa come simbolo un\u2019unica barretta || \uf0e0 2 ||||| \uf0e0 5</p> <p>Sistemi di Numerazione Addizionali Sistema di Numerazione Romano \u2022 Il sistema addizionale pi\u00f9 conosciuto \u00e8 quello romano \u2022 Simboli I= 1 V= 5 X= 10 L= 50 C= 100 D= 500 M= 1000 \u2022 Regola il valore di ciascun simbolo viene sommato se alla sua destra compare un simbolo di valore inferiore o uguale (o se \u00e8 l\u2019ultimo), altrimenti viene sottratto DCXXII \uf0e0 622 CMV \uf0e0 905</p> <p>Sistemi di Numerazione Posizionali \u2022 In un sistema di numerazione posizionale il valore di ogni cifra dipende dalla sua posizione all\u2019interno del numero \u2022 ad ogni posizione \u00e8 associato un peso pi \u2022 le posizioni si contano da destra a sinistra a partire da 0 \u2022 Il valore della cifra viene moltiplicato per la base b elevata alla posizione N c n 1 c n 2 c 1 c 0 V(N) N)==(c n 1 b n 1 ))++(c n 2 b n 2 ))++....++(c 1 b 1 ))++(c 0 b 0 notazione espansa)</p> <p>Sistemi di Numerazione Posizionali Forma polinomiale \u2022 Possiamo definire la seguente relazione detta forma polinomiale \u2022 analogamente possiamo scrivere numeri frazionari: \u2022 o numeri con parte intera e parte frazionaria: Informatica per l\u2019ingegneria 26 Nota Il sistema di numerazione in base 10, o sistema decimale, \u00e8 il sistema comunemente usato, ed i numeri in base 10 sono rappresentati di norma senza l\u2019indicazione della base.</p> <p>Sistema Binario (base \u2022 E\u2019 il sistema di numerazione con la base pi\u00f9 piccola possibile \u2022 In questo caso le cifre sono 0 1 \u2022 Si parla di cifra binaria binary digit o bit) \u2022 Il bit \u00e8 l\u2019unit\u00e0 minima di informazione</p> <p>Sistema Binario (base Vantaggio minor numero di simboli fondamentali 0 1 facilit\u00e0 di stabilire una corrispondenza biunivoca con due possibili stati di funzionamento dei circuiti elettronici Svantaggio maggior numero di cifre necessarie per rappresentare un numero ( 2 cifre decimali 7 cifre binarie)</p> <p>Conversioni di base \u2022 I numeri sono concetti astratti rappresentabili in una qualsiasi base di numerazione (a seconda di quanti simboli si possono combinare tra loro) \u2022 \u00c8 possibile che la stessa quantit\u00e0 sia descritta in modi diversi, cio\u00e8 usando simboli diversi di un sistema di numerazione basato su una base diversa \u2022 Ci\u00f2 comporta la necessit\u00e0 di passare da una base di numerazione ad un\u2019altra, attraverso dei meccanismi matematici molto semplici \u2022 L\u2019operazione con cui si passa da una base di numerazione ad un\u2019altra, si chiama conversione di base</p> <p>Conversione Base 10 \uf0e0 Base B Interi Numeri interi \u2022 Un numero intero in base 10 si pu\u00f2 esprime in base B dividendolo ripetutamente per B fino ad ottenere un quoziente 0 e recuperando i resti in ordine inverso alla loro determinazione \u2022 Quindi se la base \u00e8 2 \u2022 dividere ripetutamente per 2 fermandosi solo quando si ottiene un quoziente nullo i resti delle divisioni effettuate, presi in ordine inverso a quello con cui sono stati calcolati, formano il numero convertito</p> <p>Conversione Base 10 \uf0e0 Base B Frazionari \u2022 Un numero intero in base 10 si pu\u00f2 esprime in base B dividendolo ripetutamente per B fino ad ottenere un quoziente 0 e recuperando i resti in ordine inverso alla loro determinazione \u2022 Per la parte frazionaria moltiplicare ripetutamente per B fino ad ottenere un valore 0 e recuperando la parte intera nell\u2019ordine di determinazione Informatica per l\u2019ingegneria 33 (11,25) 10 = ( 2 Oppure fino a raggiungere il numero massimo di cifre binarie con cui si intende rappresentare il numero frazionario (si ottiene un\u2019approssimazione per difetto del numero decimale). Infatti, in alcuni casi il risultato della moltiplicazione per 2 non arriver\u00e0 mai ad avere parte decimale nulla</p>"},{"location":"material/02_algorithms/14_sorting/lecture/","title":"15 - Insertion sort","text":"<p>Il secondo algoritmo che vedremo \u00e8 l'insertion sort. Per introdurlo, partiamo dal</p> <p>un altro modo \u00e8 l\u2019insertion sort. Immaginiamo che stimao giocando un gioco di carte. Stiamo tenendo delle carte in mano, e tutte queste carte sono ordinate. Il dealer ci d\u00e0 esattamente una nuova carta. Si deve metterla nel posto corretto in modo che la carta cheabbiamo in mano siano ancora ordinate. Nel selection sort, ogni elemento che aggiungiamo all\u2019array ordinato non pu\u00f2 essere pi\u00f9 piccolo degli elementi gi\u00e0 presenti nell\u2019arry ordinato. Ma nel nostro esempio, la nuova carta pu\u00f2 essere pi\u00f9 piccola delle carte che abbiamo gi\u00e0 in mano, per cui dobbiamo andare gi\u00f9 nella linea, comparando le nuove card con ognuna delle carte in mano, fino a che non troviamo un posto epr inserirla. Inseriamo la nuova carta nel punto giusto, e nuovamente la nostra mano ha delle card completamente ordinate. Quindi il dealer ci da un\u2019altra carta, e si ripete la stesa procedura. Quindi un\u2019altra carta, e via dicendo, fino a che il dealer non ci d\u00e0 pi\u00f9 alcuna carta.</p> <p>Questa \u00e8 l\u2019idea dietro linsertion sort. Iterare nelle posizsioni dell\u2019array, a partire dall\u2019indice 1. COn ogni nuova posizione \u00e8 come la nuova carta che civieen data dal dealer, e dobbiamo inserirla nel psto corretto nel subarray ordinato a sinistra di quella posizione.</p> <p>Immaginiamo che il subarray dall\u2019indice 0 all\u2019indice 5 sia gi\u00e0 ordinato, e vogliamo inserire l\u2019ekemeto attuamlmente all\u2019indice 6 in questo subarray gi\u00e0 ordinato, in modo che il subarray dall\u2019indice 0 all\u2019indice 6 sia ordinato.</p> <p>2 3 7 8 10 13 5  PER ARRIVARE A 2 3 5 7 9 10 13</p> <p>Per inserire l\u2019eeento in posizione 6 nel subarray alla sua sinsitra, compariamo ripetutatmente questo con gli elementi alla sua sinistra, andando da destra verso sinistra. Chiamaiamo quindi l\u00ecelemento in posizione 6 chiave. ogni volta che capiamo che la chiave \u00e8 inferiroe di un elemento alla sua sinistra, lo spostiamo verso destra, dal momento che sappiamo che la chiave dovr\u00e0 andare alla sinistra di quell\u2019elemento. Dovremo fare altre due cose per far funzionare questa idea: dovremo avere un\u2019operazione slide (che sposta un elemento di una posizione a destra), e dovremo salvare il valore della chiave in un puno separato. Nel nostro esempio, :</p> <p>1.- inseriamo l\u2019elemento all\u2019indice 6 in ua variabile chiamata key compariamo key con l\u2019elemento alla posizione 5. sappiamo che key \u00e8 inferiore all\u2019elemento in posizione 5, quindi faccioamo lo slide di questo alla posizione 6.</p> <p>Notiamo che l\u2019operazione di slide si limita a copiare l\u2019eemento una posizione a destra. Quindi, compariamo key con l\u2019elemento in posizione 4. troviamo che key \u00e8 inferiore, e reiteriamo la procedura.</p> <p>Quando l\u2019elemento\u00e8 inferiore di key, non effettuiamo l\u2019operazione di slide. Invece, lasciamo la variabile key in quella posizione, immediatamente all\u2019elemento a destra. Il risultato \u00e8 \u2018ordinamento di tutto l\u2019array.</p> <p>Il nome dell\u2019insertion sort deriva dal fatto che questo inserisce ripetutamente un elemento nel subarray a sinistra dell\u2019elemento che sta valutando. Di conseguenza, nel caso generale, si parte considerando sempre il primo elemento del subarray (o meglio un subarray di un elemento), che non pu\u00f2 non essere ordinato (\u00e8 ordinato rispetto a se stesso). La prima chiave sar\u00e0 quindi l\u2019elemento con indice 1. </p> <p>10   7   3  13 7 10   3 13</p> <p>A questo punto, il subarray ordinato va da 0 ad 1, quindi il nuovo key \u00e8 indice 2. compariamo questo con quelli a sinistra ed abbiamo:</p> <p>7 10 3 13 7 3 10 13 3 7 10 13</p> <p>Ci sono un paio di situazioni limite. Il primo \u00e8 quando l\u2019elemento chiave \u00e8 inferiore a tutti gli elementi nel subarray ordinato; il secondo \u00e8 qunado invece \u00e8 superiore. Nel primo, ogni elemento del subarray deve effettuare uno slide, nel secondo non ci sono slide da effettuare.</p> <p>pseudocdice</p> <p>chiamo insert per inserire l\u2019elemento cheinizia all\u2019indice 1 nell\u2019array ordinato all\u2019indice 0. chiamo insert per insierire l\u2019elemento che inizia all\u2019indice 2 nell\u2019array ordinato in un indice che va da 0 ad 1. \u2026 Chiamo insert per insserire l\u2019elemento che inizia all\u2019indice n-1 nell\u2019array ordinato nell\u2019indice che va da 0 ad n - 2.</p> <p>analisi come nel caso del selection sort, l\u2019insertion sort fa un loop sugli indici dell\u2019array. chiama semplicemente insert sugli elementi di indice che vanno da 1 ad n-1. Ogni chiamata ad insert richiede un certo periodo di tempo.</p> <p>Prendiamo una situazione nella quale chiamoiamo insrt ed il valore che viene inserito nel subarray \u00e8 inferiore ad ogni elemento nel sybarray. Quindi, ogni elemento nel subarray dovr\u00e0 effettuare lo slide di una posizione a sinistra. Per cui, in generale, se stiamo inserendo un nuovo elemento in un subarray con k elementi, tutti i k elementi dovranno effettuare uno slide di una posizione. Pitutosto che contare esattamente quante linee di codice dobbiamo usare, diciamo che questo numero \u00e8 c. Quindi, potremmo aver bisogno di c * k linee per inserire un valore in un subarray di k elementi.</p> <p>Supponiamo che ad ogni chiamata ad insert, il valore che venga inserito sia inferirore ad ogni elmento nel subarray alla sua sinsitra. Quando chiamiamo insert la prima vlta, con k = 1. La seconda volta, k = 2. La terza volta, k = 3. E via, fino all\u2019ultima volta, quando k = n -1. Quinid, il tempo totale speso ad inserire qualcosa nel sub array \u00e8</p> <p>c * (1 + 2 + .. + n-1).</p> <p>Anche in questo caso abbiamo una serie aritmetica. Tornando alla notazione, O(n^2).</p> <p>Molto probabilmente, per\u00f2, l\u2019insertion sort potrebbe avere meno tempo necessario (ad esempio, questo accadrebbe nel caso avessimo un array gi\u00e0 ordinato). Per\u00f2 non \u00e8 detto, quindi \u00e8 necessario sempre e comunque considerare un tempo pari a O(n^2). Potremmo per\u00f2 considerare il caso migliroe, che avrebbe un O(n) (in questo caso l\u2019array \u00e8 gi\u00e0 quasi ordinato).</p>"},{"location":"material/02_algorithms/14_sorting/selection_sort/","title":"14 - Algoritmi di ordinamento","text":"<p>Uno dei problemi pi\u00f9 \"classici\" nello studio degli algoritmi \u00e8 quello di ordinare una lista di elementi affini (ovvero dello stesso tipo). Questo problema, soltanto apparentemnete banale, ha in realt\u00e0 numerosi riscontri pratici, in quanto capita molto spesso di dover ordinare una lista secondo un certo criterio (ad esempio, un elenco di nomi in ordine alfabetico, oppure i prezzi di diversi beni in ordine ascendente). Per far questo, nel tempo sono stati definiti diversi algoritmi detti di ordinamento o, in inglese, sorting algorithms. Vediamone alcuni tra i pi\u00f9 conosciuti.</p>"},{"location":"material/02_algorithms/14_sorting/selection_sort/#141-selection-sort","title":"14.1 - Selection sort","text":"<p>Il primo algoritmo che vedremo \u00e8 chiamato selection sort. Questo \u00e8 un algoritmo di tipo iterativo, che analizza quindi un elemento della lista alla volta alla ricerca dell'elemento minore; per comprendere appieno il funzionamento dell'algoritmo, \u00e8 opportuno utilizzare un esempio concreto.</p>"},{"location":"material/02_algorithms/14_sorting/selection_sort/#1411-esempio-e-formalizzazione","title":"14.1.1 - Esempio e formalizzazione","text":"<p>Immaginiamo quindi di voler ordinare un mazzo di dieci carte dalla pi\u00f9 piccola alla pi\u00f9 grande. Per farlo, seguiamo questi passi:</p> <ol> <li>disponiamo tutte le carte presenti nel mazzo in un'unica fila;</li> <li>cerchiamo la carta pi\u00f9 piccola, e posizioniamola all'estrema sinistra del mazzo;</li> <li>dividiamo la fila in due parti: nella parte pi\u00f9 a sinistra inseriamo le carte gi\u00e0 ordinate, mentre in quella destra quelle da ordinare;</li> <li>prendiamo dalla fila di destra la carta pi\u00f9 piccola, posizionandola a destra dell'ultimo elemento della fila di sinistra;</li> <li>reiteriamo il passo 4 fino a che non vi sono pi\u00f9 carte nella fila di destra.</li> </ol> <p>Volendo, \u00e8 possibile formalizzare i passi precedenti come segue. Dato un vettore \\(x\\) fatto da \\(n\\) numeri interi:</p> <ol> <li>Associare ad \\(i\\) il primo indice dell'array, ovvero \\(i = 0\\), ed a \\(j\\) l'ultimo, ovvero \\(j = n-1\\).</li> <li>Associare alla variabile \\(m\\) il valore di \\(x(0)\\), supponendo che \\(m\\) sia il valore pi\u00f9 piccolo attualmente presente all'interno dell'array.</li> <li>Confrontare \\(m\\) con tutti gli elementi \\(x(k), k \\in (0, n-1]\\). Se \\(x(k) &lt; m\\) per qualche \\(k\\), allora \\(m = x(k)\\).</li> <li>Aumentare il valore di \\(i\\) di un'unit\u00e0.</li> <li>Reiterare le istruzioni 3-4 fino a che \\(i = x(n-1)\\).</li> </ol>"},{"location":"material/02_algorithms/14_sorting/selection_sort/#1412-esempio-pratico","title":"14.1.2 - Esempio pratico","text":"<p>Immaginiamo di avere un array di numeri interi, i cui elementi assumono valore <code>[12, 4, 8, 7, 2]</code>. Seguiamo i passi evidenziati in precedenza per l'algoritmo.</p> <ul> <li>Step 1: imponiamo \\(i = 0, j = 4\\).</li> <li>Step 2: imponiamo \\(m = x(0) = 12\\).</li> <li>Step 3: dal confronto, emerge che \\(x(1) = 4 &lt; m \\Rightarrow m = x(1)\\). Continuando per\u00f2 ad incrementare \\(i\\), notiamo che \\(x(4) = 2 &lt; m \\Rightarrow m = x(4)\\).</li> <li>Step 4: poniamo \\(i = i + 1 = 2\\).</li> <li>Step 5: reiteriamo le istruzioni 3-4 fino a che \\(i = 4\\), ottenendo l'array finale.</li> </ul> <p>In altre parole:</p> <pre><code>START\n\nCICLO 0\nx = [12, 4, 8, 7, 2];\ni = 0; j = 4; min = x(0) = 12;\n\nCICLO 1\nx = [2, 12, 4, 8, 7];\ni = 1; j = 4; min = x(1) = 12;\n\nCICLO 2\nx = [2, 4, 12, 8, 7];\ni = 2; j = 4; min = x(2) = 12;\n\nCICLO 3\nx = [2, 4, 7, 12, 8];\ni = 3; j = 4; min = x(3) = 12;\n\nCICLO 4\nx = [2, 4, 7, 8, 12];\ni = 4; j = 4; min = x(4) = 12;\n\nSTOP\n</code></pre>"},{"location":"material/02_algorithms/14_sorting/selection_sort/#1413-analisi-della-complessita-computazionale-dellalgoritmo","title":"14.1.3 - Analisi della complessit\u00e0 computazionale dell'algoritmo","text":"<p>L'algoritmo di selection sort cicla su tutti gli \\(n\\) indici di un array. Per comprendere quante operazioni sono necessarie a completare l'ordinamento, dovremo contare il numero di comparazioni necessarie ad individuare l'elemento \"minore\" attualmente presente all'interno dell'array.</p> <p>In particolare, alla prima iterazione (con \\(i = 0\\)), avremo la necessit\u00e0 di effettuare \\(n\\) operazioni di comparazione, una per ogni elemento dell'array; alla seconda, con \\(i = 1\\), dovremo fare \\(n - 1\\) confronti, alla terza \\(n - 2\\), e cos\u00ec via. Ci\u00f2 implica che avremo bisogno di un numero di operazioni pari a:</p> \\[ C_T = n + (n - 1) + \\ldots + 2 + 1 = \\frac{n^2}{2} + \\frac{n}{2} \\] <p>La complessit\u00e0 di caso peggiore tiene conto del limite asintotico del valore precedente, ed \u00e8 chiaramente pari ad un \\(O(n^2)\\).</p>"},{"location":"material/02_algorithms/34_searching/lecture/","title":"15 - Algoritmi di ricerca","text":"<p>Vediamo in ultimo gli algoritmi di ricerca.</p>"},{"location":"material/02_algorithms/34_searching/lecture/#151-ricerca-binaria","title":"15.1 - Ricerca binaria","text":""},{"location":"material/02_algorithms/34_searching/lecture/#introduzione-al-problema","title":"Introduzione al problema","text":"<p>Supponiamo di voler trovare un determinato elemento all'interno di una lista di valori, come ad esempio il numero di un nostro contatto all'interno della nostra rubrica (ovviamente, supponiamo di non voler utilizzare la funzionalit\u00e0 di ricerca integrata nella rubrica stessa).</p> <p>Supponiamo di voler trovare il nostro gruppo tra quello dei partecipanti al tema d'anno. Ovviamente, l'idea sarebbe quella di scrivere un programma che faccia la ricerca del nostro gruppo in maniera automatica.</p> <p>Una prima idea potrebbe essere quindi quella di esaminare ogni gruppo, partendo dal primo, mediante un approccio chiamato ricerca lineare (linear search). Ci\u00f2 significa che il nostro programma dovrebbe esaminare una quarantina di gruppi per trovare quello di cui ha bisogno; non molti, giusto?</p> <p>Beh, immaginiamo adesso di voler trovare Betelgeuse nel catalogo stellare Tycho-2, che contiene non quaranta studenti, ma pi\u00f9 di due milioni e mezzo di stelle. L'impresa non sembra pi\u00f9 tanto semplice.</p> <p>Non disperiamo, per\u00f2. Esiste un approccio che ci permette di ridurre in maniera drastica il numero di operazioni da eseguire, ovvero la ricerca dicotomica o, pi\u00f9 comunemente, la binary search. </p> <p>Definizione del problema</p> <p>Abbiamo dimenticato una parte fondamentale nella descrizione dell'algoritmo, ovvero definire pi\u00f9 o meno formalmente quale problema risolve. In breve, la ricerca dicotomica serve a trovare un oggetto in una lista ordinata.</p>"},{"location":"material/02_algorithms/34_searching/lecture/#descrizione-dellalgoritmo","title":"Descrizione dell'algoritmo","text":"<p>L'idea alla base della binary search \u00e8 tenere traccia di un intervallo di ipotesi ragionevoli. Facciamo un rapido esempio per capire al meglio di cosa si tratta.</p> <p>Immaginiamo che noi, Alice, chiediamo al nostro collega, Bob, di pensare ad un numero compreso tra uno e cento. Il nostro obiettivo \u00e8 quello di indovinare il numero in meno di otto mosse: facendolo, costringeremo Bob a pagare il caff\u00e8 (anche al Docente). Le regole dicono che, ad ogni mossa, diremo a Bob un numero, e lui ci dir\u00e0 soltanto se quello che ha pensato \u00e8 inferiore o superiore.</p> <p>Bob gi\u00e0 gongola, pensando al caff\u00e8 che guster\u00e0 a nostre spese: in realt\u00e0, per\u00f2, non sa che noi abbiamo seguito l'insegnamento del Docente, e quindi siamo pronti a fargli sparire il sorriso dalle labbra.</p> <p>La nostra strategia \u00e8 semplice: scartare, ad ogni mossa, il maggior numero possibile di ipotesi false, ovvero di numeri che non coincidono con quello pensato da Bob. Per farlo, partiamo con una mossa standard: diciamo a Bob che, a nostro avviso, il numero cui ha pensato \u00e8 50. Bob, ovviamente, sogghigna: non \u00e8 quello, e si limita a dirci che \u00e8 superiore. Quello che lui non afferra al volo \u00e8 che ha appena ridotto di met\u00e0 il nostro spazio delle ipotesi, che da cento possibilit\u00e0 \u00e8 passato a cinquanta.</p> <p>La seconda mossa \u00e8 altrettanto semplice: infatti, gli proponiamo la met\u00e0 del nuovo intervallo, ovvero 75. Bob continua a godersela, dicendoci che \u00e8 inferiore. Ma noi abbiamo ulteriormente delimitato il nostro range di possibilit\u00e0.</p> <p>Il gioco prosegue come segue.</p> <pre><code>ROUND 3\n--------------------------------\nALICE -&gt; 62 --- BOB -&gt; INFERIORE\n--------------------------------\nROUND 4\n--------------------------------\nALICE -&gt; 56 --- BOB -&gt; SUPERIORE\n--------------------------------\nROUND 5\n--------------------------------\nALICE -&gt; 59 --- BOB -&gt; SUPERIORE\n--------------------------------\nROUND 6 (BOB IMPALLIDISCE)\n--------------------------------\nALICE -&gt; 61 --- BOB -&gt; INFERIORE\n--------------------------------\nROUND 7 (BOB TREMANTE...)\n--------------------------------\nALICE -&gt; 60 --- BOB -&gt; PAGARE\n</code></pre> <p>In sole sette mosse, abbiamo trovato il valore immaginato da Bob e, mentre sorseggiamo il meritato caff\u00e8, ringraziamo il Docente di Informatica per averci illuminato.</p>"},{"location":"material/02_algorithms/34_searching/lecture/#fase-di-progettazione","title":"Fase di progettazione.","text":"<p>Potremmo voler implementare questo algoritmo in un linguaggio di programmazione, di modo da serializzare la vittoria di caff\u00e8 con gli altri nostri amici Charlie, Dave, etc.</p> <p>Per farlo, \u00e8 necessario per prima cosa scrivere l'algoritmo in pseudocodice, e poi definirne il flow chart.</p> <p>TODO: da qui</p> <p>Per questo gioco, posso usare poche variabili. Possiamo usare la variabile min per indicare l'ipotesi minima pi\u00f9 ragionevole, e la variabile max per l'ipotesi massima ragionevole.</p> <p>Ecco un'implementazione step-by-step:</p> <ol> <li>sia min = 1 e max = n</li> <li>troviamo il valore medio tra min e max, arrotondato ad un intero</li> <li>se abbiamo trovato il numero, fermiamoci. altrimenti</li> <li>se l'ipotesi era troppo bassa, impostiamo min a n/2 + 1</li> <li>se l'ipotesi era troppo altra, impostiamo max a n/2 - 1</li> <li>torniamo al passo 2</li> </ol>"},{"location":"material/02_algorithms/34_searching/lecture/#todo-flow-chart","title":"TODO: flow chart","text":""},{"location":"material/02_algorithms/34_searching/lecture/#complessita-computazionale","title":"Complessit\u00e0 computazionale","text":"<p>Sappiamo che la ricerca lineare di un array di \\(n\\) elementi potrebbe dover consultare fino ad \\(n\\) ipotesi.</p> <p>Vediamo come capire qual \u00e8 il numero massimo di ipotesi che invece porta avanti la ricerca dicotomica.</p> <p>L'idea chiave \u00e8 che quando la ricerca dicotomica fa un'ipotesi incorretta, la porzione dell'array che contiene le ipotesi ragionevoli \u00e8 ridotta di met\u00e0. Se la porzione ragiovenole ha 32 elemnti, un'ipotesi non corretta la riduce di 16. Quindi, la ricerca dicotomica dimezza la diemnsione della porzioe ragionevole ad ogni ipotesi non corretta.</p> <p>Quindi, se iniziamo con un array lungo 8, la prima ipotesi non corretta riduce la dimensione delk problema a 4, quindi a 2, e quindi a 1. Una volta che la poszione ragionevole contiene solo unn elemento, non c'\u00e8 bvisogno di ulteriori ipotesi; infatti, in questo caso, l'ipotesi pu\u00f2 essere corretta o incorretta, e comunque abbiamo finito. POer cui con un array di otto elmenti sono necessari al pi\u00f9 quattro valutazioni.</p> <p>Cosa accade con 16? Beh, \u00e8 semplice verificare che serve un passaggio in pi\u00f9, e quindi sono necessarie cinque valutazioni.</p> <p>Questo ci porta ad un pattern. Ogni volta che raddoppiamo la dimensione dell'array, abbiamo bisogno di soltanto una nuova ipotesi. Supponendo di avere \\(m\\) ipotesi per un array di lunghezza \\(n\\). Quindi, se la lunghezza dell'array raddoppia a $2 * n\", il numero di ipotesi diventa \\(m + 1\\).</p> <p>Possiamo quinid esprimere il numero di ipotesi, nel caso peggiore, come \"il numero di volte che dobbiamo ripetutatmente dimezzare, aprtendo da \\(n\\), fino ad arrivare ad 1, pi\u00f9 1\". Questo significa che dobbiamo usare un log_2 (n). Questo significa che, se n come nel nostro caso \u00e8 circa 64, avremo che il numero di ricerche \u00e8 pari a 6. Per i 2.600.000 stelle, il numero di ipotesi \u00e8 pari a 22.</p> <p>Nota</p> <p>I numeri che abbiamo indicato non sono potenze di 2. in questo caso, valuteremo la potenza di deu immediatamente inferiroe, e vi aggiungeremo 1. Ecco perch\u00e9 per gli studenti abbiamo 7, mentre per le stelle abbiamo 22.</p> <p>Il vantaggio di una complessit\u00e0 logaritmica \u00e8 che cresce molto lentamente, essendo l'inverso della funzione esponenziale, che invece cresce molto rapidamente.</p>"},{"location":"material/02_algorithms/34_searching/lecture/#152-ricerca-in-ampiezza","title":"15.2 - Ricerca in ampiezza","text":""},{"location":"material/02_algorithms/34_searching/lecture/#descrizione-dellalgoritmo_1","title":"Descrizione dell'algoritmo","text":"<p>La ricerca in ampiezza, o, in inglese, breath-first search (BFS), \u00e8 un algoritmo di ricerca che lavora su grafi e, per estensione, alberi.</p> <p>Le sue applicazioni sono svariate: pu\u00f2 ad esempio, trovare i collegamenti tra due nodi ad una distanza pari a \\(k\\), oppure individuare i nodi adiacenti all'interno di una rete, o, ancora, trovare il cammino minimo tra due nodi.</p> <p>Per far questo, la BFS opera \"attraversando\" tutti i nodi presenti ad una data distanza dal nodo sorgente. Una volta esplorati questi nodi, la distanza viene incrementata, ed i nodi a distanza immediatamente maggiore sono esplorati. In tal senso, esistono diverse possibili implementazioni della BFS; quella che esploreremo prevede l'utilizzo di una coda.</p> <p>Per semplicit\u00e0, comunque, partiremo vedendo l'applicazione della BFS sugli alberi.</p>"},{"location":"material/02_algorithms/34_searching/lecture/#bfs-sugli-alberi","title":"BFS sugli alberi","text":"<p>Visualizzare l'applicazione della BFS su un albero \u00e8 molto semplice. Supponiamo di dover considerare il seguente albero.</p> <p></p> <p>La BFS opera considerando due parametri:</p> <ol> <li>il nodo attualmente ispezionato;</li> <li>i figli di questo nodo, ovvero quelli adiacenti al nodo attualmente attraversato.</li> </ol> <p>In particolare, alla prima iterazione il nodo attualmente ispezionato \u00e8 proprio i</p> <ol> <li>il nodo radice, ovvero quello da cui parte la ricerca;</li> <li>la distanza dal nodo radice, ovvero il numero di archi che separano un dato nodo dal nodo radice;</li> <li>il predecessore del nodo</li> </ol> <p>Il primo nodo che dovremo considerare \u00e8 quello relativo al nodo radice, ovvero il nodo \\(1\\).</p> <p>Il primo valore che andremo a considerare \u00e8 proprio quello relativo al nodo radice, ovvero il nodo \\(1\\).</p> <p>Il primo valore \u00e8 la distanza, che ci d\u00e0 il numeor minimo di archi in un qualsiasi percorso presente dal vertice sorgente al vertice \\(v\\).</p> <p>Il seocndo \u00e8 il vertice predecessore di \\(v\\) lunco il percorso pi\u00f9 breve dal vertice sorgente. Il predecessore del sorgente, ovviamente, non c'\u00e8.</p> <p>Se non vi \u00e8 alcun path dal vertice sorgente al vertice \\(v\\), la distnaza di \\(v\\) \u00e8 infinita ed il suo predecessore non esiste.</p> <p>TODO: esempio vertice isolato</p> <p>Nella BFS, impostiamo inizialmente la distanza ed il predecessore di ogni vertice al valore null. Iniziamo a cercare dal nodo sorgente, e vi assegniamo una distanza pari a 0. Quindi, visitiamo tutti i vicini del nodo sorgente, e vi assegnamo una distanza di 1, impostando il predecessore come sorgente. Quindi, visitiamo tutti i vicini dei vertici la cui distanza \u00e8 1 e che nono sono stati viistati prima, e diamo a ciascuno di quesi vertici una distanza di 2, ed impostiamo il loro predecessore come l vertice a partire dal quale abbiamo fatto la visita. Procediamo iterativamente con questa procedura fino a che tutti i veritci raggiungibili dal nodo radice non sono stati visitati, sempre visitando tutti i vertici a distanza \\(k\\) dalla sorgente prima di visitare un qualsiasi vertice a distanza di \\(k + 1\\).</p> <p>TODO: ESEMPIO SU ALBERO</p> <p>Una volta completato l'esempio, possono sorgere un paio di domande. la prima \u00e8 come determianre se un vertice \u00e8 gi\u00e0 stato visitato. Questo \u00e8 in realt\u00e0 semplice: la distanza di un vertice \u00e8 nulla prima che \u00e8 stata visitata, nel qual momento assume un valore numerico. Quindi, quando siesaminano i vicini di un vertice, visitiamo solo quelli la cui distanza \u00e8 auttlamente a null.</p> <p>L'altra domanda \u00e8 come tener traccia di quali vertici sono gi\u00e0 stati visitati ma che devono essere ancora analizzati. Si usa in questo caso una coda.</p> <p>In particoalre, quando visitiamo un vertice, lo mettiamo in una coda. All'inizio, mettiamo nella coda il vertice sorgente perch\u00e9 \u00e8 sempre il primo che visiteremo. Per decidere quale vertice vgisitare in seguito, scegliamo il vertice che \u00e8 stato maggiormente in coda, e lo rimuoviamo dalla coda - in altre parole, usiamo il vertice che viene restituito dall'operazione di dequeue().</p> <p>TODO: esempio su albero</p> <p>Notiamo che, in ogni momento, la coda o contiene tutti i vertici alla stessa distanza, o contiene i vertici con distanza \\(k\\) seguiti dai vertici con distanza \\(k + 1\\). In questo modo, ci assicuriamo di visitare tutti i vertici a distanza \\(k\\) prima di visitare un qualsiasi vertice a distanza \\(k + 1\\).</p>"},{"location":"material/02_algorithms/34_searching/lecture/#analisi-della-bfs","title":"Analisi della BFS","text":"<p>Quanto impiega la BFS per un grafo con un insieme di vertici \\(V\\) ed un insieme di archi \\(E\\)? La risposta \u00e8 un tempo pari a \\(O(V + E)\\).</p> <p>Vediamo il perch\u00e9. Ipotizziamo che \\(|E| \\geq |V|\\), che \u00e8 il caso per la maggior parte dei grafi, specialmente quelli per i quali eseguiamo la BFS. Quindi:</p> \\[ |V| + |E| \\leq |E| + |E| = 2 \\times |E| \\] <p>Dato che ignoriamo i fattori costanti nella notazione asintotica, vediamo che quando \\(|E| \\geq |V|\\), allora \\(O(V + E)\\) \u00e8 in pratica \\(O(E)\\). Se, per\u00f2, abbiamo \\(|E| &lt; |V|\\), allora:</p> \\[ |V| + |E| \\leq |V| + |V| = 2 \\times |V| \\] <p>per cui \\(O(V + E)\\) significa in realt\u00e0 \\(O(V)\\). Possiamo mettere i casi insieme dicendo che \\(O(V + E)\\) significa \\(O(max(V, E))\\).</p> <p>In generale, se abbiamo dei parametri \\(x\\) ed \\(y\\), \\(O(x + y)\\) significa in realt\u00e0 \\(O(max(x, y))\\).</p> <p>Perch\u00e9 la BFS quindi viene eseguita in \\(O(V+E)\\)? E' necessario \\(O(V)\\) per inizializzare la distanza ed i predecessori per ciascun vertice. Ognif vertice \u00e8 visitato almeno una volta, perch\u00e8 soltanto la prima volta che viene raggiunto la sua distanza \u00e8 pari a <code>null</code>, per cui ogni vertice \u00e8 messo nella coda almeno una volta. Dal momento in cui esaminiamo gli archi indicednti s un vertice solo quando lo usiamo come putno di partenza, ogni edge \u00e8 esaminato almeno due volte, una per ognuno dei veritci su cui incide. Di conseguenza, la BFS spende \\(O(V+E)\\) tempo visitando i vertici.</p>"},{"location":"material/02_programming_c/14_intro/lecture/","title":"14 - Introduzione al linguaggio C","text":"<p>Materiale e link utili</p> Materiale Disponibilit\u00e0 Link Slides mostrate a lezione Download Video esplicativo Link non disponibile <p>Il linguaggio C \u00e8 un linguaggio a livello medio-alto inizialmente sviluppato da Dennis M. Ritchie ai Bell Labs. La primissima implementazione del C risale al 1972, ma fu soltanto nel 1978 che venne reso disponibile al grande pubblico il primo draft del linguaggio, in quello che oggi \u00e8 conosciuto come K&amp;R standard. La formalizzazione vera e propria del linguaggio avvenne poi da parte dell'ANSI (American National Standard Institute) nel 19814.</p> <p>Al giorno d'oggi, il C \u00e8 ancora uno tra i linguaggi di programmazione pi\u00f9 utilizzati, ed ha applicazioni praticamente ovunque, dai sistemi operativi ai compilatori, passando per database, programmi per smartphone ed editor di testo.</p>"},{"location":"material/02_programming_c/14_intro/lecture/#141-il-programma-hello-world","title":"14.1 - Il programma Hello, world!","text":"<p>Dopo questa breve (ma dovuta) introduzione \"storica\", partiamo con quella che \u00e8 da sempre la maniera \"classica\" di apprendere un linguaggio di programmazione, ovvero scrivendo il nostro primo programma, chiamato per convenzione Hello, world! (Ciao, mondo!).</p> <p>Apriamo Visual Studio (o un editor equivalente) e scriviamo:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // Questo \u00e8 un commento!\n    printf(\"Hello, World! \\n\");\n\n    return 0;\n}\n</code></pre> <p>Proviamo ad eseguire il programma usando il tasto Run o premendo F5, e sulla console dovrebbe apparire la scritta <code>Hello, World!</code>.</p>"},{"location":"material/02_programming_c/14_intro/lecture/#142-descrizione-del-codice","title":"14.2 - Descrizione del codice","text":"<p>Nonostante la loro semplicit\u00e0, in queste poche righe di codice sono riacchiusi i principali concetti sintattici che saranno usati per scrivere programmi ben pi\u00f9 complessi. Vediamoli uno per uno.</p>"},{"location":"material/02_programming_c/14_intro/lecture/#1421-la-direttiva-include","title":"14.2.1 - La direttiva <code>#include</code>","text":"<p>L'istruzione alla riga 1 \u00e8 chiamata direttiva, ed \u00e8 una parte di codice che viene elaborata in automatico dal programma delegato alla \"comprensione\" del linguaggio C (ovvero, al compilatore). In altre parole, ogni volta che si specifica una direttiva, viene effettuata una determinata azione: in questo caso, viene incluso tutto il codice contenuto all'interno del file <code>stdio.h</code>, che altro non \u00e8 che una delle librerie standard del C, delegata alle operazioni di input ed output da e verso diverse fonti (come schermo, tastiera, stampante, file, etc.).</p> <p>Nota</p> <p>Spesso, la direttiva <code>#include</code> prevede l'utilizzo o dei simboli di maggiore e minore (come in questo caso), oppure di due doppi apici. Nel primo caso, la ricerca del file specificato avviene all'interno dei file \"standard\" del C, mentre nel secondo all'interno della directory attuale.</p>"},{"location":"material/02_programming_c/14_intro/lecture/#1422-il-metodo-main","title":"14.2.2 - Il <code>metodo main</code>","text":"<p>Alla riga 3 vediamo quello che \u00e8 l'unico metodo presente in tutti i programmi scritti in C, ovvero il <code>main</code>. Nonostante questo sia in tutto e per tutto una funzione, con parametri accettati in ingresso ed un valore di ritorno, il <code>main</code> rappresenta il punto di accesso del programma, ovvero la parte di codice che verr\u00e0 effettivamente eseguita a runtime, richiamando e \"componendo\", alla bisogna, le altre istruzioni e funzioni invocate dal programma.</p>"},{"location":"material/02_programming_c/14_intro/lecture/#1423-commenti","title":"14.2.3 - Commenti","text":"<p>Alla riga 4 vi \u00e8 una stringa che ha preposti due caratteri di slash (ovvero <code>//</code>); una stringa di questo tipo \u00e8 chiamata commento, e permette di inserire dei \"suggerimenti\" per facilitare la comprensione del codice. Il commento alla riga 4 \u00e8 un commento a singola linea; ne esistono anche di multilinea, che iniziano con la sequenza <code>/*</code> e terminano con la sequenza <code>*/</code>:</p> <pre><code>/*\n * Questo \u00e8 un commento multilinea!\n */\n\n// E questo \u00e8 un commento a linea singola!\n</code></pre>"},{"location":"material/02_programming_c/14_intro/lecture/#1424-listruzione-printf","title":"14.2.4 - L'istruzione <code>printf</code>","text":"<p>L'istruzione alla riga 5 richiama una funzione definita all'interno del file <code>stdio.h</code> che abbiamo invocato in precedenza nella direttiva <code>include</code>, ovvero la funzione <code>printf</code>. Questa accetta in ingresso una stringa (in questo caso <code>\"Hello, World! \\n\"</code>) e la stampa sul terminale dello schermo.</p>"},{"location":"material/02_programming_c/14_intro/lecture/#1425-listruzione-di-ritorno-return","title":"14.2.5 - L'istruzione di ritorno <code>return</code>","text":"<p>Nella testa della funzione <code>main</code> vediamo come viene indicato un valore di ritorno di tipo intero. Di conseguenza, l'istruzione <code>return 0</code> indica il valore che sar\u00e0 restituito al termine della funzione <code>main</code>.</p> <p>Nota</p> <p>Per convenzione, restituire il valore <code>0</code> indica che il programma \u00e8 uscito con successo, mentre altri valori di ritorno, come <code>-1</code>, indicano l'insorgenza di errori durante l'esecuzione del programma.</p>"},{"location":"material/02_programming_c/15_fundamentals/exercises/","title":"E14 - Nozioni fondamentali su C","text":""},{"location":"material/02_programming_c/15_fundamentals/exercises/#esercizio-e141","title":"Esercizio E14.1","text":"<p>Definire il programma Matematicamente in modo che sia composto da:</p> <ul> <li>una libreria trigonometria, al cui interno ci siano le funzioni <code>coseno</code> e <code>seno</code> per il calcolo, rispettivamente, del coseno a partire dal seno e del seno a partire dal coseno;</li> <li>una libreria aritmetica, composta dalle funzioni <code>aggiungi</code> e <code>moltiplica</code>;</li> <li>un file <code>main.c</code> all'interno del quale si richiamano le funzioni presenti nelle precedenti librerie.</li> </ul>"},{"location":"material/02_programming_c/15_fundamentals/exercises/#soluzione-s91","title":"Soluzione S9.1","text":"<p>Ecco una possibile soluzione.</p> <p>Per la libreria trigonometria:</p> <pre><code>// trigonometria.h\n#ifndef TRIGONOMETRIA_H\n#define TRIGONOMETRIA_H\n\nfloat coseno(float seno);\nfloat seno(float coseno);\n\n#endif // !TRIGONOMETRIA_H\n</code></pre> <pre><code>// trigonometria.c\n#include \"trigonometria.h\"\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n\nfloat seno(float coseno) {\n    float sin_quad = 1 - (coseno * coseno);\n    printf(\"%f\\n\", sin_quad);\n    return sqrtf(sin_quad);\n}\n\nfloat coseno(float seno) {\n    float cos_quad = 1 - (seno * seno);\n    return sqrtf(cos_quad);\n}\n</code></pre> <p>Per la libreria aritmetica:</p> <pre><code>// aritmetica.h\n#ifndef ARITMETICA_H\n#define ARITMETICA_H\n\nint aggiungi(int a, int b);\nint moltiplica(int a, int b);\n\n#endif // !ARITMETICA_H\n</code></pre> <pre><code>// aritmetica.c\n#include \"aritmetica.h\"\n\nint aggiungi(int a, int b) {\n    return a + b;\n}\n\nint moltiplica(int a, int b) {\n    return a * b;\n}\n</code></pre> <p>Ecco un esempio di file <code>main.c</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"aritmetica.h\"\n#include \"trigonometria.h\"\n\nint main() {\n    int somma;\n    int prodotto;\n    int i = 2;\n    int j = 3;\n    somma = aggiungi(i, j);\n    prodotto = moltiplica(i, j);\n    printf(\"La somma e' %d\\n\", somma);\n    printf(\"Il prodotto e' %d\\n\", prodotto);\n\n    float cos;\n    cos = coseno(0.5);\n    printf(\"Il coseno e' %f\\n\", cos);\n    float sin;\n    sin = seno(0.5);\n    printf(\"Il seno e' %f\\n\", sin);\n}\n</code></pre>"},{"location":"material/02_programming_c/15_fundamentals/lecture/","title":"15 - Nozioni fondamentali su C","text":"<p>Materiale e link utili</p> Materiale Disponibilit\u00e0 Link Slides mostrate a lezione Link non disponibile Video esplicativo Link non disponibile <p>In questo breve capitolo illustriamo alcuni concetti fondamentali da tenere a mente quando scriviamo un programma in C.</p>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#151-nozioni-generali-sulla-struttura-del-programma","title":"15.1 - Nozioni generali sulla struttura del programma","text":"<p>La struttura di un programma C si basa su una serie di concetti ben definiti. Vediamoli rapidamente.</p>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#1511-modularita","title":"15.1.1 - Modularit\u00e0","text":"<p>I programmi scritti in C devono essere pensati come modulari, ovvero suddivisi in opportune sezioni (chiamate appunto moduli) ognuna delle quali contiene informazioni ed istruzioni necessarie ad espletare una certa funzione.</p> <p>Ad esempio, se scrivessimo un ipotetico programma Calcolatrice, potremmo decidere di tenere separati i moduli Algebra, che si occuper\u00e0 delle operazioni algebriche, e Trigonometria, delegato alla gestione delle operazioni di natura trigonometrica.</p> <p>Modularit\u00e0 e funzionalit\u00e0</p> <p>Idealmente, ciascun modulo deve espletare un'unica funzione ben definita, e non essere in alcun modo interdipendente dagli altri moduli. Tuttavia, molto spesso \u00e8 impossibile evitare completamente dette interdipendenze, per cui ci si assicura prevalentemente che il loro impatto sia minimo.</p>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#1512-file-header-e-file-sorgente","title":"15.1.2 - File header e file sorgente","text":"<p>Quando abbiamo introdotto l'Hello, World abbiamo visto che nella prima riga di codice era importato il file <code>stdio.h</code>, che abbiamo contestualmente detto essere rappresentativo di una libreria delegata alla gestione delle operazioni di input ed output da e verso diversi tipi di sorgente.</p> <p>Un file di questo tipo (ovvero un file con estensione <code>.h</code>) \u00e8 chiamato file header, e contiene al suo interno una serie di prototipi, ovvero le definizioni di un insieme di funzioni. Ad ogni file header corrisponde un file sorgente, la cui estensione \u00e8 <code>.c</code>, nella quale le funzioni sono effettivamente implementate.</p> <p>Semplificando: in un file header, vi sono soltanto le \"firme\" delle funzioni, mentre nel file sorgente dette funzioni vengono effettivamente implementate.</p> <p>Suggerimento</p> <p>Il motivo alla base della separazione tra file header e sorgenti \u00e8 da ricercarsi nel concetto di modularit\u00e0: infatti, in questo modo \u00e8 possibile separare l'effettiva implementazione di una serie di funzioni dal codice che le user\u00e0, interfacciandovisi esclusivamente mediante l'header.</p>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#15121-un-esempio","title":"15.1.2.1 - Un esempio","text":"<p>Facciamo un breve esempio. Immaginiamo di voler scrivere il nostro programma calcola che implementa al suo interno due funzioni: <code>aggiungi</code>, che somma due numeri, e <code>moltiplica</code>, che moltiplica detti numeri tra loro. Per implementarlo, avremo bisogno di tre file:</p> <ul> <li>un file <code>calcolatrice.c</code>, nel quale sono contenuti i corpi delle funzioni <code>aggiungi</code> e <code>moltiplica</code>;</li> <li>un file <code>calcolatrice.h</code>, ovvero l'header relativo al sorgente <code>calcolatrice.c</code>;</li> <li>un file <code>calcola.c</code>, che rappresenta la parte di codice al cui interno \u00e8 contenuto il <code>main</code>.</li> </ul> <p>Quindi, il file <code>calcolatrice.h</code> conterr\u00e0 due definizioni:</p> <pre><code>int aggiungi(int a, int b);\nint moltiplica(int a, int b);\n</code></pre> <p>Il file <code>calcolatrice.c</code> conterr\u00e0 invece il corpo delle due funzioni definite nell'header:</p> <pre><code>#include \"calcola.h\"\n\naggiungi(int a, int b) {\n    return a + b;\n}\n\nmoltiplica(int a, int b) {\n    return a * b;\n}\n</code></pre> <p>Il file <code>calcola.c</code> conterr\u00e0 invece il metodo <code>main</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"calcola.h\"\n\nint main() {\n    int somma = aggiungi(2, 3);\n    int prodotto = moltiplica(2, 3);\n    printf(\"La somma di 2 e 3 e': %d \\n\", somma);\n    printf(\"Il prodotto di 2 per 3 e': %d \\n\", prodotto);\n}\n</code></pre> <p>Alcune note:</p> <ul> <li>nel file header inseriamo esclusivamente i prototipi delle funzioni, senza alcuna implementazione;</li> <li>nel file sorgente includiamo l'header ed implementiamo le funzioni, omettendo il tipo di ritorno (<code>int</code> in entrambi i casi);</li> <li>nel file principale includiamo l'header da noi definito specificando i doppi apici; in questo modo, possiamo richiamare le funzioni definite in <code>calcola.h</code>.</li> </ul>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#1513-direttive","title":"15.1.3 - Direttive","text":"<p>Abbiamo visto in precedenza come l'uso della direttiva <code>#include</code> permetta di \"incorporare\" all'interno del nostro programma funzioni definite ed implementate esternamente. Tuttavia, la direttiva <code>#include</code> non \u00e8 l'unica esistente: ne esistono infatti di diverse, alcune delle quali pi\u00f9 utilizzate di altre, ma tutte molto importanti.</p> <p>Ad esempio, gli header includono normalmente un riferimento ad almeno altre tre direttive, definite header guards, ovvero:</p> <ul> <li><code>#define</code>: questa direttiva permette di definire un valore di sistema valido all'interno del programma;</li> <li><code>#ifndef</code>: questa direttiva controlla se il valore immediatamente alla sua destra non \u00e8 gi\u00e0 stato definito mediante la direttiva <code>#define</code>, ed \u00e8 data dalla crasi della direttiva <code>#if</code> (equivalente appunto ad una verifica condizionale) e della direttiva <code>#define</code> \"negata\". Infatti, se analizziamo attentamente il nome della direttiva, possiamo vedere un'assonanza con i termini if not defined;</li> <li><code>#endif</code>: questa direttiva indica il termine della condizione di controllo.</li> </ul> <p>In base a queste nozioni, normalmente si modifica un header come segue:</p> <pre><code>#ifndef HEADER.H\n#define HEADER.H\n\n// Prototipi delle funzioni...\n\n#endif\n</code></pre> <p>Possiamo trasformare quindi il nostro <code>calcolatrice.h</code> come segue:</p> <pre><code>// calcola.h\n#ifndef CALCOLA_H\n#define CALCOLA_H\n\nint aggiungi(int a, int b);\nint moltiplica(int a, int b);\n\n#endif\n</code></pre> <p>Perch\u00e9 si usano le header guards?</p> <p>Il motivo alla base dell'uso delle header guards riguarda la necessit\u00e0 di evitare l'inclusione ripetuta dello stesso codice. Infatti, potrebbe capitare che l'header <code>calcolatrice.h</code> venga incluso in diverse parti del nostro codice, come ad esempio altri header; per evitare che in fase di compilazione del codice il codice incluso nel file sorgente <code>calcolatrice.c</code> venga \"copiato\" pi\u00f9 volte, si preferisce usare una header guard che fa s\u00ec che la direttiva <code>#define</code> non venga chiamata pi\u00f9 volte con lo stesso argomento.</p> <p>Per una lista completa di direttive C, potete consultare questo indirizzo.</p>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#152-nozioni-generali-sulla-sintassi","title":"15.2 - Nozioni generali sulla sintassi","text":"<p>Vediamo adesso alcune nozioni generali da osservare sulla sintassi dei programmi in C.</p>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#1521-parole-riservate","title":"15.2.1 - Parole riservate","text":"<p>In C, come in ogni altro linguaggio di programmazione, esiste una serie di parole riservate, o keyword che, indicando delle specifiche funzionalit\u00e0 del linguaggio di programmazione, non possono in alcun modo essere utilizzate dall'utente. Normalmente, queste parole chiave si riferiscono ai tipi di una variabile, o indicano l'inizio di una struttura condizionale o di un ciclo, oppure ancora sono utilizzate per particolari funzionalit\u00e0 (come ad esempio le direttive viste in precedenza).</p> <p>Ad esempio, se provassimo a creare una variabile chiamandola <code>int</code>, avremmo un errore:</p> <pre><code>int int = 10;\n</code></pre> <pre><code>error C2632: 'int' non pu\u00f2 essere seguito da 'int'\nerror C2513: 'int': nessuna variabile dichiarata prima di '='\n</code></pre> <p>Un elenco di keyword per il linguaggio C \u00e8 disponibile a questo indirizzo.</p>"},{"location":"material/02_programming_c/15_fundamentals/lecture/#1522-ambito-e-parentesi","title":"15.2.2 - Ambito e parentesi","text":"<p>In C, come in molti altri linguaggi, l'uso delle parentesi non \u00e8 arbitrario, e segue una specifica convenzione. In particolare:</p> <ul> <li>le parentesi tonde devono essere utilizzate per delimitare i parametri di ingresso di una funzione, o anche una particolare espressione logica od aritmetica;</li> <li>le parentesi quadre definiscono un ambito locale.</li> </ul> <p>In altre parole, possiamo usare le parentesi tonde quando definiamo i parametri all'interno del prototipo di una funzione:</p> <pre><code>int nome_funzione(tipo_1 nome_par_1, tipo_2 nome_par_2);\n</code></pre> <p>oppure ancora quando valutiamo una condizione o creiamo un ciclo:</p> <pre><code>if (variabile_a &lt; variabile_b) // ... \n</code></pre> <pre><code>for (int i=0; i&lt;= 10; i++) // ...\n</code></pre> <p>Le parentesi graffe indicano invece l'ambito di una funzione o di una struttura condizionale od iterativa. Ad esempio:</p> <pre><code>aggiungi (int a, int b) { // qui inizia l'ambito della funzione aggiungi...\n    return a + b;\n} // e qui termina!\n\nif (a &lt; b) { //qui inizia l'ambito della struttura condizionale...\n    int c = a + b;\n} // e qui termina!\n</code></pre> <p>E le parentesi quadre?</p> <p>Le parentesi quadre hanno un utilizzo specifico per la definizione e l'accesso agli elementi di un array; ne parleremo pi\u00f9 avanti.</p>"},{"location":"material/02_programming_c/16_scope/exercises/","title":"E16 - Ambito di una variabile","text":""},{"location":"material/02_programming_c/16_scope/exercises/#esercizio-e161","title":"Esercizio E16.1","text":"<p>Scrivere in linguaggio C un programma che definisca due funzioni.</p> <ul> <li>Nella prima, chiamata <code>calcola_area_quadrato</code>, viene calcolata e stampata a schermo l'area di un quadrato.</li> <li>Nella seconda, chiamata <code>calcola_perimetro_quadrato</code>, viene calcolato e stampato a schermo il perimetro dello stesso quadrato.</li> </ul> <p>Entrambe le funzioni accettano come argomento il parametro <code>lato</code> di tipo intero.</p> <p>Utilizzare, ove possibile, un approccio modulare, suddividendo il codice in header e sorgenti.</p>"},{"location":"material/02_programming_c/16_scope/exercises/#soluzione-s161","title":"Soluzione S16.1","text":"<p>Possiamo organizzare il codice rispettando la struttura suggerita da Visual Studio Community o, in alternativa, creando all'interno della stessa cartella tre file, un <code>main.c</code>, che sar\u00e0 il file sorgente principale, un <code>funzioni.c</code>, che sar\u00e0 il sorgente per le funzioni che scriveremo nel codice, ed un <code>funzioni.h</code>, che sar\u00e0 l'header relativo alle stesse funzioni.</p> <p>Di seguito una possibile implementazione.</p>"},{"location":"material/02_programming_c/16_scope/exercises/#file-mainc","title":"File <code>main.c</code>","text":"<p>Il file <code>main.c</code> conterr\u00e0 le istruzioni principali del nostro programma.</p> <pre><code>/**\n * File main.c.\n *\n * Rappresenta il punto di accesso principale al programma.\n */\n#include &lt;stdio.h&gt;\n#include \"funzioni.h\"\n\nint lato = 5;\n\nint main() {\n    int area = calcola_area_quadrato(lato);\n    int perimetro = calcola_perimetro_quadrato(lato);\n    return 0;\n}\n</code></pre> <p>All'interno del file sorgente andremo a:</p> <ul> <li>creare una variabile globale chiamata <code>lato</code> a cui sar\u00e0 assegnato il valore 5;</li> <li>definire la funzione <code>main</code>.</li> </ul> <p>All'interno della funzione <code>main</code>:</p> <ul> <li>invochiamo la funzione <code>calcola_area_quadrato</code> passando come argomento <code>lato</code>;</li> <li>invochiamo la funzione <code>calcola_perimetro_quadrato</code> passando come argomento <code>lato</code>.</li> </ul>"},{"location":"material/02_programming_c/16_scope/exercises/#file-funzionih","title":"File <code>funzioni.h</code>","text":"<p>Il file <code>funzioni.h</code> \u00e8 un classico file header, nel quale andremo ad inserire i prototipi delle due funzioni che andremo poi ad implementare nel codice.</p> <pre><code>#ifndef FUNZIONI_H\n#define FUNZIONI_H\n\nint calcola_area_quadrato(int lato);\nint calcola_perimetro_quadrato(int lato);\n\n#endif\n</code></pre>"},{"location":"material/02_programming_c/16_scope/exercises/#file-funzionic","title":"File <code>funzioni.c</code>","text":"<p>Il file <code>funzioni.c</code> conterr\u00e0 l'implementazione delle funzioni definite nell'header.</p> <pre><code>#include \"funzioni.h\"\n#include &lt;stdio.h&gt;\n\nint calcola_area_quadrato(int lato) {\n    int area = lato * lato;\n    printf(\"Valore area: %d\\n\", area);\n    return area;\n}\n\nint calcola_perimetro_quadrato(int lato) {\n    int perimetro = lato * 4;\n    printf(\"Valore perimetro: %d\\n\", perimetro);\n    return perimetro;\n}\n</code></pre> <p>Le funzioni in s\u00e9 sono abbastanza semplici da interpretare, infatti entrambe calcolano rispettivamente area e perimetro di un quadrato, stampano il valore a schermo e restituiscono il valore calcolato.</p>"},{"location":"material/02_programming_c/16_scope/lecture/","title":"16 - Visibilit\u00e0 di una variabile","text":"<p>Nella lezione 9 abbiamo trattato dell'ambito di una variabile. Estendiamo il discorso, e parliamo del concetto di visibilit\u00e0 di una variabile nel linguaggio C.</p> <p>Per comprendere il concetto, facciamo un esempio.</p>"},{"location":"material/02_programming_c/16_scope/lecture/#161-un-esempio","title":"16.1 - Un esempio","text":"<p>Supponiamo di scrivere un programma C che definisca due funzioni in aggiunta al <code>main</code>, le quali accettano come parametro in ingresso un numero intero rappresentativo del lato di un quadrato. Le due funzioni dovranno, rispettivamente, calcolare l'area ed il perimetro del quadrato; provvediamo quindi all'implementazione delle stesse. In particolare, facciamo in modo che all'interno della funzione <code>calcola_area_quadrato</code> vengano mostrati a schermo i valori dell'area e del perimetro del quadrato.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint calcola_area_quadrato(int lato) {\n    int area = lato * lato;\n    printf(\"Valore area: %d\", area);\n    printf(\"Valore perimetro: %d\", perimetro);\n    return area;\n}\n\nint calcola_perimetro_quadrato(int lato) {\n    int perimetro = lato * 4;\n    return perimetro;\n}\n</code></pre> <p>Proviamo adesso a richiamare entrambe le funzioni dal <code>main</code>.</p> <pre><code>int main() {\n    int lato = 5;\n    int area = calcola_area_quadrato(lato);\n    int perimetro = calcola_perimetro_quadrato(lato);\n    return 0;\n}\n</code></pre> <p>Provando ad eseguire questo programma con Visual Studio Community, otterremo in uscita due errori del tipo:</p> <pre><code>E0020: identificatore \"perimetro\" non definito\nC2065: 'perimetro': identificatore non dichiarato\n</code></pre> <p>I due errori precedenti ci suggeriscono che la variabile <code>perimetro</code> non sia \"visibile\", e di conseguenza accessibile, dall'interno dell'ambito definito dalla funzione <code>calcola_area_quadrato</code>. Per risolvere questo errore, possiamo provare a stampare i valori a schermo direttamente dal <code>main</code>.</p> <p>Modifichiamo la funzione <code>calcola_area_quadrato</code> come segue:</p> <pre><code>int calcola_area_quadrato(int lato) {\n    int area = lato * lato;\n    return area;\n}\n</code></pre> <p>Modifichiamo adesso il <code>main</code>:</p> <pre><code>int main() {\n    int lato = 5;\n    int area = calcola_area_quadrato(lato);\n    int perimetro = calcola_perimetro_quadrato(lato);\n    printf(\"Valore area: %d\\n\", area);\n    printf(\"Valore perimetro: %d\\n\", perimetro);\n    return 0;\n}\n</code></pre> <p>Questa volta, vedremo che l'output a schermo \u00e8 correttamente dato da:</p> <pre><code>Valore area: 25\nValore perimetro: 20\n</code></pre> <p>Abbiamo quindi visto come il concetto di ambito di una variabile possa essere foriero di errori se non compreso alla perfezione. Inoltre, \u00e8 preferibile prestare particolare attenzione ai nomi assegnati alle variabili, che idealmente non dovrebbero \"sovrapporsi\" onde evitare confusione (torneremo su quest'ultimo aspetto in seguito quando parleremo di passaggio per valore e per reference). Inoltre, \u00e8 opportuno tenere sempre a mente che, in caso di ambiguit\u00e0, verr\u00e0 sempre data precedenza alla variabile locale.</p> <p>Ambito delle variabili nel <code>main</code></p> <p>Contrariamente a quanto si potrebbe pensare, il <code>main</code> non definisce un ambito globale per le variabili. Per verificarlo, proviamo a modificare la funzione calcolaareaquadrato come segue:</p> <p><pre><code>int calcola_area_quadrato(int l) {\n    printf(\"Lato: %d\\n\", lato);\n    int area = l * l;\n    return area;\n}\n</code></pre> Noteremo anche in questo caso la coppia di errori <code>E0020</code> e <code>C2065</code>, che ci indicheranno la mancanza di visibilit\u00e0 dell'identificativo <code>lato</code>.</p>"},{"location":"material/02_programming_c/16_scope/lecture/#162-un-altro-esempio","title":"16.2 - Un altro esempio","text":"<p>Approfondiamo ulteriormente il concetto di visibilit\u00e0 con un altro esempio.</p> <p>Supponiamo, in questo caso, di definire all'interno di un programma C una funzione <code>incrementa</code>. Questa funzione, come suggerisce il nome stesso, ha al suo interno una variabile (locale) di tipo intero chiamata <code>contatore</code>, la quale aumenta di uno ogni volta che <code>incrementa</code> viene chiamata.</p> <pre><code>#include&lt;stdio.h&gt; \n\nint incrementa() {\n    int contatore = 0;\n    contatore++;\n    return contatore;\n}\n</code></pre> <p>Proviamo a chiamare due volte questa funzione dal <code>main</code>. Cosa ci aspettiamo?</p> <pre><code>int main() {\n    printf(\"Valore contatore: %d \\n\",  incrementa());\n    printf(\"Valore contatore: %d \\n\", incrementa());\n    return 0;\n}\n</code></pre> <p>Ovviamente, vedremo a schermo due volte il valore <code>1</code>: ci\u00f2 \u00e8 legato al fatto che la variabile <code>contatore</code> ha visibilit\u00e0 limitata all'ambito della funzione <code>incrementa</code>, e quindi viene \"eliminata\" (o, per meglio dire, distrutta) una volta usciti dall'ambito della funzione stessa.</p> <p>In tal senso, possiamo definire una variabile a visibilit\u00e0 pi\u00f9 \"ampia\", andando a modificare il codice come segue:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint contatore = 0;\n\nvoid incrementa() {\n    contatore++;\n}\n\nint main() {\n    incrementa();\n    printf(\"Valore contatore: %d \\n\", contatore);\n    incrementa();\n    printf(\"Valore contatore: %d \\n\", contatore);\n    return 0;\n}\n</code></pre> <p>In questo caso, abbiamo definito una variabile globale chiamata <code>contatore</code>, di valore iniziale pari a <code>0</code>, che viene incrementata ad ogni chiamata della funzione <code>incrementa()</code>. Ovviamente, l'output sar\u00e0 quello atteso, e vedremo che al termine dell'esecuzione del programma il valore di <code>contatore</code> sar\u00e0 pari a <code>2</code>.</p> <p>Il valore di ritorno <code>void</code></p> <p>Notiamo che la funzione <code>incrementa</code> non restituisce alcun valore, in quanto opera su una variabile di tipo globale. In questo caso, indichiamo come tipo di ritorno <code>void</code> (letteralmente vuoto in inglese).</p>"},{"location":"material/02_programming_c/17_operators/exercises/","title":"E17 - Operatori nel linguaggio C","text":""},{"location":"material/02_programming_c/17_operators/exercises/#esercizio-e171","title":"Esercizio E17.1","text":"<p>Scriviamo un programma che calcoli il quadrato di un numero.</p>"},{"location":"material/02_programming_c/17_operators/exercises/#soluzione-s171","title":"Soluzione S17.1","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint quadrato(int n) {\n    return n * n;           // Analogamente potremmo scrivere n ^ 2\n}\n\nint main() {\n    int l = 3;\n    int q = quadrato(l);\n    printf(\"Il quadrato di %d \u00e8 %d\\n\", l, q);\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/17_operators/exercises/#esercizio-e172","title":"Esercizio E17.2","text":"<p>Scriviamo un programma che determini se un numero \u00e8 pari. In tal senso, utilizzare l'operatore di confronto <code>==</code> per confrontare due variabili.</p>"},{"location":"material/02_programming_c/17_operators/exercises/#soluzione-s172","title":"Soluzione S17.2","text":"<p>Ecco una possibile soluzione:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint numero_pari(int n) {\n    if (n % 2 == 0) {\n        return 1;\n    }\n    return 0;\n}\n\nvoid scrivi_pari_o_dispari(int numero, int pari_dispari) {\n    if (pari_dispari == 0) {\n        printf(\"Il valore %d \u00e8 dispari\", numero);\n    } else if (pari_dispari == 1) {\n        printf(\"Il valore %d \u00e8 pari\", numero);\n    } else {\n        printf(\"C'\u00e8 stato un errore. Riprovare.\");\n    }\n}\n\nint main() {\n    int a = 4;\n    int b = 5;\n\n    scrivi_pari_o_dispari(a, numero_pari(a));\n    scrivi_pari_o_dispari(b, numero_pari(b));\n\n    return 0;\n}\n</code></pre> <p>Alcune note:</p> <ul> <li>nella funzione <code>numero_pari</code> valutiamo un numero come pari se e solo se il resto della divisione dello stesso per due \u00e8 pari a 0;</li> <li>nella funzione <code>scrivi_pari_o_dispari</code> prendiamo il valore in uscita dalla funzione <code>numero_pari</code> e lo usiamo per scrivere a schermo se siamo la condizione di parit\u00e0 \u00e8 rispettata.</li> </ul>"},{"location":"material/02_programming_c/17_operators/exercises/#esercizio-e173","title":"Esercizio E17.3","text":"<p>Scriviamo un programma che confronti due intervalli di valori \\([a, b]\\) e \\([c, d]\\), con \\(a\\), \\(b\\), \\(c\\) e \\(d\\) numeri interi. Il programma deve stampare a schermo il maggiore tra gli estremi inferiori \\(a\\) e \\(c\\), il minore tra gli estremi superiori \\(b\\) e \\(d\\), e stabilire se il numero di elementi presenti nei due intervalli \u00e8 lo stesso.</p>"},{"location":"material/02_programming_c/17_operators/exercises/#soluzione-s173","title":"Soluzione S17.3","text":"<p>Ecco una possibile soluzione:</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid compara_estremi_inferiori(int a, int c) {\n    if (a &lt; c) {\n        printf(\"L'estremo inferiore di valore minore \u00e8 %d\\n\", a);\n    } else if (a &gt; c) {\n        printf(\"L'estremo inferiore di valore minore \u00e8 %d\\n\", c);\n    } else {\n        printf(\"I due estremi inferiori hanno lo stesso valore\\n\");\n    }\n}\n\nvoid compara_estremi_superiori(int b, int d) {\n    if (b &lt; d) {\n        printf(\"L'estremo superiore di valore maggiore \u00e8 %d\\n\", d);\n    } else if (b &gt; d) {\n        printf(\"L'estremo superiore di valore maggiore \u00e8 %d\\n\", b);\n    } else {\n        printf(\"I due estremi superiori hanno lo stesso valore\\n\");\n    }\n}\n\nvoid compara_intervalli(int a, int b, int c, int d) {\n    int els_ac = c - a;\n    int els_bd = d - b;\n    if (els_ac &gt; els_bd) {\n        printf(\"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\", a, c, b, d);\n    } else if (els_ac &lt; els_bd) {\n        printf(\"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\", b, d, a, c);\n    } else {\n        printf(\"I due intervalli hanno lo stesso numero di elementi\");\n    }\n}\n\nint main() {\n    int a = 5;\n    int b = 7;\n    int c = 10;\n    int d = 14;\n\n    compara_estremi_inferiori(a, c);\n    compara_estremi_superiori(b, d);\n    compara_intervalli(a, b, c, d);\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/17_operators/exercises/#esercizio-e174","title":"Esercizio E17.4","text":"<p>Dati gli intervalli visti nell\u2019esercizio 17.3, scrivere un programma che indichi se questi hanno lo stesso numero di elementi e gli estremi coincidono, oppure se solo una di queste condizioni \u00e8 verificata. Usare solo operatori logici.</p>"},{"location":"material/02_programming_c/17_operators/exercises/#soluzione-s174","title":"Soluzione S17.4","text":"<p>Possiamo integrare le seguenti istruzioni nella funzione <code>compara_intervalli</code>.</p> <pre><code>void compara_intervalli(int a, int b, int c, int d) {\n    int els_ac = c - a;\n    int els_bd = d - b;\n    if (els_ac &gt; els_bd) {\n        printf(\"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\", a, c, b, d);\n    } else if (els_ac &lt; els_bd) {\n        printf(\"L'intervallo [%d, %d] ha pi\u00f9 elementi dell'intervallo [%d, %d]\", b, d, a, c);\n    } else {\n        printf(\"I due intervalli hanno lo stesso numero di elementi\");\n    }\n\n    if ((a == c) &amp;&amp; (b == d) &amp;&amp; (els_ac == els_bd)) {\n        printf(\"Gli intervalli coincidono, ed i due estremi hanno lo stesso numero di elementi\");\n    } else if ((a == c) &amp;&amp; (b == d) || (els_ac == els_bd)) {\n        printf(\"Gli intervalli coincidono, o i due estremi hanno lo stesso numero di elementi\");\n    }\n}\n</code></pre> <p>Nota</p> <p>Ovviamente, se gli estremi coincidono allora i due insiemi hanno necessariamente lo stesso numero di elementi. Tuttavia, a scopo di esempio, ignoriamo questo (ovvio) fenomeno.</p>"},{"location":"material/02_programming_c/17_operators/lecture/","title":"17 - Operatori in C","text":"<p>In matematica, un operatore \u00e8 comunemente inteso come una azione su uno o pi\u00f9 dati, o operandi. Un semplice esempio \u00e8 dato dai comuni operatori di tipo aritmetico, come quello di somma, che permette (appunto) di sommare le quantit\u00e0 a destra e sinistra dell'operatore <code>+</code>.</p> <p>In questa lezione approfondiremo il concetto di operatore, e ne vedremo alcuni tra i pi\u00f9 utilizzati nel linguaggio C.</p>"},{"location":"material/02_programming_c/17_operators/lecture/#171-operatori-ed-espressioni","title":"17.1 - Operatori ed espressioni","text":"<p>Generalmente, nei linguaggi di programmazione esistono due tipi di operatori:</p> <ul> <li>gli operatori binari, che agiscono su di una coppia di dati (normalmente a sinistra ed a destra dell'operatore);</li> <li>gli operatori unari, che agiscono su un singolo dato.</li> </ul> <p>In particolare, il dato a sinistra dell'operatore \u00e8 chiamato l-value, mentre quello a destra dell'operatore \u00e8 detto r-value.</p> <p>Gli operatori possono essere concatenati all'interno di un'espressione, intesa quindi come sequenza di operatori regolata da due principi:</p> <ul> <li>il principio di precedenza, valente soltanto in caso di pi\u00f9 operatori, che prevede che le operazioni ad essere eseguite per prime siano quelle tra parentesi tonde, e che successivamente si segua un ordine da sinistra verso destra;</li> <li>il principio di associativit\u00e0 indica l'ordine con cui sono valutati gli operatori, anche in questo caso prevalentemente da sinistra verso destra.</li> </ul>"},{"location":"material/02_programming_c/17_operators/lecture/#172-loperatore-di-assegnazione","title":"17.2 - L'operatore di assegnazione","text":"<p>L'operatore di assegnazione, contraddistinto dal simbolo uguale <code>=</code>, permette di assegnare un dato valore ad una variabile. Abbiamo gi\u00e0 usato questo operatore pi\u00f9 volte in fase di inizializzazione:</p> <pre><code>int a = 10;\nchar c = 'b';\n</code></pre> <p>Importantissimo sottolineare come l'operatore di assegnazione non valuti il valore di una variabile, ma si limiti ad assegnarne uno nuovo.</p>"},{"location":"material/02_programming_c/17_operators/lecture/#173-gli-operatori-matematici","title":"17.3 - Gli operatori matematici","text":"<p>Gli operatori matematici sono quelli coinvolti in tutte le operazioni di tipo aritmetico che \u00e8 possibile effettuare in C, e sono riassunti nella seguente tabella.</p> Operatore Spiegazione <code>+</code> Somma l-value ed r-value. <code>-</code> Sottrae r-value ad l-value. <code>/</code> Divide l-value per r-value. <code>*</code> Moltiplica l-value per r-value. <code>%</code> Calcola il modulo in r-value di l-value. <code>^</code> Eleva l-value ad r-value. <p>Particolarmente interessante \u00e8 l'operatore di modulo <code>%</code>: questo, infatti, restituisce il resto della divisione tra l-value ed r-value. Ad esempio:</p> <pre><code>int a = 5 % 2; // risultato: 1\nint b = 12 % 4; // risultato: 0\nint c = 17 % 13; // risultato: 4\n</code></pre> <p>Di estrema importanza sono anche gli operatori di confronto, riassunti nella seguente tabella.</p> Operatore Spiegazione <code>==</code> Verifica che l-value sia uguale ad r-value. <code>&gt;</code> Verifica che l-value sia maggiore di r-value. <code>&lt;</code> Verifica che l-value sia minore di r-value. <code>&gt;=</code> Verifica che l-value sia maggiore o uguale ad r-value. <code>&lt;=</code> Verifica che l-value sia minore o uguale ad r-value. <p>Interessante notare come questi operatori restituiscano un valore di verit\u00e0, ovvero un vero o un falso a seconda del fatto che la condizione sia rispettata o meno.</p>"},{"location":"material/02_programming_c/17_operators/lecture/#173-operatori-booleani","title":"17.3 - Operatori booleani","text":"<p>Gli operatori booleani regolano le interazioni relative all'algebra di Boole, ovvero quella che gestisce variabili che possono assumere soltanto due valori: vero, convenzionalmente associato al valore 1, e falso, convenzionalmente associato al valore 0.</p> <p>Vediamo insieme quali operazioni fondamentali sono definite dalla logica booleana.</p>"},{"location":"material/02_programming_c/17_operators/lecture/#1731-cenni-di-logica-booleana","title":"17.3.1 - Cenni di logica booleana","text":""},{"location":"material/02_programming_c/17_operators/lecture/#17311-operatori-binari","title":"17.3.1.1 - Operatori binari","text":""},{"location":"material/02_programming_c/17_operators/lecture/#17311-operazione-di-and-logico","title":"17.3.1.1 - Operazione di <code>AND</code> logico","text":"<p>L'operazione di <code>AND</code> logico prevede che il risultato sia vero se e solo se sia l-value che r-value sono veri. Di conseguenza, vale la seguente tabella:</p> l-value r-value Risultato 0 0 0 0 1 0 1 0 0 1 1 1"},{"location":"material/02_programming_c/17_operators/lecture/#173112-operazione-di-or-logico","title":"17.3.1.1.2 - Operazione di <code>OR</code> logico","text":"<p>L'operazione di <code>OR</code> logico prevede che il risultato sia vero se e solo se almeno uno tra l-value ed r-value \u00e8 vero. Di conseguenza, vale la seguente tabella:</p> l-value r-value Risultato 0 0 0 0 1 1 1 0 1 1 1 1"},{"location":"material/02_programming_c/17_operators/lecture/#173113-operazione-di-xor-logico","title":"17.3.1.1.3 - Operazione di <code>XOR</code> logico","text":"<p>L'operazione di <code>XOR</code> (eXclusive OR) logico prevede che il risultato sia vero se e solo se esattamente uno tra l-value ed r-value \u00e8 vero. Di conseguenza, vale la seguente tabella:</p> l-value r-value Risultato 0 0 0 0 1 1 1 0 1 1 1 0"},{"location":"material/02_programming_c/17_operators/lecture/#17312-operatori-logici-unari","title":"17.3.1.2 - Operatori logici unari","text":""},{"location":"material/02_programming_c/17_operators/lecture/#173121-operazione-di-not-logico","title":"17.3.1.2.1 - Operazione di <code>NOT</code> logico","text":"<p>L'unico operatore logico unario \u00e8 l'operatore di <code>NOT</code> logico, che prevede che venga \"negato\" il valore in ingresso all'operatore. Di conseguenza, vale la seguente tabella:</p> value Risultato 0 1 1 0"},{"location":"material/02_programming_c/17_operators/lecture/#1732-operatori-logici-nel-linguaggio-c","title":"17.3.2 - Operatori logici nel linguaggio C","text":"<p>Il linguaggio C mette a disposizione un operatore per la maggior parte delle operazioni logiche. Detti operatori sono riassunti nella seguente tabella.</p> Operazione Operatore AND <code>&amp;&amp;</code> OR <code>||</code> NOT <code>!</code> <p>Per quello che riguarda lo XOR, questo non \u00e8 messo direttamente a disposizione come operatore logico dal linguaggio C. Tuttavia, \u00e8 possibile ricavarlo come combinazione degli altri operatori fondamentali: farlo \u00e8 lasciato al lettore.</p> <p>Suggerimento</p> <p>Provate a fare un AND dei risultati delle operazioni di AND ed OR.</p>"},{"location":"material/02_programming_c/17_operators/lecture/#174-operatori-logici-binari","title":"17.4 - Operatori logici binari","text":"<p>Un altro tipo di operatore logico presente nel C \u00e8 quello binario, che opera non pi\u00f9 a livello dell'intero dato, ma a livello di rappresentazione in termini di bit. Nella tabella successiva sono mostrati i principali operatori di questo tipo:</p> Operatore Descrizione <code>&gt;&gt;</code> Right shift <code>&lt;&lt;</code> Left shift <code>&amp;</code> AND bit a bit <code>|</code> OR bit a bit <code>^</code> XOR bit a bit <p>Soffermiamoci per un attimo sugli operatori di scorrimento. Questi, in buona sostanza, equivalgono a dividere (right shift) o moltiplicare (left shift) il nostro numero in rappresentazione binaria per 2 elevato all'r-value specificato sull'operatore. Se, ad esempio, abbiamo una variabile di tipo <code>byte</code> pari a 4, e quindi rappresentata in binario ad otto bit come:</p> <pre><code>int 4 = 00000010;\n</code></pre> <p>applicando gli operatori di left shift e right shift otterremo, rispettivamente:</p> <pre><code>a &gt;&gt; 1; // 00000010 / 2 = 00000001\na &lt;&lt; 1; // 00000010 * 2 = 00000100\n</code></pre> <p>Per quello che riguarda invece gli operatori binari, questi funzionano esattamente come gli operatori logici classici, ma operano bit a bit. Ad esempio:</p> Operatore <code>a</code> <code>b</code> <code>risultato</code> <code>&amp;</code> 10001011 01011010 00001010 <code>|</code> 10001011 01011010 11011011 <code>^</code> 10001011 01011010 11010001"},{"location":"material/02_programming_c/17_operators/lecture/#175-conversione-di-tipo","title":"17.5 - Conversione di tipo","text":"<p>Chiudiamo il discorso sugli operatori parlando dell'operazione di conversione di tipo, conosciuta anche come casting.</p> <p>Come suggerisce il nome stesso, questa operazione permette di convertire un dato da un tipo (ad esempio, intero) ad un altro (ad esempio, float). Ovviamente, questa operazione deve tenere conto non solo delle differenze di formato, ma anche in termini di memoria occupata.</p> <p>La conversione pu\u00f2 essere di due tipi:</p> <ul> <li>nella conversione implicita, gli operatori matematici trattati in precedenza effettuano una conversione \"automatica\", semplificando di solito i tipi pi\u00f9 complessi;</li> <li>nella conversione esplicita, \u00e8 il programmatore che effettua la conversione mediante l'operazione di casting.</li> </ul> <p>Vediamo alcuni esempi applicativi, partendo dalla conversione implicita. Provando a sommare due <code>float</code> ed associare al risultato una variabile di tipo <code>int</code>, avviene una conversione implicita.</p> <pre><code>int a = 3.2 + 4.2; // il risultato sar\u00e0 \"troncato\" a 7\n</code></pre> <p>Un'altra situazione nella quale avviene una conversione implicita \u00e8 quella in cui si prova ad assegnare ad uno <code>short</code>, il cui valore massimo gestibile \u00e8 65535, un valore superiore; in questo caso, il valore verr\u00e0 automaticamente troncato al limite massimo.</p> <pre><code>ushort s = 9999999; // sar\u00e0 troncato a 65.535\n</code></pre> <p>Per ci\u00f2 che riguarda la conversione esplicita, invece, dobbiamo usare l'operatore di casting, che consiste nella specifica del tipo destinazione tra parentesi tonde. Ad esempio, per convertire un <code>int</code> in <code>float</code>:</p> <pre><code>int a = 3;\nfloat b = (float) a;\n</code></pre> <p>Nota sulle conversioni di tipo</p> <p>In generale, \u00e8 consigliabile evitare, per quanto possibile, di effettuare delle conversioni di tipo esplicite. Ovviamente, anche l'uso di conversioni di tipo in forma implicita \u00e8 sconsigliato, perch\u00e9 conduce spesso ad errori di troncamento che, nel migliore dei casi, possono portare a risultati non attesi (e, nel peggiore, compromettere il funzionamento del software).</p>"},{"location":"material/02_programming_c/18_arrays/exercises/","title":"E18 - Array","text":""},{"location":"material/02_programming_c/18_arrays/exercises/#esercizio-e181","title":"Esercizio E18.1","text":"<p>Un tensore \u00e8 un array ad \\(n\\) dimensioni contenente valori arbitrari. Creare due tensori di dimensioni \\(3 \\times 3 \\times 3\\), uno contenente valori itneri, e l'altro contenente valori in formato <code>double</code>. Utilizzare l'operatore <code>sizeof</code> per confrontare lo spazio occupato in memoria dai due tenosri, e visualizzare a schermo tutti i valori dell'array pi\u00f9 \"pesante\".</p>"},{"location":"material/02_programming_c/18_arrays/exercises/#soluzione-s181","title":"Soluzione S18.1","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#pragma warning(disable : 4996)\n\nint main() {\n    int tensore_interi[3][3][3];\n    double tensore_decimali[3][3][3];\n    int contatore_interi = 1;\n    double contatore_double = 1.0;\n    // Popolo i tensori\n    for (int i = 0; i &lt; 3; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            for (int k = 0; k &lt; 3; k++) {\n                tensore_interi[i][j][k] = contatore_interi;\n                contatore_interi++;\n                tensore_decimali[i][j][k] = contatore_double;\n                contatore_double++;\n            }\n        }\n    }\n\n    // Stampo a schermo\n    for (int i = 0; i &lt; 3; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            for (int k = 0; k &lt; 3; k++) {\n                printf(\"L'elemento in posizione [i][j][k] per il tensore di interi e' %d\\n\", tensore_interi[i][j][k]);\n            }\n        }\n    }\n\n    for (int i = 0; i &lt; 3; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            for (int k = 0; k &lt; 3; k++) {\n                printf(\"L'elemento in posizione [i][j][k] per il tensore di decimali e' %f\\t\", tensore_decimali[i][j][k]);\n            }\n        }\n    }\n\n    if (sizeof(tensore_decimali) &gt; sizeof(tensore_interi)) {\n        printf(\"La dimensione del tensore di decimali e': %d\\n\", sizeof(tensore_decimali));\n    }\n    else {\n        printf(\"La dimensione del tensore di interi e': %d\\n\", sizeof(tensore_interi));\n    }\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/18_arrays/exercises/#esercizio-e182","title":"Esercizio E18.2","text":"<p>Scriviamo un programma che, data in ingresso una stringa rappresentativa di un numero \\(x\\), con \\(x\\) numero reale o naturale, chiami l\u2019adeguata funzione per convertirlo in una variabile di tipo numerico. Utilizziamo poi il risultato restituito dalla funzione <code>sprintf</code> per visualizzare a schermo il valore della stringa associata ad \\(x\\).</p>"},{"location":"material/02_programming_c/18_arrays/exercises/#soluzione-s182","title":"Soluzione S18.2","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#pragma warning(disable : 4996)\n\nvoid determina_intero_decimale(char numero[5]) {\n    char stringa[32];\n    int length = 5;\n    for (int i = 0; i &lt; length; i++) {\n        if (numero[i] == '.') {\n            double valore = atof(numero);\n            sprintf(stringa, \"Il numero %f e' reale\\n\", valore);\n            printf(stringa);\n            return;\n        }\n    }\n    int valore = atoi(numero);\n    sprintf(stringa, \"Il numero %d e' un intero\\n\", valore);\n    printf(stringa);\n}\n\nint main() {\n    char intero[5] = \"10\";\n    char decimale[5] = \"1.1\";\n    determina_intero_decimale(intero);\n    determina_intero_decimale(decimale);\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/18_arrays/lecture/","title":"18 - Array in C","text":"<p>Nella lezione 10 abbiamo introdotto il concetto di array in questo modo:</p> <p>Definizione di array</p> <p>Un array contiene una sequenza di elementi, tipicamente dello stesso tipo, ed organizzati seguendo un ordine specifico, \"esplorabile\" mediante il concetto di indice.</p> <p>La maggior parte dei linguaggi di programmazione offre un'implementazione nativa di questa struttura dati; ovviamente, il C non fa eccezione.</p>"},{"location":"material/02_programming_c/18_arrays/lecture/#181-concetti-fondamentali-sugli-array-in-c","title":"18.1 - Concetti fondamentali sugli array in C","text":"<p>Un array ad \\(n\\) elementi \u00e8 caratterizzato in C da degli indici che vanno da \\(0\\) ad \\(n-1\\). In altre parole, per accedere al primo elemento dell'array dovremo richiamare l'indice \\(0\\), per accedere al secondo dovremo richiamare l'indice \\(1\\), e cos\u00ec via fino all'indice \\(n-1\\), da usare per accedere all'\\(n\\)-mo elemento. Importante sottolineare anche che il valore di \\(n\\), ovvero la dimensione dell'array, \u00e8 predefinito ed invariabile: provare a modificare il numero di elementi di un array, infatti, equivale a crearne uno nuovo.</p> <p>Vediamo per\u00f2 adesso come sia possibile creare un nuovo array, o anche accedere ai singoli elementi dello stesso.</p>"},{"location":"material/02_programming_c/18_arrays/lecture/#182-operatori-notevoli-sugli-array","title":"18.2 - Operatori notevoli sugli array","text":""},{"location":"material/02_programming_c/18_arrays/lecture/#1821-loperatore","title":"18.2.1 - L'operatore <code>[]</code>","text":"<p>L'operatore <code>[]</code> (ovvero, la coppia di parentesi quadre) viene usato per la definizione ed inizializzazione di un nuovo array. Supponiamo, ad esempio, di voler dichiarare un nuovo array contenente 5 numeri interi; per farlo, potremo usare questa notazione:</p> <pre><code>int mio_array[5];\n</code></pre> <p>In sostanza, la dichiarazione assume quindi una forma del tipo:</p> <pre><code>array_type array_id[size];\n</code></pre> <p>con <code>array_type</code> tipo degli elementi dell'array, <code>array_id</code> identificatore dell'array, e <code>size</code> numero di elementi dello stesso.</p> <p>Nota</p> <p>In buona sostanza, la dichiarazione di un array \u00e8 praticamente analoga a quella di una variabile.</p> <p>Analogamente, anche l'inizializzazione di un array pu\u00f2 avvenire contestualmente alla dichiarazione:</p> <pre><code>int mio_array[5] = {1, 2, 3, 4, 5};\n</code></pre> <p>Notiamo anche come i valori associati ai membri dell'array siano indicati tra parentesi graffe. In questo caso, possiamo anche omettere la dimensione dell'array, che sar\u00e0 automaticamente inferita dall'r-value:</p> <pre><code>int mio_array[] = {1, 2, 3, 4, 5};\n</code></pre> <p>Nota</p> <p>Un array non \u00e8 un l-value, quindi un'espressione del tipo <code>mio_array = {1, 2, 3, 4, 5};</code> non \u00e8 da ritenersi valida.</p> <p>L'operatore <code>[]</code> \u00e8 usato anche per scrivere o leggere i singoli elementi dell'array. Infatti, l'istruzione:</p> <pre><code>mio_array[3] = 10;\n</code></pre> <p>ci permette di sovrascrivere l'elemento in posizione <code>4</code> dell'array, che adesso sar\u00e0 pari a <code>[1, 2, 3, 10, 5]</code>. Utilizzando invece la notazione:</p> <pre><code>int a = mio_array[2];\n</code></pre> <p>assegneremo alla variabile di tipo intero <code>a</code> il valore <code>3</code>.</p>"},{"location":"material/02_programming_c/18_arrays/lecture/#1822-loperatore-sizeof","title":"18.2.2 - L'operatore <code>sizeof</code>","text":"<p>Il linguaggio C mette a disposizione l'operatore <code>sizeof</code> per conoscere il numero complessivo di byte occupato in memoria dall'array.</p> <p>Nota</p> <p>Importantissimo sottolineare come l'operatore <code>sizeof</code> restituisca le dimensioni in memoria e non il numero di elementi dell'array!</p>"},{"location":"material/02_programming_c/18_arrays/lecture/#183-array-multidimensionali","title":"18.3 - Array multidimensionali","text":"<p>Il linguaggio C permette di creare degli array di dimensionalit\u00e0 arbitraria.</p> <p>Nota</p> <p>Ad esempio, una matrice \u00e8 un array di dimensionalit\u00e0 pari a due.</p> <p>Per far questo, possiamo utilizzare una notazione del tipo:</p> <pre><code>array_type array_id[size_1][size_2];\n</code></pre> <p>A parte l'uso ripetuto dell'operatore <code>[]</code>, valgono esattamente le stesse regole usate per gli array monodimensionali. Di conseguenza, per definire una matrice \\(3 \\times 3\\) a valori in \\(\\mathbb{R}\\), potremo scrivere:</p> <pre><code>float matrix[3][3];\n</code></pre> <p>mentre per inizializzarla:</p> <pre><code>float matrix [3][3] = { {2.0, 0.0, 1.0}, {1.0, 3.0, 2.0}, {4.0, 3.0, 3.0} };\n</code></pre> <p>ed infine per accedere all'elemento in posizione \\((1, 2)\\):</p> <pre><code>int el = matrix[0][1];\n</code></pre>"},{"location":"material/02_programming_c/18_arrays/lecture/#184-array-e-stringhe","title":"18.4 - Array e stringhe","text":"<p>Una stringa altro non \u00e8 se non una sequenza di caratteri.</p> <p>Interessante notare come le stringhe non siano dati di tipo primitivo; tuttavia, sono estremamente utilizzate, per cui il loro supporto \u00e8 presente in praticamente ogni linguaggio di programmazione. Per capirci, una delle funzioni \"fondamentali\" del C, come la <code>printf</code>, accetta una stringa.</p> <p>Data la loro natura, le stringhe sono rappresentate come degli array di char null terminated. Questo concetto \u00e8 estremamente peculiare: infatti, affinch\u00e9 un array sia riconosciuto come stringa, deve essere composto soltanto da char e, inoltre, il suo ultimo elemento deve essere un null value. </p> <p>Facciamo un esempio:</p> <pre><code>char valid_string[6] = {'a', 'b', 'c', 'd', 'e', null};\nchar non_valid_string[6] = {'a', 'b', 'c', 'd', 'e', 'f'};\n</code></pre> <p>In questo esempio, l'array <code>valid_string</code> sar\u00e0 considerato dal compilatore come una stringa, mentre l'arryay <code>non_valid_string</code> sar\u00e0 un array di tipo char a sei elementi.</p> <p>Ovviamente, usare una notazione come la precedente per scrivere un array risulta oltremodo scomodo, per cui si preferisce utilizzare i doppi apici:</p> <pre><code>char string_with_quotes[10] = \"abcdef\";\n</code></pre> <p>In questo caso, ovviamente, il terminatore <code>null</code> sar\u00e0 aggiunto automaticamente.</p> <p>Conversione da stringa a tipo numerico</p> <p>Non \u00e8 possibile effettuare nativamente la conversione da stringa a numero intero o float. In tal senso, si utilizzano due funzioni, definite nell'header <code>stdlib.h</code>, ovvero <code>atoi</code> ed <code>atof</code>, che convertono una stringa rispettivamente in intero e float.</p> <p>Conversione da tipo numerico a stringa</p> <p>Per convertire da tipo numerico a stringa, invece, possiamo usare la funzione <code>sprintf</code>, definita in <code>stdio.h</code>. Questa funzione, che restituisce una stringa in uscita, pu\u00f2 accettare degli interi o dei float da inserire all'interno dell'output mediante delle apposite format string. Ad esempio, per convertire il numero 10, potremmo usare l'istruzione <code>sprintf(out_string, \"%d\", 10);</code>.</p>"},{"location":"material/02_programming_c/18_arrays/lecture/#185-esercizi","title":"18.5 - Esercizi","text":"<ol> <li>Esercizio 1: un tensore \u00e8 un array ad \ud835\udc5b dimensioni contenente valori arbitrari. Creare due tensori di dimensioni 3\u00d73\u00d73, uno contenente valori interi, e l\u2019altro contenente valori in formato double. Usare l\u2019operatore sizeof per confrontarne lo spazio occupato in memoria, e visualizzare a schermo tutti i valori dell\u2019array pi\u00f9 \u2018pesante\u2019.</li> <li>Esercizio 2: scriviamo un programma che, data in ingresso una stringa rappresentativa di un numero \ud835\udc65, con \ud835\udc65 numero reale o naturale, chiami l\u2019adeguata funzione per convertirlo in una variabile di tipo numerico. Utilizziamo poi il risultato restituito dalla funzione sprintf per visualizzare a schermo il valore della stringa associata ad \ud835\udc65.</li> </ol>"},{"location":"material/02_programming_c/19_pointers/exercises/","title":"E19 - I puntatori","text":""},{"location":"material/02_programming_c/19_pointers/exercises/#esercizio-e191","title":"Esercizio E19.1","text":"<p>Definire mediante un'apposita struttura di librerie delle funzioni che:</p> <ul> <li>mostrino l'indirizzo di una variabile intera o in formato <code>double</code>;</li> <li>verifichino che il valore dereferenziato da un puntatore coincida con la variabile;</li> <li>mostrino la differenza tra passaggio per valore e passaggio per reference;</li> <li>descrivano un puntatore a void.</li> </ul>"},{"location":"material/02_programming_c/19_pointers/exercises/#soluzione-e191","title":"Soluzione E19.1","text":"<p>Ecco una possibile soluzione, organizzata creando un'apposita libreria puntatori.</p> <pre><code>// puntatori.h\n#ifndef PUNTATORI_H\n#define PUNTATORI_H\n\nvoid mostra_puntatore_intero(int intero);\nvoid mostra_puntatore_double(double decimale);\nint deferenzia_compara_intero(int* puntatore_intero, int comparato);\ndouble deferenzia_compara_decimale(double* puntatore_decimale, double comparato);\nint* restituisci_puntatore(int intero);\nvoid puntatore_a_void(char ch);\n\n#endif // !PUNTATORI_H\n</code></pre> <pre><code>// puntatori.c\n#include &lt;stdio.h&gt;\n#include \"puntatori.h\"\n\nvoid mostra_puntatore_intero(int intero) {\n    int* puntatore = &amp;intero;\n    printf(\"L'indirizzo della variabile e': %p\\n\", puntatore);\n}\n\nvoid mostra_puntatore_double(double decimale) {\n    double* puntatore = &amp;decimale;\n    printf(\"L'indirizzo della variabile e': %p\\n\", puntatore);\n}\n\nint* restituisci_puntatore(int intero) {\n    return &amp;intero;\n}\n\nint deferenzia_compara_intero(int* puntatore_intero, int comparato) {\n    int puntato = *puntatore_intero;\n    if (puntato == comparato) {\n        printf(\"La comparazione ha avuto successo!\\n\");\n    }\n    return puntato;\n}\n\ndouble deferenzia_compara_decimale(double* puntatore_decimale, double comparato) {\n    double puntato = *puntatore_decimale;\n    if (puntato == comparato) {\n        printf(\"La comparazione ha avuto successo!\\n\");\n    }\n    return puntato;\n}\n\nvoid puntatore_a_void(char ch) {\n    void* puntatore;\n    puntatore = &amp;ch;\n    printf(\"Il puntatore a void ha indirizzo: %p\\n\", puntatore_a_void);\n    char* puntatore_a_char = (char*)puntatore;\n    // Dereferenziazione\n    printf(\"La variabile originaria e': %c\\n\", *puntatore_a_char);\n}\n</code></pre> <pre><code>// main.c\n#include &lt;stdio.h&gt;\n#include \"puntatori.h\"\n#include \"puntatori_funzione.h\"\n\nint main() {\n    // Parte 1\n    int a = 1;\n    double b = 0.1;\n    mostra_puntatore_intero(a);\n    mostra_puntatore_double(b);\n\n    // Parte 2\n    int c = deferenzia_compara_intero(&amp;a, a);\n    double d = deferenzia_compara_decimale(&amp;b, b);\n\n    // Parte 3\n    int* p = restituisci_puntatore(a);\n    if (p == &amp;a) {\n        printf(\"I puntatori combaciano!\\n\");\n    }\n    else {\n        printf(\"I puntatori non combaciano!\\n\");\n    }\n\n    // Parte 4\n    puntatore_a_void('c');\n\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/19_pointers/lecture/","title":"19 - I puntatori","text":"<p>Quello di puntatore \u00e8 un concetto estremamente importante per la comprensione del linguaggio C, nonostante possa a volte rivelarsi ostico.</p> <p>In particolare, un puntatore \u00e8, nei fatti, una variabile che contiene l'indirizzo di memoria dove risiede un'altra variabile. Per meglio comprendere questo concetto, osserviamo la seguente figura.</p> <p></p> <p>Analizziamo brevemente la figura precedente. Ad esempio, la variabile di nome <code>ch</code>, il cui valore \u00e8 pari ad <code>l</code>, risiede nell'indirizzo di memoria <code>0x100000</code>; la variabile <code>bs</code>, intero di valore <code>2</code>, risiede nell'indirizzo di memoria immediatamente adiacente, ovvero <code>0x100001</code>, e via discorrendo; un puntatore ci permette quindi di tenere traccia di questi valori.</p> <p>Gli indirizzi di memoria</p> <p>Gli indirizzi di memoria, nei fatti, sono rappresentabili mediante variabili di tipo intero. Tuttavia, molto spesso si preferisce utilizzare la notazione esadecimale.</p> <p>Operazioni aritmetiche</p> <p>Dato che gli indirizzi di memoria sono variabili di tipo intero, \u00e8 possibile effettuare su di essi delle operazioni di natura aritmetica. Tuttavia, \u00e8 sconsigliato farlo se non in casi eccezionali.</p>"},{"location":"material/02_programming_c/19_pointers/lecture/#191-loperatore","title":"19.1 - L'operatore <code>&amp;</code>","text":"<p>Se invocato su di una variabile, l'operatore <code>&amp;</code> permette di restituirne l'indirizzo, ottenendo quindi il valore associabile ad un puntatore. Ad esempio:</p> <pre><code>printf(\"%x\", &amp;ch);      // questa istruzione restituir\u00e0 0x100000\n</code></pre> <p>Format specifier per il puntatore</p> <p>Notiamo che il format specifier usato per il puntatore non \u00e8 quello usato per i numeri interi.</p> <p>Di conseguenza, possiamo definire la modalit\u00e0 con cui \u00e8 possibile dichiarare ed inizializzare una variabile da associare ad un puntatore come:</p> <pre><code>char ch = 'l';\nchar* puntatore_char = &amp;ch;\n</code></pre> <p>La notazione <code>type*</code> indica quindi che stiamo definendo un puntatore ad un tipo specifico; ad esempio, <code>char*</code> \u00e8 un puntatore a <code>char</code>, mentre <code>int*</code> \u00e8 un puntatore ad <code>int</code>, e via dicendo.</p>"},{"location":"material/02_programming_c/19_pointers/lecture/#192-loperatore-di-dereferenziazione","title":"19.2 - L'operatore di dereferenziazione","text":"<p>Nel contesto dei puntatori, l'operatore <code>*</code> ci permette anche di effettuare la cosiddetta operazione di dereferenziazione, che ci permette di recuperare il valore associato all'indirizzo di memoria cui si riferisce il puntatore. Ad esempio:</p> <pre><code>print(\"%c\", *pointer);      // questa istruzione restituir\u00e0 l\n</code></pre>"},{"location":"material/02_programming_c/19_pointers/lecture/#193-passaggio-per-valore-e-passaggio-per-reference","title":"19.3 - Passaggio per valore e passaggio per reference","text":"<p>Il passaggio di una variabile come argomento di una funzione avviene secondo due diverse modalit\u00e0.</p> <p>Nella prima modalit\u00e0, il passaggio avviene per valore: questo significa che viene creata una copia della variabile, la quale sar\u00e0 mandata in ingresso alla funzione. Ovviamente, ci\u00f2 implica che la variabile originaria non sar\u00e0 modificata.</p> <p>Il secondo modo \u00e8, invece, per reference: in questo caso, viene passato il riferimento all'indirizzo di memoria associato alla variabile in ingresso alla funzione, e la variabile originaria sar\u00e0 quindi modificata.</p> <p>Nota</p> <p>I \"fanatici\" del C affermano che il linguaggio preveda esclusivamente il passaggio per valore. Tuttavia, il passaggio per reference pu\u00f2 essere tranquillamente emulato utilizzando un puntatore come argomento della funzione, come vedremo a breve.</p>"},{"location":"material/02_programming_c/19_pointers/lecture/#1931-passaggio-di-un-puntatore-come-argomento-di-una-funzione","title":"19.3.1 - Passaggio di un puntatore come argomento di una funzione","text":"<p>Come abbiamo detto in precedenza, per \"emulare\" un passaggio per reference potremo passare un puntatore come argomento di una funzione. Questo implica, ovviamente, che il passaggio avverr\u00e0 s\u00ec per valore, ma sar\u00e0 relativo ad un indirizzo di memoria!</p> <p>Di conseguenza, ogni operazione effettuata sul puntatore avr\u00e0 esclusiva validit\u00e0 all'interno della funzione, ma la variabile puntata sar\u00e0, nei fatti, passata per reference, e potr\u00e0 essere modificata. In questi casi, si parla (in maniera in qualche modo forzata) di passaggio per indirizzo. Ad esempio:</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid f(int *j) {\n  (*j)++;\n}\n\nint main() {\n  int i = 20;\n  int *p = &amp;i;\n  f(p);\n  printf(\"i = %d\\n\", i);        // i sar\u00e0 pari a 21!\n  return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/19_pointers/lecture/#194-puntatore-a-void","title":"19.4 - Puntatore a void","text":"<p>A volte potrebbe essere necessario creare un puntatore prima che il programma \"conosca\" il tipo della variabile puntata. In questo caso, si utilizza un puntatore a <code>void</code>:</p> <pre><code>void* puntatore_generico;\n</code></pre> <p>In pratica, un puntatore di questo tipo pu\u00f2 essere utilizzato come generico placeholder, e non pu\u00f2 essere in alcun modo dereferenziato. Nel momento in cui lo si vorr\u00e0 utilizzare, inoltre, sar\u00e0 necessario effettuare un cast al tipo cui si riferisce:</p> <pre><code>char* puntatore_char = (char*) puntatore_generico;\n</code></pre>"},{"location":"material/02_programming_c/19_pointers/lecture/#195-puntatori-ed-array","title":"19.5 - Puntatori ed array","text":"<p>Esiste una corrispondenza pratica tra array e puntatori; infatti, dal punto di vista semantico, gli array sono dei particolari tipi di puntatori. Infatti, nel momento in cui si dichiara un array, si alloca la memoria necessaria sia alla struttura dati stessa, sia all'area puntata; \u00e8 per questo, quindi, che \u00e8 necessario definire a priori la lunghezza dell'array, e procedere con un'allocazione di tipo statico.</p> <p>Interessante anche notare come il puntatore associato all'array sia dichiarato costante mediante la keyword <code>const</code>. La conseguenza diretta di questo \u00e8 che l'indirizzo dell'array non \u00e8 modificabile; una conseguenza indiretta, ma altrettanto importante, \u00e8 che l'array non pu\u00f2 essere usato come l-value. E, in definitiva, \u00e8 questo il motivo per il quale una serie di istruzioni di questo tipo non \u00e8 valida:</p> <pre><code>int lista[3];\nlista = { 1, 2, 3 };\n</code></pre>"},{"location":"material/02_programming_c/19_pointers/lecture/#196-puntatori-e-funzioni","title":"19.6 - Puntatori e funzioni","text":"<p>Per una funzione \u00e8 possibile avere un puntatore come valore di ritorno.</p> <p>Ricordiamo che il valore di ritorno \u00e8, come sempre, passato per valore: ci\u00f2 garantisce quindi che il puntatore usato nell'ambito della funzione sia restituito correttamente. Ci\u00f2, tuttavia, non \u00e8 garantito per la variabile puntata, che deve appartenere ad un ambito adeguato (e, quindi, non locale alla funzione), oppure essere dichiarata <code>static</code>.</p>"},{"location":"material/02_programming_c/19_pointers/lecture/#197-esercizi","title":"19.7 - Esercizi","text":"<ol> <li>Scriviamo le funzioni, <code>mostra_puntatore_intero</code> e <code>mostra_puntatore_decimale</code>, che accettano, rispettivamente, un valore intero ed un valore reale. Le due funzioni non restituiscono alcun valore, e stampano a schermo l'indirizzo di memoria associato alla variabile passata come parametro.</li> <li>Scriviamo le funzioni <code>deferenzia_compara_intero</code> e <code>deferenzia_compara_decimale</code>, che accettano due argomenti in ingresso, ovvero una variabile ed un puntatore alla stessa. Come suggerisce il nome delle funzioni, la prima tratta valori interi, la seconda decimali. Le funzioni devono verificare la correttezza dell'operazione di dereferenziazione, ed in caso affermativo restituire il vlaore della variabile dereferenziata, mentre in caso negativo restituire il valore -1.</li> <li>Scriviamo la <code>restituisci_puntatore</code> che accetta come parametro un intero e restituisce il puntatore allo stesso. Verificare se l\u2019indirizzo associato al puntatore restituito \u00e8 lo stesso ottenuto utilizzando l\u2019operatore <code>&amp;</code> all\u2019interno della funzione chiamante.</li> <li>Scriviamo la funzione <code>puntatore_a_void</code> per creare un puntatore a void da associare poi ad una variabile di tipo <code>char</code> passata in ingresso.</li> </ol>"},{"location":"material/02_programming_c/20_memory/lecture/","title":"20 - Allocazione statica e dinamica della memoria","text":"<p>La memoria di un calcolatore \u00e8 tipicamente divisa in tre sezioni:</p> <ul> <li>la heap, ovvero una parte di memoria richiamabile all'occorrenza dal programmatore;</li> <li>lo stack, nel quale le variabili vengono dichiarate, inizializzate a runtime, e che agisce secondo una logica LIFO;</li> <li>la code section, dove viene memorizzato il programma a runtime.</li> </ul> <p>Questa disposizione della memoria ci permette quindi di allocarla (ovvero assegnarla) secondo due modalit\u00e0, statica e dinamica.</p>"},{"location":"material/02_programming_c/20_memory/lecture/#201-allocazione-statica-della-memoria","title":"20.1 - Allocazione statica della memoria","text":"<p>L'allocazione statica della memoria prevede che il programma in esecuzione abbia una dimesione prefissata a compile time, la quale non pu\u00f2 essere in alcun modo modificata a runtime. Ovviamente, ci\u00f2 implica che il programmatore sia in grado di definire esattamente a priori i requisiti del suo programma in termini di memoria. </p> <p>Un esempio di allocazione statica della memoria \u00e8 il seguente:</p> <pre><code>int main()\n{\n    int a;      // prealloco 4 byte\n    long b;     // prealloco 8 byte\n}\n</code></pre> <p>Nel codice precedente dichiariamo due variabili, per le quali saranno allocate, rispettivamente, 32 e 64 bit all'interno dello stack. A runtime, a meno che non siano specificate delle apposite operazioni di cast, la quantit\u00e0 di memoria allocata non verr\u00e0 modificata, e sar\u00e0 liberata in automatico soltanto al termine dell'esecuzione dello stesso.</p> <p>Riassumiamo quindi i vantaggi e gli svantaggi dell'allocazione statica.</p> Vantaggi Svantaggi Semplicit\u00e0 di utilizzo.Delega al compilatore dell'allocazione della memoria.Efficiente a runtime. Memoria non necessariamente utilizzata al meglio (specie con array).Necessit\u00e0 di conoscere a priori i requisiti in termini di memoria.Impossibilit\u00e0 di riallocare la memoria a runtime."},{"location":"material/02_programming_c/20_memory/lecture/#202-allocazione-dinamica-della-memoria","title":"20.2 - Allocazione dinamica della memoria","text":"<p>A differenza dell'allocazione statica, nell'allocazione dinamica \u00e8 il programmatore a controllare quanta memoria viene allocata. Inoltre, in questo caso, viene utilizzata la memoria heap, e non lo stack. L'allocazione dinamica prevede quindi che la memoria non sia allocata a priori, ovvero a compile time, ma piuttosto a runtime; di conseguenza, pu\u00f2 essere sia assegnata, sia liberata, e farlo in maniera corretta comporta un utilizzo pi\u00f9 efficiente della memoria stessa.</p> <p>Dal punto di vista pratico, la libreria <code>stdlib.h</code> offre una serie di funzioni che permettono l'allocazione dinamica della memoria, che vediamo di seguito.</p>"},{"location":"material/02_programming_c/20_memory/lecture/#2021-la-funzione-malloc","title":"20.2.1 - La funzione <code>malloc</code>","text":"<p>La funzione <code>malloc</code> permette di allocare un certo quantitativo di memoria a runtime, specificando come parametro passato alla funzione il numero di byte da allocare. Quindi, ad esempio:</p> <pre><code>int num_values = 10;\nint *p = (int*) malloc(num_values);\n</code></pre> <p>Grazie all'istruzione precedente, avremo allocato spazio sufficiente a contenere dieci numeri interi a quattro byte, ovvero quaranta byte.</p> <p>Inoltre, \u00e8 opportuno notare come la <code>malloc</code> restituisca in uscita un indirizzo di memoria; in questo caso, quindi, \u00e8 necessario effettuare un casting a puntatore ad intero.</p>"},{"location":"material/02_programming_c/20_memory/lecture/#2022-la-funzione-calloc","title":"20.2.2 - La funzione <code>calloc</code>","text":"<p>La funzione <code>calloc</code> offre un vantaggio rispetto alla <code>malloc</code>, inizializzando gli elementi allocati in modo che questi assumano un valore pari a zero. La sintassi \u00e8 la seguente:</p> <pre><code>int num_values = 10;\nint *p = (int*) calloc(num_values, sizeof(int))\n</code></pre> <p>Notiamo subito come vi sia una prima differenza rispetto alla <code>malloc</code> legata al fatto che la funzione accetta due parametri, ovvero il numero di oggetti per i quali \u00e8 richiesta l'allocazione, e la dimensione di ciascun oggetto. Anche in questo caso, la funzione restituisce un indirizzo di memoria.</p>"},{"location":"material/02_programming_c/20_memory/lecture/#2023-la-funzione-realloc","title":"20.2.3 - La funzione <code>realloc</code>","text":"<p>La funzione <code>realloc</code> ci permette di riutilizzare o estendere la memoria che abbiamo allocato in precedenza mediante la <code>malloc</code> o la <code>calloc</code>. In tal senso, la funzione accetta due argomenti, ovvero il tipo del puntatore precedentemente allocato, ed il numero di nuovi elementi da allocare.</p> <pre><code>int new_size = 20;\np = (int*) realloc(p, new_size)\n</code></pre>"},{"location":"material/02_programming_c/20_memory/lecture/#2024-la-funzione-free","title":"20.2.4 - La funzione <code>free</code>","text":"<p>Una delle cose pi\u00f9 importanti da tenere a mente quando abbiamo a che fare con l'allocazione dinamica \u00e8 che la memoria deve essere sempre rilasciata qualora non sia pi\u00f9 richiesta. Ci\u00f2 avviene di solito in maniera automatica al termine dell'esecuzione del programma; tuttavia, \u00e8 consigliato effettuare tale rilascio sempre in maniera esplicita. Per farlo, dobbiamo utilizzare la funzione <code>free</code>, passando come argomento il puntatore all'indirizzo di memoria che desideriamo liberare.</p> <p>Facciamo adesso un esempio completo:</p> <pre><code>#include &lt;stdlib.h&gt;\n\nint main()\n{\n    int *p;\n    p = (int*) malloc(5 * sizeof(int));\n    free(p);\n    return 0;\n}\n</code></pre> <p>Nel codice precedente:</p> <ul> <li>alla riga 5, dichiariamo un puntatore ad intero <code>p</code>;</li> <li>il puntatore viene memorizzato nello stack, e punta all'indirizzo del primo valore di memoria disponibile nell'heap grazie alla <code>malloc</code> (riga 6);</li> <li>una volta terminata la serie di istruzioni da eseguire, la memoria puntata da <code>p</code> viene rilasciata mediante la <code>free</code>.</li> </ul> <p>Anche per l'allocazione dinamica possiamo riassumere vantaggi e svantaggi.</p> Vantaggi Svantaggi Allocazione della memoria fatta a runtime.Possibilit\u00e0 di allocare, deallocare e riallocare ulteriore memoria alla bisogna. Maggior tempo di esecuzione richiesto per l'allocazione dinamica.Necessit\u00e0 di gestire la deallocazione della memoria in forma esplicita."},{"location":"material/02_programming_c/21_io_files/lecture/","title":"20 - Tecniche di I/O in C","text":""},{"location":"material/02_programming_c/21_io_files/lecture/#201-il-concetto-di-stream","title":"20.1 - Il concetto di stream","text":"<p>Il linguaggio C adotta estensivamente il concetto di stream (traducibile in italiano con flusso) per gestire i meccanismi di interazione di un programma con le sorgenti di input (ingresso) o le destinazioni in output (uscita). Abbiamo gi\u00e0 usato uno stream, ad esempio, con la funzione <code>printf</code>: in questo caso, infatti, abbiamo creato un flusso dati verso l'utente, mostrando a schermo un certo output definito all'interno del nostro programma.</p> <p>Concettualmente, uno stream \u00e8 assimilabile ad una sorta di \"intermediario\", che permette al nostro programma di gestire indirettamente la sorgente (o destinazione) dei dati. In altre parole, il programma non interagisce direttamente con i dispositivi di input ed output, ma bens\u00ec esclusivamente con lo stream. Ci\u00f2 permette quindi di \"astrarsi\" dall'effettivo dispositivo di interazione, consentendo di utilizzare oggetti e metodi affini in casi eterogenei, come uso di tastiera, stampanti, o anche (e soprattutto) file.</p>"},{"location":"material/02_programming_c/21_io_files/lecture/#202-i-file-in-c","title":"20.2 - I file in C","text":"<p>Intuitivamente, sappiamo che i file altro non sono se non degli insiemi di dati, organizati e memorizzati in memoria in maniera ordinata. In particolare, il C riconosce due tipi di file: </p> <ul> <li>i primi sono i file di testo, normalmente intelliggibili dall'essere umano, e formati da sequenze di caratteri organizzate in linee, ognuna delle quali termina con l'escape character <code>\\n</code>;</li> <li>i second sono i file binari, costituiti da sequenze di bit di lunghezza arbitraria, e contenenti dati relativi a programmi, librerie, o altro ancora.</li> </ul> <p>Ad ogni modo, i contenuti di un file sono accessibili in C secondo due diverse modalit\u00e0:</p> <ul> <li>accedendo ad un file in maniera sequenziale, possiamo accedere a ciascun elemento \"scorrendo\" i precedenti;</li> <li>accedendo ad un file in maniera casuale, o diretta, siamo in grado di accedere direttamente all'elemento che ci interessa.</li> </ul>"},{"location":"material/02_programming_c/21_io_files/lecture/#2021-accesso-al-file","title":"20.2.1 - Accesso al file","text":""},{"location":"material/02_programming_c/21_io_files/lecture/#20211-puntatore-a-file","title":"20.2.1.1 - Puntatore a <code>FILE</code>","text":"<p>Per accedere ad un file, C ci mette a disposizione un apposito puntatore al tipo <code>FILE</code>, definito nell'header <code>stdio.h</code>, che restituisce la locazione iniziale del file a cui si vuole accedere. Questa sintassi va quindi sempre utilizzata qualora si voglia interagire con un file:</p> <pre><code>#include &lt;stdio.h&gt;\n\n// ...\n\nFILE *fp;\n</code></pre>"},{"location":"material/02_programming_c/21_io_files/lecture/#20212-apertura-del-file-con-fopen","title":"20.2.1.2 - Apertura del file con <code>fopen</code>","text":"<p>Per aprire il file, \u00e8 necessario utilizzare la funzione <code>fopen</code>, contenuta in <code>stdio.h</code> che permette di operare in diverse modalit\u00e0 usando una sintassi del tipo:</p> <pre><code>FILE fopen(file_name, mode);\n</code></pre> <p>In particolare:</p> <ul> <li><code>file_name</code> \u00e8 un array di <code>char</code> che indica il nome del file da aprire;</li> <li><code>mode</code> \u00e8 un array di <code>char</code> che indica la modalit\u00e0 con cui il file sar\u00e0 aperto.</li> </ul> <p>Per quello che riguarda la modalit\u00e0 di apertura del file, si pu\u00f2 scegliere una tra le seguenti:</p> Modo Descrizione File gi\u00e0 esistente? <code>r</code> Apertura di un file in sola lettura. S\u00ec, necessario. <code>r+</code> Apertura di un file esistente in lettura/scrittura. S\u00ec, necessario. <code>w</code> Creazione di un nuovo file in scrittura. Se il file esiste, ne viene cancellato il contenuto. Non necessario. <code>w+</code> Creazione di un nuovo file in lettura/scrittura. Se il file esiste, ne viene cancellato il contenuto. Non necessario. <code>a</code> Aggiunta di nuovi contenuti a partire dalla fine del file. Se il file non esiste, viene creato. Non necessario. <code>a+</code> Aggiunta e lettura di nuovi contenuti a partire dalla fine del file. Se il file non esiste, viene creato. Non necessario. <p>In aggiunta al mode, \u00e8 possibile specificare il tipo di file da aprire, specificando la lettera <code>b</code> (binario) o <code>t</code> (testo). Se quest'ultimo valore non viene specificato, viene supposto il valore <code>t</code>.</p> <p>Ad esempio, per aprire il file di testo <code>prova.txt</code> in modalit\u00e0 di lettura/scrittura, si usano le seguenti istruzioni:</p> <pre><code>FILE *fp;\n\nif (fp=fopen(\"prova.txt\", \"w+t\") == NULL) {\n    printf(\"Errore nell'apertura del file desiderato.\");\n}\n</code></pre> <p>Nota</p> <p>Nelle istruzioni precedenti, \u00e8 bene notare come venga controllata l'esistenza del file. Con la modalit\u00e0 <code>w</code> un controllo di questo tipo \u00e8 ridondante, ma nel caso si utilizzi la modalit\u00e0 <code>r</code> tale controllo pu\u00f2 rivelarsi critico.</p>"},{"location":"material/02_programming_c/21_io_files/lecture/#20213-chiusura-di-un-file-con-fclose","title":"20.2.1.3 - Chiusura di un file con <code>fclose</code>","text":"<p>Una volta terminato l'utilizzo del file, \u00e8 necessario chiamare la funzione <code>fclose</code> che, come dice il nome stesso, permette di chiudere lo stream relativo al file stesso. In tal senso, la sintassi che si utilizza \u00e8 la seguente:</p> <pre><code>int fclose(FILE *fp);\n</code></pre> <p>La funzione <code>fclose</code> restituisce un valore intero pari a <code>0</code> se il tutto \u00e8 andato a buon fine.</p> <p>Proviamo ad estendere il programma precedente integrando la <code>fclose</code> al termine del file.</p> <pre><code>FILE *fp;\n\nif (fp=fopen(\"prova.txt\", \"w+t\") == NULL) {\n    printf(\"Errore nell'apertura del file desiderato.\");\n}\n\n// Uso del file...\n\nfclose(fp);\n</code></pre>"},{"location":"material/02_programming_c/21_io_files/lecture/#2022-scrittura-su-file","title":"20.2.2 - Scrittura su file","text":"<p>La funzione <code>fprintf</code> permette di scrivere su di un file a seguito dell'apertura dello stesso. Come appare evidente anche dall'assonanza, questa funzione \u00e8 simile alla classica <code>prinft</code>, ed adotta una sintassi del tipo:</p> <pre><code>int fprintf(FILE *fp, char *format, [args])\n</code></pre> <p>Le differenze principali rispetto alla <code>printf</code> sono quindi due:</p> <ul> <li>il primo sta nel fatto che la funzione accetta come primo argomento un puntatore a file;</li> <li>il secondo invece sta nel fatto che la funzione restituisce un intero come valore di ritorno, rappresentativo del numero di caratteri scritto nello stream.</li> </ul> <p>Nota</p> <p>Qualora la <code>fprintf</code> restituisca un valore pari alla costante <code>EOF</code>, vorr\u00e0 dire che vi \u00e8 stato un errore nella scrittura dei dati.</p> <p>Facciamo un esempio:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    FILE *fp;\n\n    if (fp=fopen(\"prova.txt\", \"w+t\") == NULL) {\n        printf(\"Errore nell'apertura del file desiderato.\");\n    }\n\n    fprintf(fp, \"Il file esiste!\");\n\n    fclose(fp);\n}\n</code></pre>"},{"location":"material/02_programming_c/21_io_files/lecture/#2023-lettura-di-un-input","title":"20.2.3 - Lettura di un input","text":""},{"location":"material/02_programming_c/21_io_files/lecture/#20231-lettura-di-uno-stream-da-tastiera-la-funzione-scanf","title":"20.2.3.1 - Lettura di uno stream da tastiera: la funzione <code>scanf</code>","text":"<p>La funzione <code>scanf</code> ci permette di acquisire una sequenza di caratteri (lettere o cifre) dalla tastiera, memorizzandola in un'opportuna variabile; per i pi\u00f9 attenti, apparir\u00e0 chiaro come questa sia una sorta di funzione \"duale\" alla <code>printf</code>.</p> <p>La sintassi della <code>scanf</code> \u00e8 quella riportata di seguito:</p> <pre><code>scanf(char* format, [args]);\n</code></pre> <p>Notiamo innazitutto che non vi \u00e8 un valore di ritorno atteso. Infatti, le variabili da \"popolare\" saranno specificate mediante un puntatore tra gli <code>args</code> passati dopo la serie di specificatori di formato associati all'argomento <code>format</code>.</p> <p>Ad esempio, usando l'istruzione:</p> <pre><code>int x;\nscanf(\"%d%, &amp;x);\n</code></pre> <p>faremo in modo che il valore numerico digitato da tastiera venga salvato nella variabile <code>x</code>. In alternativa, se volessimo salvare un intero ed un decimale, e salvarli nelle variabili <code>x</code> ed <code>y</code>, dovremmo scrivere:</p> <pre><code>int x;\nint y;\nscanf(\"%d %f\", &amp;x, &amp;y);\n</code></pre> <p>Nota</p> <p>Nel tempo, l'uso di <code>scanf</code> \u00e8 diventato \"sconsigliato\". Per approfondire, leggete qui.</p>"},{"location":"material/02_programming_c/21_io_files/lecture/#20232-lettura-di-un-file-la-funzione-fscanf","title":"20.2.3.2 - Lettura di un file: la funzione <code>fscanf</code>","text":"<p>In maniera alquanto \"prevedibile\", la funzione <code>fscanf</code> permette di leggere il contenuto di un file; rappresenta quindi la funzione duale alla <code>fprintf</code>, o equivalente alla <code>scanf</code> per file. </p> <p>Vediamo quindi qual \u00e8 il prototipo della funzione:</p> <pre><code>int fscanf(FILE *fp, char *format, [args]);\n</code></pre> <p>In questo caso, viene restituito un valore intero, che rappresenta il numero di caratteri letti dalla funzione. Inoltre, come primo argomento, avremo sempre il puntatore al file da leggere.</p>"},{"location":"material/02_programming_c/21_io_files/lecture/#2024-fine-di-un-file-la-funzione-feof","title":"20.2.4 - Fine di un file: la funzione <code>feof</code>","text":"<p>Chiudiamo questa carrellata con la funzione <code>feof</code>, che ci permette di capire se ci troviamo o meno alla fine del file. Il corpo di questa funzione \u00e8 definito come:</p> <pre><code>int feof(FILE *fp);\n</code></pre> <p>In particolare, la funzione restituir\u00e0 0 se non \u00e8 ancora stata raggiunta la fine del file, o 1 altrimenti. </p> <p>L'uso della <code>feof</code> pu\u00f2 essere utile nel momento in cui, ad esempio, si legge un file carattere per carattere all'interno di un ciclo, e si vuole uscire dallo stesso quando il file termina. Ad esempio:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define N 5\n\nint main() {\n    FILE *fp;\n    char cognome[20];\n    char nome[20];\n    int i, voto;\n\n    if((fp=fopen(\"alunni.txt\", \"rt\"))==NULL) {\n        printf(\"Errore nell'apertura del file'\");\n        exit(1);\n    }\n\n    while(!feof(fp)){\n        fscanf(fp,\"%s %s %d\\n\", &amp;cognome, &amp;nome, &amp;voto);\n        printf(\"cognome: %s, nome: %s, voto: %d\\n\", cognome, nome, voto);\n    }\n    fclose(fp);\n\nreturn 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/22_typedef/exercises/","title":"E21 - <code>Struct</code>, <code>typedef</code> ed <code>union</code>","text":""},{"location":"material/02_programming_c/22_typedef/exercises/#esercizio-e211","title":"Esercizio E21.1","text":"<p>Scrivere un programma che definisca una <code>struct</code> per gli studenti, rappresentante nome, cognome ed et\u00e0, ed una <code>union</code> per il voto di un esame, che pu\u00f2 essere intero o reale. Mostrarne il funzionamento in un'apposita funzione <code>main()</code>.</p>"},{"location":"material/02_programming_c/22_typedef/exercises/#soluzione-s211","title":"Soluzione S21.1","text":"<p>Ecco una possibile soluzione.</p> <pre><code>#pragma warning(disable: 4996)\n#include &lt;stdio.h&gt;\n\ntypedef struct studente\n{\n    char nome[20];\n    char cognome[20];\n    int eta;\n} STUDENTE;\n\ntypedef union voto_esame\n{\n    int voto_int;\n    double voto_double;\n} VOTO_ESAME;\n\nint main() {\n    // Accedo mediante l'operatore punto\n    STUDENTE primo_studente = { \"\", \"\", 0 };\n\n    // Popolo\n    printf(\"Inserire il nome: \");\n    if (scanf(\"%s\", primo_studente.nome) &lt;= 0)\n        return -1;\n    printf(\"Inserire il cognome: \");\n    if (scanf(\"%s\", primo_studente.cognome) &lt;= 0)\n        return -1;\n    printf(\"Inserire l'eta': \");\n    if (scanf(\"%d\", &amp;primo_studente.eta) &lt;= 0)\n        return -1;\n\n    printf(\"Nome: %s - Cognome: %s - Eta: %d\\n\", primo_studente.nome, primo_studente.cognome, primo_studente.eta);\n\n    // Accedo mediante puntatore\n    STUDENTE secondo_studente = { \"\", \"\", 0 };\n    STUDENTE* puntatore_studente = &amp;secondo_studente;\n\n    // Popolo\n    printf(\"Inserire un nuovo nome: \");\n    if (scanf(\"%s\", puntatore_studente-&gt;nome) &lt;= 0)\n        return -1;\n    printf(\"Inserire un nuovo cognome: \");\n    if (scanf(\"%s\", puntatore_studente-&gt;cognome) &lt;= 0)\n        return -1;\n    printf(\"Inserire una nuova eta': \");\n    if (scanf(\"%d\", &amp;puntatore_studente-&gt;eta) &lt;= 0)\n        return -1;\n\n    printf(\"Nome: %s - Cognome: %s - Eta: %d\\n\", secondo_studente.nome, secondo_studente.cognome, secondo_studente.eta);\n\n    // Definisco la union\n    VOTO_ESAME voto_primo_esame = { 0 };\n    VOTO_ESAME voto_secondo_esame = { 0.0 };\n    VOTO_ESAME* puntatore_primo_esame = &amp;voto_primo_esame;\n\n    printf(\"Inserire il voto (intero) per il primo esame: \");\n    if (scanf(\"%d\", &amp;voto_primo_esame.voto_int) &lt;= 0)\n        return -1;\n\n    printf(\"Inserire il voto (decimale) per il secondo esame: \");\n    if (scanf(\"%lf\", &amp;voto_secondo_esame.voto_double) &lt;= 0)\n        return -1;\n\n    printf(\"Aggiornare il voto (decimale) per il primo esame: \");\n    if (scanf(\"%lf\", &amp;puntatore_primo_esame-&gt;voto_double) &lt;= 0)\n        return -1;\n\n    printf(\"Il voto per il primo esame e' %d (intero) e %lf (decimale)\\n\", voto_primo_esame.voto_int, voto_primo_esame.voto_double);\n\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/22_typedef/lecture/","title":"21 - <code>Struct</code>, <code>typedef</code> ed <code>union</code>","text":"<p>Abbiamo visto come il linguaggio C consenta l'utilizzo di una serie di tipi di dati primitivi. Tuttavia, consentirci soltanto questo sarebbe in un certo senso \"limitante\": ad esempio, potremmo voler creare una singola variabile che rappresenti una persona, senza dover necessariamente \"far proliferare\" tutta una serie di sottovariabili contenenti, ad esempio, nome, cognome ed et\u00e0.</p> <p>Per ovviare a questa limitazione, quindi, il C ci mette a disposizione un particolare costrutto rappresentativo di una struttura dati definita dall'utente; come prevedibile, tale costrutto va sotto il nome di <code>struct</code>.</p>"},{"location":"material/02_programming_c/22_typedef/lecture/#211-le-struct","title":"21.1 - Le <code>struct</code>","text":"<p>I pi\u00f9 attenti ricorderanno come abbiamo gi\u00e0 visto il concetto di struct durante il nostro excursus sulle strutture dati; ovviamente, le <code>struct</code> C rappresentano un'implementazione di questa classe di strutture dati, e permettono quindi di \"raggruppare\" diverse variabili tra loro.</p> <p>Ad esempio, potremmo creare una <code>struct</code> che serva a caratterizzare una persona:</p> <pre><code>struct persona\n{\n    char *nome;\n    char *cognome;\n    int eta;\n};\n</code></pre> <p>In generale, quindi, una <code>struct</code> \u00e8 definita nel modo che segue:</p> <pre><code>struct NOME_STRUCT\n{\n    tipo_variabile_1 id_variabile_1;\n    tipo_variabile_2 id_variabile_2;\n    // ...\n    tipo_variabile_n id_variabile_n;\n}\n</code></pre> <p>Nel nostro esempio, una variabile associata alla struct <code>persona</code> avr\u00e0 quindi un array di <code>char</code> relativo al nome, un array di <code>char</code> relativo al cognome, ed un <code>int</code> relativo all'et\u00e0.</p> <p>Proviamo adesso ad utilizzare questa <code>struct</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nstruct persona\n{\n    char *nome;\n    char *cognome;\n    int eta;\n};\n\nint main()\n{\n    struct persona studente;\n    return 0;\n}\n</code></pre> <p>Abbiamo creato una variabile di \"tipo\" persona. Potremo accedere a ciascuna delle \"sottovariabili\", o membri, della <code>struct</code> utilizzando l'operatore dot (punto):</p> <pre><code>#include &lt;stdio.h&gt;\n\nstruct persona\n{\n    char *nome;\n    char *cognome;\n    int eta;\n};\n\nint main()\n{\n    struct persona studente;\n\n    studente.nome = \"John\";\n    studente.cognome = \"Doe\";\n    studente.eta = 19;\n\n    printf(\"Lo studente %s %s ha %d anni\\n\", studente.name, studente.cognome, studente.eta);\n\n    return 0;\n}\n</code></pre> <p>Abbiamo quindi visto come l'accesso mediante l'operatore punto valga sia in lettura, sia in scrittura.</p>"},{"location":"material/02_programming_c/22_typedef/lecture/#2211-puntatori-a-struct","title":"22.1.1 - Puntatori a <code>struct</code>","text":"<p>Possiamo anche definire dei puntatori ad una struttura. In questo caso, per\u00f2, per accedre alla singola propriet\u00e0 della <code>struct</code>, dovremo utilizzare infix (-&gt;)</p> <pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct persona\n{\n    char *nome;\n    char *cognome;\n    int eta;\n} PERSONA;\n\nint main()\n{\n    PERSONA* puntatore_studente;\n\n    puntatore_studente-&gt;nome = \"John\";\n    puntatore_studente-&gt;cognome = \"Doe\";\n    puntatore_studente-&gt;eta = 19;\n\n    printf(\"Lo studente %s %s ha %d anni\\n\", studente-&gt;name, studente-&gt;cognome, studente-&gt;eta);\n\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/22_typedef/lecture/#222-definizione-di-tipo-con-typedef","title":"22.2 - Definizione di tipo con <code>typedef</code>","text":"<p>Abbiamo visto come le <code>struct</code> ci permettano di \"associare\" diverse variabili tra loro, definendo dei veri e propri \"tipi\" composti da diverse variabili appartenenti a tipi primitivi. Il passo successivo, quindi, \u00e8 quello di \"formalizzare\" queste strutture; per farlo, il linguaggio C ci mette a disposizione la parola chiave <code>typedef</code> che, come suggerisce il nome stesso, consente di creare un tipo definito dall'utente.</p> <p>Ad esempio, potremmo creare un tipo da associare alla <code>struct</code> persona:</p> <pre><code>typedef struct persona\n{\n    char *nome;\n    char *cognome;\n    int eta;\n} TIPO_PERSONA;\n</code></pre> <p>In questo caso, l'identificativo associato alla <code>struct</code> rimane <code>persona</code> (in minuscolo), mentre il tipo definito a partire dalla <code>struct persona</code> sar\u00e0 <code>TIPO_PERSONA</code>.</p> <p>Potremo quindi creare una variabile di tipo <code>TIPO_PERSONA</code> proprio come se fosse una variabile di tipo primitivo:</p> <pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct persona\n{\n    char *nome;\n    char *cognome;\n    int eta;\n}PERSONA;\n\nint main()\n{\n    PERSONA studente;\n    // altre istruzioni\n    return 0;\n}\n</code></pre> <p>Sottolineamo come la definizione di un tipo non sia vincolata ad una struct. Ad esempio, potremmo definire un tipo che rappresenta un puntatore ad intero.</p> <pre><code>#include &lt;stdio.h&gt;\n\ntypedef int* int_pointer;\n\nint main() {\n    int val = 0.0;\n    int_pointer pointer = &amp;val;\n    printf(\"Il valore del puntatore e': %p\", pointer);\n    return 0;\n}\n</code></pre>"},{"location":"material/02_programming_c/22_typedef/lecture/#223-le-union","title":"22.3 - Le <code>union</code>","text":"<p>Quando abbiamo parlato di strutture dati abbiamo visto, oltre alle struct, le union. Prevedibilmente, il C ci mette a disposizione oggetti di questo tipo, che risultano essere sintatticamente analoghi alle <code>struct</code>, ma che tuttavia implementano una struttura dati di tipo differente. Vediamo un rapido esempio.</p> <pre><code>#include&lt;stdio.h&gt;\n\ntypedef union lettura_sensore {\n    double d;\n    int i;\n} LETTURA_SENSORE;\n\nint main()\n{\n    LETTURA_SENSORE lettura;\n    lettura.d = 12.0;\n    lettura.i = 5;\n}\n</code></pre> <p>TODO: puntatore, printf</p>"},{"location":"material/03_programming_python/23_intro/exercises/","title":"E23 - Introduzione a Python","text":""},{"location":"material/03_programming_python/23_intro/exercises/#esercizio-e231","title":"Esercizio E23.1","text":"<p>Creiamo una stringa che assuma valore IUL.</p>"},{"location":"material/03_programming_python/23_intro/exercises/#soluzione-s101","title":"Soluzione S10.1","text":"<pre><code>&gt;&gt;&gt; s = 'IUL'\n</code></pre>"},{"location":"material/03_programming_python/23_intro/exercises/#esercizio-e232","title":"Esercizio E23.2","text":"<p>Valutiamo la lunghezza della stringa creata nell'esercizio precedente.</p>"},{"location":"material/03_programming_python/23_intro/exercises/#soluzione-s102","title":"Soluzione S10.2","text":"<pre><code>&gt;&gt;&gt; len(s)\n</code></pre>"},{"location":"material/03_programming_python/23_intro/exercises/#esercizio-e233","title":"Esercizio E23.3","text":"<p>Proviamo a creare una lista a partire dalla stringa creata nell'esercizio precedente.</p>"},{"location":"material/03_programming_python/23_intro/exercises/#soluzione-s103","title":"Soluzione S10.3","text":"<pre><code>&gt;&gt;&gt; l = ['IUL']\n&gt;&gt;&gt; l = ['I', 'U', 'L']\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/","title":"23 - Introduzione a Python","text":"<p>Materiale e link utili</p> Materiale Disponibilit\u00e0 Link Slides mostrate a lezione Download Video esplicativo Link non disponibile <p>Prima di iniziare a parlare del linguaggio Python, \u00e8 opportuno verificare che l'interprete sia installato nel nostro sistema. Per farlo, apriamo un terminale (Shell o Command Prompt, a seconda del nostro sistema), e scriviamo:</p> <pre><code>$ python\n</code></pre> <p>Se apparir\u00e0 una schermata simile a quella mostrata in figura, Python sar\u00e0 gi\u00e0 correttamente presente nel nostro sistema.</p> <p></p> <p>In alternativa, dovremo provvedere ad installarlo seguendo la procedura indicata sul sito ufficiale, ed aggiungerlo al path di sistema.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#231-python-e-tipizzazione","title":"23.1 - Python e tipizzazione","text":""},{"location":"material/03_programming_python/23_intro/lecture/#2311-tipizzazione-dinamica","title":"23.1.1 - Tipizzazione dinamica","text":"<p>Python \u00e8 un linguaggio interpretato ed a tipizzazione dinamica. In breve, questo significa che l'interprete valuta il tipo di ciascuna variabile a runtime, e che questo pu\u00f2 cambiare durante l'esecuzione del programma.</p> <p>Ma, a conti fatti, in cosa si traduce per il programmatore? Beh, molto semplice.</p> <p>Immaginiamo di dover definire ed inizializzare una variabile di tipo intero in un linguaggio a tipizzazione statica, come ad esempio il C++. Per farlo, scriveremo qualcosa simile a:</p> <pre><code>int var = 0;\n</code></pre> <p>In Python, potremo omettere il tipo, che sar\u00e0 inferito direttamente dal valore assegnato alla variabile:</p> <pre><code>var = 0\n</code></pre> <p>Immaginiamo ora che la nostra variabile debba diventare un decimale. In C++, dovremo effettuare il casting:</p> <pre><code>float fVar = float(var);\nfVar + 1.1;\n</code></pre> <p>In Python questo non sar\u00e0 necessario, e potremo effettuare direttamente le operazioni desiderate:</p> <pre><code>var + 1.1           # Il risultato sar\u00e0 2.1\n</code></pre> <p>Questo pu\u00f2 apparentemente semplificare di molto la vita, in quanto non \u00e8 pi\u00f9 necessario preoccuparsi del tipo della variabile. Non \u00e8 per\u00f2 tutto oro ci\u00f2 che luccica: per comprenderlo, infatti, \u00e8 il momento di parlare del (pilatesco) principio del duck typing.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#23111-duck-typing","title":"23.1.1.1 - Duck Typing","text":"<p>Il duck typing \u00e8 riassumibile nella seguente massima:</p> <p>Duck Typing</p> <p>If it walks like a duck and it quacks like a duck, then it must be a duck.</p> <p>che in italiano suona pi\u00f9 o meno Se cammina come un papero, e starnazza come un papero, deve essere un papero. Traduciamola brevemente in \"informatichese\". </p> <p>Immaginiamo di istruire il nostro interprete Python ad assegnare alla nostra variabile <code>var</code> il valore di <code>1</code>. L'interprete nota che la variabile si \"comporta\" come un numero intero, e quindi \"stabilir\u00e0\" che si tratti proprio di questo.</p> <p>Proviamo ora a sommare a <code>var</code> un valore pari ad <code>1.1</code>. Il risultato, come ovvio, sar\u00e0 un numero decimale, e quindi l'interprete \"cambier\u00e0 idea\", in quanto i comportamenti assunti da <code>var</code> sono adesso assimilabili ad una variabile di tipo <code>float</code>.</p> <p>L'utilit\u00e0 del duck typing \u00e8 evidente: permette allo sviluppatore di \"risparmiare\" numerose operazioni di cast, rendendo il codice pi\u00f9 semplice da scrivere e manutenere. Tuttavia, occorre tenerne conto nel momento in cui si usano classi ed oggetti, in quanto l'interprete prover\u00e0 ad inferire ed usare automaticamente un tipo in base al contesto in cui viene usata la variabile, con le comodit\u00e0 (ed i potenziali disastri) che questo comporta.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#232-linterprete-python","title":"23.2 - L'interprete Python","text":"<p>Nella sezione introduttiva abbiamo visto come installare l'interprete Python, in modo da avere un ambiente di lavoro accessibile direttamente mediante riga di comando. Lanciamolo di nuovo usando il seguente comando da una shell:</p> <pre><code>python\n</code></pre> <p>Potremo quindi finalmente iniziare ad utilizzare Python.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#233-calcoli-e-numeri","title":"23.3 - Calcoli e numeri","text":"<p>Proviamo ad usare l'interprete come una semplice calcolatrice; per farlo, scriviamo direttamente dopo il simbolo <code>&gt;&gt;&gt;</code> le operazioni che vogliamo eseguire, e premiamo il tasto <code>Invio</code>. Ad esempio:</p> <pre><code>&gt;&gt;&gt; 2 + 2\n4\n&gt;&gt;&gt; 3 * 5\n15\n&gt;&gt;&gt; 10 - 2 * 4\n2\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2331-divisioni","title":"23.3.1 - Divisioni","text":"<p>Le divisioni restituiscono sempre un numero in virgola mobile. Ad esempio:</p> <pre><code>&gt;&gt;&gt; 16 / 3\n5.333333333333333\n&gt;&gt;&gt; 2 / 2\n2.0\n</code></pre> <p>Proviamo ora ad usare altri due operatori, molto simili al classico operatore di divisione:</p> <pre><code>&gt;&gt;&gt; 16 // 3\n5\n&gt;&gt;&gt; 16 % 3\n1\n</code></pre> <p>Notiamo come in questi casi siano restituiti dei numeri interi. Il perch\u00e9 \u00e8 presto detto: gli operatori <code>//</code> e <code>%</code> calcolano, rispettivamente, il quoziente ed il resto della divisione e, come sappiamo, entrambi sono dei valori interi.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#2332-elevazione-a-potenza","title":"23.3.2 - Elevazione a potenza","text":"<p>Per elevare un numero a potenza, \u00e8 necessario usare l'operatore <code>**</code>, in cui l'operando sinistro \u00e8 la base, mentre quello destro l'esponente:</p> <pre><code>&gt;&gt;&gt; 3 ** 2\n9\n&gt;&gt;&gt; 2 ** 8\n256\n</code></pre> <p>Tipi numerici in Python</p> <p>Abbiamo finora parlato soltanto di numeri interi e decimali; tuttavia, Python supporta anche altri tipi, come ad esempio <code>Decimal</code> e <code>Fraction</code>. E' inoltre presente un supporto nativo ai numeri complessi, esprimibili usando il suffisso <code>j</code> per indicare la parte immaginaria.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#234-stringhe","title":"23.4 - Stringhe","text":"<p>In Python le stringhe possono indifferentemente essere racchiuse tra virgolette singole e doppie.</p> <pre><code>&gt;&gt;&gt; \"una stringa\"\n'una stringa'\n&gt;&gt;&gt; 'un\\'altra stringa'\n\"un'altra stringa\"\n</code></pre> <p>Notiamo nella seconda istruzione l'uso del carattere di escape (<code>\\</code>) che precede l'apostrofo; se lo omettessimo, l'interprete ci restituirebbe un errore sintattico (<code>SyntaxError</code>):</p> <pre><code>&gt;&gt;&gt; 'un'altra stringa'\n  File \"&lt;stdin&gt;\", line 1\n    'un'altra stringa\n            ^\nSyntaxError: invalid syntax\n</code></pre> <p>Nota</p> <p>Tutti i caratteri preceduti dal simbolo <code>\\</code> saranno interpretati come escape character, a meno di aggiungere il simbolo <code>r</code> prima dell'inizio della stringa:</p> <pre><code>&gt;&gt;&gt; print('C:\\nuova_cartella')\nC:\nuova_cartella\n&gt;&gt;&gt; print(r'C:\\nuova_cartella')\nC:\\nuova_cartella\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2341-stringhe-su-righe-multiple","title":"23.4.1 - Stringhe su righe multiple","text":"<p>Stringhe e liste</p> <p>La maggior parte dei concetti che vedremo nel seguito sono applicabili anche alle liste. Anzi, per essere precisi, derivano proprio dalle liste, in quanto Python considera una stringa un particolare tipo di lista.</p> <p>Le stringhe possono articolarsi su pi\u00f9 righe. Per farlo, possiamo usare le triple-quotes, ovvero tre virgolette di seguito, per indicare l'inizio e la fine della stringa:</p> <pre><code>&gt;&gt;&gt; print(\"\"\"Questo \u00e8 un esempio\\\n         di\n        riga multipla\\\n        \"\"\")\n    Questo \u00e8 un esempio di\n    riga multipla\n</code></pre> <p>Nota</p> <p>Notiamo nel precedente snippet il carattere <code>\\</code>, usato per evitare che venga automaticamente inserito dall'interprete il carattere newline (<code>\\n</code>) al termine di ogni riga. Infatti, si vede come il newline non sia stato aggiunto nelle righe evidenziate, mentre sia presente nella riga 2.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#2342-concatenazione-di-stringhe","title":"23.4.2 - Concatenazione di stringhe","text":"<p>Concatenare due stringhe in Python \u00e8 estremamente semplice, e basta usare l'operatore <code>+</code>:</p> <pre><code>&gt;&gt;&gt; stringa_a = \"Prima stringa\"\n&gt;&gt;&gt; stringa_b = \"Seconda stringa\"\n&gt;&gt;&gt; print(stringa_a + \" - \" + stringa_b)\nPrima stringa - Seconda stringa\n</code></pre> <p>Nota</p> <p>Se usiamo l'operatore <code>*</code> possiamo concatenare pi\u00f9 volte la stessa stringa:</p> <pre><code>&gt;&gt;&gt; 3 * 'co.'\n'co.co.co.'\n</code></pre> <p>Possiamo anche semplicemente porre le due stringhe l'una di seguito all'altra:</p> <pre><code>&gt;&gt;&gt; \"Py\" \"thon\"\n'Python'\n</code></pre> <p>Attenzione</p> <p>Bisogna fare particolare attenzione a non concatenare un literal (ovvero una stringa racchiusa tra virgolette) ad una variabile di tipo stringa. Se proviamo a farlo, l'interprete ci restituir\u00e0 questo errore:</p> <pre><code>&gt;&gt;&gt; py=\"Py\"\n&gt;&gt;&gt; py \"thon\"\nFile \"&lt;stdin&gt;\", line 1\npy \"thon\"\n        ^\nSyntaxError: invalid syntax\n</code></pre> <p>Lo stesso errore si presenterebbe se al posto della variabile <code>py</code> usassimo il risultato di una operazione di concatenazione:</p> <p><pre><code>&gt;&gt;&gt; ('p' + 'y') 'thon'\nFile \"&lt;stdin&gt;\", line 1\n    ('p' + 'y') 'thon'\n                  ^\nSyntaxError: invalid syntax\n</code></pre> Il consiglio, in questi casi \"ibridi\", \u00e8 quello di usare l'operatore standard di concatenazione, ovvero il <code>+</code>.</p> <p>Nota</p> <p>Esistono modi pi\u00f9 efficienti di concatenare delle stringhe, specialmente quando si ha a che fare con numerose operazioni di concatenazione in grossi cicli; l'approfondimento di tali metodi \u00e8 demandato al lettore.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#2343-indicizzazione-di-stringhe","title":"23.4.3 Indicizzazione di stringhe","text":"<p>Python definisce le stringhe come degli array di caratteri; \u00e8 quindi possibile indicizzarli. Ad esempio:</p> <pre><code>&gt;&gt;&gt; stringa = 'Python'\n&gt;&gt;&gt; stringa[0]\n'P'\n</code></pre> <p>Anche i singoli caratteri sono considerati come delle stringhe, ovviamente di lunghezza unitaria:</p> <pre><code>&gt;&gt;&gt; lettera = 'P'\n&gt;&gt;&gt; lettera[0]\n'P'\n</code></pre> <p>Python permette di accedere anche usando degli indici negativi, considerando quindi gli elementi che vanno da destra verso sinistra. In questo caso, l'indice del primo elemento da destra sar\u00e0 indicato con <code>-1</code>:</p> <pre><code>&gt;&gt;&gt; stringa[-1]\n'n'\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2344-slicing-su-stringhe","title":"23.4.4 - Slicing su stringhe","text":"<p>L'operazione di slicing permette di estrarre una certa parte di una stringa. In generale, assume la seguente forma:</p> <pre><code>&gt;&gt;&gt; stringa[i:j:s]\n</code></pre> <p>dove <code>i</code> \u00e8 l'indice iniziale, <code>j</code> quello finale ed <code>s</code> lo step utilizzato. E' importante sottolineare come l'elemento all'indice iniziale sar\u00e0 incluso, mentre quello all'indice finale sar\u00e0 escluso.</p> <p>Ad esempio:</p> <pre><code>&gt;&gt;&gt; stringa[0:2]\n'Py'\n&gt;&gt;&gt; stringa[2:5]\n'tho'\n</code></pre> <p>Se volessimo considerare tutti i caratteri fino a <code>j</code> (escluso), dovremmo usare la seguente notazione:</p> <pre><code>&gt;&gt;&gt; stringa [:j]\n</code></pre> <p>Se invece volessimo considerare tutti i caratteri a partire da <code>i</code> (incluso), dovremmo usare la seguente notazione:</p> <pre><code>&gt;&gt;&gt; stringa [i:]\n</code></pre> <p>Ad esempio:</p> <pre><code>&gt;&gt;&gt; stringa[1:]\n'ython'\n&gt;&gt;&gt; stringa[:5]\n'Pytho'\n</code></pre> <p>Anche in questo caso, \u00e8 possibile usare degli indici negativi. Ad esempio, se volessimo prendere tutti i caratteri dalla terzultima lettera fino alla fine, potremmo scrivere:</p> <pre><code>&gt;&gt;&gt; stringa[-3:]\n'hon'\n</code></pre> <p>mentre se volessimo prendere tutti i caratteri fino alla terzultima lettera (esclusa):</p> <pre><code>&gt;&gt;&gt; stringa[:-3]\n'Pyt'\n</code></pre> <p>Suggerimento</p> <p>E' possibile ottenere un'intera stringa mediante l'operazione di slicing in questo modo:</p> <pre><code>&gt;&gt;&gt; stringa[:]\n'Python'\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2345-lunghezza-di-una-stringa","title":"23.4.5 - Lunghezza di una stringa","text":"<p>La funzione <code>len()</code> ci restituisce la lunghezza di una stringa:</p> <pre><code>&gt;&gt;&gt; len(stringa)\n6\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2346-immutabilita-di-una-stringa","title":"23.4.6 - Immutabilit\u00e0 di una stringa","text":"<p>Le stringhe in Python sono immutabili. Come indica la parola stessa, questo significa che non possono essere modificate: se, ad esempio, provassimo a ridefinirne uno o pi\u00f9 elementi, acceduti magari mediante indexing o slicing, avremmo un errore.</p> <pre><code>&gt;&gt;&gt; stringa[0] = 'C'# Errore!\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'str' object does not support item assignment\n</code></pre> <p>Suggerimento</p> <p>Possiamo comunque assegnare il nome <code>stringa</code> ad una nuova variabile.</p>"},{"location":"material/03_programming_python/23_intro/lecture/#235-liste","title":"23.5 - Liste","text":"<p>Abbiamo gi\u00e0 detto che una stringa altro non \u00e8 se non un caso particolare di lista. La domanda che sorge spontanea \u00e8 quindi: cosa \u00e8 una lista?</p> <p>Le liste sono uno dei quattro tipi di strutture built-in che Python offre per memorizzare sequenze di dati. Da un punto di vista puramente \"concettuale\", potremmo considerarle alla stregua degli array presenti in altri linguaggi di programmazione, seppur con alcune, significative differenze.</p> <p>Possiamo creare una lista in questo modo:</p> <pre><code>&gt;&gt;&gt; lista = [1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2351-concatenazione-indicizzazione-e-slicing-su-liste","title":"23.5.1 - Concatenazione, indicizzazione e slicing su liste","text":"<p>Come sulle stringhe, sulle liste \u00e8 possibile effettuare operazioni di indicizzazione, slicing e concatenazione:</p> <pre><code>&gt;&gt;&gt; lista[0]\n1\n&gt;&gt;&gt; lista[2:]\n[3, 4, 5]\n&gt;&gt;&gt; lista_due = [6,7]\n&gt;&gt;&gt; lista + lista_due\n[1, 2, 3, 4, 5, 6, 7]\n&gt;&gt;&gt; lista + [6]\n[1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2352-alcuni-esempi","title":"23.5.2 - Alcuni esempi","text":"<p>Ecco alcuni esempi di slicing su lista, con annessi risultati ottenibili.</p> <p>Consideriamo la seguente stringa:</p> <pre><code>&gt;&gt;&gt; l = [1, 2, 3, 4, 5, 6]\n</code></pre> <p>Prendiamo gli elementi sugli indice pari (ovvero 0, 2 e 4):</p> <pre><code>&gt;&gt;&gt; l[0::2]\n[1, 3, 5]\n</code></pre> <p>Prendiamo tutti gli elementi a partire dal terzultimo e con indice pari:</p> <pre><code>&gt;&gt;&gt; l[-3::2]\n[4, 6]\n</code></pre> <p>Partiamo dal terzultimo elemento, e proseguiamo all'indietro verso l'origine:</p> <pre><code>&gt;&gt;&gt; l[-3::-1]\n[4, 3, 2, 1]\n</code></pre> <p>Partiamo dall'ultimo elemento e proseguiamo sino al terz'ultimo dall'origine:</p> <pre><code>&gt;&gt;&gt; l[:3:-1]\n[6, 5]\n</code></pre> <p>Prendiamo gli ultimi tre elementi in ordine inverso:</p> <pre><code>&gt;&gt;&gt; l[len(l)-1:len(l)-4:-1]\n[6, 5, 4]\n</code></pre> <p>Prendiamo gli elementi agli indici pari in ordine inverso:</p> <pre><code>&gt;&gt;&gt; l[::-2]\n[6, 4, 2]\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2353-mutabilita-di-una-lista","title":"23.5.3 - Mutabilit\u00e0 di una lista","text":"<p>A differenza delle stringhe, le liste sono oggetti mutabili. Di conseguenza, possiamo modificarne il contenuto:</p> <pre><code>&gt;&gt;&gt; lista[0] = 99\n&gt;&gt;&gt; lista\n[99, 2, 3, 4, 5]\n</code></pre>"},{"location":"material/03_programming_python/23_intro/lecture/#2354-operazioni-sulle-liste","title":"23.5.4 - Operazioni sulle liste","text":"<p>Possiamo anche eliminare elementi da una lista usando l'operatore <code>[]</code> combinato all'operazione di slicing:</p> <pre><code>&gt;&gt;&gt; lista[4:] = []\n&gt;&gt;&gt; lista\n[99, 2, 3, 4]\n</code></pre> <p>Nota</p> <p>I pi\u00f9 attenti avranno notato che l'operatore <code>[]</code> non fa altro che indicare una lista vuota.</p> <p>Suggerimento</p> <p>Possiamo eliminare tutti gli elementi contenuti in una lista mediante lo slicing e l'operatore <code>[]</code>:</p> <pre><code>&gt;&gt;&gt; lista[:] = []\n&gt;&gt;&gt; lista\n[]\n</code></pre> <p>Una lista pu\u00f2 contenere elementi tra loro eterogenei. E' addirittura consentito contenere degli iterabili, tra cui altre liste:</p> <pre><code>&gt;&gt;&gt; lista.append([1,2,3])\n&gt;&gt;&gt; lista\n[99, 2, 3, 4, [1, 2, 3]]\n</code></pre> <p>Nell'esempio precedente, abbiamo usato la funzione <code>append()</code> per inserire un elemento in coda alla lista. E' interessante notare l'elemento inserito in coda sia esso stesso una lista, e \"conviva\" tranquillamente con gli altri elementi di tipo numerico.</p> <p>Proviamo ad estendere ulteriormente la lista cambiando il primo elemento con una stringa:</p> <pre><code>&gt;&gt;&gt; lista [0] = stringa\n&gt;&gt;&gt; lista\n['Python', 2, 3, 4, [1, 2, 3]]\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/exercises/","title":"E24 - Programmare in Python","text":""},{"location":"material/03_programming_python/24_syntax/exercises/#esercizio-e241","title":"Esercizio E24.1","text":"<p>Scriviamo una funzione che iteri fino a che il valore associato ad un contatore intero \u00e8 minore di 10. Usiamo un ciclo <code>while</code>.</p>"},{"location":"material/03_programming_python/24_syntax/exercises/#soluzione-s111","title":"Soluzione S11.1","text":"<pre><code>def itera_while():\n    i=0\n    while i &lt; 10:\n            i=i+1\n            print(\"{}-ma iterazione\".format(i))\n</code></pre> <p>Il risultato ottenuto sar\u00e0:</p> <pre><code>&gt;&gt;&gt; itera_while()\n1-ma iterazione\n2-ma iterazione\n3-ma iterazione\n4-ma iterazione\n5-ma iterazione\n6-ma iterazione\n7-ma iterazione\n8-ma iterazione\n9-ma iterazione\n10-ma iterazione\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/exercises/#esercizio-e242","title":"Esercizio E24.2","text":"<p>Scriviamo una funzione che iteri fino a che una condizione booleana non \u00e8 <code>False</code>. Usiamo un ciclo <code>for</code>, ponendo come numero massimo di iterazioni 100 e se necessario, usando il metodo <code>random.randint(a, b)</code>.</p>"},{"location":"material/03_programming_python/24_syntax/exercises/#soluzione-s112","title":"Soluzione S11.2","text":"<pre><code>def itera_for():\n    cond=True\n    for i in range(100):\n            eval = random.randint(-10, 10)\n            print('Valuto numero {}'.format(eval))\n            if eval &lt; 0:\n                    print('Esco')\n                    cond=False\n                    return cond\n            else:\n                    print('Continuo')\n    return cond\n</code></pre> <p>Il risultato ottenuto sar\u00e0:</p> <pre><code>&gt;&gt;&gt; itera_for()\nValuto numero 6\nContinuo\nValuto numero 7\nContinuo\nValuto numero 8\nContinuo\nValuto numero -4\nEsco\nFalse\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/exercises/#esercizio-e243","title":"Esercizio E24.3","text":"<p>Estraiamo tutti gli indici pari di una lista arbitraria di dieci elementi in ordine inverso. Per farlo, usiamo sia la funzione <code>range</code> sia lo slicing.</p>"},{"location":"material/03_programming_python/24_syntax/exercises/#soluzione-s113","title":"Soluzione S11.3","text":"<pre><code>def estrai_con_slice(lista):\n    if len(lista) != 10:\n            print('Errore!')\n            return []\n    else:\n            return lista[-2::-2]\n\ndef estrai_con_range(lista):\n    if len(lista) != 10:\n        print('Errore!')\n        return []\n    else:\n        l_out = []\n        for i in range(8, -1, -2):\n            l_out.append(lista[i])\n        return l_out\n</code></pre> <p>Il risultato ottenuto sar\u00e0:</p> <pre><code>&gt;&gt;&gt; l = [1,2,3,4,5,6,7,8,9,10]\n&gt;&gt;&gt; estrai_con_slice(l)\n[10, 8, 6, 4, 2]\n&gt;&gt;&gt; estrai_con_range(l)\n[10, 8, 6, 4, 2]\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/exercises/#esercizio-e244","title":"Esercizio E24.4","text":"<p>Utilizzare il pattern matching per stampare a schermo la parola \"Vero\" se il valore di una variabile \u00e8 <code>True</code>, e \"Falso\" altrimenti.</p>"},{"location":"material/03_programming_python/24_syntax/exercises/#soluzione-s114","title":"Soluzione S11.4","text":"<pre><code>def match_case(true_or_false):\n    match true_or_false:\n        case True:\n            return \"Vero\"\n        case False:\n            return \"Falso\"\n</code></pre> <p>Il risultato ottenuto sar\u00e0:</p> <pre><code>&gt;&gt;&gt; a = True\n&gt;&gt;&gt; match_case(a)\n'Vero'\n&gt;&gt;&gt; b = False\n&gt;&gt;&gt; match_case(b)\n'Falso'\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/exercises/#esercizio-e245","title":"Esercizio E24.5","text":"<p>Creare un metodo che raddoppi una lista passata come argomento in ingresso. Provare ad utilizzare un ciclo <code>for</code> e ricordare la differenza tra shallow e deep copy.</p>"},{"location":"material/03_programming_python/24_syntax/exercises/#soluzione-s115","title":"Soluzione S11.5","text":"<p>Potremmo essere tentati di scrivere una funzione come la seguente:</p> <pre><code>def raddoppia_lista(lista):\n    for elemento in lista:\n        lista.append(elemento)\n        print(f\"Lista all'iterazione attuale: {lista}\")\n</code></pre> <p>Proviamo a chiamare questa funzione; avremo subito un output ingestibile. Ci\u00f2 \u00e8 legato al fatto che Python \u00e8 fermo in un loop infinito: il metodo agisce sulla lista originaria, che ad ogni iterazione del ciclo \"ingloba\" un altro elemento, provocando di conseguenza un aumento delle dimensioni della lista e, quindi, un'ulteriore iterazione, e cos\u00ec via all'infinito.</p> <p>Possiamo per\u00f2 ottenere il risultato che ci serve usando il metodo <code>deepcopy</code>:</p> <pre><code>from copy import deepcopy\n\ndef raddoppia_lista_deep(lista):\n    lista_appoggio = deepcopy(lista)\n    for elemento in lista_appoggio:\n        lista.append(elemento)\n        print(f\"Lista di appoggio: {lista_appoggio}\")\n        print(f\"Lista attuale: {lista}\")\n</code></pre> <p>In questo caso, stiamo creando un'altra variabile, chiamata <code>lista_appoggio</code>, che sar\u00e0 utilizzata come \"buffer\" per aggiungere alla lista originaria gli elementi relativi a s\u00e9 stessa. Provando a chiamare questo codice otterremo il risultato desiderato:</p> <pre><code>&gt;&gt;&gt; raddoppia_lista_deep([1, 2])\nLista di appoggio: [1, 2]\nLista attuale: [1, 2, 1]\nLista di appoggio: [1, 2]\nLista attuale: [1, 2, 1, 2]\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/lecture/","title":"24 - Programmare in Python","text":"<p>Materiale e link utili</p> Materiale Disponibilit\u00e0 Link Slides mostrate a lezione Download Video esplicativo Link non disponibile"},{"location":"material/03_programming_python/24_syntax/lecture/#241-alcuni-concetti-sintattici-fondamentali","title":"24.1 - Alcuni concetti sintattici fondamentali","text":"<p>Oltre al duck typing, esistono altri concetti che caratterizzano la sintassi di Python. Vediamoli brevemente.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#2411-uso-delle-parentesi","title":"24.1.1 - Uso delle parentesi","text":"<ol> <li> <p>Le parentesi tonde sono usate soltanto nel caso di chiamata a funzione, oltre che per esprimere la precedenza nelle operazioni. In tutti gli altri casi, sono opzionali e possono essere omesse. Ad esempio:</p> <p><pre><code>a = 2\nb = 3\nc = 4\nr_1 = a + b * c     # Valore restituito: 14\nr_2 = (a + b) * c   # Valore restituito: 24\n\nif a &gt; 2:\n    # Questa notazione \u00e8 valida, ed \u00e8 equivalente ad (a &gt; 2)\n</code></pre> 2. Le parentesi quadre sono usate per la creazione e l'accesso agli elementi di una struttura dati.</p> <p><pre><code># Creo una lista\nlista = [1, 2, 3]\n# Accedo al secondo elemento della lista\nlista[1]            # Il valore acceduto \u00e8 2\n</code></pre> 3. Le parentesi graffe sono usate per la creazione di un dizionario. <pre><code>dizionario = {'a': 1, 'b': 2}\n# Notiamo che per accedere ad una chiave di un dizionario useremo comunque la parentesi quadra.\ndizionario[a]       # Il valore acceduto \u00e8 1, ovvero quello relativo alla chiave 'a'\n</code></pre></p> </li> </ol>"},{"location":"material/03_programming_python/24_syntax/lecture/#2412-ambito-e-termine-di-unistruzione","title":"24.1.2 - Ambito e termine di un'istruzione","text":"<p>A differenza del C, che prevede che ogni istruzione sia terminata da un punto e virgola, Python prevede che un'istruzione termini quando si va a capo. Quindi:</p> <pre><code>a = 1           # L'istruzione di assegnazione \u00e8 terminata!\n</code></pre> <p>In altre parole, si pu\u00f2 omettere il punto e virgola.</p> <p>Per quello che riguarda invece la definizione di un ambito, ad esempio locale all'interno di una funzione, Python si affida ai due punti, che sostituiscono la parentesi graffa di apertura, ed al numero di indentazioni.</p> <p>Ambito e indentazioni</p> <p>In generale, possiamo dire che le istruzioni allo stesso livello di indentazione sono considerate dall'interprete Python come istruzioni appartenenti al medesimo ambito.</p> <p>Quindi:</p> <pre><code># L'inizio della funzione, e quindi dell'ambito \n# che questa delimita, \u00e8 contrassegnato dai due punti\ndef funzione(): # Inizio ambito\n    # Il codice deve essere allo stesso livello di indentazione\n    a = 1\n    a + 1\n    # ...\n    return 0\n</code></pre> <p>Le indentazioni</p> <p>Per ottenere l'indentazione, occorre usare il tasto tab sulla tastiera, oppure quattro spazi. E' comunque estremamente importante non mescolare le due tecniche.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#242-programmazione-strutturata","title":"24.2 - Programmazione strutturata","text":"<p>Il linguaggio Python utilizza una sintassi per le strutture di controllo differente da quella usata nei tipici linguaggi C-like.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#2421-istruzioni-condizionali-if","title":"24.2.1 - Istruzioni condizionali (<code>if</code>)","text":"<p>Partiamo dall'istruzione condizionale <code>if</code>. Questa, in Python, ha una sintassi di questo tipo.</p> <pre><code>if condizione:\n    istruzioni()\nelif altra_condizione:\n    altre_istruzioni()\nelse:\n    ultime_istruzioni()\n</code></pre> <p>Notiamo l'utilizzo della keyword <code>elif</code> come crasi della forma <code>else if</code> utilizzata in altri linguaggi di programmazione. Ad esempio, se volessimo verificare il valore di una variabile intera, potremmo scrivere:</p> <pre><code>a = 5\nif a &lt; 5:\n    print('a \u00e8 minore di 5')\nelif a == 5:\n    print('a \u00e8 uguale a 5')\nelse:\n    print('a \u00e8 maggiore di 5')\n</code></pre> <p>L'output di questo controllo sar\u00e0:</p> <pre><code>a \u00e8 uguale a 5\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/lecture/#2422-pattern-matching","title":"24.2.2 - Pattern matching","text":"<p>Fino alla versione 3.10, Python non offriva il costrutto <code>switch/case</code>. A partire da quest'ultima, per\u00f2, il pattern matching \u00e8 stato implementato usando questa sintassi:</p> <pre><code>match command:\n    case \"caso 1\":\n        istruzioni()\n    case \"altro caso\":\n        print(\"Comando sconosciuto\")\n</code></pre>"},{"location":"material/03_programming_python/24_syntax/lecture/#2423-cicli","title":"24.2.3 - Cicli","text":""},{"location":"material/03_programming_python/24_syntax/lecture/#24231-ciclo-for","title":"24.2.3.1 - Ciclo <code>for</code>","text":"<p>Il ciclo <code>for</code> itera su una sequenza, come una lista o una stringa, ed ha una sintassi del tipo:</p> <pre><code>for elemento in sequenza:\n    istruzioni()\n</code></pre> <p>Per fare un esempio, nel seguente blocco di codice vediamo come mostrare a schermo in maniera iterativa i numeri che vanno da 0 a 5:</p> <pre><code>vals = [0,1,2,3,4]\nfor i in vals:\n    print(i)\n</code></pre> <p>Il risultato che sar\u00e0 stampato a schermo \u00e8:</p> <pre><code>0\n1\n2\n3\n4\n</code></pre> <p>Rispetto ai linguaggi \"classici\", quindi, il ciclo <code>for</code> opera esclusivamente sugli iterabili, per cui potrebbe in qualche caso occorrere una riprogettazione del codice. Tuttavia, questa caratteristica di Python comporta anche una maggiore semplicit\u00e0 del codice; ad esempio, vediamo come \u00e8 molto semplice iterare su una stringa:</p> <pre><code>string = \"Python\"\nfor char in string:\n    print(char)\n</code></pre> <p>A schermo vedremo in entrambi i casi il seguente risultato:</p> <pre><code>    P\n    y\n    t\n    h\n    o\n    n\n</code></pre> <p>No free lunches!</p> <p>Come ci ricorda il no free lunches theorem, non esistono pasti gratuiti! Infatti, la maggiore semplicit\u00e0 sintattica offerta da Python non \u00e8 indolore, ma ha un costo. Uno script Python, infatti, per quanto ottimizzato, non potr\u00e0 quasi mai offrire performance paragonabili ad un codice ottimizzato in C o C++, a meno di non usare particolari (ed avanzati) accorgimenti.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#24232-ciclo-while","title":"24.2.3.2 - Ciclo <code>while</code>","text":"<p>A differenza del ciclo <code>for</code>, il funzionamento del <code>while</code> \u00e8 analogo a quello delle controparti negli altri linguaggi di programmazione. La sintassi generica \u00e8:</p> <pre><code>while(condizione):\n    istruzioni()\n</code></pre> <p>Ad esempio:</p> <pre><code>i = True\nwhile (i):\n    if randint(-5, 5) &gt; 0:\n        print(\"Continuo!\")\n    else:\n        print(\"Esco!\")\n        i = False\n</code></pre> <p>Il codice nel blocco precedente non fa altro che generare un valore numerico intero casuale nell'intervallo \\([-5, 5]\\) mediante la funzione <code>randint</code>. Se tale valore \u00e8 superiore a \\(0\\), il ciclo continua, altrimenti si esce dallo stesso.</p> <p>A schermo vedremo, ad esempio:</p> <pre><code>Continuo!\nContinuo!\nEsco!\n</code></pre> <p>I valori booleani in Python</p> <p>I pi\u00f9 attenti avranno notato come i valori booleani in Python siano stati scritti come <code>True</code> e <code>False</code>. Questo non \u00e8 un refuso: la prima lettera \u00e8 proprio una maiuscola.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#244-la-funzione-range","title":"24.4 - La funzione <code>range()</code>","text":"<p>Riprendiamo adesso il ciclo <code>for</code> visto in precedenza.</p> <pre><code>vals = [0,1,2,3,4]\nfor i in vals:\n    print(i)\n</code></pre> <p>Nonostante il codice sia gi\u00e0 compatto, scrivere manualmente la sequenza da iterare pu\u00f2 facilmente diventare un'operazione abbastanza complessa. Python ci viene quindi in aiuto tramite la funzione <code>range(i, j, s)</code>, che genera una sequenza avente tutti i numeri compresi tra <code>i</code> (incluso) e <code>j</code> (escluso) a passo <code>s</code>. Ad esempio, per generare i numeri compresi tra 0 e 4 scriveremo:</p> <pre><code>r = range(0, 5, 1)\nprint(list(r))\n[0, 1, 2, 3, 4]\n</code></pre> <p>Nota</p> <p>Notiamo che per mandare in output i valori di <code>r</code> dovremo convertirlo in lista (<code>list(r)</code>).</p> <p>Qualora omessi, <code>i</code> ed <code>s</code> assumono valori di default rispettivamente 0 ed 1:</p> <pre><code>&gt;&gt;&gt; r = range(5)\n&gt;&gt;&gt; print(list(r))\n[0, 1, 2, 3, 4]\n</code></pre> <p>E' anche possibile specificare una sequenza decrementale ponendo <code>i &gt; j</code> ed <code>s &lt; 0</code>:</p> <pre><code>&gt;&gt;&gt; r = range(5, 1, -1)\n&gt;&gt;&gt; print(list(r))\n[5, 4, 3, 2]\n</code></pre> <p>Esercizio: Proviamo ad iterare su tutti i valori della lista <code>['Pippo', 'Pluto', 5, 'Paperino']</code>.</p> <p>Soluzione: Usiamo la funzione <code>range()</code> assieme alla funzione <code>len()</code>:</p> <pre><code>l = ['Pippo', 'Pluto', 5, 'Paperino']\nfor i in range(len(l)):\n    print(l[i])\n# Output\nPippo\nPluto\n5\nPaperino\n</code></pre> <p>In pratica, dato che la funzione <code>len(l)</code> ci restituisce il numero di elementi nella lista, ovvero \\(4\\), stiamo andando a definire un range che va da 0 a 3. A questo punto, ci baster\u00e0 elemento per elemento ai valori contenuti all'interno della lista, ed avremo ottenuto il risultato sperato.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#245-istruzioni-break-e-continue","title":"24.5 - Istruzioni <code>break</code> e <code>continue</code>","text":"<p>Le istruzioni <code>break</code> e <code>continue</code> permettono rispettivamente di uscire dal ciclo o di saltare all'iterazione successiva. Ad esempio:</p> <pre><code>while (True):\n    if randint(-5, 5) &gt; 0:\n        print(\"Continuo!\")\n        continue\n    else:\n        print(\"Esco!\")\n        break\nprint(\"Sono uscito!\")\n</code></pre> <p>Le istruzioni precedenti usciranno dal ciclo quando viene generato casualmente un numero negativo, mentre continueranno ad iterare quando viene generato casualmente un numero positivo.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#246-definire-una-funzione","title":"24.6 - Definire una funzione","text":"<p>In Python \u00e8 possibile definire una funzione in questo modo:</p> <pre><code>def nome_funzione(parametri):\n    # istruzioni\n    return valore_ritorno\n</code></pre> <p>E' importante notare che:</p> <ul> <li>non \u00e8 necessario definire un tipo, ma soltanto un valore di ritorno. Qualora la funzione non restituisca alcun valore, potr\u00e0 essere omessa l'istruzione <code>return</code>;</li> <li>non \u00e8 (strettamente) necessario definire il tipo di ciascuno dei parametri passati;</li> <li>\u00e8 consentito inserire dei parametri opzionali, con valori di default.</li> </ul> <p>Esercizio: Creiamo una funzione che concateni ad una lista il doppio dei singoli valori presenti nella stessa.</p> <p>Soluzione: usiamo la funzione <code>append</code> per mettere in coda i nuovi elementi della lista.</p> <pre><code>def raddoppia_lista(lista):\n    for i in range(len(lista)):\n        lista.append(l[i] * 2)\nl = [1,2]\nraddoppia_lista(l)          # Risultato atteso: [1, 2, 2, 4]\n</code></pre> <p>Esercizio: Creiamo una funzione che generi una lista di elementi casuali tra \\(0\\) e \\(10\\), usando un parametro opzionale per specificarne la lunghezza.</p> <p>Soluzione: usiamo la funzione <code>append()</code> in accoppiata alla funzione <code>randint()</code>.</p> <pre><code>def genera_lista_casuale(lunghezza=5):\n    l = []\n    for i in range(lunghezza):\n        l.append(randint(0, 10))\n    return l\n...\ngenera_lista_casuale()      # Possibile risultato: [3, 1, 2, 0, 6]\ngenera_lista_casuale(10)    # Possibile risultato: [7, 9, 1, 10, 2, 4, 9, 1, 4, 8]\n</code></pre> <p>Tipo dei parametri di ingresso</p> <p>Il duck typing fa s\u00ec che non venga effettuato alcun controllo sui parametri in ingresso. Ci\u00f2 per\u00f2 non significa che non si possa provare a chiamare (ad esempio) la funzione <code>genera_lista_casuale()</code> passando come parametro una stringa; ci\u00f2 tuttavia causer\u00e0 un (prevedibile) errore.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#2461-passaggio-di-parametri-a-funzione","title":"24.6.1 - Passaggio di parametri a funzione","text":"<p>Python prevede che i parametri siano passati ad una funzione secondo una modalit\u00e0 ibrida chiamata call-by-assignment. In pratica, il passaggio avviene esclusivamente per valore, ma con effetti differenti su tipi mutabili ed immutabili.</p> <p>Ad esempio, provando a passare un valore primitivo (come un intero), Python si comporter\u00e0 come se si stesse effettuando un passaggio per valore:</p> <pre><code>def raddoppia(intero):\n    intero = intero * 2\n    print(f'Valore all\\'interno della funzione: {intero}')\n</code></pre> <p>Il risultato sar\u00e0:</p> <pre><code>&gt;&gt;&gt; intero = 1\n&gt;&gt;&gt; raddoppia(intero)\n\"Valore all'interno della funzione: 2\"\n&gt;&gt;&gt; print(f'Valore all\\'esterno della funzione: {intero}')\n\"Valore all'interno della funzione: 1\"\n</code></pre> <p>Ci\u00f2 \u00e8 legato al fatto che il passaggio viene effettuato per valore, per cui la funzione <code>raddoppia</code> agir\u00e0 su una copia della variabile passata come argomento, e non sulla variabile originaria. Se invece usassimo una funzione che modifica una lista:</p> <pre><code>def aggiungi_a_lista(lista, elemento):\n    lista.append(elemento)\n    print(f'Valore all\\'interno della funzione: {lista}')\n</code></pre> <p>Il risultato sar\u00e0:</p> <pre><code>&gt;&gt;&gt; lista = [1, 2]\n&gt;&gt;&gt; aggiungi_a_lista(lista, 3)\n\"Valore all'interno della funzione: [1, 2, 3]\"\n&gt;&gt;&gt; print(f'Valore all\\'esterno della funzione: {lista}')\n\"Valore all'interno della funzione: [1, 2, 3]\"\n</code></pre> <p>In questo caso, essendo la lista mutabile, il passaggio viene effettuato nei fatti per reference: ci\u00f2 significa che le operazioni comppiute all'interno della funzione <code>aggiungi_a_lista</code> agiranno sulla lista originaria.</p> <p>Shallow e deep copy</p> <p>Di default, Python copia le variabili per mezzo di una shallow copy: ci\u00f2 significa che un'operazione di assignment del tipo <code>a = b</code> fa in modo che <code>a</code> punti allo stesso indirizzo di memoria di <code>b</code> e, di conseguenza, ogni modifica a <code>b</code> si rifletta su <code>a</code>. Per evitare un fenomeno di questo tipo occorre usare una deep copy grazie alla funzione <code>deepcopy</code> della libreria <code>copy</code>.</p>"},{"location":"material/03_programming_python/24_syntax/lecture/#2462-listruzione-pass","title":"24.6.2 - L'istruzione <code>pass</code>","text":"<p>Chiudiamo accennando all'istruzione <code>pass</code>. Questa non fa assolutamente nulla; \u00e8 utile, ad esempio, quando vogliamo inserire una funzione (o una classe) vuota, che definiremo per qualche motivo in seguito:</p> <pre><code>&gt;&gt;&gt; def funzione_vuota():\n...     pass\n...\n&gt;&gt;&gt; funzione_vuota()\n</code></pre> <p>Nota</p> <p>Anche se di primo acchitto potrebbe non essere evidente, esistono diverse situazioni in cui l'istruzione <code>pass</code> risulta essere estremamente utile.</p>"},{"location":"material/03_programming_python/25_oop/lecture/","title":"25 - Principi di OOP","text":"<p>Materiale e link utili</p> Materiale Disponibilit\u00e0 Link Slides mostrate a lezione Download Video esplicativo Link non disponibile <p>La programmazione orientata agli oggetti (in inglese object-oriented programming, OOP) \u00e8 un paradigma di programmazione che sposta il focus dalle funzioni ai dati. In particolare, la OOP prevede che tutto sia un oggetto: una qualsiasi variabile \u00e8 interpretata come un oggetto, cos\u00ec come anche le funzioni stesse (in alcuni linguaggi).</p> <p>Ci\u00f2 si estende ovviamente anche ai tipi definiti dall'utente, che assumono il nome di classi. Facciamo un esempio.</p>"},{"location":"material/03_programming_python/25_oop/lecture/#251-la-classe-persona","title":"25.1 - La classe <code>Persona</code>","text":"<p>Immaginiamo di voler definire una struttura dati che contenga al suo interno le informazioni necessarie a definire una persona, come nome, cognome, genere ed et\u00e0. Per farlo, ovviamente, dovremo \"unire\" tra di loro diversi dati primitivi: potremo usare una stringa per il nome, una per il cognome, una per il genere e, infine, un intero per l'et\u00e0.</p> <p>In tal senso, possiamo creare quindi la classe <code>Persona</code>, che avr\u00e0 quattro attributi, come mostrato in figura.</p> <p></p> <p>Sottolineamo come una classe rappresenti tutte le possibili persone: infatti, si cerca di creare delle strutture dati generiche, che abbiano degli attributi comuni a tutte le possibili istanze. Nel nostro caso, sappiamo che ogni persona ha un nome, un cognome, un genere ed un'et\u00e0, quindi usiamo questi quattro valori come attributi di classe.</p> <p>Differenza tra classe ed istanza</p> <p>Abbiamo detto che una classe rappresenta tutte le possibili istanze della stessa. Ci\u00f2 si traduce, nel nostro esempio, nel fatto che la classe <code>Persona</code> \u00e8 in grado di rappresentare tutte le persone, e un'istanza della classe <code>Persona</code> \u00e8 una singola variabile, o oggetto, che rappresenta una certa persona. Per capirci: un'istanza di <code>Persona</code> \u00e8 \"Angelo, Cardellicchio, Uomo, 37\", mentre un'altra istanza \u00e8 data da \"Frank, Hood, Uomo, 42\", un'altra ancora da \"Camilla, Lilla, Donna, 55\", e cos\u00ec via.</p> <p>Ovviamente, potremo in qualche modo agire con degli opportuni metodi su questi attributi. Ad esempio, se avessimo a disposizione anche il luogo e la data di nascita, potremmo creare un metodo <code>calcola_cf</code> che, per l'appunto, permette di generare il codice fiscale di una singola istanza.</p> <p>Oltre al concetto di classe, tuttavia, la OOP definisce altri tre concetti base. Vediamoli di seguito.</p>"},{"location":"material/03_programming_python/25_oop/lecture/#252-concetto-1-ereditarieta","title":"25.2 - Concetto 1: Ereditariet\u00e0","text":"<p>Per ereditariet\u00e0 si intende la capacit\u00e0 di una classe di \"discendere\" da un'altra. Non dobbiamo, per\u00f2, pensare al nostro albero genealogico: infatti, noi abbiamo parte delle caratteristiche di ciascuno dei nostri genitori, mentre una classe figlia eredita in toto le caratteristiche di una classe madre.</p> <p>Ad esempio, potremmo definire la classe <code>Studente</code> come figlia della classe <code>Persona</code>, cui aggiunger\u00e0 i seguenti attributi:</p> <p></p> <p>Possiamo visualizzare questa relazione in ordine gerarchico come segue:</p> <p></p> <p>Da notare che la classe <code>Studente</code> pu\u00f2 aggiungere anche dei metodi, oltre che degli attributi a quelli offerti da <code>Persona</code>, come ad esempio <code>genera_media_voto</code>.</p> <p>In ultimo, notiamo come ogni istanza di <code>Studente</code> \u00e8 un'istanza di <code>Persona</code>, ma non \u00e8 vero il contrario, e quindi non tutte le persone sono degli studenti. Per aiutarci a comprendere questo concetto, possiamo visualizzare gli insiemi delle istanze di <code>Persona</code> e di <code>Studente</code>:</p> <p></p> <p>Generalizzazione e specializzazione</p> <p>La relazione di ereditariet\u00e0 pu\u00f2 anche essere vista in termini di generalizzazione e specializzazione. In questo contesto, la classe <code>Studente</code> \u00e8 una specializzazione di <code>Persona</code>, in quanto sottende ad un insieme pi\u00f9 specifico; al contrario, le persone sono viste come una generalizzazione degli studenti.</p> <p>Ereditariet\u00e0 multipla e multilivello</p> <p>Alcuni linguaggi, compreso Python, offrono la possibilit\u00e0 di ereditare da pi\u00f9 classi; tale concetto \u00e8 chiamato ereditariet\u00e0 multipla. Se invece stabiliamo una vera e propria gerarchia di classi, con una classe \"nonna\", una \"madre\" ed una \"figlia\", avremo una struttura multilivello.</p>"},{"location":"material/03_programming_python/25_oop/lecture/#253-concetto-2-incapsulamento","title":"25.3 - Concetto 2: Incapsulamento","text":"<p>Il concetto di incapsulamento prevede che sia possibile accedere ad un metodo (o anche ad un attributo) di una classe esclusivamente mediante la sua interfaccia verso il mondo esterno. Vediamo cosa significa.</p> <p>Immaginiamo di voler calcolare il codice fiscale di una persona: dovremo seguire una procedura ben precisa e moderatamente complessa, che potremo tranquillamente \"nascondere\" al codice che usa la classe <code>Persona</code>, il quale dovr\u00e0 semplicemente invocare il metodo <code>calcola_cf</code>. Tuttavia, se volessimo seguire il principio di modularit\u00e0, che ci suggerisce di \"suddividere\" funzioni complesse in maniera tale da renderle pi\u00f9 semplici, dovremmo creare altre funzioni ausiliarie, che potrebbero calcolare la rappresentazione di nome e cognome (<code>calcola_nc</code>) e i dati alfanumerici derivanti da luogo e data di nascita (<code>calcola_ld</code>). Ovviamente, non vi \u00e8 il bisogno di accedere dall'esterno della classe a questi metodi, in quanto hanno valenza esclusiva nell'ambito del calcolo del codice fiscale: per questo motivo, li si potr\u00e0 dichiarare come privati, e potranno essere acceduti soltanto dall'interno della classe.</p> <p>In questo modo, la classe mantiene un'interfaccia stabile ed essenziale verso l'esterno: il codice che usa la classe avr\u00e0 sempre un punto di accesso ben definito e, nel caso si debbano modificare dei comportamenti interni alla classe, non sar\u00e0 influenzato da dette modifiche. Ad esempio, infatti, se per qualche motivo si decidesse di cambiare l'ordine con cui si mostrano nel codice fiscale la rappresentazione del cognome e del nome, basterebbe modificare il metodo <code>calcola_nome_cognome_codice_fiscale</code>, ed il resto dell'implementazione (sia della classe, sia del codice chiamante) non ne sarebbe influenzata.</p> <p></p>"},{"location":"material/03_programming_python/25_oop/lecture/#254-concetto-3-polimorfismo","title":"25.4 - Concetto 3: Polimorfismo","text":"<p>Il concetto di polimorfismo prevede che sia possibile modificare il comportamento associato ad un metodo a seconda della classe che lo utilizza.</p> <p>Immaginiamo ad esempio di specializzare la classe <code>Studente</code> in due ulteriori rappresentazioni, ovvero <code>StudenteUniversitario</code> e <code>StudenteScolastico</code>. Ovviamente, il metodo <code>genera_media_voto</code> sar\u00e0 ereditato da entrambe le classi; tuttavia, l'implementazione dovr\u00e0 essere necessariamente differente, in quanto la media di laurea \u00e8 pesata in modo diverso rispetto alla classica media aritmetica usata nelle scuole fino alla secondaria.</p> <p>Il polimorfismo ci permette di raggiungere questo obiettivo: potremo effettuare una procedura di override del metodo <code>genera_media_voto</code> che, pur conservando la stessa firma, avr\u00e0 differenti implementazioni nelle classi <code>StudenteUniversitario</code> e <code>StudenteScolastico</code>. Ovviamente, il fatto che il metodo conservi la stessa firma rappresenta un vantaggio paragonabile a quello ottenuto mediante il polimorfismo: infatti, un programmatore potr\u00e0 usare il metodo <code>genera_media_voto</code> alla stessa maniera per uno studente universitario ed uno di scuola media secondaria, senza per questo dover tenere a mente due diverse interfacce.</p> <p></p>"},{"location":"material/03_programming_python/26_classes/exercises/","title":"E26 - Programmazione orientata agli oggetti in Python","text":""},{"location":"material/03_programming_python/26_classes/exercises/#esercizio-e261","title":"Esercizio E26.1","text":"<p>Scrivere una classe <code>Persona</code> applicando i concetti visti durante la lezione.</p>"},{"location":"material/03_programming_python/26_classes/exercises/#soluzione-s131","title":"Soluzione S13.1","text":"<p>Scriviamo la classe <code>Persona</code> come segue:</p> <pre><code>class Persona():\n\n    def __init__(self, nome, cognome, eta):\n        self.nome = nome\n        self.cognome = cognome\n        self.eta = eta\n\n    @property\n    def nome(self):\n        return self.__nome\n\n    @nome.setter\n    def nome(self, value):\n        if len(value) &lt; 2:\n            raise ValueError('La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.')\n        else:\n            self.__nome = value\n\n    @property\n    def cognome(self):\n        return self.__cognome\n\n    @cognome.setter\n    def cognome(self, value):\n        if len(value) &lt; 2:\n            raise ValueError('La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.')\n        else:\n            self.__cognome = value  \n\n    @property\n    def eta(self):\n        return self.__eta\n\n    @eta.setter\n    def eta(self, value):\n        if value &lt; 0:\n            raise ValueError(\"L'et\u00e0 non pu\u00f2 essere negativa.\")\n        else:\n            self.__eta = value\n</code></pre> <p>Alcune note:</p> <ul> <li>abbiamo riscritto la classe <code>Persona</code> in modo da trasformare tutti gli attributi in propriet\u00e0;</li> <li>per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa;</li> <li>oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input.</li> </ul> <p>Vediamo come usare la nostra nuova classe:</p> <pre><code>&gt;&gt;&gt; draco = Persona('Draco', 'Malfoy', 12)\n&gt;&gt;&gt; print(draco.nome)\nDraco\n&gt;&gt;&gt; print(draco.eta)\n12\n&gt;&gt;&gt; hermione = PersonProperty('', 'Granger', 18)\nValueError: La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.\n</code></pre> <p>Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.</p>"},{"location":"material/03_programming_python/26_classes/exercises/#esercizio-e262","title":"Esercizio E26.2","text":"<p>Creiamo due classi: la prima \u00e8 la classe <code>Quadrato</code>, che modella tutti i quadrati; la seconda \u00e8 la classe <code>Cerchio</code>, che modella tutti i cerchi. Entrambe devono discendere da una classe base chiamata <code>Figura</code>.</p>"},{"location":"material/03_programming_python/26_classes/exercises/#soluzione-s132","title":"Soluzione S13.2","text":"<pre><code>from abc import ABC, abstractmethod\nfrom math import pi\n\nclass Figura(ABC):\n\n    @property\n    def perimetro(self):\n        return self.__perimetro\n\n    @property\n    def area(self):\n        return self.__area\n\n    @abstractmethod\n    def perimetro(self):\n        pass\n\n    @abstractmethod\n    def area(self):\n        pass\n\n\nclass Quadrato(Figura):\n\n    def __init__(self, lato):\n        self.lato = lato\n\n    @property\n    def lato(self):\n        return self.__lato\n\n    @lato.setter\n    def lato(self, value):\n        self.__lato = value\n\n    def perimetro(self):\n        return self.lato * 4\n\n    def area(self):\n        return self.lato ** 2\n\n\nclass Cerchio(Figura):\n\n    def __init__(self, raggio):\n        self.raggio = raggio\n\n    @property\n    def raggio(self):\n        return self.__raggio\n\n    @raggio.setter\n    def raggio(self, value):\n        self.__raggio = value\n\n    def perimetro(self):\n        return 2 * pi * self.raggio\n\n    def area(self):\n        return pi * (self.raggio ** 2)\n\n\n# Esempio di uso\nq = Quadrato(5)\nprint('Lato: {} - Perimetro: {} - Area: {}'.format(q.lato, q.perimetro(), q.area()))\n\nc = Cerchio(5)\nprint('Raggio: {} - Perimetro: {} - Area: {}'.format(c.raggio, c.perimetro(), c.area()))\n</code></pre>"},{"location":"material/03_programming_python/26_classes/lecture/","title":"26 - Programmazione orientata agli oggetti in Python","text":"<p>Materiale e link utili</p> Materiale Disponibilit\u00e0 Link Slides mostrate a lezione Download Video esplicativo Link non disponibile <p>Python offre un esteso supporto alla programmazione orientata agli oggetti. Prima di proseguire, per\u00f2, \u00e8 opportuno introdurre brevemente questo concetto.</p>"},{"location":"material/03_programming_python/26_classes/lecture/#261-la-programmazione-orientata-agli-oggetti","title":"26.1 - La programmazione orientata agli oggetti","text":"<p>Quello della programmazione orientata agli oggetti (OOP) \u00e8 un paradigma di programmazione che permette di creare nuovi tipi definiti dall'utente, da intendersi come complementari ai tipi definiti dal linguaggio di programmazione. In tal senso, la OOP sposta il focus dalle funzioni, centrali nei linguaggi come il C e nel paradigma procedurale, ai dati.</p> <p>In tal senso, si arriva a dire che nella OOP tutto \u00e8 un oggetto.</p>"},{"location":"material/03_programming_python/26_classes/lecture/#2611-classi","title":"26.1.1 - Classi","text":"<p>Una classe \u00e8 un prototipo per un determinato tipo di dati definito dall'utente. Ad esempio:</p> <ul> <li>la classe <code>Studente</code> rappresenta tutte le propriet\u00e0 e le azioni associate ad uno studente;</li> <li>la classe <code>Auto</code> rappresenta tutte le propriet\u00e0 e le azioni associate ad un'auto;</li> <li>la classe <code>Motore</code> definisce i comportamenti dei motori;</li> </ul> <p>e via discorrendo.</p> <p>In generale, quindi, pu\u00f2 esistere una classe per ogni tipologia di oggetti presenti nel mondo, sia esso reale o informatico.</p> <p>Importante \u00e8 non confondere la classe con il singolo oggetto, chiamato istanza. Ad esempio:</p> <ul> <li>lo studente Angelo Cardellicchio \u00e8 un'istanza della classe <code>Studente</code>;</li> <li>l'auto Opel Corsa targata AB 123 CD \u00e8 un'istanza della classe <code>Auto</code>;</li> <li>l'auto Hyundai Tucson CD 321 AB \u00e8 un'istanza della classe <code>Auto</code>;</li> <li>l'auto Opel Corsa targata AA 123 CC \u00e8 un'altra istanza della classe <code>Auto</code>.</li> </ul>"},{"location":"material/03_programming_python/26_classes/lecture/#26111-metodi-ed-attributi","title":"26.1.1.1 - Metodi ed attributi","text":"<p>Ogni classe ha dei metodi, che caratterizzano delle azioni che \u00e8 possibile effettuare su ogni istanza della classe, e degli attributi, ovvero delle caratteristiche dell'istanza.</p> <p>In particolare, ogni nuovo tipo, chiamato classe, avr\u00e0 opportuni attributi e metodi, ognuno dei quali accessibile dall'esterno mediante opportuni modificatori.</p> <p>Ad esempio, l'auto Opel Corsa targata AB 123 CD ha una casa costruttrice (Opel), un modello (Corsa), una targa (AB 123 CD), una cilindrata, e via dicendo.</p>"},{"location":"material/03_programming_python/26_classes/lecture/#262-classi-in-python","title":"26.2 - Classi in Python","text":"<p>Per definire una classe, dovremo usare la parola chiave <code>class</code>:</p> <pre><code>class NomeClasse(ClasseBase):\n    # Attributi e metodi di classe...\n</code></pre> <p>Con la sintassi precedente, abbiamo creato una classe chiamata <code>NomeClasse</code> discendente da una classe base (<code>ClasseBase</code>).</p>"},{"location":"material/03_programming_python/26_classes/lecture/#263-il-metodo-__init__","title":"26.3 - Il metodo <code>__init__</code>","text":"<p>La maggior parte dei linguaggi di programmazione utilizza il concetto di costruttore per creare un'istanza di una classe. Il Python, tuttavia, non prevede l'utilizzo di un costruttore vero e proprio, quanto piuttosto di un metodo di inizializzazione dei singoli attributi dell'istanza. Da qui deriva il nome del metodo, ovvero <code>__init__</code>:</p> <pre><code>class NomeClasse(ClasseBase):\n\n    def __init__(self, *args, **kwargs):\n        # ...\n        self.arg_1 = arg_1\n        # ...\n</code></pre> <p>Unpacking</p> <p>Con la sintassi <code>*args</code> e <code>**kwargs</code> vogliamo rappresentare l'azione di unpacking di (rispettivamente) una lista ed un dizionario, mediante la quale stiamo passando tutti i valori contenuti all'interno della sequenza.</p> <p>Occorre prestare particolare attenzione all'uso della keyword <code>self</code>, che permette di riferirsi alla specifica istanza di una classe (per chi ha familiarit\u00e0 con i linguaggi come il C++, \u00e8 concettualmente simile alla parola chiave <code>this</code>). Ad esempio:</p> <pre><code>class Persona(object):\n\n    def __init__(self, nome, cognome, eta=18):\n        self.nome = nome\n        self._cognome = cognome\n        self.__eta = eta\n</code></pre> <p>Questo snippet ci permette di evidenziare quattro punti:</p> <ol> <li>la classe generica <code>object</code>, da cui derivano tutte le classi Python (ma la cui dichiarazione pu\u00f2 comunque essere omessa);</li> <li>il funzionamento della parola chiave <code>self</code>, che permette di associare agli attributi della singola istanza un determinato valore;</li> <li>la possibilit\u00e0 di inserire tra i parametri dei valori opzionali e di default (in questo caso <code>eta</code>, che di default vale <code>18</code>);</li> <li>la presenza di uno o due simboli <code>_</code> (underscore) davanti ad alcuni attributi.</li> </ol> <p>Approfondiamo brevemente il punto 4.</p>"},{"location":"material/03_programming_python/26_classes/lecture/#264-modificatori-di-accesso","title":"26.4 - Modificatori di accesso","text":"<p>Python prevede l'uso di modificatori di accesso ai dati; nello specifico, troviamo i classici <code>public</code>, <code>protected</code> e <code>private</code>. Tuttavia, a differenza di altri linguaggi, per distinguere tra i tre modificatori di accesso si utilizzano uno o due underscore come suffisso al nome dell'attributo; in particolare, usare un underscore singolo indica un attributo protected, mentre un underscore doppio indica un attributo <code>private</code>. Nel nostro caso:</p> <pre><code>class Persona(object):\n\n    def __init__(self, nome, cognome, eta=18):\n        self.nome = nome                # Membro \"public\"\n        self._cognome = cognome         # Membro \"protected\"\n        self.__eta = eta                # Membro \"private\"\n</code></pre> <p>Attenzione</p> <p>Nonostante il modificatore di accesso, \u00e8 possibile accedere ai membri protetti dall'esterno della classe. Infatti:</p> <pre><code>&gt;&gt;&gt; p = Persona('Jax', 'Teller')\n&gt;&gt;&gt; print(p.nome)\n&gt;&gt;&gt; print(p._cognome)\nJax\nTeller\n</code></pre> <p>Questo non vale per gli attributi privati:</p> <pre><code>&gt;&gt;&gt; try:\n&gt;&gt;&gt;     print(p.__eta)\n&gt;&gt;&gt; except AttributeError:\n&gt;&gt;&gt;     print('Et\u00e0 \u00e8 privato!')\nEt\u00e0 \u00e8 privato!\n</code></pre> <p>Questa sintassi pu\u00f2 ovviamente essere utilizzata per definire dei metodi protetti o privati.</p> <p>Suggerimento</p> <p>La sintassi che abbiamo mostrato nello snippet precedente \u00e8 relativa alla gestione delle eccezioni.</p>"},{"location":"material/03_programming_python/26_classes/lecture/#265-metodi","title":"26.5 - Metodi","text":"<p>La sintassi per definire il metodo di una classe \u00e8 analoga a quella usata per definire una funzione.</p> <pre><code>def metodo(self, *args, **kwargs):\n    pass\n</code></pre> <p>Esiste tuttavia una differenza fondamentale: infatti, il primo attributo di un metodo appartenente ad una classe \u00e8 sempre un riferimento all'istanza tramite la parola chiave <code>self</code>. Tale riferimento non va specificato quando il metodo viene chiamato dall'esterno:</p> <pre><code># ...\np = Persona()           # p \u00e8 un'istanza di Persona\np.metodo(parametro)     # richiamo il metodo dall'istanza\n# ...\n</code></pre> <p>Nel codice precedente, abbiamo usato l'operatore <code>.</code> per accedere a <code>metodo</code> definito all'interno della classe <code>Persona</code>.</p> <p>Approfondiamo adesso alcune particolari tipologie di metodi, ottenibili usando determinati decorator (cfr. appendice B).</p>"},{"location":"material/03_programming_python/26_classes/lecture/#2651-metodi-di-classe","title":"26.5.1 - Metodi di classe","text":"<p>Il decorator <code>@classmethod</code> ci permette di definire i cosiddetti metodi di classe:</p> <pre><code>@classmethod\ndef builder_stringa(cls, stringa: str):\n    nome, cognome, eta = stringa.split(' ')\n    return Persona(nome, cognome, eta)\n</code></pre> <p>A differenza dei metodi standard, i metodi di classe hanno un riferimento alla classe (<code>cls</code>) e non all'istanza (<code>self</code>). Questo significa che sono dei metodi che si applicano all'intera classe, e non alla singola istanza. Un tipico esempio di utilizzo di un metodo di classe \u00e8 mostrato nello snippet precedente, nel quale stiamo creando un oggetto di classe <code>Persona</code> a partire da una stringa.</p> <p>Curiosit\u00e0</p> <p>Il metodo precedente \u00e8, di fatto, un'implementazione del design pattern Builder.</p> <p>Per richiamare un metodo di classe occorre riferirsi al nome della classe stessa, e non ad una singola istanza:</p> <pre><code>&gt;&gt;&gt; persona = Person.builder_stringa('Bobby Munson 58')\n&gt;&gt;&gt; print(\"{} {}\".format(persona.nome, persona._cognome))\nBobby Munson\n</code></pre>"},{"location":"material/03_programming_python/26_classes/lecture/#2652-metodi-statici","title":"26.5.2 - Metodi statici","text":"<p>Mediante il decoratore <code>@staticmethod</code> possiamo definire un metodo statico. In Python il funzionamento di un metodo di questo tipo \u00e8 riassumibile in un comportamento assimilabile ad una funzione \"semplice\", definita per\u00f2 all'interno della classe, e richiamabile su istanze della stessa. Ad esempio:</p> <pre><code>@staticmethod\ndef nome_valido(nome):\n    if len(nome) &lt; 2:\n        return False\n    else:\n        return True\n</code></pre> <p>Questo metodo \u00e8 quindi liberamente richiamabile mediante l'operatore <code>.</code> da una singola istanza:</p> <pre><code>&gt;&gt;&gt; print(persona.nome_valido('Li'))\nTrue\n</code></pre> <p>Un'altra possibilit\u00e0 \u00e8 richiamarlo sulla classe stessa: </p> <pre><code>&gt;&gt;&gt; print(Persona.nome_valido('X'))\nFalse\n</code></pre>"},{"location":"material/03_programming_python/26_classes/lecture/#2653-metodi-astratti","title":"26.5.3 - Metodi astratti","text":"<p>Possiamo definire dei metodi astratti (cfr. Appendice C) mediante il decorator <code>@abstractmethod</code>. Per farlo, la nostra classe deve discendere dalla classe <code>ABC</code> (acronimo che sta per Abstract Base Class), contenuta nel package <code>abc</code>:</p> <pre><code>from abc import ABC\n\nclass ClasseBase(ABC):\n\n    # ...\n\n    @abstractmethod\n    def metodo_da_sovrascrivere(self):\n        pass\n</code></pre> <p>I metodi contrassegnati con il decorator <code>@abstractmethod</code> dovranno essere implementati nelle classi derivate (in altre parole, dovremo farne l'override):</p> <pre><code>class ClasseDerivata(ClasseBase):\n\n    # ...\n\n    def metodo_da_sovrascrivere(self):\n        # ...\n</code></pre>"},{"location":"material/03_programming_python/26_classes/lecture/#266-le-proprieta","title":"26.6 - Le propriet\u00e0","text":"<p>In molti linguaggi di programmazione si usano tradizionalmente i metodi accessori (getter) e modificatori (setter) per accedere agli attributi delle istanze di una classe. Python non vieta di farlo: ad esempio, possiamo scrivere un metodo <code>get_nome(self)</code> per accedere al nome di una persona, ed un metodo <code>set_nome(self, nome)</code> per impostare detta propriet\u00e0.</p> <p>Tuttavia, \u00e8 possibile usare una sintassi pi\u00f9 compatta (e, in definitiva, maggiormente pythonic) mediante il decorator <code>@property</code>, che rappresenta una funzione a quattro parametri:</p> <pre><code>property(fget=None, fset=None, fdel=None, doc=None)\n</code></pre> <p>In particolare:</p> <ul> <li><code>fget</code> \u00e8 la funzione usata per recuperare il valore dell'attributo;</li> <li><code>fset</code> \u00e8 la funzione usata per impostare il valore dell'attributo;</li> <li><code>fdel</code> \u00e8 la funzione per rimuovere l'attributo;</li> <li><code>doc</code> \u00e8 la funzione per documentare e descrivere l'attributo.</li> </ul> <p>Grazie a <code>property</code>, potremo seguire le \"best practice\" della OOP, rendendo privati gli attributi della classe ed accedendovi mediante opportuni metodi.</p> <pre><code>class Persona():\n\n    def __init__(self, nome, cognome, eta):\n        self.nome = nome\n        self.cognome = cognome\n        self.eta = eta\n\n    @property\n    def nome(self):\n        return self.__nome\n\n    @nome.setter\n    def nome(self, value):\n        if len(value) &lt; 2:\n            raise ValueError('La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.')\n        else:\n            self.__nome = value\n\n    @property\n    def cognome(self):\n        return self.__cognome\n\n    @cognome.setter\n    def cognome(self, value):\n        if len(value) &lt; 2:\n            raise ValueError('La lunghezza del cognome non pu\u00f2 essere inferiore a due caratteri.')\n        else:\n            self.__cognome = value  \n\n    @property\n    def eta(self):\n        return self.__eta\n\n    @eta.setter\n    def eta(self, value):\n        if value &lt; 0:\n            raise ValueError(\"L'et\u00e0 non pu\u00f2 essere negativa.\")\n        else:\n            self.__eta = value\n</code></pre> <p>Alcune note:</p> <ul> <li>abbiamo riscritto la classe <code>Persona</code> in modo da trasformare tutti gli attributi in propriet\u00e0;</li> <li>per ogni propriet\u00e0, abbiamo specificato un getter, che restituisce il valore della stessa;</li> <li>oltre al getter, \u00e8 stato specificato un setter, nel quale vi \u00e8 anche una forma di validazione del valore passato in input.</li> </ul> <p>Vediamo come usare la nostra nuova classe:</p> <pre><code>&gt;&gt;&gt; draco = Persona('Draco', 'Malfoy', 12)\n&gt;&gt;&gt; print(draco.nome)\nDraco\n&gt;&gt;&gt; print(draco.eta)\n12\n&gt;&gt;&gt; hermione = PersonProperty('', 'Granger', 18)\nValueError: La lunghezza del nome non pu\u00f2 essere inferiore a due caratteri.\n</code></pre> <p>Notiamo che, dal punto di vista dello script che richiama la classe, non ci sono differenze di sorta; tuttavia, la logica di validazione ci permette di evitare errori e situazioni incoerenti, ed \u00e8 inoltre possibile sfruttare le propriet\u00e0 per accedere agli attributi privati della classe.</p>"},{"location":"material/03_programming_python/27_data_structures/exercises/","title":"E27 - Esercizi sulle strutture dati","text":""},{"location":"material/03_programming_python/27_data_structures/exercises/#esercizio-e271","title":"Esercizio E27.1","text":"<p>Proviamo a valutare il tempo necessario alle operazioni di <code>insert</code> e <code>pop</code> su una coda in Python usando la libreria <code>time</code>. Confrontiamo il risultato ottenuto con quello ottenibile implementando una coda come una struttura di tipo <code>deque</code> e usando gli opportuni metodi <code>appendleft</code> e <code>popleft</code>.</p>"},{"location":"material/03_programming_python/27_data_structures/exercises/#soluzione-s271","title":"Soluzione S27.1","text":"<pre><code>from time import time\nfrom collections import deque\n\ndef queue(queue, pushed=1):\n    tic = time()\n    queue.insert(0, 4)\n    queue.pop()\n    toc = time()\n    return tic, toc\n\ndef queue_con_deque(queue, pushed=1):\n    tic = time()\n    queue.appendleft(pushed)\n    queue.popleft()\n    toc = time()\n    return tic, toc\n</code></pre> <p>Proviamo a chiamare le due funzioni:</p> <pre><code>queue = list(range(10000000))\nqueue_d = deque(queue)\n\nqueue_classica(queue)\nqueue_con_deque(queue_d)\n</code></pre> <p>Avremo un output simile al seguente:</p> <pre><code>Tempo necessario con lista: 0.08756685126958008\nTempo necessario con deque: 0.0\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/exercises/#esercizio-e272","title":"Esercizio E27.2","text":"<p>Selezioniamo tutti i nomi che iniziano con la lettera B dalla seguente lista:</p> <pre><code>lista_nomi = [\n    \"Jax Teller\",\n    \"Walter White\",\n    \"Billy Butcher\",\n    \"Luke Skywalker\",\n    \"Bobby Singer\",\n    \"Johnny Lawrence\"]\n</code></pre> <p>Facciamolo usando un ciclo ed una list comprehension.</p>"},{"location":"material/03_programming_python/27_data_structures/exercises/#soluzione-s272","title":"Soluzione S27.2","text":"<p>Usando un ciclo:</p> <pre><code>output_for = []\nfor nome in lista_nomi:\n    if nomi[0] == \"B\":\n        output_for.append(nome)\n</code></pre> <p>Usando una list comprehension:</p> <pre><code>output = [nome for nome in lista_nomi if nome[0] == \"B\"]\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/exercises/#esercizio-e273","title":"Esercizio E27.3","text":"<p>Ottenere una lista che abbia al suo interno tutti i quadrati dei numeri che vanno da 1 a 10</p>"},{"location":"material/03_programming_python/27_data_structures/exercises/#soluzione-s273","title":"Soluzione S27.3","text":"<p>Usando un ciclo:</p> <pre><code>def quadrato(numero):\n    return numero ** 2\n\noutput = []\nfor i in range(1, 11):\n    output.append(quadrato(i))\n</code></pre> <p>Usando una list comprehension:</p> <pre><code>output = [quadrato(i) for i in range(1, 11)]\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/exercises/#esercizio-e274","title":"Esercizio E27.4","text":"<p>Ottenere una lista che abbia la stringa <code>pari</code> in corrispondenza dei numeri pari, mentre quella <code>dispari</code> in corrispondenza dei numeri dispari, per tutti i numeri che vanno da 1 a 10.</p>"},{"location":"material/03_programming_python/27_data_structures/exercises/#soluzione-s274","title":"Soluzione S27.4","text":"<p>Usando un ciclo:</p> <pre><code>output = []\nfor i in range(1, 10):\n    if i % 2 == 0:\n        output.append(\"pari\")\n    else:\n        output.append(\"dispari\")\n</code></pre> <p>Usando una list comprehension:</p> <pre><code>output = [\"pari\" if i % 2 == 0 else \"dispari\" for i in range(1, 10)]\n</code></pre> <p>Suggerimento</p> <p>Possiamo usare la forma base della list comprehension definendo una funzione accessoria. Ad esempio:</p> <pre><code>def pari_o_dispari(numero):\n    if numero % 2 == 0:\n        return 'pari'\n    else:\n        return 'dispari'\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/exercises/#esercizio-e275","title":"Esercizio E27.5","text":"<p>Scrivere una dict comprehension che permetta di ottenere il dizionario <code>vecchio_o_giovane</code> dato il seguente dizionario:</p> <pre><code>dizionario = {\n\u00a0 \u00a0 'Jax Teller': 27,\n\u00a0 \u00a0 'Walter White': 52,\n\u00a0 \u00a0 'Billy Butcher': 41,\n\u00a0 \u00a0 'Luke Skywalker': 79,\n\u00a0 \u00a0 'Bobby Singer': 68,\n\u00a0 \u00a0 'Johnny Lawrence': 49}\n</code></pre> <p>In particolare, il dizionario <code>vecchio_o_giovane</code> avr\u00e0 le stesse chiavi del dizionario di partenza, a cui sar\u00e0 associato il valore <code>giovane</code> soltanto se il valore della chiave del dizionario di partenza \u00e8 inferiore a 65.</p>"},{"location":"material/03_programming_python/27_data_structures/exercises/#soluzione-s275","title":"Soluzione S27.5","text":"<pre><code>vecchio_o_giovane = { k: 'vecchio' if v &gt; 65 else 'giovane' for (k, v) in dizionario.items() }\n</code></pre> <p>Nota</p> <p>Per iterare sul dizionario originale, usiamo il metodo <code>items()</code> che, come visto in precedenza, ci restituisce un oggetto di tipo <code>dict_items</code> il quale \u00e8, per l'appunto, iterabile.</p>"},{"location":"material/03_programming_python/27_data_structures/lecture/","title":"27 - Strutture dati in Python","text":"<p>Materiale e link utili</p> Materiale Disponibilit\u00e0 Link Slides mostrate a lezione Download Video esplicativo Link non disponibile"},{"location":"material/03_programming_python/27_data_structures/lecture/#271-liste-pile-e-code","title":"27.1 - Liste, pile e code","text":"<p>Python ci offre una grande variet\u00e0 di metodi per gestire le liste; troviamo un elenco esaustivo a questo indirizzo.</p> <p>Grazie a questi metodi, \u00e8 possibile costruire una pila o una coda in modo molto pi\u00f9 semplice rispetto ad altri linguaggi.</p>"},{"location":"material/03_programming_python/27_data_structures/lecture/#2711-pila","title":"27.1.1 - Pila","text":"<p>Una pila (in inglese stack) adotta una strategia di accesso ai dati di tipo Last-In, First-Out (LIFO). Questo significa che il primo elemento ad uscire (ovvero ad essere analizzato) \u00e8 quello in cima alla pila, ovvero l'ultimo ad esservi entrato.</p> <p>Esempio di pila</p> <p>Un tipico esempio di pila \u00e8 quella dei piatti da lavare. Quasi sicuramente, il piatto in cima alla pila sar\u00e0 l'ultimo che avremo preso dal tavolo; tuttavia, sar\u00e0 anche il primo ad essere lavato.</p> <p>Per implementare una pila a partire da una lista possiamo usare due metodi:</p> <ul> <li>il metodo <code>append()</code> ci permette di inserire un nuovo elemento in cima alla pila (ovvero alla posizione \\(n-1\\)-ma, con una lista ad \\(n\\) componenti);</li> <li>il metodo <code>pop(pos)</code> ci permette di estrarre l'elemento in posizione <code>pos</code>. Di default, non specificando alcun valore di <code>pos</code>, estrarremo l'elemento in posizione \\(n-1\\)-ma.</li> </ul> <p>Ad esempio:</p> <pre><code>s = [1, 2, 3]\ns.append(4)         # s sar\u00e0 pari a [1, 2, 3, 4]\ne = s.pop()         # e sar\u00e0 pari a 4, mentre s sar\u00e0 pari a [1, 2, 3]\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#2712-coda","title":"27.1.2 - Coda","text":"<p>Una coda (in inglese queue) adotta una strategia di accesso ai dati di tipo First-In, First-Out (FIFO). In questo caso, il primo elemento ad uscire \u00e8 presente da pi\u00f9 tempo in coda.</p> <p>Esempio di coda</p> <p>Un tipico esempio di coda \u00e8 quella che tutti quanti, prima o poi, abbiamo fatto alle Poste: il primo ad arrivare \u00e8 il primo ad essere servito, poi il secondo, il terzo, e via cos\u00ec.</p> <p>Per implementare una coda a partire da una lista, possiamo usare il metodo <code>pop(pos)</code> con <code>pos = 0</code>, che ci permetter\u00e0 quindi di estrarre il primo elemento della coda, ed il metodo <code>insert(pos, el)</code> ci permette di inserire alla posizione <code>pos</code> l'elemento <code>el</code>.</p> <pre><code>q = [1, 2, 3]\nq.insert(0, 4)      # q sar\u00e0 pari a [4, 1, 2, 3]\ne = q.pop(0)        # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3]\n</code></pre> <p>Questo approccio, per quanto semplice, ha uno svantaggio: infatti, i metodi <code>insert()</code> e <code>pop()</code> sono computazionalmente onerosi, in quanto fanno in modo di riallocare lo spazio occupato dagli elementi della lista.</p> <p>In alternativa, possiamo usare una struttura contenuta nella libreria <code>collections</code> e chiamata <code>deque</code>. Il vantaggio sta nel fatto che la <code>deque</code> \u00e8 progettata specificamente per eseguire in maniera efficiente i metodi <code>append()</code> e <code>pop()</code> da entrambi i capi della struttura dati:</p> <pre><code>from collections import deque\nq = deque([1, 2, 3])\nq.appendleft(4)     # q sar\u00e0 pari a [4, 1, 2, 3]\ne = q.popleft()     # e sar\u00e0 pari a 4, q sar\u00e0 pari a [1, 2, 3]\n</code></pre> <p>Nota</p> <p>Sottolineamo che <code>q</code> non \u00e8 pi\u00f9 una lista, ma una <code>deque</code>.</p>"},{"location":"material/03_programming_python/27_data_structures/lecture/#272-list-comprehension","title":"27.2 - List comprehension","text":"<p>Una delle tecniche pi\u00f9 usate per effettuare delle operazioni sugli elementi di una lista \u00e8 usare la tecnica della list comprehension, che permette di sostituire quasi completamente i classici cicli.</p> <p>Nella forma base, una list comprehension ha una sintassi di questo tipo:</p> <pre><code>lista_output = [f(elemento) for elemento in lista_input]\n</code></pre> <p>In altre parole, otterremo in output una lista (<code>lista_output</code>) applicando ad ogni <code>elemento</code> della lista originaria (<code>lista_input</code>) la funzione <code>f()</code>.</p> <p>Nota</p> <p>Per essere precisi, pi\u00f9 che di lista, sarebbe opportuno parlare di iterabile di input.</p>"},{"location":"material/03_programming_python/27_data_structures/lecture/#2721-forma-estesa-con-if-else","title":"27.2.1 - Forma estesa con if-else","text":"<p>La list comprehension pu\u00f2 anche includere delle istruzioni condizionali. Un primo esempio \u00e8 la seguente forma:</p> <pre><code>lista_output_if = [f(elemento) for elemento in lista_input if condizione]\n</code></pre> <p>In questo caso, la funzione <code>f()</code> sar\u00e0 chiamata esclusivamente sugli elementi che soddisfano la <code>condizione</code> indicata. Invece, se usassimo questa forma:</p> <pre><code>lista_output_if_else = [f(elemento) if condizione else g(elemento) for elemento in lista_input]\n</code></pre> <p>la funzione <code>f()</code> sarebbe invocata su tutti gli elementi che soddisfano la <code>condizione</code>, mentre la funzione <code>g()</code> su tutti quelli che non la soddisfano.</p> <p>Perch\u00e9 usare le list comprehension?</p> <p>Le list comprehension sono utili e versatili, e permettono, in molti casi, di sostituire i classici cicli con una sintassi pi\u00f9 snella. Tuttavia, bisogna fare attenzione a non abusare di questo strumento: infatti, facendolo si rischia di complicare inutilmente il nostro programma, rendendolo poco leggibile e manutenibile. Come regola generale, quindi, ricordiamo il principio del rasoio di Occam: anche se \u00e8 facile innamorarsi delle list comprehension, \u00e8 bene ricordarsi che anche i cicli sono leciti e funzionali, per cui non \u00e8 sempre necessario trovare a tutti i costi una soluzione usando una list comprehension.</p>"},{"location":"material/03_programming_python/27_data_structures/lecture/#273-le-assignment-expressions","title":"27.3 - Le assignment expressions","text":"<p>Come apparso dalla trattazione, le list comprehension sono state pensate per approcci puramente iterativi. Di conseguenza, risulta complesso implementare forme di ricorsione. Per ovviare a questo inconveniente, Python ha introdotto le assignment expression.</p> <p>Da un punto di vista \"formale\", un'assignment expression permette di assegnare e restituire un valore all'interno di un'unica istruzione mediante il cosiddetto walrus operator:</p> <pre><code>&gt;&gt;&gt; print(enjoy := True)\nTrue\n</code></pre> <p>Vediamo come utilizzare questo concetto per combinare ricorsione e list comprehension. Definiamo i valori di \\(F_0\\) ed \\(F_1\\) per la sequenza di Fibonacci:</p> <pre><code>&gt;&gt;&gt; fib = [0, 1]\n</code></pre> <p>Vediamo cosa succede se proviamo ad usare una assignment expression in modo da restituire una lista che abbia come primo elemento il secondo della precedente (ovvero <code>1</code>), e come secondo la somma di tutti gli elementi della lista (ovvero <code>0 + 1</code>):</p> <pre><code>&gt;&gt;&gt; (fib := [fib[1], fib[0] + fib[1]])\n&gt;&gt;&gt; fib\n[1, 1]\n</code></pre> <p>Notiamo che l'operazione ha modificato il valore della lista <code>fib</code>! A noi, per\u00f2, interessa soltanto la somma degli elementi precedenti della lista (e quindi il secondo valore ottenuto). Per isolarlo, possiamo adoperare l'operatore booleano <code>and</code>:</p> <pre><code>&gt;&gt;&gt; (fib := [fib[1], fib[0] + fib[1]]) and fib[1]\n1\n</code></pre> <p>Proviamo a combinare i due passaggi precedenti, ed usare una list comprehension per concatenare i risultati ottenuti per i numeri che vanno fino ad \\(F_9\\):</p> <pre><code>&gt;&gt;&gt; fib = [0, 1]\n&gt;&gt;&gt; fib += [(fib := [fib[1], fib[0] + fib[1]]) and fib[1] for i in range(10)]\n&gt;&gt;&gt; fib\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#274-tuple","title":"27.4 - Tuple","text":"<p>Le tuple permettono di rappresentano un insieme di valori eterogenei separadoli da una virgola. Ad esempio:</p> <pre><code>tupla = ('hello', 'world', 12)\n</code></pre> <p>Un po' come avviene per le liste, uno dei valori della tupla pu\u00f2 a sua volta essere un'altra tupla. Ad esempio:</p> <pre><code>tupla = ('hello', 'world', (1, 2))\n</code></pre> <p>A differenza di una lista, per\u00f2, le tuple sono immutabili. Ci\u00f2 non implica per\u00f2 che non possano contenere al loro interno oggetti mutabili. Guardiamo il seguente esempio:</p> <pre><code>tupla = ('hello', 'world', [1, 2, 3])\n</code></pre> <p>La tupla avr\u00e0 al suo interno due stringhe (immutabili) ed una lista (mutabile). Proviamo a modificare la lista:</p> <pre><code>tupla[2] = [2, 2, 3]\n</code></pre> <p>Apparir\u00e0 un errore simile a questo:</p> <pre><code>Traceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n</code></pre> <p>Come prevedibile, abbiamo avuto un errore di assegnazione legato all'immutabilit\u00e0 della tupla. Proviamo adesso per\u00f2 a modificare direttamente la lista:</p> <pre><code>tupla[2][0] = 2         # La tupla sar\u00e0 ('hello', 'world', [2, 2, 3])\n</code></pre> <p>L'operazione \u00e8 evidentemente ammissibile, ed il risultato \u00e8 stato proprio quello atteso.</p> <p>Tuple e liste</p> <p>Ad un attento osservatore non sfuggir\u00e0 come tuple e liste siano simili dal punto di vista sintattico, e differiscano in buona sostanza per la mutabilit\u00e0. Da qui discende che le tuple sono estremamente efficaci nel caso si debba esclusivamente accedere agli elementi contenuti, mentre le liste devono essere usate quando \u00e8 anche necessario modificare all'occorrenza detti elementi.</p>"},{"location":"material/03_programming_python/27_data_structures/lecture/#275-set","title":"27.5 - Set","text":"<p>Anche i set sono molto simili alle liste dal punto di vista sintattico, ma offrono una significativa differenza: infatti, in un set non possono esserci elementi ripetuti.</p> <p>Nota</p> <p>Notiamo un'evidente analogia con il concetto matematico di insieme.</p> <p>La sintassi da usare per creare un set \u00e8 la seguente.</p> <pre><code>insieme = { 1, \"stringa\", 2 }\n</code></pre> <p>Il set ammette al suo interno dati eterogenei, tuttavia non pu\u00f2 contenere al suo interno delle liste o dei dizionari. Questo \u00e8 legato al fatto che i set (cos\u00ec come gli stessi dizionari) sono delle hash table, e quindi sfruttano il concetto di hash per rappresentare i dati contenuti in maniera compatta ed efficiente. Il fatto che le liste ed i dizionari non possano essere rappresentati in questo modo li esclude in automatico dall'includibilit\u00e0 all'interno di un set.</p> <p>Un'altra considerazione da fare \u00e8 che il set non \u00e8 ordinato: ci\u00f2 rende impossibile accedere ad (e modificare) un elemento del set mediante il suo indice, come succedeva per liste e tuple.</p> <p>Suggerimento</p> <p>I set possono essere usati per isolare gli elementi univoci presenti in una lista. Per farlo, basta convertire la lista in set:</p> <pre><code>l = [1, 2, 2, 3]      # La lista sar\u00e0 [1, 2, 2, 3]\ns = set(l)            # Il set sar\u00e0 [1, 2, 3]\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#276-dizionari","title":"27.6 - Dizionari","text":"<p>Il quarto ed ultimo tipo di contenitore per sequenze di dati \u00e8 il dizionario, presente anche in altri linguaggi di programmazione con il nome di array associativo o hash map.</p> <p>L'elemento base di un dizionario \u00e8 la coppia chiave - valore, nella quale un certo valore (di qualsiasi tipo) \u00e8 associato ad una determinata chiave (di tipo immutabile).</p> <p>I dizionari hanno diverse caratteristiche comuni ai set, dall'inutilizzabilit\u00e0 delle liste come chiavi al fatto di non permettere chiavi ripetute. Inoltre, le coppie chiave - valore sono accedute, per l'appunto, per chiave, e non in base all'ordine delle coppie.</p> <p>Nota</p> <p>Una differenza tra set e dizionari sta nel fatto che questi ultimi sono ordinati a partire da Python 25.7.</p> <p>Per creare un dizionario, possiamo usare una sintassi simile a quella usata per i set. Ad esempio, per creare un dizionario vuoto:</p> <pre><code>dizionario = {}\n</code></pre> <p>Possiamo quindi inserire delle coppie chiave - valore in questo modo:</p> <pre><code>dizionario['k'] = 'v'\ndizionario[1] = 'n'         # Il dizionario sar\u00e0 {'k': 'v', 1: 'n'}\n</code></pre> <p>Per accedere al valore associato ad una determinata chiave:</p> <pre><code>dizionario[1]               # Il valore restituito sar\u00e0 'n'\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#2561-chiavi-e-valori","title":"25.6.1 - Chiavi e valori","text":"<p>E' possibile recuperare la lista di tutte le chiavi presenti in un dizionario usando il metodo <code>keys()</code>, che restituisce un oggetto di tipo <code>dict_keys</code>, a sua volta convertibile in lista:</p> <pre><code>chiavi = dizionario.keys()          # Restituisce dict_keys(['k', 1]), che non \u00e8 una lista!\nlist(chiavi)                        # Restituisce ['k', 1], che \u00e8 una lista!\n</code></pre> <p>In modo analogo, si pu\u00f2 accedere a tutti i valori presenti nel dizionario mediante il metodo <code>values()</code>, che restituir\u00e0 un oggetto di tipo <code>dict_values</code>, da convertire anch'esso in lista:</p> <pre><code>valori = dizionario.values()        # Restituisce dict_values(['v', 'n']), che non \u00e8 una lista!\nlist(valori)                        # Restituisce ['v', 'n'], che \u00e8 una lista!\n</code></pre> <p>Possiamo accedere anche a tutte le coppie chiave - valore mediante il metodo <code>items()</code>, che ci restituisce un oggetto di tipo <code>dict_items</code>, il quale pu\u00f2 essere convertito in una lista di tuple:</p> <pre><code>coppie = dizionario.items()         # Restituisce dict_items([('k', 'v'), (1, 'n')])\nlist(coppie)                        # Restituisce una lista di tuple\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#2562-creazione-di-un-dizionario-non-vuoto","title":"25.6.2 - Creazione di un dizionario (non vuoto)","text":"<p>Abbiamo diversi modi per creare un dizionario non vuoto.</p>"},{"location":"material/03_programming_python/27_data_structures/lecture/#25621-uso-delloperatore","title":"25.6.2.1 - Uso dell'operatore <code>{}</code>","text":"<p>Il pi\u00f9 semplice, che \u00e8 quello che useremo pi\u00f9 spesso, \u00e8 quello di dichiarare nell'operatore <code>{}</code> le coppie chiave - valore iniziali:</p> <pre><code>&gt;&gt;&gt; dizionario = { 'k1': 1, 'k2': 2 }\n&gt;&gt;&gt; dizionario\n{'k1': 1, 'k2': 2}\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#25622-uso-del-costruttore-dict","title":"25.6.2.2 - Uso del costruttore <code>dict()</code>","text":"<p>Un altro modo \u00e8 usare il metodo costruttore <code>dict()</code>:</p> <pre><code>dizionario = dict(k1=1, k2=2)       # Il dizionario sar\u00e0 {'k1': 1, 'k2': 2}\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#25623-uso-della-funzione-zip","title":"25.6.2.3 - Uso della funzione <code>zip</code>","text":"<p>Possiamo poi usare la funzione <code>zip</code> per creare un dizionario a partire da due liste:</p> <pre><code>chiavi = ['k1', 'k2']\nvalori = [1, 2]\ndizionario = dict(zip(chiavi, valori))\n</code></pre>"},{"location":"material/03_programming_python/27_data_structures/lecture/#25624-dict-comprehension","title":"25.6.2.4 - Dict comprehension","text":"<p>Un modo per ottenere un dizionario a partire da un altro oggetto iterabile \u00e8 la dict comprehension, che ha una forma del tipo:</p> <pre><code>output = { chiave: valore for valore in iterabile }\n</code></pre> <p>Possiamo ad esempio creare un dizionario contenente come chiave i numeri da 1 a 9, e come valori corrispondenti i quadrati degli stessi:</p> <pre><code>quadrati = {str(i): i ** 2 for i in range(1, 10)}\nprint(quadrati)\n# Risultato: {'1': 1, '2': 4, '3': 9, '4': 16, '5': 25, '6': 36, '7': 49, '8': 64, '9': 81}\n</code></pre>"},{"location":"material/03_programming_python/28_modules/lecture/","title":"28 - Script e moduli","text":"<p>Quando si usa Python la tentazione \u00e8 quella di interagire direttamente con l'interprete, lanciandolo da terminale ed eseguendo di volta in volta le istruzioni necessarie. Ovviamente questo approccio, seppur immediato, presenta diversi svantaggi. Ad esempio:</p> <ul> <li>non avremo a disposizione il syntax highlighting offerto da una normale IDE;</li> <li>non potremo recuperare il codice una volta chiuso l'interprete;</li> <li>non potremo n\u00e9 modificare, n\u00e9 verificare facilmente il funzionamento del codice.</li> </ul> <p>Appare quindi evidente come usare l'interprete non sia un modo ottimale di sviluppare codice Python. Di conseguenza, sar\u00e0 necessario definire, mediante la nostra IDE di riferimento, dei veri e propri script che saranno salvati sotto forma di file con estensione <code>.py</code>, ognuno dei quali contenenti una serie di istruzioni necessarie all'esecuzione del nostro programma.</p>"},{"location":"material/03_programming_python/28_modules/lecture/#281-il-primo-script","title":"28.1 - Il primo script","text":"<p>Proviamo quindi a creare il nostro primo script Python. Per farlo, apriamo la nostra IDE di riferimento, come Visual Studio Code, e creiamo un file chiamato <code>main.py</code>, all'interno del quale inseriremo il seguente codice:</p> <pre><code># main.py\ndef hello_world():\n    print('Hello, world')\n\nhello_world()\n</code></pre> <p>Adesso apriamo un terminale, spostiamoci nella cartella nel quale abbiamo salvato questo script, ed eseguiamolo:</p> <pre><code>cd cartella_dove_risiede_lo_script\npython main.py\n</code></pre> <p>Le due istruzioni precedenti:</p> <ul> <li>servono a cambiare cartella (change directory, <code>cd</code>), spostandoci nella cartella dove risiede lo script;</li> <li>dicono all'interprete Python di lanciare lo script <code>main.py</code>.</li> </ul> <p>A schermo, se tutto \u00e8 andato per il verso giusto, apparir\u00e0 la scritta <code>Hello, world</code>:</p> <pre><code>Hello, world\n</code></pre>"},{"location":"material/03_programming_python/28_modules/lecture/#282-i-moduli","title":"28.2 - I moduli","text":"<p>Quando le dimensioni della nostra code base (ovvero la quantit\u00e0 di codice che scriviamo nel nostro programma) iniziano ad essere particolarmente \"ingombranti\", \u00e8 opportuno adottare un approccio modulare, separando in file differenti parti di codice delegate a funzioni eterogenee. Facciamo un esempio.</p> <p>Immaginiamo di voler scrivere un programma che definisca delle funzioni per calcolare l'area delle principali figure geometriche. Modifichiamo quindi il nostro file <code>main.py</code> come segue:</p> <pre><code>def calcola_area_quadrato(lato):\n    return lato * lato\n\n\ndef calcola_area_rettangolo(base, altezza):\n    return base * altezza\n\n\ndef calcola_area_triangolo(base, altezza):\n    return (base * altezza) / 2\n\n\narea_quadrato = calcola_area_quadrato(4)\narea_rettangolo = calcola_area_rettangolo(2, 3)\narea_triangolo = calcola_area_triangolo(2, 3)\n</code></pre> <p>Immaginiamo di voler quindi aggiungere una funzione di calcolo trigonometrico:</p> <pre><code>import math\n\ndef calcola_tangente(angolo):\n    return math.sin(angolo) / math.cos(angolo)\n\n\ntangente_pi = calcola_tangente(math.pi)\n</code></pre> <p>Il codice del nostro file <code>main.py</code> comprender\u00e0 adesso funzioni di tipo geometrico e trigonometrico.</p> <p>Cosa succederebbe se volessimo integrare delle funzioni di calcolo integrale, o di altro tipo? Ovviamente, ci sarebbe da un lato un aumento delle dimensioni della code base, dall'altro un \"mix\" tra funzioni che afferiscono ad ambiti differenti (seppur simili tra loro). Una buona idea sarebbe quindi quella di separare le diverse parti del programma, magari raggruppando le funzioni geometriche nel file <code>geometria.py</code>, le funzioni trigonometriche nel file <code>trigonometria.py</code>, e via discorrendo.</p> <p>Questi file, che conterranno al loro interno prevalentemente funzioni (ma non solo), sono chiamati moduli.</p> <p>Nota</p> <p>La linea che distingue gli script dai moduli \u00e8 molto sottile, e nei fatti \u00e8 facile fare confusione ed utilizzarli in maniera \"intercambiabile\". Sottolineamo per\u00f2 che, idealmente, gli script devono contenere al loro interno soltanto del codice che sar\u00e0 eseguito, mentre i moduli solo del codice che sar\u00e0 invocato da uno o pi\u00f9 script.</p> <p>Interprete e nome di un modulo</p> <p>L'interprete \u00e8 in grado di risalire al nome di un modulo dal nome del file in cui \u00e8 contenuto. Se, ad esempio, definiamo un modulo nel file <code>geometria.py</code>, l'interprete associer\u00e0 a quel modulo il nome <code>geometria</code>. Detto nome \u00e8 inoltre accessibile globalmente e dall'interno del modulo richiamando la variabile globale <code>__name__</code>.</p>"},{"location":"material/03_programming_python/28_modules/lecture/#2821-i-moduli-geometria-e-trigonometria","title":"28.2.1 - I moduli <code>geometria</code> e <code>trigonometria</code>","text":"<p>Creiamo adesso il file <code>geometria.py</code>, all'interno del quale \"sposteremo\" le funzioni definite in precedenza per il calcolo geometrico.</p> <pre><code># geometria.py\ndef calcola_area_quadrato(lato):\n    return lato * lato\n\n\ndef calcola_area_rettangolo(base, altezza):\n    return base * altezza\n\n\ndef calcola_area_triangolo(base, altezza):\n    return (base * altezza) / 2\n</code></pre> <p>Analogamente, nel file <code>trigonometria.py</code> andremo a definire la funzione per il calcolo della tangente.</p> <pre><code>import math\n\ndef calcola_tangente(angolo):\n    return math.sin(angolo) / math.cos(angolo)\n</code></pre> <p>Riscriviamo ora il file <code>main.py</code>:</p> <pre><code>import geometria\nimport trigonometria\n\nif __name__ == \"__main__\":\n    print(geometria.calcola_area_quadrato(4))\n    print(trigonometria.calcola_tangente(math.pi))\n</code></pre> <p>Possiamo notare due cose.</p> <ol> <li>In primis, stiamo richiamando le funzioni <code>calcola_area_quadrato()</code> e <code>calcola_tangente()</code> definite nei moduli <code>geometria</code> e <code>trigonometria</code>, rispettivamente. Questi moduli sono importati all'interno del nostro script mediante la direttiva <code>import</code>.</li> <li>Alle righe 5 e 6, la \"strana\" sintassi mostrata serve a dichiarare quello che \u00e8 il <code>main</code>, ovvero il punto di \"accesso\" al codice del nostro programma. Il <code>main</code> \u00e8 normalmente presente in tutti i linguaggi di programmazione, alle volte sotto forme un po' differenti da quella qui mostrata; tuttavia, nel caso di script particolarmente semplici, il <code>main</code> pu\u00f2 essere tranquillamente omesso, in quanto l'interprete riuscir\u00e0 ad eseguirlo in maniera autonoma.</li> </ol> <p>Proviamo a lanciare lo script; per farlo, digitiamo l'istruzione <code>python main.py</code> da terminale. A schermo, se tutto \u00e8 andato per il verso giusto, vedremo i valori dell'area di un quadrato e della tangente di \\(\\pi\\).</p>"},{"location":"material/03_programming_python/28_modules/lecture/#283-usare-gli-import","title":"28.3 - Usare gli import","text":"<p>Relativamente al modulo <code>geometria</code>, abbiamo usato esclusivamente la funzione <code>calcola_area_quadrato()</code>, \"trascurando\" le altre due funzioni comunque presenti nel modulo. In queste circostanze, possiamo usare una versione modificata della direttiva <code>import</code>, che assume la seguente forma:</p> <pre><code>from modulo import funzione_o_classe\n</code></pre> <p>il che, nel nostro caso specifico, diventa:</p> <pre><code>from geometria import calcola_area_quadrato\n</code></pre> <p>In questo modo, possiamo importare solamente quello che ci serve, il che risulta particolarmente utile a migliorare l'efficienza del nostro codice; il perch\u00e9 sar\u00e0 chiaro a breve.</p>"},{"location":"material/03_programming_python/28_modules/lecture/#2831-alias","title":"28.3.1 - Alias","text":"<p>La direttiva <code>import</code> ci permette di definire anche degli alias, particolarmente utili nel caso si usino dei nomi di package complessi. Ad esempio:</p> <pre><code>import trigonometria as tr\n\nprint(tr.calcola_tangente(math.pi))\n</code></pre>"},{"location":"material/03_programming_python/28_modules/lecture/#284-la-funzione-dir","title":"28.4 - La funzione <code>dir()</code>","text":"<p>La funzione <code>dir()</code> restituisce una lista con tutti i nomi (sia di funzione, sia di classe) definiti da un modulo. Ad esempio:</p> <pre><code>&gt;&gt;&gt; dir(geometria)\n['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'calcola_area_quadrato', 'calcola_area_rettangolo', 'calcola_area_triangolo']\n</code></pre> <p>E' interessante notare come, oltre a funzioni, classi e variabili da noi definite, nel modulo <code>geometria</code> siano automaticamente definite altre variabili, che saranno importate usando import:</p> <pre><code>import geometria\n\nif __name__ == \"__main__\":\n    print(geometria.__file__)\n    print(geometria.calcola_area_quadrato(4))\n</code></pre> <p>Notiamo che saremo in grado di accedere alla variabile <code>__file__</code> del modulo <code>geometria</code>, che indica il percorso relativo dello stesso all'interno del file system. Ovviamente, questa variabile non \u00e8 quasi mai utile, ma comporta un ulteriore carico sul codice, da cui diventa evidente l'importanza dell'opportuno uso della direttiva <code>from</code>.</p>"},{"location":"material/03_programming_python/28_modules/lecture/#285-moduli-della-libreria-standard","title":"28.5 - Moduli della libreria standard","text":"<p>Python ha diversi moduli appartenenti ad una libreria standard, i quali sono automaticamente disponibili a valle dell'installazione dell'interprete. Alcuni tra i pi\u00f9 utilizzati sono:</p> <ul> <li><code>sys</code>: \u00e8 il modulo integrato nell'interprete, ed offre diverse utility necessarie al suo funzionamento;</li> <li><code>os</code>: modulo delegato all'interazione con il sistema operativo su cui gira l'interprete;</li> <li><code>time</code>: modulo usato per tutte le utility riguardanti il \"cronometraggio\" del tempo di esecuzione di una funzione;</li> <li><code>datetime</code>: modulo usato per le funzionalit\u00e0 di data ed ora;</li> <li><code>copy</code>: modulo usato per gestire, tra le altre cose, la deep copy di un oggetto.</li> </ul> <p>Per una lista esaustiva, si rimanda alla Python Library Reference.</p>"},{"location":"material/03_programming_python/28_modules/lecture/#286-package","title":"28.6 - Package","text":"<p>Chiudiamo la trattazione con un accenno ai package, ovvero a delle vere e proprie \"collezioni\" che raggruppano moduli tra loro coerenti, in modo da facilitarne il successivo accesso. In pratica, i package non sono altro se non delle cartelle contenenti pi\u00f9 moduli (quindi, file con estensione <code>nome_modulo.py</code>), oltre ad un file, chiamato <code>__init__.py</code>, che permette all'interprete di riconoscere quella cartella come package e, occasionalmente, contiene delle istruzioni di inizializzazione del package.</p> <p>Per poter accedere ad un modulo contenuto all'interno di un package, possiamo usare la direttiva <code>import</code>, modificandola come segue:</p> <pre><code>import nome_package.nome_modulo\n# oppure...\nfrom nome_package.nome_modulo import nome_funzione\n</code></pre>"},{"location":"material/03_programming_python/29_io/lecture/","title":"29 - Lettura e scrittura di file in Python","text":"<p>Python offre numerose funzioni (gi\u00e0 integrate nel core del linguaggio) per la gestione dei file. Queste sono a loro volta divise in vari moduli, quali (ad esempio) <code>os</code>, <code>shutil</code> e <code>pathlib</code>.</p> <p>In questa lezione, vedremo alcune tra le principali funzioni usate per effettuare le pi\u00f9 comuni operazioni sui file Python.</p>"},{"location":"material/03_programming_python/29_io/lecture/#291-file-di-testo-vs-file-binari","title":"29.1 File di testo vs. file binari","text":"<p>Prima di passare a vedere le principali funzioni usate da Python per la gestione dei file, dobbiamo parlare dei due diversi tipi di file esistenti, ovvero file binari e file di testo.</p> <p>La maggior parte dei file che usiamo durante il normale utilizzo del computer sono, infatti, file di tipo binario. Nonostante quello che si possa pensare, infatti, anche un documento di Word (o di un programma equivalente) \u00e8, in realt\u00e0, un file binario, pur avendo soltanto del testo al suo interno. Altri esempi di file binario sono dati dalle immagini, dai database, o anche dai fogli Excel. Ci\u00f2 \u00e8 principalmente legato al fatto che file di questo tipo sono, in realt\u00e0, codificati in un formato che rende necessario un software specifico per la loro apertura.</p> <p>Un file di testo, invece, non ha una codifica specifica, e pu\u00f2 essere aperto da un normale editor di testo (per intenderci, anche Blocco Note). Tuttavia, occorre notare che:</p> <ul> <li>i file di testo devono essere leggibili da un essere umano;</li> <li>i dati contenuti in un file di testo devono essere organizzati in righe distinte.</li> </ul> <p>In tal senso, al termine di ogni riga dei file di testo vi \u00e8 un carattere di terminazione che, in Python, \u00e8 la sequenza di escape <code>\\n</code> (mentre in altri linguaggi, come ad esempio il C, \u00e8 data dal punto e virgola).</p>"},{"location":"material/03_programming_python/29_io/lecture/#292-python-e-gli-strumenti-per-linputoutput-io","title":"29.2 - Python e gli strumenti per l'input/output (I/O)","text":"<p>Innazitutto \u00e8 necessario premettere che Python integra di default gli strumenti per leggere (input) e scrivere (output) su file (o su altri supporti). Ci\u00f2 differisce da altri linguaggi, come ad esempio il C++, nel quale \u00e8 necessario includere una libreria facente parte del core del linguaggio (<code>#include &lt;fstream&gt;</code>).</p> <p>Vediamo adesso come aprire un file in Python.</p>"},{"location":"material/03_programming_python/29_io/lecture/#2921-apertura-di-un-file-in-python","title":"29.2.1 - Apertura di un file in Python","text":"<p>Per aprire un file in Python occorre usare la funzione <code>open()</code>, il cui utilizzo base \u00e8 il seguente:</p> <pre><code>riferimento_file = open(nome_file, modalit\u00e0)\n</code></pre> <p>La funzione <code>open()</code> restituisce un riferimento, o puntatore, al file a partire da due parametri:</p> <ul> <li><code>nome_file</code>, ovvero il nome del file con il quale vogliamo interagire, comprensivo dell'estensione;</li> <li><code>modalit\u00e0</code>, che indica il modo in cui interagiremo con il file.</li> </ul> <p>In particolare, se il file con cui vogliamo interagire \u00e8 nella stessa cartella del nostro script Python, potremo limitarci ad utilizzarne il nome completo di estensione (ad esempio, <code>dati.txt</code>). In caso contrario, invece, dovremo specificarne il percorso relativo al nostro script, o il percorso assoluto (ad esempio, <code>C:/documenti/dati.txt</code>).</p> <p>Slash e backslash</p> <p>Quando si utilizzano i percorsi assoluti, \u00e8 importante fare attenzione al corretto uso di slash e backslash. Il consiglio \u00e8 quello di utilizzare le slash o, in alternativa, il doppio backslash. Tuttavia, potrebbe essere saggio utilizzare strumenti pi\u00f9 pythonic, come le librerie os e pathlib, che approfondiremo altrove.</p> <p>La modalit\u00e0 indica invece quello che vogliamo fare con il nostro file; le diverse opzioni sono riassunte nella tabella successiva.</p> Modalit\u00e0 Abbreviazione Descrizione Piazzamento del puntatore al file Write <code>w</code> Questa modalit\u00e0 \u00e8 usata quando dobbiamo modificare il file da zero. Risulta importante sottolineare come, in questa modalit\u00e0, un eventuale file gi\u00e0 esistente viene cancellato Il puntatore al file \u00e8 piazzato all'inizio del file. Read <code>r</code> Questa modalit\u00e0 \u00e8 usata quando il file va esclusivamente letto e non modificato in alcun modo. Il puntatore al file \u00e8 piazzato all'inizio del file. Append <code>a</code> Questa modalit\u00e0 \u00e8 usata quando occorre aggiungere ulteriori informazioni al termine del file. Il puntatore al file \u00e8 piazzato al termine del file. Read/Write <code>r+</code> Questa modalit\u00e0 \u00e8 usata quando occorre sia modificare completamente sia leggere il file. Il puntatore al file \u00e8 piazzato all'inizio del file. Append/Read <code>a+</code> Questa modalit\u00e0 \u00e8 usata quando occorre sia aggiungere ulteriori informazioni al termine del file sia permetterne la lettura. Il puntatore al file \u00e8 piazzato alla fine del file. Exclusive Creation <code>x</code> Questa modalit\u00e0 \u00e8 usata esclusivamente per creare un nuovo file; ci\u00f2 significa che, se esiste gi\u00e0 un file con lo stesso nome, la funzione lancer\u00e0 un'eccezione. N.D. <p>Le modalit\u00e0 precedentemente elencate funzionano con i file di testo; per usarle sui file binari, baster\u00e0 aggiungere una <code>b</code> al modificatore, ovvero:</p> Modalit\u00e0 Shortcut (testo) Shortcut (binario) Write <code>w</code> <code>wb</code> Read <code>r</code> <code>rb</code> Append <code>a</code> <code>ab</code> Read/Write <code>r+</code> <code>rb+</code> Append/Read <code>a+</code> <code>ab+</code> Exclusive Creation <code>x</code> <code>xb</code>"},{"location":"material/03_programming_python/29_io/lecture/#29211-un-esempio","title":"29.2.1.1 - Un esempio","text":"<p>Vediamo un esempio di come \u00e8 possibile aprire un file in modalit\u00e0 write. Supponiamo di avere un file chiamato <code>dati.txt</code>, e che questo sia nella stessa cartella del nostro script:</p> <pre><code>file_dati = open('dati.txt', 'w')\n</code></pre> <p>Avremo quindi creato un oggetto chiamato <code>file_dati</code> che potremo conseguentemente utilizzare per manipolare, in modalit\u00e0 di scrittura, il nostro file <code>dati.txt</code>.</p> <p>Modalit\u00e0 utilizzate</p> <p>Le modalit\u00e0 di cui ci serviremo nei casi pratici saranno spesso quelle di lettura e scrittura.</p>"},{"location":"material/03_programming_python/29_io/lecture/#293-chiusura-di-un-file","title":"29.3 - Chiusura di un file","text":"<p>Quando si utilizza un file in lettura o scrittura si crea un flusso (in inglese stream) che va da o verso il nostro file. In altre parole, lo script crea un \"canale di comunicazione\" che tiene aperto il file, non rendendolo disponibile ad altre applicazioni fino a che questo non viene liberato.</p> <p>Va da s\u00e9 che chiudere questo stream sia estremamente importante per due motivi, ovvero liberare risorse ed assicurarsi che eventuali modifiche provvisorie siano finalizzate. Per farlo, Python ci mette a disposizione la funzione <code>close()</code> da chiamare sul riferimento al file. Ad esempio:</p> <pre><code>file_dati.close()\n</code></pre> <p>Dopo aver chiuso il file, non potremo pi\u00f9 accedervi (a meno che, ovviamente, non lo riapriamo successivamente). Per verificarlo, proviamo ad eseguire le seguenti istruzioni da un terminale Python:</p> <pre><code>&gt;&gt;&gt; file_dati = open(\"dati.txt\", \"w\")\n&gt;&gt;&gt; file_dati.close()\n&gt;&gt;&gt; file_dati.read()\n\nTraceback (most recent call last):\n  File \"&lt;input&gt;\", line 1, in &lt;module&gt;\n    file_dati.read()\nValueError: I/O operation on closed file.\n</code></pre>"},{"location":"material/03_programming_python/29_io/lecture/#294-la-parola-chiave-with","title":"29.4 - La parola chiave with","text":"<p>Python offre una sintassi consigliata per l'interazione con i file mediante l'uso della parola chiave <code>with</code>. Grazie a questa sintassi, il file verr\u00e0 automaticamente chiuso dopo che l'esecuzioni delle istruzioni presenti nel blocco di codice annidato all'interno del <code>with</code>. Ad esempio, l'istruzione precedente si trasforma nel seguente modo:</p> <pre><code>with open(\"dati.txt\", \"w\") as file_dati:\n    # Abbiamo un puntatore chiamato file_dati.\n    # Eseguiamo alcune operazioni sul file:\n    file_dati.read()\n\n# Siamo usciti dall'ambito del with.\n# Il file \u00e8 adesso chiuso.\n</code></pre> <p>Nota</p> <p>Nel prosieguo, utilizzeremo esclusivamente la sintassi che usa la parola chiave <code>with</code>.</p>"},{"location":"material/03_programming_python/29_io/lecture/#295-interagire-con-un-file","title":"29.5 - Interagire con un file","text":"<p>Una volta aperto un file, potremo usare i metodi integrati in Python per interagire con il file. Vediamone brevemente come fare.</p>"},{"location":"material/03_programming_python/29_io/lecture/#2951-lettura-dei-dati","title":"29.5.1 - Lettura dei dati","text":"<p>Per leggere i contenuti di un file, dobbiamo usare il metodo <code>read(size)</code>. Se non specifichiamo il parametro <code>size</code> (in italiano dimensione), il metodo legger\u00e0 l'intero contenuto del file, stampandolo a schermo sotto forma di stringa (se \u00e8 un file di testo) o come byte (se \u00e8 un file binario).</p> <p>Le dimensioni contano</p> <p>Di solito, la funzione <code>read()</code> viene tranquillamente utilizzata lasciando il parametro di default. TUttavia, se il file che stiamo leggendo ha dimensioni maggiori rispetto alla memoria disponibile, non potremo accedervi in una sola volta, e dovremo usare il parametro <code>size</code> per \"spezzarlo\" in parti gestibili.</p> <p>Vediamo un esempio di utilizzo del parametro <code>size</code>. Supponiamo che il nostro file <code>dati.txt</code> contenga il seguente testo:</p> <pre><code>Dati sulla riga 1\nDati sulla riga 2\nDati sulla riga 3\n</code></pre> <p>Proviamo quindi a scrivere questo codice:</p> <pre><code>with open(\"dati.txt\", \"r\") as dati:\n    print(\"Nome del file: \", dati.name)\n    line = dati.read()\n    print(line)\n</code></pre> <p>L'output sar\u00e0:</p> <pre><code>Nome del file: dati.txt\nDati sulla riga 1\nDati sulla riga 2\nDati sulla riga 3\n</code></pre> <p>Proviamo adesso a modificare la terza riga come segue:</p> <pre><code>line = dati.read(6)\n</code></pre> <p>L'output cambier\u00e0 di conseguenza nel seguente:</p> <pre><code>Nome del file: dati.txt\nDati s\n</code></pre> <p>Appare evidente come l'operazione di lettura legga i dati nel file soltanto fino alla posizione 6, che \u00e8 il valore che abbiamo passato alla precedente chiamata a <code>read()</code>.</p> <p>Nota</p> <p>Nel caso provassimo ad effettuare nuovamente l'operazione di lettura sullo stesso file, continueremo a leggere i dati da dove ci eravamo precedentemente interrotti; in tal modo, possiamo elaborare un file dalle grandi dimensioni in pezzi dalle dimensioni ridotte.</p>"},{"location":"material/03_programming_python/29_io/lecture/#2952-leggere-i-file-di-testo-riga-per-riga","title":"29.5.2 Leggere i file di testo riga per riga","text":"<p>Abbiamo visto come l'istruzione <code>read()</code> ci permette di leggere un file nella sua interezza. Tuttavia, possiamo decidere di leggere un file riga per riga mediante l'istruzione <code>readline(size)</code>.</p> <p>Il parametro <code>size</code></p> <p>Il parametro <code>size</code> funzioni esattamente come per la funzione <code>read</code>.</p> <p>Facciamo un esempio:</p> <pre><code>with open(\"dati.txt\", \"r\") as dati:\n    print(\"Nome del file: \", dati.name)\n    line = dati.readline()\n    print(line)\n</code></pre> <p>L'uscita in questo caso sar\u00e0:</p> <pre><code>Nome del file: dati.txt\nDati sulla riga 1\n</code></pre> <p>Ovviamente, possiamo chiamare ripetutamente il metodo <code>readline()</code> allo scopo di leggere ulteriori righe dal file; in alternativa, possiamo usare <code>readlines()</code>, che restituisce una lista di tutte le righe contenute nel file.</p> <p>Ad esempio:</p> <pre><code>print(dati.readlines())\n</code></pre> <p>restituir\u00e0 il seguente output:</p> <pre><code>['Dati sulla riga 1', 'Dati sulla riga 2', 'Dati sulla riga 3']\n</code></pre> <p><code>readline()</code> su file binari</p> <p>Dato che i file binari non hanno al loro interno il concetto di \"riga di codice\", i metodi <code>readline()</code> e <code>readlines()</code> non funzioneranno su questo tipo di file.</p> <p>Un modo alternativo di mostrare il contenuto di un file riga dopo riga \u00e8 quello di usare un ciclo:</p> <pre><code>with open(\"dati.txt\", \"r\") as dati:\n    for line in dati:\n        print(line)\n</code></pre> <p>Queste istruzioni avranno l'output che segue:</p> <pre><code>Dati sulla riga 1\nDati sulla riga 2\nDati sulla riga 3\n</code></pre> <p>Efficienza nella lettura</p> <p>L'approccio che prevede la lettura riga dopo riga del file mediante <code>readline()</code> \u00e8, in realt\u00e0, pi\u00f9 efficiente di quello che si limita a leggere il file nella sua interezza mediante <code>read()</code>. Infatti, non dovremo leggere l'intero file e tenerlo in memoria, ma potremo leggere ed elaborare ogni riga in maniera individuale, il che \u00e8 ovviamente vantaggioso in termini di memoria, specie nel caso di file di grandi dimensioni.</p>"},{"location":"material/03_programming_python/29_io/lecture/#2953-scrivere-su-file","title":"29.5.3 - Scrivere su file","text":"<p>Appare chiaro come i file non servano a molto se non \u00e8 possibile scrivervi dei dati. Per farlo, dovremo aprire il file in scrittura, mediante (ad esempio) la modalit\u00e0 <code>w</code>.</p> <p>Suggerimento</p> <p>Spesso \u00e8 opportuno utilizzare la modalit\u00e0 append per non eliminare se non si vogliono sovrascrivere i contenuti di un file gi\u00e0 esistente.</p> <p>Una volta aperto il file, sar\u00e0 necessario usare la funzione <code>write(data)</code>, dove <code>data</code> sono i dati che saranno scritti sul file. Ad esempio, possiamo aggiungere una nuova riga al nostro file di dati come segue:</p> <pre><code>dati.write(\"Dati sulla riga 4\\n\")\n</code></pre> <p>Suggerimento</p> <p>Ricordiamo che la sequenza <code>\\n</code> indica una nuova riga; in tal modo, le scritture successive avverranno a partire dalla riga successiva.</p> <p>Se volessimo scrivere delle variabili non rappresentative di una stringa, come, ad esempio, una serie di numeri, dovremmo effettuarne il cast. Ad esempio, volendo scrivere una lista di tre numeri:</p> <pre><code>values = [1, 2, 3]\n\nwith open(\"dati.txt\", \"a+\") as dati:\n    for value in values:\n        str_value = str(value)\n        dati.write(f'{str_value}\\n')\n</code></pre>"},{"location":"material/03_programming_python/29_io/lecture/#2954-ricerca-nei-file","title":"29.5.4 Ricerca nei file","text":"<p>In precedenza abbiamo visto come quando scriviamo in modalit\u00e0 read il riferimento al file punta all'inizio dello stesso. Se volessimo leggere una sezione intermedia del file, dovremmo \"scorrerlo\" fino ad individuare la parte di interesse.</p> <p>In alternativa, dovremo spostare il puntatore dall'inizio del file: il modo pi\u00f9 semplice di farlo \u00e8 usare il metodo <code>seek(offset, from_what)</code>. In particolare, il parametro <code>offset</code> indica il numero di caratteri da considerare a partire dal parametro <code>from_what</code>, che pu\u00f2 assumere tre possibili valori:</p> <ul> <li><code>0</code>: indica l'inizio del file;</li> <li><code>1</code>: indica il puntatore alla posizione attuale;</li> <li><code>2</code>: indica la fine del file.</li> </ul> <p>Differenza tra file di testo e binari</p> <p>Sottolineamo che quando lavoriamo con dei file di testo possiamo usare soltanto i valori <code>0</code> e <code>2</code>.</p> <p>Di conseguenza, usare <code>dati.seek(5, 0)</code> far\u00e0 in modo da posizionare il puntatore al quarto carattere (ricordiamo che il conteggio in Python parte da 0). Di conseguenza, potremmo avere un output di questo tipo:</p> <pre><code>sulla riga 1\nDati sulla riga 2\nDati sulla riga 3\n</code></pre> <p>Se volessimo controllare l'attuale posizione del puntatore, possiamo usare il metodo <code>tell()</code>. Questo metodo pu\u00f2 essere usato anche per capire quanto \u00e8 lungo il file attuale:</p> <pre><code>with open(\"dati.txt\", \"a\") as dati:\n    print(dati.tell())\n</code></pre> <p>Il valore restituito dovrebbe essere 55, il che rappresenta la dimensione del file.</p>"},{"location":"material/03_programming_python/29_io/lecture/#296-inserire-nuovi-elementi-in-file-esistenti","title":"29.6 Inserire nuovi elementi in file esistenti","text":"<p>Ci potrebbero essere delle occasioni dove \u00e8 necessario modificare internamente un file esistente, senza necessariamente aggiungervi dei dati. Per farlo, non possiamo usare semplicemente le modalit\u00e0 append o write: infatti, la prima inserir\u00e0 nuovi dati al termine del file, mentre la seconda sovrascriver\u00e0 l'intero file.</p> <p>Dovremo quindi usare dei metodi alternativi. Quello pi\u00f9 semplice prevede di creare una lista di righe a partire dalla lettura del file, usando poi il metodo <code>insert(i, x)</code> su questa per inserire i nuovi dati nella lista stessa. Una volta terminata la modifica della lista, potremo effettuarne il <code>join()</code> e scriverla sul nostro file.</p> <p>La funzione <code>insert</code></p> <p>Ricordiamo che la funzione <code>insert(i, x)</code> prevede che <code>i</code> sia un intero che indica l'indice di lista nel quale inserire <code>x</code>.</p> <p>Ad esempio, volendo inserire una nuova riga nel nostro file tra la 1 e la 2, dovremo usare il codice che segue:</p> <pre><code># Leggiamo i contenuti del file e salviamoli in una lista\nwith open(\"dati.txt\", \"r\") as dati:\n    righe_dati = dati.readlines()\n\nrighe_dati.insert(1, \"Questo va tra le righe 1 e 2\\n\")\n\n# Sovrascriviamo il vecchio file con i nuovi contenuti\nwith open(\"dati.txt\", \"w\") as dati:\n    nuovi_dati = \"\".join(righe_dati)\n    dati.write(nuovi_dati)\n</code></pre> <p>Andando a leggere il file, il risultato finale sar\u00e0 il seguente:</p> <pre><code>Dati sulla riga 1\nQuesto va tra le righe 1 e 2\nDati sulla riga 2\nDati sulla riga 3\n</code></pre>"},{"location":"material/03_programming_python/29_io/lecture/#297-conclusioni","title":"29.7 - Conclusioni","text":"<p>In questa lezione, abbiamo visto una serie di tecniche e modi per leggere, creare e modificare file esistenti in Python. Per approfondire la conoscenza di metodi e concetti, il consiglio \u00e8, al solito, quello di rivolgersi alla documentazione ufficiale.</p>"},{"location":"material/03_programming_python/30_argparse/lecture/","title":"17 - Il modulo <code>argparse</code>","text":"<p>Il modulo <code>argparse</code> ci permette di inserire degli argomenti da passare al nostro script Python mediante riga di comando.</p> <p>Per farlo, dobbiamo seguire un processo articolato in quattro step:</p> <ol> <li>creiamo un oggetto di classe <code>ArgumentParser</code>;</li> <li>aggiungiamo gli argomenti di cui intendiamo fare il parsing;</li> <li>effettuiamo il parsing di questi argomenti;</li> <li>usiamo gli argomenti per chiamare il metodo opportuno</li> </ol> <p>Vediamo un esempio.</p> <p>Supponiamo di avere una classe <code>Persona</code>, e di voler scrivere uno script per creare un oggetto di questa classe mediante riga di comando. Potremo scrivere:</p> <pre><code>from argparse import ArgumentParser\n\nclass Persona():\n\n    def __init__(self, nome, cognome):\n        self.nome = nome\n        self.cognome = cognome\n\n    def __str__(self):\n        return f'{self.nome} {self.cognome}'\n\n\ndef run(args):\n    \"\"\" Definiamo il metodo `run` che sar\u00e0 invocato\n    ad ogni esecuzione dello script.\n    Il metodo accetta un parametro args che rappresenta\n    gli argomenti di cui \u00e8 stato effettuato il parsing.\n    \"\"\"\n    p = Persona(args.nome, args.cognome)\n    print(p)\n\n\nif __name__ == '__main__':\n    # Step 1: creiamo un oggetto di classe `ArgumentParser`\n    parser = ArgumentParser()\n    # Step 2: aggiungiamo due argomenti al parser\n    parser.add_argument(\n        '-n',                       # abbreviazione con cui invocare l'argomento\n        '--nome',                   # nome completo dell'argomento\n        help='Nome della persona',  # messaggio di aiuto per descrivere l'argomento\n        default='Pippo',            # valore di default dell'argomento\n    )\n    parser.add_argument(\n        '-c',\n        '--cognome',\n        help='Cognome della persona',\n        required=True               # indica che l'argomento non pu\u00f2 essere omesso\n    )\n    # Step 3: facciamo il parsing degli argomenti\n    args = parser.parse_args()      # gli argomenti saranno salvati in args\n    # Step 4: passiamo gli argomenti al metodo run\n    run(args)\n</code></pre> <p>Proviamo a salvare questo script in un file <code>run.py</code>, ed eseguiamolo usando la notazione abbreviata:</p> <pre><code>python run.py -n Nome -c Cognome\n</code></pre> <p>A schermo vedremo:</p> <pre><code>Nome Cognome\n</code></pre> <p>Possiamo anche omettere il nome, ma non il cognome, in quanto \u00e8 un parametro richiesto:</p> <pre><code>python run.py -c Cognome\nPippo Cognome\n</code></pre> <p>Possiamo poi invocare l'help scrivendo:</p> <pre><code>python run.py -h\n</code></pre> <p>Proviamo infine ad utilizzare la notazione completa:</p> <pre><code>python run.py --nome Nome --cognome Cognome\nNome Cognome\n</code></pre> <p>Proviamo adesso a modificare la classe <code>Persona</code> inserendovi l'et\u00e0. In tal senso, specifichiamo che l'et\u00e0 deve essere un valore intero; qualora questo non avvenga, sar\u00e0 lanciata un'eccezione.</p> <pre><code>class Persona():\n\n    def __init__(self, nome, cognome, eta):\n        self.nome = nome\n        self.cognome = cognome\n        self.eta = eta\n\n    @property\n    def eta(self):\n        return self._eta\n\n    @eta.setter\n    def eta(self, value):\n        if not isinstance(eta, int):\n            raise ValueError(\"Fornire un intero per l'et\u00e0.\")\n        self._eta = value\n\n    def __str__(self):\n        return f'{self.nome} {self.cognome}'\n</code></pre> <p>Modifichiamo il resto dello script per adattarci alle nuove esigenze. Partiamo dal metodo <code>run</code>:</p> <pre><code>def run(args):\n    \"\"\" Definiamo il metodo `run` che sar\u00e0 invocato\n    ad ogni esecuzione dello script.\n    Il metodo accetta un parametro args che rappresenta\n    gli argomenti di cui \u00e8 stato effettuato il parsing.\n    \"\"\"\n    p = Persona(args.nome, args.cognome, args.eta)\n    print(p)\n</code></pre> <p>Aggiungiamo poi un altro argomento al <code>parser</code>:</p> <pre><code>if __name__ == '__main__':\n    # Step 1: creiamo un oggetto di classe `ArgumentParser`\n    parser = ArgumentParser()\n    # Step 2: aggiungiamo due argomenti al parser\n    parser.add_argument(\n        '-n',                       # abbreviazione con cui invocare l'argomento\n        '--nome',                   # nome completo dell'argomento\n        help='Nome della persona',  # messaggio di aiuto per descrivere l'argomento\n        default='Pippo',            # valore di default dell'argomento\n    )\n    parser.add_argument(\n        '-c',\n        '--cognome',\n        help='Cognome della persona',\n        required=True               # indica che l'argomento non pu\u00f2 essere omesso\n    )\n    parser.add_argument(\n        '-e',\n        '--eta',\n        help='Et\u00e0 della persona'\n    )\n    # Step 3: facciamo il parsing degli argomenti\n    args = parser.parse_args()      # gli argomenti saranno salvati in args\n    # Step 4: passiamo gli argomenti al metodo run\n    run(args)\n</code></pre> <p>Proviamo ad eseguire di nuovo lo script:</p> <pre><code>python run.py -n Nome -c Cognome -e 18\n</code></pre> <p>Vedremo che viene lanciato un errore, in quanto gli argomenti passati mediante argparse sono normalmente interpretati come delle stringhe.</p> <p>Per risolvere questo problema dovremo specificare il parametro <code>type</code>, ponendolo ad <code>int</code>:</p> <pre><code>parser.add_argument(\n    '-e',\n    '--eta',\n    help='Et\u00e0 della persona',\n    type=int\n)\n</code></pre> <p>Se proviamo ad eseguire nuovamente lo script non riscontreremo alcun errore.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/","title":"Lecture","text":"<p>La maggior parte dei linguaggi OOP come Java, C++, C# hanno il concetto di un costruttore, un metodo speciale che crei ed inizializzi l'oggetto quando viene creato. Python \u00e8 un po' differente: ha un costruttore ed un inizializzatore. La funzione costruttore \u00e8 raramente usata a meno che non stia facendo qualcosa di esotico. Di conseguenza, iniziamo la nostra discussione con il metodo di inizializzazione.</p> <p>La funzione costruttore in Python \u00e8 chiamata new ed init \u00e8 la funzione di inizializzazione.</p> <p>Andardo a riprendere la documentazione Python, new \u00e8 usato qunado abbiamo bisogno di controllare la creazione di una nuova istanza mentre init \u00e8 usato quando abbaimo bisogno dell'inizializzazione di una nuova istanza.</p> <p>new \u00e8 il primo step della creazione dell'istanza. E' chiamata per prima ed \u00e8 responsabile per restituire una nuova istanza della nosttra classe.</p> <p>In contrasto, init non restituisce niente: \u00e8 responsabile soltanto per inizializzare l'istanza dopo che \u00e8 stata creata. In generale, non dovremo sovrascrivere il metodo new, a meno che non stiamo andando ad usare una subclass per un tipo immutabile come str, int, Unicode o tuple.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#costruttori-di-class-in-python-ed-il-processo-di-istanziamento","title":"Costruttori di class in Python ed il processo di Istanziamento","text":"<p>Come molti altri linguaggi di programmazione, Python supporta la OOP. Al centro delle capacit\u00e0 object-oriented di Python, troveremo la keyword class, che ci permette di definire le classi custom che possono avere degli attributi per memorizzare i dati ed i metodi per fornire dei comportamenti.</p> <p>Una volta avuta una classe con cui lavorare, a questo punto possiamo iniziare a creare nuove istanze o ogetti della classe, che \u00e8 un modo efficiente per riutilizzare le funzionalit\u00e0 nel nostro codice.</p> <p>Creare ed inizializzare gli oggetti di una data classe sono uno step fondamentale nella OOP. Questo passo \u00e8 spesso riferito come costruzione o istanziamento degli oggetti. I tool responsabile per creare questo processo di istanziamento \u00e8 spesso conosciuto come costruttore di classe.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#conoscere-i-costruttori-di-classe-di-python","title":"Conoscere i costruttori di classe di Python","text":"<p>In Python, per costruire un oggetto di una data classe, dobbiamo soltanto chiamare la classe con degli argomenti appropriati, cos\u00ec come chiameremmo una qualsiasi funzione:</p> <pre><code>class SomeClass:\n    pass\n\nSomeClass()\n#FAR VEDRE LA CALSSE\n</code></pre> <p>In questo esempio, definiamo SomeClass usando la parola chiave class. QUesta classe \u00e8 al momento vuota perch\u00e9 non ha attributi o metodi. Invece, il corpo della classe contiene soltanto un'istruzione pass come istruzione \"placeholder\" che non fa niente.</p> <p>Quindi creiamo una nuova istanza di SomeClass chiamando la clase con una coppia di paretnesi. In questo esempio, non dobbiamo passare alcun argomento nella chiamata perch\u00e9 la nostra classe non prende ancora alcun argomento.</p> <p>In Python, quando chiamiamo una classe come fatto nell'esempio prcecente, stiamo chiamando il costruttore di classe, che crea, inizializza e restituisce un nuovo oggetto lanciando il processo interno di istanziamento di Python.</p> <p>Un ultimo punto da notare \u00e8 che chiamare una classe non \u00e8 lo stesso di chiamare un'istanza di una classe. Questi sono due topic differenti e completamente incorrelati. Per rendere chiamabile l'istanza di una classe, dobbiamo implementare un metodo speciale __call(), che non ha niente a che fare con il processo di istanziamento di Python.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#comprendere-il-processo-di-istanziamento-di-python","title":"Comprendere il processo di istanziamento di Python","text":"<p>Lanciamo il processo di istanziamento di PYthon quando chiamiamo una classe Python per creare una nuova istanza. Questo processo viene eseguito in due step separati, che possiamo descrivere come segue:</p> <ul> <li>creazione di una nuova istanza della classe target</li> <li>inizializzazione della nuova istanza con uno stato iniziale appropriato</li> </ul> <p>Per eseguire il primo step, le classi Python hanno un metodo speciale chiamato new(), che \u00e8 responsabile per la creazione e la restituzione di un nuovo oggetto vuoto. A questo punto un nuovo metodo speciale, init(), prende l'oggetto risultante, assieme agli argomenti del costruttore di classe.</p> <p>Il metodo init prende il nuovo oggetto come suo primo argometno, <code>self</code>. Quindi imposta ogni attributo dell'istanza richiesto ad uno stato valido usando gli argomenti che gli ha passato il costruttore di classe.</p> <p>In breve, il processo di istanziamento di Python inizia con una chiamata al costruttore di classe, che lancia il creatore dell'istanza, new(), facendogli creare un nuovo oggetot vuoto. Il processo continua con l'inizializzatore dell'istanza, inti(), che prende gli argometni del crostruttore per inizializzare l'oggetto appena creato.</p> <p>Per esploare il processo di istanziamento di Python internamente, possiamoc consdierare il seguente esempio di una classe Punto che implementa una versione custom di entrambi i metodi.</p> <pre><code>class Punto:\n    def __new__(cls, *args, **kwargs):\n        print(\"1. Creazione di una nuova istanza di Punto.\")\n        return super().__new__(cls)\n\n    def __init__(self, x, y):\n        print(\"2. Inizializzazione di una nuova istanza di Punto.\")\n        self.x = x\n        self.y = y\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}(x={self.x}, y={self.y})\"\n</code></pre> <p>Questo codice:</p> <ul> <li>alla riga 3, definisce la classe Punto usando la parola chiave <code>class</code> seguita dal nome della classe.</li> <li>alla riga 4, definisce il metodo new(), che prende la classe come primo argomento. Notiamo che il primo argomento \u00e8 <code>cls</code>. Il metodo prende inoltre <code>*args</code> e <code>**kwargs</code>, che permettono di passare un numero indefinito di argomenti di inizializzazione all'istanza sottostante.</li> <li>alla riga 5, scriviamo un messaggio quando new() esegue lo step di creazione</li> <li>alla rgia 6, creiamo una nuova istanza di Punto chiamando il metodo new() della classe padre con cls come argomento. In questo esempio, la class padre \u00e8 <code>object</code>, e la chiamata a super() vi d\u00e0 accesso. Quindi, l'istanza viene restituita. Questa istanza sar\u00e0 il primo argometno ad init.</li> <li>alla riga 8 definisce init(), che si occupa dello step di inizializzazione. Questo metodo prende un primo argomento (self), che ha un riferimento all'instanza atutale. Il metodo prende anche due ulteriori argomenti, x ed y. QUesti argomenti hanno i valori iniziali per gli attributi dell'istanza x ed y. Dobbiamo passare dei valori adatti per questi argomenti nella chiamata a Punto(), come vedremo a breve.</li> <li>la riga 9 scrive un messaggio quando init() esegue lo step di inizializzazione dell'oggetto</li> <li>le righe 10 ed 11 inizializzano x ed y, rispettivamente. Per farlo, usano gli argomenti di input forniti (x ed y)</li> <li>le righe 13 e 14 implementano il metodo speciale repr, che fornisce una rappresentazione aduegata sotto forma di stringa degli oggetti di classe Point.</li> </ul> <p>Possiamo adesso scoprire come funziona il processo di istanziamento nella pratica. Salviamo il nostro codice in un file chiamato putno.py e lanciamo il nostro itnerprete Python in una finestra a riga di comando. Quindi eseguiamo il seguente codice:</p> <pre><code>from point import Point\n\npoint = Point(21, 42)\n\n1. Create a new instance of Point.\n2. Initialize the new instance of Point.\n</code></pre> <p>Chiamare il costruttore di classe Point() crea, inizializza e restituisce una nuova istanza della classe. Questa istanza \u00e8 quindi assegnata alla variabile point.</p> <p>In questo esempio, la chiamata al costruttore ci permette anche di conoscere gli step che Python esegue internamente per costruire l'istanza. In primis, Python chiama <code>__new__()</code>, e quindi <code>__init__()</code>, il che risulta in una nuova e completamente inizializzata istanza di <code>Punto</code>, come possiamo vedere al termine dell'esempio.</p> <p>Possiamo anche provare ad eseguire entrambi gli step manualmente:</p> <pre><code>from point import Point\n\npoint = Point.__new__(Point)\n1. Create a new instance of Point.\n\n&gt;&gt;&gt; # The point object is not initialized\n&gt;&gt;&gt; point.x\nTraceback (most recent call last):\n    ...\nAttributeError: 'Point' object has no attribute 'x'\n&gt;&gt;&gt; point.y\nTraceback (most recent call last):\n    ...\nAttributeError: 'Point' object has no attribute 'y'\n\n&gt;&gt;&gt; point.__init__(21, 42)\n2. Initialize the new instance of Point.\n\n&gt;&gt;&gt; # Now point is properly initialized\n&gt;&gt;&gt; point\nPoint(x=21, y=42)\n</code></pre> <p>In questo esempio, per prima cosa chiamiamo <code>__new__()</code> sulla classe Punto, passando la classe stessa come primoa rgomento al meotod. Questa chiamata viene solo eseguita come primo step del processo di istanziamento, creando un nuovo oggetto vuoto. Notiamo che creare un'istanza in questo modo bypassa la chiamata ad <code>__init__()</code>.</p> <p>Nota</p> <p>L'esempio precedente deve essere inteso come un esempio dimostrativo di come funziona il processo di istanziamento itnernamente. Non \u00e8 un qualcosa che vogliamo tipicamente fare nel codice reale.</p> <p>Una volta che abbiamo il nuovo oggetto, possiamo inizializzarlo chiamando <code>__init__()</code> con un insieme appropriato di argomenti. Dopo questa chiamata, il nostro oggetto Punto \u00e8 inizializzato, con tutti i suoi attributi impostati.</p> <p>Un sottile, ma importante, dettaglio da notare su <code>__new__()</code> \u00e8 che pu\u00f2 anche restituire un'istanza di una classe differente dalla classe che implementa il metodo stesso. Quando questo accade, Python non chiama <code>__init__()</code> nella classe attuale, perch\u00e9 non c'\u00e8 modo di sapere in maniera non ambigua come inizializzare un oggetto di una classe differente.</p> <p>Consideriamo il seguente esempio, nel quale il metodo new() della classe B restituisce un'istanza della classe A:</p> <pre><code># ab_classes.py\n\nclass A:\n    def __init__(self, a_value):\n        print(\"Initialize the new instance of A.\")\n        self.a_value = a_value\n\nclass B:\n    def __new__(cls, *args, **kwargs):\n        return A(42)\n\n    def __init__(self, b_value):\n        print(\"Initialize the new instance of B.\")\n        self.b_value = b_value\n</code></pre> <p>Siccome <code>B.__new__()</code> restituisce un'istanza di una clase differente, Python non esegue B.init(). Per confermare questo comportamento, salviamo il codice in un file chiamato classi_ab.py e quindi eseguiamo il codice seguente in una sessione Python interattiva.</p> <pre><code>&gt;&gt;&gt; from ab_classes import B\n\n&gt;&gt;&gt; b = B(21)\nInitialize the new instance of A.\n\n&gt;&gt;&gt; b.b_value\nTraceback (most recent call last):\n    ...\nAttributeError: 'A' object has no attribute 'b_value'\n\n&gt;&gt;&gt; isinstance(b, B)\nFalse\n&gt;&gt;&gt; isinstance(b, A)\nTrue\n\n&gt;&gt;&gt; b.a_value\n42\n</code></pre> <p>La chiamata al costruttore della classe <code>B()</code> esegue <code>B.__new__()</code>, che restituisce un'istanza di A invece di B. Per questo motivo, <code>B.__ini__()</code> non viene mai eseguito. Notiamo che b non ha un attributo bvalue. In contrasto, b ha un attributo avalue, con valore 42.</p> <p>Ora che conosciamo gli step che Python percorre internamente per creare istanze di una data classe, possiamo scendere pi\u00f9 nel dettaglio nelle altre caratteristiche di init(), new() e gli step che eseguono.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#inizializazzione-degli-oggetti-con-init","title":"INizializazzione degli oggetti con init()","text":"<p>In Python, il metodo init() \u00e8 probabilmente il metodo speciale pi\u00f9 comemente sovrascritto nelle nostre classi custom. Pi\u00f9 o meno tutte le nostre classi avranno bisogno di un'implementazione custom di init(). Sovrascrivere questo metodo ci permette di inizializzare propriamente i nostri oggetti.</p> <p>LO scopo di questo step di inizializzazione \u00e8 lasciare i nostri nuovi oggetti in uno stato valido, in modo che li si possa iniziare ad usare immediatamente nel nostro codice. In questa sezione, vedremo le basi di scrivere i nostri metodi init(), e come ci possono aiutare a customizzare le nostre classi.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#fornire-degli-inizializzatori-custom-degli-oggetti","title":"Fornire degli inizializzatori custom degli oggetti","text":"<p>L'implementazione pi\u00f9 basilare di init() che possiamo scrivere si occuper\u00e0 soltanto di assegnare gli argomenti in input ai corrispondenti attributi dell'istanza. Ad esempio, diciamo che stiamo scrivendo una classe Rettangolo che richiede gli attributi width ed height. In questo caso, possiamo fare qualcosa come questa:</p> <pre><code>&gt;&gt;&gt; class Rectangle:\n...     def __init__(self, width, height):\n...         self.width = width\n...         self.height = height\n...\n\n&gt;&gt;&gt; rectangle = Rectangle(21, 42)\n&gt;&gt;&gt; rectangle.width\n21\n&gt;&gt;&gt; rectangle.height\n42\n</code></pre> <p>Come abbiamo visto prima, init() esegue il secondo step dell'istanziamento dell'oggetto in Python. Il suo primo argomento, <code>self</code>, contiene la nuova istanza che risulta dalla chiamata a <code>__new__()</code>. Il resto degli argomenti ad <code>__init__()</code> sono normalmente usati per inizializzare gli attributi dell'istanza. Nell'esempio precedente, abbiamo inizializzato le propriet\u00e0 width ed height del rettangolo usando gli argomenti width ed height passati ad inti().</p> <p>E' importante notare che, senza contare il self, gli argomenti all'init() sono gli stessi che passiamo nella chiamata al costruttore di classe. Di conseguenza, possiamo dire che la firma init() definisce la firma del costruttore di classe.</p> <p>Inoltre, teniamo a mente che inti() non deve esplciritamente restituire un qualcosa di diverso da None, o otterremo un'eccezione di tipo TypeError.</p> <pre><code>&gt;&gt;&gt; class Rectangle:\n...     def __init__(self, width, height):\n...         self.width = width\n...         self.height = height\n...         return 42\n...\n\n&gt;&gt;&gt; rectangle = Rectangle(21, 42)\nTraceback (most recent call last):\n    ...\nTypeError: __init__() should return None, not 'int'\n</code></pre> <p>In questo esempio, il metodo init() prova a restituire un numero intero, che finisce per lanciare un'eccezione <code>TypeError</code> a runtime.</p> <p>Il messaggio di errore nell'esempio precedente ci dice che il metodo init() deve restituire None. Ad ogni modo, non dobbiamo aggiungere un return None esplciitamente, perch\u00e9 i metodi e le funzioni senza un'istruzione return esplicita semplicemente restituiscono None, in Python.</p> <p>Con l'implementazione precedente di init(), ci assicuriamo che width ed height vengano inizializzati ad uno stato valido quando chiamiamo il Costruttore di lcasse con argomenti adeguati. In questo modo, i nostri rettangoli saranno pronti all'uso dopo che finisce il processo di costruzione.</p> <p>In init(), possiamo eseguire una qualsiasi trasformazione degli argomenti di input per inizializzare propriamente gli attributi dell'istanza. Ad esempio, se i nostri utenti useranno direttamente un rettangolo, allora potremmo voler validare i valori forniti di width ed height ed assicurarci che siano corretti prima di inizializzare gli attributi corrispondenti:</p> <pre><code>&gt;&gt;&gt; class Rectangle:\n...     def __init__(self, width, height):\n...         if not (isinstance(width, (int, float)) and width &gt; 0):\n...             raise ValueError(f\"positive width expected, got {width}\")\n...         self.width = width\n...         if not (isinstance(height, (int, float)) and height &gt; 0):\n...             raise ValueError(f\"positive height expected, got {height}\")\n...         self.height = height\n...\n\n&gt;&gt;&gt; rectangle = Rectangle(-21, 42)\nTraceback (most recent call last):\n    ...\nValueError: positive width expected, got -21\n</code></pre> <p>In questa implementazione aggiornata di init(), ci assicuriamo che gli argomenti di input width ed height siano numeri positivi prima di inizializzare gli attributi width ed height corrispondenti. Se una validazione tra le due fallisce, abbiamo un ValueError.</p> <p>Nota</p> <p>Una tecnica maggiormente Pythonica prevede dii gestire la validazione degli attributi mediante delle property.</p> <p>Ora diciamo ches tiamo usando l'ereditariet\u00e0 per fcreare una gerarchia di classi custom e riutilizzare delle funzionalit\u00e0 nel nostro codice. Se la nostra sottoclasse fornisce un metodo init(), allora questo metodo deve esplicitamente chiamare l'init() della classe base con argomenti appropriati per assicurare la corretta inizializzazione delle istanze. Per farlo, dobbiamo suare la funzione built-in super() come nel seguente esempio.</p> <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name, birth_date):\n...         self.name = name\n...         self.birth_date = birth_date\n...\n\n&gt;&gt;&gt; class Employee(Person):\n...     def __init__(self, name, birth_date, position):\n...         super().__init__(name, birth_date)\n...         self.position = position\n...\n\n&gt;&gt;&gt; john = Employee(\"John Doe\", \"2001-02-07\", \"Python Developer\")\n\n&gt;&gt;&gt; john.name\n'John Doe'\n&gt;&gt;&gt; john.birth_date\n'2001-02-07'\n&gt;&gt;&gt; john.position\n'Python Developer'\n</code></pre> <p>La prima riga nel metodo init() di Impiegato chiama super().init() con argomenti nome e data di compleanno. Questa chiamata assicura l'inizializzazione degli attributi name e birth_date nella classe madre, Persona. Questa tecnica ci permette di estendere la classe base con nuovi attributi e funzioanlit\u00e0.</p> <p>PEr terminare questa sezione, dovremo sapere che l'implementazione base di init() viene dalla classe object. Questa implementazione viene chiamata in automatico quando non forniamo un metodo init() esplicito nelle nostre classi.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#costruire-degli-inizializzatori-flessibili","title":"Costruire degli inizializzatori flessibili","text":"<p>Possiamo rendere gli step di inizializzazione dei nostri oggetti flessibili e versatili modificando il metodo init(). A tal scopo, una delle tecniche pi\u00f9 popolari \u00e8 quella di usare degli argomenti opzionali. Questa tecnica ci permette di scrivere delle classi nelle quali il costruttore accetta diversi insiemi di argomenti di input al momento dell'istanziamento. Quali arogmenti utilizzare ad un dato istante di tempo dipende dai nostri specifici obiettivi e contesto.</p> <p>Come rapido esempio, vediamo la seguente classe Greeter:</p> <pre><code># greet.py\n\nclass Greeter:\n    def __init__(self, name, formal=False):\n        self.name = name\n        self.formal = formal\n\n    def greet(self):\n        if self.formal:\n            print(f\"Good morning, {self.name}!\")\n        else:\n            print(f\"Hello, {self.name}!\")\n</code></pre> <p>IN questo esempio, init() prende un argomento regolare chiamato <code>name</code>. Accetta anche un argomento opzionale chiamato <code>formal</code>, che di default assume il valore <code>False</code>. Dato che <code>formal</code> ha un valore di default, possiamo costruire degli oggetti affidandoci a questo valore o fornirne uno noi.</p> <p>Il comportamento finale della classe dipender\u00e0 dal valore di formal. Se questo argomento \u00e8 False, allora avremo un greeting informale qunado chiameremo il metodo greet(). Altrimenti, avremo un benvenuto pi\u00f9 formale.</p> <p>Per provare Greeter, salviamo il codice in un file greet.py. Quindi, apriamo una sessione interattiva nella nostra cartella di lavoro, eseguendo questo codice:</p> <pre><code>&gt;&gt;&gt; from greet import Greeter\n\n&gt;&gt;&gt; informal_greeter = Greeter(\"Pythonista\")\n&gt;&gt;&gt; informal_greeter.greet()\nHello, Pythonista!\n\n&gt;&gt;&gt; formal_greeter = Greeter(\"Pythonista\", formal=True)\n&gt;&gt;&gt; formal_greeter.greet()\nGood morning, Pythonista!\n</code></pre> <p>Nel primo esempio, creiamo un oggetto chiamato informal_greeter passando un valore all'argomento name ed affidandoci al valore di default di formal. Otteniamo un messaggio di benvenuto informale sul nostro schermo quando chiamiamo greet() su questo oggetto.</p> <p>Nel secondo esempio, usiamo un nome ed un argomento formale per istanziare Greeter. Siccome formal \u00e8 True, il risultato di chiamare greet() \u00e8 un messaggio di benvenuto formale.</p> <p>Anche se questo \u00e8 un esempio \"toy\", mostra come i valori degli argomenti di default sono una feature potente in Python che possiamo usare per scrivere degli inizializzatori flessibili per le nostre classi. Questi inizializzatori ci permettono di istanziare le nostre classi usando diversi insiemi di argomenti a seconda delle nostre necessit\u00e0.</p> <p>Adesso che conosciamo le basi di init() e dello step di inizializzazione dell'oggetto, \u00e8 il momento di cambiare marcia ed iniziare a vedere new() e lo step di creazione dell'oggetto.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#creazione-delloggetto-con-new","title":"Creazione dell'oggetto con new()","text":"<p>Quando scriviamo delle classi Python, tipicamente non dobbiamo fornire la nostra implementazione del metodo speciale new(). La maggior parte delle volte, l'implementazione base dalla classe built-in object \u00e8 sufficiente a creare un oggetto vuoto per la nostra classe attuale.</p> <p>Tuttavia, ci sono alcuni casi d'uso interessanti per questo metodo. Ad esempio, possiamo usare new() per creare delle sottoclassi di tipi immutabili, come int, float, tuple e str. Nella seguente sezioni, vedremo come scrivere implementazioni custom di new() nelle nostre classi. Per farlo, codificheremo alcuni campioni che ci daranno un'idea di quando potremmo dover sovrascrivere questo metodo.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#fornire-dei-creatori-di-oggetti-custom","title":"Fornire dei creatori di oggetti custom","text":"<p>Tipicamente, scriveremo un'implementazione personalizzata di new() soltanto qunado dobbiamo controllare la crezione di una nuova istanza a basso livello. Adesso, se abbiamo bisogno di un'implementazione personalizzata di questo metodo, dobbiamo seguire alcuni step:</p> <ul> <li>creazione di una nuova istanza chiamando <code>super().__new__()</code> con gli argomenti adeguati</li> <li>personalizzazione della nuova istanza in accordo ai nostri obiettivi specifici</li> <li>restituzione della nuova istanza per continuare il processo di istanziamento</li> </ul> <p>Con questi tre step circoncisi, siamo in grado di personalizzare lo step di creazione dell'istanza nel processo di istanziamento Python. Ecco un esempio di come possiamo tradurre questi step in codice Python.</p> <pre><code>class SomeClass:\n    def __new__(cls, *args, **kwargs):\n        instance = super().__new__(cls)\n        # Customize your instance here...\n        return instance\n</code></pre> <p>Questo esempio fornisce una specie di implementazione template di new(). Come sempre, new() prende la classe attuale come argomento tipicamente indicato come <code>cls</code>. Notiamo che stiamo usando *args e **kwargs per rendere il metodo pi\u00f9 flessibile e manutenibile accettando un numero qualisasi di argomenti.</p> <p>Notiamo che stiamo usando *args e **kwargs per rendere il metodo pi\u00f9 flessibile e manutenibile accettando un numero arbitrario di argomenti. Dovremmo sempre definire new() con *args e **kwargs, a meno che non si abbiano buone ragioni per seguire un pattern differente.</p> <p>Alla prima riga di new(), chiamiamo il metodo new() della classe padre per creare una nuova istanza ed allocarvi memoria. Per accedere al metodo new() della classe padre, usiamo la funzione super(). Questa catena di chiamate va fino al metodo new() di object, che \u00e8 l'implementazione base di new() per tutte le classi Python.</p> <p>Nota</p> <p>La classe object integrata \u00e8 la classe base di default per tutte le classi Python.</p> <p>Il passo successivo \u00e8 personalizzare l'istanza appena creata. Possiamo fare tutto quello di cui abbiamo bisogno per personalizzare l'istanza. Infine, nel terzo step, dobbiamo restituire la nuova istanza per continuare il processo di istanziamento con lo step di inizializzazione.</p> <p>E' importante notare che il metodo new() da solo accetta soltanto un arogmento singolo, ovvero la classe da istanziare. SE chiamiamo il metodo new() con pi\u00f9 argomenti, avremo un TypeError:</p> <pre><code>&gt;&gt;&gt; class SomeClass:\n...     def __new__(cls, *args, **kwargs):\n...         return super().__new__(cls, *args, **kwargs)\n...     def __init__(self, value):\n...         self.value = value\n...\n\n&gt;&gt;&gt; SomeClass(42)\nTraceback (most recent call last):\n    ...\nTypeError: object.__new__() takes exactly one argument (the type to instantiate)\n</code></pre> <p>In questo esempio, abbiamo mandato *args e **kwargs come argomenti aggiuntivi nella chiamata a super().new(). Il sottostante metodo object.new() accetta soltanto la classe come argomento, per cui abbiamo un TypeError quando istanziamo la classe.</p> <p>Ad ogni modo, new() accetta e passa argomenti extra ad init() se la nostra classe non sovrasrive new(), come nella seguente variazione di SomeClass:</p> <pre><code>&gt;&gt;&gt; class SomeClass:\n...     def __init__(self, value):\n...         self.value = value\n...\n\n&gt;&gt;&gt; some_obj = SomeClass(42)\n&gt;&gt;&gt; some_obj\n&lt;__main__.SomeClass object at 0x7f67db8d0ac0&gt;\n&gt;&gt;&gt; some_obj.value\n42\n</code></pre> <p>In questa implementazione di SomeClass, non sovrascriviamo new(). La creazione dell'oggetto \u00e8 quindi delegata ad object.new(), che adessoa ccetta dei valori e li pasa a SomeClass.init() per finalizzare l'istanziamento. Adesso creiamo delle nuove, e completamente inizializzate, istanze di SomeClass, proprio come some_obj nell'esempio.</p> <p>Adesso che sappiamo come scrivere la nostra implementazione di new(), siamo in grado di valutare alcuni esempi pratici che mostrano alcuni dei casi d'uso pi\u00f9 comuni di questo metodo nella programmazione Python.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#subclassing-dei-tipi-built-in-immutabili","title":"SUbclassing dei tipi built-in immutabili","text":"<p>Per iniziare, vedriamo un caso d'uso di new() che consiste nel creare una sottoclasse di un tipo immutabile built-in. Ad esempio, diciamo di dover scrivere una classe Distanza come sottoclasse del tipo float di Python. La nostra classe avr\u00e0 un ulteriore attributo per memorizzare l'unit\u00e0 usata per misurare la distanza.</p> <p>Ecco un primo approccio a questo problema usando il metodo init():</p> <pre><code>&gt;&gt;&gt; class Distance(float):\n...     def __init__(self, value, unit):\n...         super().__init__(value)\n...         self.unit = unit\n...\n\n&gt;&gt;&gt; in_miles = Distance(42.0, \"Miles\")\nTraceback (most recent call last):\n    ...\nTypeError: float expected at most 1 argument, got 2\n</code></pre> <p>Quando si fa una sottoclasse di un tipo immutabile built-in, abbiamo un errore. Parte del problema \u00e8 che il valore \u00e8 impostato durante la creazione, ed \u00e8 troppo tardi per cambiarlo durante l'inizializzazione. Inoltre, float.new() viene chiamato \"sotto al cofano\", e non si occupa di argomenti extra allo stesso modo di object.new(). Questo \u00e8 ci\u00f2 che lancia l'errore nel nostro esempio precedente.</p> <p>Per evitare questo problema, possiamo inizializzare l'oggetto al momento della creazione con new() invece di sovrascrivere init(). Ecco come possiamo farlo in pratica:</p> <pre><code>&gt;&gt;&gt; class Distance(float):\n...     def __new__(cls, value, unit):\n...         instance = super().__new__(cls, value)\n...         instance.unit = unit\n...         return instance\n...\n\n&gt;&gt;&gt; in_miles = Distance(42.0, \"Miles\")\n&gt;&gt;&gt; in_miles\n42.0\n&gt;&gt;&gt; in_miles.unit\n'Miles'\n&gt;&gt;&gt; in_miles + 42.0\n84.0\n\n&gt;&gt;&gt; dir(in_miles)\n['__abs__', '__add__', ..., 'real', 'unit']\n</code></pre> <p>In questo esempio, new() esegue i tre step che abbiamo visto nella sezione precedente. Per priam cosa, il metodo crea una nuova istanza della classe attuale, cls, chiamando super().new(). Questa volta, la chiamata va indietro a float.new(), che cera una nuova istanza inizializzando il suo valore come argomento. QUindi, il metodo customizza la nuova istanza aggiungendovi un attributo .unit. Infine, la nuova istanza viene restituita.</p> <p>Nota</p> <p>La classe <code>Distance</code> nell'esempio precedente non fornisce un meccanismo di conversione di unit\u00e0 appropriato. Questo significa che qualcosa come <code>Distance(10, \"km\") + Distance(20, \"miles\")</code> non prover\u00e0 a convertire le unit\u00e0 prima di aggiungere i valori.</p> <p>Ecco fatto! Ora la classe Distance funziona come atteso, permettendoci di usare un attributo dell'istanza per memorizzare l'unit\u00e0 nella quale stiamo misurando la distanza. A differenza dei valori a virgola mobile memorizzati in una data istanza di <code>Distance</code>, l'attributo <code>.unit</code> \u00e8 mutabile, per cui possiamo cambiare il suo valore qunado vogliamo. Infine, notiamo come una chiamata alla funzione <code>dir()</code> riveli che la nostra classe eredita feature e metodi da <code>float</code>.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#restituire-istanze-di-una-classe-differente","title":"Restituire istanze di una classe differente","text":"<p>Restituire un oggetto di una classe differente \u00e8 un requisito che pu\u00f2 richiedere un'implementazione custom di new(). Tuttavia, dovremmo porre attenzione perch\u00e9 in questo caso Python salta interamente lo step di inizializzazione. Avremo quindi la responsabilit\u00e0 di prendere l'oggetto appena creto in uno stato valido prima di usarlo nel nostro codice.</p> <p>Vediamo il seguente esempio, nel quale la classe Pet usa new() per restituire istanze di classe scelte casualmente.</p> <pre><code># pets.py\n\nfrom random import choice\n\nclass Pet:\n    def __new__(cls):\n        other = choice([Dog, Cat, Python])\n        instance = super().__new__(other)\n        print(f\"I'm a {type(instance).__name__}!\")\n        return instance\n\n    def __init__(self):\n        print(\"Never runs!\")\n\nclass Dog:\n    def communicate(self):\n        print(\"woof! woof!\")\n\nclass Cat:\n    def communicate(self):\n        print(\"meow! meow!\")\n\nclass Python:\n    def communicate(self):\n        print(\"hiss! hiss!\")\n</code></pre> <p>In questo esempio, <code>Pet</code> fornisce un metodo <code>__new__()</code> che crea una nuova istanza selezionando casualmente una classe da una lista di classi esistenti.</p> <p>Ecco come possiamo usare questa clase Pet come una factory di oggetti pet:</p> <pre><code>&gt;&gt;&gt; from pets import Pet\n\n&gt;&gt;&gt; pet = Pet()\nI'm a Dog!\n&gt;&gt;&gt; pet.communicate()\nwoof! woof!\n&gt;&gt;&gt; isinstance(pet, Pet)\nFalse\n&gt;&gt;&gt; isinstance(pet, Dog)\nTrue\n\n&gt;&gt;&gt; another_pet = Pet()\nI'm a Python!\n&gt;&gt;&gt; another_pet.communicate()\nhiss! hiss!\n</code></pre> <p>Ogni volta che istanziamo Pet, otteniamo u oggetto casuale da una diversa classe. Questo risultato \u00e8 possibile perch\u00e9 non vi sono restrizioni sull'oggetto che <code>__new__()</code> pu\u00f2 restituire. Usare <code>__new__()</code> in questo modo trasforma una classe in una factory flessibile e potente di oggetti, non limitate alle istanze di s\u00e9 stessa.</p> <p>Infine, notiamo come il metodo <code>__init__()</code> di Pet non viene mai eseguito. Questo \u00e8 legato al fatto che <code>Pet.__new__()</code> restituisce sempre oggetti di una classe diversa da Pet stesso.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#permettere-solo-una-singola-istanza-nelle-nostre-classi","title":"PErmettere solo una singola istanza nelle nostre classi","text":"<p>Alle volte dobbiamo implementare una classe che ci permette la creazione di una singola istanza. QUesto tipo di classe \u00e8 comunemente conosciuto come singleton. In questa situazione, il metodo <code>__new__()</code> ci viene in aiuto perch\u00e9 ci aiuta a restringere il numero di istanze che una data classe pu\u00f2 avere.</p> <p>Nota</p> <p>La maggior parte degli sviluppatori Python noter\u00e0 che non dobbiamo implementare il design pattern singleton in Python a meno che non abbiamo gi\u00e0 una classe funzionante a cui dobbiamo aggiungere le funzionalit\u00e0 del pattern. Il resto delle volte, possiamo usare una costante a livello di modulo per ottenre le stesse funzionalit\u00e0 singleton senza dover scrivere una classe relativamente complessa.</p> <p>Ecco un esempio di come codificare una classe Singleton con un metodo new() che pemrmette la creazione di un'unica istanza alla volta. Per farlo, <code>__new__()</code> controlla l'esistenza di un'istanza precedentemente messa in cache di un attributo di classe:</p> <pre><code>&gt;&gt;&gt; class Singleton(object):\n...     _instance = None\n...     def __new__(cls, *args, **kwargs):\n...         if cls._instance is None:\n...             cls._instance = super().__new__(cls)\n...         return cls._instance\n...\n\n&gt;&gt;&gt; first = Singleton()\n&gt;&gt;&gt; second = Singleton()\n&gt;&gt;&gt; first is second\nTrue\n</code></pre> <p>La classe Singleton in questo esempio ha un attributo di classe chiamato <code>_instance</code> di valore di default None che funziona come cache. Il metodo <code>__new__()</code> controlla che non esistano istanze precedenti testando il fatto che <code>cls._instance</code> sia None.</p> <p>Nota</p> <p>Nell'esempio precedente, la classe <code>Singleton</code> non fornisce un'implementazione di <code>__init__()</code>. Se dovessimo aver bisogno di una classe con un metodo <code>__init__()</code>, teniamo a mente che questo metodo sar\u00e0 eseguito ogni volta che chiamiamo il costruttore <code>Singleton()</code>. Questo comportamento pu\u00f2 causare degli strani effetti di inizializzazione e bug.</p> <p>Se questa condizione \u00e8 vera, allora il blocco di codice if crea una nuova istanza di Singleton e la memorizza in <code>cls._instance</code>. Infine, il metodo restituisce la nuova o esistente istanza al chiamante.</p> <p>Quindi istanziamo Singleton due volte per provare a copstruire due diversi gogetti, <code>first</code> e <code>second</code>. Se compariamo l'identit\u00e0 di questi oggetti con l'operatore <code>is</code>, allora noteremo che entrambi gli oggetti sono in realt\u00e0 lo stesso. I nomi <code>first</code> e <code>second</code> sono solo due reference allo stesso oggetto <code>Singleton</code>.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#emulazione-parziale-di-collectionsnamedtuple","title":"Emulazione parziale di collections.namedtuple","text":"<p>Come esempio finale di come sfruttare <code>__new__()</code> nel nostro codice, possiamo spingere le nostre abilit\u00e0 Python e scrivere una funzione factory che emula parzialmente <code>collections.namedtuple()</code>. La funzione <code>namedtuple()</code> ci permette di creare delle sottoclassi di tuple con la feature aggiuntiva di avere campi nominali per accedere agli oggetti nella tupla.</p> <p>Il codice sottostante implementa una funzione <code>named_tuple_factory()</code> che emula parzialmente questa funzionalit\u00e0 sovrascrivendo il metodo <code>__new__()</code> di una classe annidata chiamata <code>NamedTuple</code>:</p> <pre><code># named_tuple.py\n\nfrom operator import itemgetter\n\ndef named_tuple_factory(type_name, *fields):\n    num_fields = len(fields)\n\n    class NamedTuple(tuple):\n        __slots__ = ()\n\n        def __new__(cls, *args):\n            if len(args) != num_fields:\n                raise TypeError(\n                    f\"{type_name} expected exactly {num_fields} arguments,\"\n                    f\" got {len(args)}\"\n                )\n            cls.__name__ = type_name\n            for index, field in enumerate(fields):\n                setattr(cls, field, property(itemgetter(index)))\n            return super().__new__(cls, args)\n\n        def __repr__(self):\n            return f\"\"\"{type_name}({\", \".join(repr(arg) for arg in self)})\"\"\"\n\n    return NamedTuple\n</code></pre> <p>Ecco come funziona questa factory riga per riga:</p> <ul> <li>alla riga 3 importiamo <code>itemgetter()</code> dal modulo <code>operator</code>. Questa funzione ci permette di restituire gli ingressi usando il loro indice nella sequenza che li contiene.</li> <li>alla riga 5 definiamo <code>named_tuple_factory()</code>. Questa funzione prende un primo argomento chiamato <code>type_name</code>, che conterr\u00e0 il nome della sottoclasse delle tuplce che vogliamo creare. L'argomento *fileds ci permette di parssare un numero indefinito di nomi di campi come stringhe.</li> <li>la riga 6 definisce una variabile locale per contenere il numero di named fields forniti dall'utente.</li> <li>la riga 8 definisce una classe annidata chiamata <code>NamedTuple</code>, che discende dalla classe integrata <code>tuple</code>.</li> <li>la riga 9 fornisce un attributo di classe <code>__slots__</code>. Questo attributo definisce una tupla per contenere gli attributi dell'istanza. Questa tupla risparmia memoria agendo come una sostituta per il dizionario dell'istanza, <code>__dict__</code>, che altrimenti giocherebbe un ruolo simile.</li> <li>la riga 11 implementa <code>__new__()</code> con <code>cls</code> come primo argomento. Questa implementazione prende anche l'argomento <code>*args</code> per accettare un numero indefinito di valori per il campo.</li> <li>le righe dalla 12 alla 16 definiscono un'istruzione condizionale che controlla se il numero di oggetti da memorizzare nella tupla finale differisce dal numero di campi con un nome. Se questo \u00e8 il caso, allora la condizione lancia un <code>TypeError</code> con un messaggio di errore.</li> <li>la riga 17 imposta l'attributo <code>__name__</code> della classe attuale al valore fornito da <code>type_name</code>.</li> <li>le righe 18 e 19 definsicon un ciclo for che cambia tutti i campi con un nome in una property che usa itemgetter() per restituire l'oggetto al dato indice. Il ciclo usa la funzione itnegrata <code>setattr()</code> per effettuare questa azione. Notiamo che la funzione integrata <code>enumerate()</code> fornisce il valore appropriato dell'indice.</li> <li>la riga 20 restituisce una nuova istanza della classe attuale chiamando <code>super().__new__()</code>.</li> <li>le righe 22 e 23 definiscono un metodo <code>__repr__()</code> per la nostra classe.</li> <li>la riga 25 restituisce la nuova classe <code>NamedTuple</code>.</li> </ul> <p>Per provare la classe <code>named_tuple_factory()</code>, lanciamo una sessione interattiva nella cartella conenente il file named_tuple.py ed eseguiamo il seguente codice:</p> <pre><code>&gt;&gt;&gt; from named_tuple import named_tuple_factory\n\n&gt;&gt;&gt; Point = named_tuple_factory(\"Point\", \"x\", \"y\")\n\n&gt;&gt;&gt; point = Point(21, 42)\n&gt;&gt;&gt; point\nPoint(21, 42)\n&gt;&gt;&gt; point.x\n21\n&gt;&gt;&gt; point.y\n42\n&gt;&gt;&gt; point[0]\n21\n&gt;&gt;&gt; point[1]\n42\n\n&gt;&gt;&gt; point.x = 84\nTraceback (most recent call last):\n    ...\nAttributeError: can't set attribute\n\n&gt;&gt;&gt; dir(point)\n['__add__', '__class__', ..., 'count', 'index', 'x', 'y']\n</code></pre> <p>In questo snippet, abbiamo creato una nuova classe Point chiamando namedtuplefactory(). Il primo argomento in questa chiamata rappresenta il nome che l'oggetto della classe risultatne user\u00e0. Il secondo e terzo argomento sono i campi cn nome disponibili nella classe risultante.</p> <p>Quindi creiamo un oggetto Point chiamando il costruttore di classe con valori appropriati epr i campi x ed y. Per accedere ai valori di ongi campo con nome, usiamo la dot notation. Possiamo anche usare gli indici per recuperare i valori dato che la nostra classe \u00e8 una sottoclasse di tuple.</p> <p>Dato che le tuple sono dei tipi di dati immutaibili, non possiamo assegnare nuovi valori alle coordinate del punto: se proviamo a farlo, avremo un AttributeError.</p> <p>Infine, la chiamata a dir() con l'istanza del nostro punto come argomento rivela che l'oggetto eredtia tutti gli attributi e metodi che le tuple normali hanno in Python.</p>"},{"location":"material/03_programming_python/31_initializer/lecture/#conclusioni","title":"conclusioni","text":"<p>Ora sappiamo come i costruttori di classe Python ci permettono di istanziare delle classi, per cui possiamo creare degli oggetti concreti e riutilizzabili nel nostro codice. In Python, i costruttori di classe lanciano internamente i processi di costruione, che prevedono la creazione ed inizializzazione dell'istanza. Questi passi sono condotti dai metodi new() ed init().</p>"},{"location":"material/03_programming_python/32_functions_adv/lecture/","title":"34 - Concetti avanzati sulle funzioni Python","text":"<p>Quando abbiamo introdotto i decorators, abbiamo accennato al fatto che Python tratti le funzioni come degli oggetti. Possiamo assegnarle a delle variabili, memorizzarle in strutture dati, passarle come argomenti ad altre funzioni, ed anche restituirle come valori da altre funzioni.</p> <p>Afferrare questi concetti ci permetter\u00e0 di comprendere feature avanzate in Python come le lambda ed i decorator in modo molto pi\u00f9 semplice, oltre che aiutarci a capire le tecniche di programmazione funzionale.</p> <p>In questa lezione vedremo alcuni esempi che ci aiuteranno a sviluppare questa conoscenza. Tuttavia, la comprensione di questi concetti potrebbe risultare leggermente pi\u00f9 complessa di qunato potreste attendervi. Non preoccupatevi.</p> <p>Attraverso questo tutorial, utilizzeremo una funzione chiamata <code>grida</code> a scopi dimostrativi, che sar\u00e0 caratterizzata da un output tutto in maiuscolo del tipo:</p> <pre><code>def yell(text):\n    return text.upper() + '!'\n\n&gt;&gt;&gt; yell('hello')\n'HELLO!'\n</code></pre>"},{"location":"material/03_programming_python/32_functions_adv/lecture/#le-funzioni-sono-oggetti","title":"Le funzioni sono oggetti","text":"<p>Tutti i dati in un programma Python sono rappresentati da oggetti o relazioni tra oggetti. Cose come stringhe, liste, moduli e funzioni sono oggetti. Non vi \u00e8 nulla di particolarmente speciale nelle funzioni Python.</p> <p>Dato che la funzione urla \u00e8 un oggetto in Python, possiamo assegnarla ad un'altra variabile, proprio come ogni altro oggetto:</p> <pre><code>&gt;&gt;&gt; abbaia = urla\n</code></pre> <p>Questa riga non chiama la funzione. Prende l'oggetto funzione riferito ad urla e crea un secondo nome che vi punta, <code>abbaia</code>. Possiamo adesso anche eseguire la stessa funzione chiamando abbaia:</p> <pre><code>&gt;&gt;&gt; abbaia('bau')\n'BAU!'\n</code></pre> <p>Gli oggetti funzione ed i loro nomi sono due cose separate. Possiamo cancellare il nomer della funzione originale, ovvero <code>urla</code>; dato che un altro nome (<code>abbaia</code>) punta ancora alla funzione sottostante, possiamo sempre chiamarla:</p> <pre><code>&gt;&gt;&gt; del yell\n\n&gt;&gt;&gt; yell('hello?')\nNameError: \"name 'yell' is not defined\"\n\n&gt;&gt;&gt; bark('hey')\n'HEY!'\n</code></pre> <p>D'altronde, Python collega un identificatore sotto forma di stringa ad ogni funzione nel momento in cui viene creata a socpo di debugging. POssiamo accedere a questo identificatore interno con l'attributo <code>__name__</code>:</p> <pre><code>&gt;&gt;&gt; bark.__name__\n'yell'\n</code></pre> <p>Il fatto che il <code>__name__</code> della funzione sia sempre <code>urla</code> non andr\u00e0 ad impattare sul come possiamo accedervi dal nostro codice. Questo identificaotre \u00e8 semplicemente un aiuto per il debugging. Una variabile che punta ad una funzione e la funzione stessa sono concetti separati.</p> <p>Nota</p> <p>A partire da Python 3.3, vi \u00e8 anche <code>__qualname__</code>, che asserve ad uno scopo simile e fornisce una stringa per disambiguare i nomi di funzioni e classi.</p>"},{"location":"material/03_programming_python/32_functions_adv/lecture/#le-funzioni-possono-essere-memorizzate-ins-trutture-dati","title":"Le funzioni possono essere memorizzate ins trutture dati","text":"<p>Dato che le funzioni sono degli oggetti, possiamo memorizzarle in strutture dati, proprio come possiamo fare con altri oggeti. Ad esempio, possiamo aggiungere le funzioni ad una lista:</p> <pre><code>&gt;&gt;&gt; funcs = [bark, str.lower, str.capitalize]\n&gt;&gt;&gt; funcs\n[&lt;function yell at 0x10ff96510&gt;,\n &lt;method 'lower' of 'str' objects&gt;,\n &lt;method 'capitalize' of 'str' objects&gt;]\n</code></pre> <p>Accedere agli oggetti funzione memorizzati all'interno della lista funziona come funzionerebbe in ogni altro tipo di oggetto:</p> <pre><code>&gt;&gt;&gt; for f in funcs:\n...     print(f, f('hey there'))\n&lt;function yell at 0x10ff96510&gt; 'HEY THERE!'\n&lt;method 'lower' of 'str' objects&gt; 'hey there'\n&lt;method 'capitalize' of 'str' objects&gt; 'Hey there'\n</code></pre> <p>Possiamo anche chiamare un oggetto fuznine memorizzato nella lista senza assegnarli prima una variabile. Possiamo fare il lookup ed immediatamente chiamare la funzione in una singola espressione:</p> <pre><code>&gt;&gt;&gt; funcs[0]('heyho')\n'HEYHO!'\n</code></pre>"},{"location":"material/03_programming_python/32_functions_adv/lecture/#le-funzioni-possono-essere-passate-ad-altre-funzioni","title":"Le funzioni possono essere passate ad altre funzioni","text":"<p>Dato che le funzioni sono oggetti possiamo passarle come argomenti ad altre funzioni. Ad esempio, una funzione greet che formatta una stirnga di benvenuto usando l'oggetto funzione passatogli e quindi stampandolo:</p> <pre><code>def greet(func):\n    greeting = func('Hi, I am a Python program')\n    print(greeting)\n</code></pre> <p>Possiamo influenzare il benvenuto risultante passandolo in diverse funzioni. Ecco cosa acccade sed passiamo la funzione yell a greet:</p> <pre><code>&gt;&gt;&gt; greet(yell)\n'HI, I AM A PYTHON PROGRAM!'\n</code></pre> <p>OVviamente possioamo anche definire una nuova funzione per generare un diverso tipo di benvenutto. Ad esempio, la seocnda funzione \"sussurra\" lavorer\u00e0 meglio se vogliamo un programma Pythondiscreto:</p> <pre><code>def whisper(text):\n    return text.lower() + '...'\n\n&gt;&gt;&gt; greet(whisper)\n'hi, i am a python program...'\n</code></pre> <p>La capacit\u00e0 di passare oggetti funzione come argomenti ad altre funzioni \u00e8 potenbte. Ci perm,ette di astrarci e passare il comportamento dei nostri programmi. In questo esempio, la funzione greet rimane la stessa ma possiamo influenzare l'output passando diversi comportmaenti di benvenuto.</p> <p>Le funzioni che possono accettare altre funzioni come argomenti sono anche chiamate funzioni di ordine superiore. Sonmo una necessit\u00e0 per lo stile di programmazione funzionale.</p> <p>IOl classico esempio di funzioni di ordine superiore in Python \u00e8 la funzione integrata <code>map</code>. Prende una funzione ed un iteratore, e chiama la funzione su ogni elemento dell'iteratore, restituiendo il risultato man mano che questo scorre.</p> <p>Ecco come potremmo formattare una sequenza di benvenuto in una volta mappando la funzione yell:</p> <pre><code>&gt;&gt;&gt; list(map(yell, ['hello', 'hey', 'hi']))\n['HELLO!', 'HEY!', 'HI!']\n</code></pre> <p>La funzione <code>map</code> ha attraversato l'intera lista applicando la funzione <code>yell</code> ad ogni elemnto.</p>"},{"location":"material/03_programming_python/32_functions_adv/lecture/#le-funzioni-possono-essere-annidate","title":"LE funzioni possono essere annidate","text":"<p>Python permette alle funzioni di essere definite all'interno di altre funzioni. Queste sono spesso chiuamate funzioni annidate o inner function. Ecco un esempio:</p> <pre><code>def speak(text):\n    def whisper(t):\n        return t.lower() + '...'\n    return whisper(text)\n\n&gt;&gt;&gt; speak('Hello, World')\n'hello, world...'\n</code></pre> <p>Cosa sta succedendo? Ogni volta che chiamiamo <code>speak</code> definisce una nuova funzione itnerna <code>whisper</code> e la chiama. La funzione <code>whisper</code> non esiste all'estenro di <code>speak</code>:</p> <pre><code>&gt;&gt;&gt; whisper('Yo')\nNameError: \"name 'whisper' is not defined\"\n\n&gt;&gt;&gt; speak.whisper\nAttributeError: \"'function' object has no attribute 'whisper'\"\n</code></pre> <p>Ma cosa succede se vogliamo accedere a questa funzione annidata dall'esterno? Le funzioni sono oggetti - per cui possiamo restituire la funzione interna al chiuamante della funzione padre. Ad esempio, ecco una funzione che definsice due funzioni annidate. A seconda dell'argomento passato alla funzione top-level, viene selezionato e restituito una delle funzioni itnerne al chiamante:</p> <pre><code>def get_speak_func(volume):\n    def whisper(text):\n        return text.lower() + '...'\n    def yell(text):\n        return text.upper() + '!'\n    if volume &gt; 0.5:\n        return yell\n    else:\n        return whisper\n</code></pre> <p>Notiamo come <code>get_speak_func</code> non chiama uno delle sue funzioni interne - semplicemente seleziona la funzione appropriata sulla base dell'argomento <code>volume</code> e restituisce l'oggetto function:</p> <pre><code>&gt;&gt;&gt; get_speak_func(0.3)\n&lt;function get_speak_func.&lt;locals&gt;.whisper at 0x10ae18&gt;\n\n&gt;&gt;&gt; get_speak_func(0.7)\n&lt;function get_speak_func.&lt;locals&gt;.yell at 0x1008c8&gt;\n</code></pre> <p>Naturalmente psosiamo chiamare la funzionem restituita, sia direttamente o assegnandola ad un nome di una variabile:</p> <pre><code>&gt;&gt;&gt; speak_func = get_speak_func(0.7)\n&gt;&gt;&gt; speak_func('Hello')\n'HELLO!'\n</code></pre> <p>Questo singifca che non solo le funzioni accettano i comportamento attraverso gli argomenti, ma che possono anche restituire dei comportamenti.</p>"},{"location":"material/03_programming_python/32_functions_adv/lecture/#le-funzioni-possono-catturare-lo-stato-locale","title":"Le funzioni possono catturare lo stato locale","text":"<p>Abbiamo appena visto come le funzioni possono contenere delle funzioni annidate ed \u00e8 possibile restiruire quest'ultime dalla funzione padre.</p> <p>Non solo le funzioni possono restiure altre funzioni, queste funzioni annidate possono anche catturare e portare parte dello stato della funzione padre con loro.</p> <p>Riscriviamo leggermente l'esempio <code>get_speak_func</code> precedente. La nuova versione prende un argomento <code>volume</code>e <code>text</code> per rendere la funzione resittuira immediatamente chiamabile:</p> <pre><code>def get_speak_func(text, volume):\n    def whisper():\n        return text.lower() + '...'\n    def yell():\n        return text.upper() + '!'\n    if volume &gt; 0.5:\n        return yell\n    else:\n        return whisper\n\n&gt;&gt;&gt; get_speak_func('Hello, World', 0.7)()\n'HELLO, WORLD!'\n</code></pre> <p>Vediamo per bene le funzioni annidate <code>whisper</code>e <code>yell</code>. Notiamo che non hanno pi\u00f9 un parametro <code>text</code>, ma accedono al parametro definito nella funzione padre. Infatti, sembrano poter cattruare e ricordare il valore di questll'argomento. Le funzioni che fanno questo sono chiamate closure lessicali, o closure. Una closure ricorda i valori dell'ambito lessicale nel quale \u00e8 inserita anche quando il flusso di programma non \u00e8 pi\u00f9 in quell'ambito. In termini pratici, questo signifca non solo che le funzioni restituiscono dei comportamenti, ma possono anche pre-configurarli. Ecco un altro esempio per illustrare questa idea:</p> <pre><code>def make_adder(n):\n    def add(x):\n        return x + n\n    return add\n\n&gt;&gt;&gt; plus_3 = make_adder(3)\n&gt;&gt;&gt; plus_5 = make_adder(5)\n\n&gt;&gt;&gt; plus_3(4)\n7\n&gt;&gt;&gt; plus_5(4)\n9\n</code></pre> <p>In questo esempio <code>make_adder</code> serve come una factory epr creare e configurare delle funzioni <code>somma</code>. Notiamo come le funzion <code>somma</code> possanoo ssempre accedere all'argomento <code>n</code> della funzione <code>make_adder</code> (che \u00e8 nell'ambito che le racchidue).</p>"},{"location":"material/03_programming_python/32_functions_adv/lecture/#gli-oggetti-si-possono-comportare-come-funzioni","title":"Gli oggetti si possono comportare come funzioni","text":"<p>Gli oggetti non sono necessariamente funzioni. Ma possono essere resi chiamabili, il che ci permette di trattarli come funzioni in molti casi.</p> <p>SE un oggetto \u00e8 chiamabile, significa che possiamo suare parentesi tonde e passargli degli argomenti di chiamata a funzione. Ad esempio:</p> <pre><code>class Adder:\n    def __init__(self, n):\n         self.n = n\n    def __call__(self, x):\n        return self.n + x\n\n&gt;&gt;&gt; plus_3 = Adder(3)\n&gt;&gt;&gt; plus_3(4)\n7\n</code></pre> <p>Dietro il cofano, chjiamare un'istanza di un oggetto come una fuinzione prova ad eseguire il metodo <code>__call__</code> dell'0oggetto. Ovviament4e, non tutti gli oggetti saranno chiamabili. Ecco perch\u00e9 vi \u00e8 una funzione built-in <code>callable</code> che controlla se un oggetto \u00e8 callable o no:</p> <pre><code>&gt;&gt;&gt; callable(plus_3)\nTrue\n&gt;&gt;&gt; callable(yell)\nTrue\n&gt;&gt;&gt; callable(False)\nFalse\n</code></pre>"},{"location":"material/03_programming_python/32_functions_adv/lecture/#note-finali","title":"Note finali","text":"<p>Tutto in Python \u00e8 un oggetto, incluse le funzioni. Possiamo assegnarle a variabili, memorizzarle in strutture dati, e passarle o restituirle da e verso altre funzioni. Questo ci permette di astrarre il comportamento nei nostri programmi.</p> <p>Le funzioni possono essere annidate, e possono catturare e portare parte dello stato delle funzioni padre con loro. Le funzioni che fanno questo sono chiamate clousres.</p> <p>Gli oggetti possono essere resi chiamabili, il che ci permette di trattarli spesso come funzioni.</p>"},{"location":"material/03_programming_python/33_decorators/lecture/","title":"Lecture","text":"<p>In questo tutorail sui decorator, vediamo cosa sono e come crearli ed usarli. I ecorator forniscono una semplice sintassi per chiamare le cosiddette funzioni di ordine superiore.</p> <p>Per definizione, un decorator \u00e8 una funzione che prende un'altra funzione e ne estende il comportamento senza modificarla esplcitgiamente.</p> <p>Questo pu\u00f2 sembrare confusionario, ma non lo \u00e8, specialmente dopo che abbiamo visto alcuni esempi di come funzionano i decoratro.</p>"},{"location":"material/03_programming_python/33_decorators/lecture/#un-semplice-decorator","title":"Un semplice decorator","text":"<p>Abbiamo vistro come le funzioni sono proprio come ogni altro oggetto in Python. Siamo quindi pronti a vedere la \"bestia mitologica\" rappresentata dai decorator Python. Iniziamo con un esempio:</p> <pre><code>def my_decorator(func):\n    def wrapper():\n        print(\"Something is happening before the function is called.\")\n        func()\n        print(\"Something is happening after the function is called.\")\n    return wrapper\n\ndef say_whee():\n    print(\"Whee!\")\n\nsay_whee = my_decorator(say_whee)\n</code></pre> <p>Cosa accade quando chiamiamo <code>say_whee()</code>?</p> <pre><code>&gt;&gt;&gt; say_whee()\nSomething is happening before the function is called.\nWhee!\nSomething is happening after the function is called.\n</code></pre> <p>Per comprender quello che sta succedendo,. vediamo l'esempio precedfente. </p> <p>L'operazione di decorazione avviene alla seguente riga:</p> <pre><code>say_whee = my_decorator(say_whee)\n</code></pre> <p>Nei fatti, il nome <code>say_whee</code> ora punta alla inner function <code>wrapper()</code>. Ricordiamo che restrituiamo <code>wrapper</code> come una funzione quando chiamiamo <code>my_decorator(say_whee)</code>:</p> <pre><code>&gt;&gt;&gt; say_whee\n&lt;function my_decorator.&lt;locals&gt;.wrapper at 0x7f3c5dfd42f0&gt;\n</code></pre> <p>Tuttavia, <code>wrapper()</code> ha un riferimento alla funzione originaria <code>say_whee()</code>, e la chiama tra le due chiamate a <code>print()</code>. Messa in modo semplice, i decorator avvolgono una funzione, modificandone il comportamento.</p> <p>Prima di andare avnati, vediamo un secondo esempio. Dato che <code>wrapper()</code> \u00e8 una normale funzione Python, il modo in cui un decorator modifica una funzione pu\u00f2 cambiare in maneira dinamica. Di conseguenza, per non disturbare i nsotri vicini, il seguente esempio eseguir\u00e0\u00f2 soltanto il codice decorato durante il giorno:</p> <pre><code>from datetime import datetime\n\ndef not_during_the_night(func):\n    def wrapper():\n        if 7 &lt;= datetime.now().hour &lt; 22:\n            func()\n        else:\n            pass  # Hush, the neighbors are asleep\n    return wrapper\n\ndef say_whee():\n    print(\"Whee!\")\n\nsay_whee = not_during_the_night(say_whee)\n</code></pre> <p>Se proviamo a chiamare <code>say_whee()</code> dopo le 22, non accadr\u00e0 nulla:</p> <pre><code>&gt;&gt;&gt; say_whee()\n&gt;&gt;&gt;\nSyntactic Sugar!\n</code></pre> <p>Il modo in cui abbiamo decorato <code>say_whee()</code> \u00e8 un p\u00f2 CLUNKY. Prima di tutto, finiamo per scrivere il nome <code>say_whee</code> tre volte. Inoltre, l'operazione di decorazione \u00e8 un po' nascosata sotto la definizione della funzione.</p> <p>Invece, Python ci permette di usare i decorator in maniera pi\u00f9 semplice con il simbolo <code>@</code>, alle volte chiamata pie syntax. Il seguente esempio fa la stessa identica cosa del primo esempio di decorator:</p> <pre><code>def my_decorator(func):\n    def wrapper():\n        print(\"Something is happening before the function is called.\")\n        func()\n        print(\"Something is happening after the function is called.\")\n    return wrapper\n\n@my_decorator\ndef say_whee():\n    print(\"Whee!\")\n</code></pre> <p>Quindi, <code>@my_decorator</code> \u00e8 semplicemente un modo pi\u00f9s emplcie di dire <code>say_whee = my_decorator(say_whee)</code>. Dipende da come si vuole applicare un decorator ad una funzione.</p>"},{"location":"material/03_programming_python/33_decorators/lecture/#riutilizzare-i-decorator","title":"Riutilizzare i decorator","text":"<p>Ricordiamo che un decorator \u00e8 semplicemente una funzione Python. Tutti gli strumenti usuali che vengono usati per la riusabilit\u00e0 sono quindi disponibili. Spostiamo il decorator nel suo modulo in modo che possa essere usato come le altre funzioni.</p> <p>Creiamo un file chiamato <code>decorators.py</code> con i seguenti contenuti:</p> <pre><code>def do_twice(func):\n    def wrapper_do_twice():\n        func()\n        func()\n    return wrapper_do_twice\n</code></pre> <p>Nota</p> <p>Possiamo chiamare la nostra inner functionc ome vogliamo, ed un nome generico come <code>wrapper()</code> va normalmente bene. Vedremo molti decorator nel seguito. Per tenerli differenziati, chiameremo la inner function con lo stesso noem del decorator ma con un prefisso wrapper_.</p> <p>Possiamo ora usare questo nuovo decorator in altri file mediante un semplice import:</p> <pre><code>from decorators import do_twice\n\n@do_twice\ndef say_whee():\n    print(\"Whee!\")\n</code></pre> <p>Quando eseguiamo questo esempio, dovremmo vedere che l'orginale <code>say_whee()</code> viene eseguito due votle:</p> <pre><code>&gt;&gt;&gt; say_whee()\nWhee!\nWhee!\n</code></pre>"},{"location":"material/03_programming_python/33_decorators/lecture/#decorare-le-funzioni-con-degli-argomenti","title":"Decorare le funzioni con degli argomenti","text":"<p>Diciamo che abbiamo una funzione che accetta degli argomenti. Possiamo sempre decorarla? Proviamo:</p> <pre><code>from decorators import do_twice\n\n@do_twice\ndef greet(name):\n    print(f\"Hello {name}\")\n</code></pre> <p>Sfortunatamente, eseguire questo codice lancia un errroe:</p> <pre><code>&gt;&gt;&gt; greet(\"World\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: wrapper_do_twice() takes 0 positional arguments but 1 was given\n</code></pre> <p>Il problema sta nel fatto che la inner function <code>wrapper_do_twice()</code> non prende alcun argomento, ma <code>name=\"World\"</code> \u00e8 stato passato alla stessa. Possiamo risolvere questo problema facendo in modo che <code>wrapper_do_twice()</code> accetti un argomento, ma quindi non funzionerebbe per la funzione <code>say_whee()</code> creata in precedenza.</p> <p>La soluzione \u00e8 quella di usare <code>*args</code> e <code>**kwargs</code> nella funzione wrapper interna. Quindi questa accetter\u00e0 un numero arbitrario di argomenti posizionali e keyword:</p> <pre><code>def do_twice(func):\n    def wrapper_do_twice(*args, **kwargs):\n        func(*args, **kwargs)\n        func(*args, **kwargs)\n    return wrapper_do_twice\n</code></pre> <p>La inner function <code>wrapper_do_twice()</code> adesso accetta un numero qualsiasi di argometni e li passa alla funzione decorata. Adesso sia say_whee() che greet() funzionano:</p> <pre><code>&gt;&gt;&gt; say_whee()\nWhee!\nWhee!\n\n&gt;&gt;&gt; greet(\"World\")\nHello World\nHello World\n</code></pre> <p>TODO: DA QUI</p> <p>Returning Values From Decorated Functions What happens to the return value of decorated functions? Well, that\u2019s up to the decorator to decide. Let\u2019s say you decorate a simple function as follows:</p> <p>from decorators import do_twice</p> <p>@dotwice def returngreeting(name):     print(\"Creating greeting\")     return f\"Hi {name}\" Try to use it:</p> <p>hiadam = returngreeting(\"Adam\") Creating greeting Creating greeting print(hi_adam) None Oops, your decorator ate the return value from the function.</p> <p>Because the dotwicewrapper() doesn\u2019t explicitly return a value, the call return_greeting(\"Adam\") ended up returning None.</p> <p>To fix this, you need to make sure the wrapper function returns the return value of the decorated function. Change your decorators.py file:</p> <p>def dotwice(func):     def wrapperdotwice(*args, **kwargs):         func(*args, **kwargs)         return func(*args, **kwargs)     return wrapperdo_twice The return value from the last execution of the function is returned:</p> <p>return_greeting(\"Adam\") Creating greeting Creating greeting 'Hi Adam' Who Are You, Really? A great convenience when working with Python, especially in the interactive shell, is its powerful introspection ability. Introspection is the ability of an object to know about its own attributes at runtime. For instance, a function knows its own name and documentation:</p> <p>print <p>print.name 'print'</p> <p>help(print) Help on built-in function print in module builtins:</p> <p>print(...)  The introspection works for functions you define yourself as well: <p>say_whee .wrapper_do_twice at 0x7f43700e52f0&gt; <p>saywhee.name 'wrapperdo_twice'</p> <p>help(saywhee) Help on function wrapperdo_twice in module decorators:</p> <p>wrapperdotwice() However, after being decorated, saywhee() has gotten very confused about its identity. It now reports being the wrapperdotwice() inner function inside the dotwice() decorator. Although technically true, this is not very useful information.</p> <p>To fix this, decorators should use the @functools.wraps decorator, which will preserve information about the original function. Update decorators.py again:</p> <p>import functools</p> <p>def dotwice(func):     @functools.wraps(func)     def wrapperdotwice(*args, **kwargs):         func(*args, **kwargs)         return func(*args, **kwargs)     return wrapperdotwice You do not need to change anything about the decorated saywhee() function:</p> <p>say_whee <p>saywhee.name 'saywhee'</p> <p>help(saywhee) Help on function saywhee in module whee:</p> <p>saywhee() Much better! Now saywhee() is still itself after decoration.</p> <p>Technical Detail: The @functools.wraps decorator uses the function functools.updatewrapper() to update special attributes like _name__ and doc that are used in the introspection.</p> <p>Remove ads A Few Real World Examples Let\u2019s look at a few more useful examples of decorators. You\u2019ll notice that they\u2019ll mainly follow the same pattern that you\u2019ve learned so far:</p> <p>import functools</p> <p>def decorator(func):     @functools.wraps(func)     def wrapperdecorator(*args, **kwargs):         # Do something before         value = func(*args, **kwargs)         # Do something after         return value     return wrapperdecorator This formula is a good boilerplate template for building more complex decorators.</p> <p>Note: In later examples, we will assume that these decorators are saved in your decorators.py file as well. Recall that you can download all the examples in this tutorial.</p> <p>Timing Functions Let\u2019s start by creating a @timer decorator. It will measure the time a function takes to execute and print the duration to the console. Here\u2019s the code:</p> <p>import functools import time</p> <p>def timer(func):     \"\"\"Print the runtime of the decorated function\"\"\"     @functools.wraps(func)     def wrappertimer(*args, **kwargs):         starttime = time.perfcounter()    # 1         value = func(*args, **kwargs)         endtime = time.perfcounter()      # 2         runtime = endtime - starttime    # 3         print(f\"Finished {func.name!r} in {runtime:.4f} secs\")         return value     return wrappertimer</p> <p>@timer def wastesometime(numtimes):     for _ in range(numtimes):         sum([i**2 for i in range(10000)]) This decorator works by storing the time just before the function starts running (at the line marked # 1) and just after the function finishes (at # 2). The time the function takes is then the difference between the two (at # 3). We use the time.perf_counter() function, which does a good job of measuring time intervals. Here are some examples of timings:</p> <p>wastesometime(1) Finished 'wastesometime' in 0.0010 secs</p> <p>wastesometime(999) Finished 'wastesometime' in 0.3260 secs Run it yourself. Work through the code line by line. Make sure you understand how it works. Don\u2019t worry if you don\u2019t get it, though. Decorators are advanced beings. Try to sleep on it or make a drawing of the program flow.</p> <p>Note: The @timer decorator is great if you just want to get an idea about the runtime of your functions. If you want to do more precise measurements of code, you should instead consider the timeit module in the standard library. It temporarily disables garbage collection and runs multiple trials to strip out noise from quick function calls.</p> <p>Debugging Code The following @debug decorator will print the arguments a function is called with as well as its return value every time the function is called:</p> <p>import functools</p> <p>def debug(func):     \"\"\"Print the function signature and return value\"\"\"     @functools.wraps(func)     def wrapperdebug(*args, **kwargs):         argsrepr = [repr(a) for a in args]                      # 1         kwargsrepr = [f\"{k}={v!r}\" for k, v in kwargs.items()]  # 2         signature = \", \".join(argsrepr + kwargsrepr)           # 3         print(f\"Calling {func.name}({signature})\")         value = func(*args, **kwargs)         print(f\"{func.name!r} returned {value!r}\")           # 4         return value     return wrapperdebug The signature is created by joining the string representations of all the arguments. The numbers in the following list correspond to the numbered comments in the code:</p> <p>Create a list of the positional arguments. Use repr() to get a nice string representing each argument. Create a list of the keyword arguments. The f-string formats each argument as key=value where the !r specifier means that repr() is used to represent the value. The lists of positional and keyword arguments is joined together to one signature string with each argument separated by a comma. The return value is printed after the function is executed. Let\u2019s see how the decorator works in practice by applying it to a simple function with one position and one keyword argument:</p> <p>@debug def makegreeting(name, age=None):     if age is None:         return f\"Howdy {name}!\"     else:         return f\"Whoa {name}! {age} already, you are growing up!\" Note how the @debug decorator prints the signature and return value of the makegreeting() function:</p> <p>makegreeting(\"Benjamin\") Calling makegreeting('Benjamin') 'make_greeting' returned 'Howdy Benjamin!' 'Howdy Benjamin!'</p> <p>makegreeting(\"Richard\", age=112) Calling makegreeting('Richard', age=112) 'make_greeting' returned 'Whoa Richard! 112 already, you are growing up!' 'Whoa Richard! 112 already, you are growing up!'</p> <p>makegreeting(name=\"Dorrisile\", age=116) Calling makegreeting(name='Dorrisile', age=116) 'make_greeting' returned 'Whoa Dorrisile! 116 already, you are growing up!' 'Whoa Dorrisile! 116 already, you are growing up!' This example might not seem immediately useful since the @debug decorator just repeats what you just wrote. It\u2019s more powerful when applied to small convenience functions that you don\u2019t call directly yourself.</p> <p>The following example calculates an approximation to the mathematical constant e:</p> <p>import math from decorators import debug</p>"},{"location":"material/03_programming_python/33_decorators/lecture/#apply-a-decorator-to-a-standard-library-function","title":"Apply a decorator to a standard library function","text":"<p>math.factorial = debug(math.factorial)</p> <p>def approximate_e(terms=18):     return sum(1 / math.factorial(n) for n in range(terms)) This example also shows how you can apply a decorator to a function that has already been defined. The approximation of e is based on the following series expansion:</p> <p>Series for calculating mathematical constant e When calling the approximate_e() function, you can see the @debug decorator at work:</p> <p>approximate_e(5) Calling factorial(0) 'factorial' returned 1 Calling factorial(1) 'factorial' returned 1 Calling factorial(2) 'factorial' returned 2 Calling factorial(3) 'factorial' returned 6 Calling factorial(4) 'factorial' returned 24 2.708333333333333 In this example, you get a decent approximation to the true value e = 2.718281828, adding only 5 terms.</p> <p>Remove ads Slowing Down Code This next example might not seem very useful. Why would you want to slow down your Python code? Probably the most common use case is that you want to rate-limit a function that continuously checks whether a resource\u2014like a web page\u2014has changed. The @slow_down decorator will sleep one second before it calls the decorated function:</p> <p>import functools import time</p> <p>def slowdown(func):     \"\"\"Sleep 1 second before calling the function\"\"\"     @functools.wraps(func)     def wrapperslowdown(*args, **kwargs):         time.sleep(1)         return func(*args, **kwargs)     return wrapperslow_down</p> <p>@slowdown def countdown(fromnumber):     if fromnumber &lt; 1:         print(\"Liftoff!\")     else:         print(fromnumber)         countdown(fromnumber - 1) To see the effect of the @slowdown decorator, you really need to run the example yourself:</p> <p>countdown(3) 3 2 1 Liftoff! Note: The countdown() function is a recursive function. In other words, it\u2019s a function calling itself. To learn more about recursive functions in Python, see our guide on Thinking Recursively in Python.</p> <p>The @slow_down decorator always sleeps for one second. Later, you\u2019ll see how to control the rate by passing an argument to the decorator.</p> <p>Registering Plugins Decorators don\u2019t have to wrap the function they\u2019re decorating. They can also simply register that a function exists and return it unwrapped. This can be used, for instance, to create a light-weight plug-in architecture:</p> <p>import random PLUGINS = dict()</p> <p>def register(func):     \"\"\"Register a function as a plug-in\"\"\"     PLUGINS[func.name] = func     return func</p> <p>@register def say_hello(name):     return f\"Hello {name}\"</p> <p>@register def be_awesome(name):     return f\"Yo {name}, together we are the awesomest!\"</p> <p>def randomlygreet(name):     greeter, greeterfunc = random.choice(list(PLUGINS.items()))     print(f\"Using {greeter!r}\")     return greeter_func(name) The @register decorator simply stores a reference to the decorated function in the global PLUGINS dict. Note that you do not have to write an inner function or use @functools.wraps in this example because you are returning the original function unmodified.</p> <p>The randomly_greet() function randomly chooses one of the registered functions to use. Note that the PLUGINS dictionary already contains references to each function object that is registered as a plugin:</p> <p>PLUGINS {'sayhello': ,  'beawesome': } <p>randomlygreet(\"Alice\") Using 'sayhello' 'Hello Alice' The main benefit of this simple plugin architecture is that you do not need to maintain a list of which plugins exist. That list is created when the plugins register themselves. This makes it trivial to add a new plugin: just define the function and decorate it with @register.</p> <p>If you are familiar with globals() in Python, you might see some similarities to how the plugin architecture works. globals() gives access to all global variables in the current scope, including your plugins:</p> <p>globals() {..., # Lots of variables not shown here.  'sayhello': ,  'beawesome': ,  'randomly_greet': } Using the @register decorator, you can create your own curated list of interesting variables, effectively hand-picking some functions from globals(). <p>Is the User Logged In? The final example before moving on to some fancier decorators is commonly used when working with a web framework. In this example, we are using Flask to set up a /secret web page that should only be visible to users that are logged in or otherwise authenticated:</p> <p>from flask import Flask, g, request, redirect, urlfor import functools app = Flask(name_)</p> <p>def loginrequired(func):     \"\"\"Make sure user is logged in before proceeding\"\"\"     @functools.wraps(func)     def wrapperloginrequired(*args, **kwargs):         if g.user is None:             return redirect(urlfor(\"login\", next=request.url))         return func(*args, **kwargs)     return wrapperloginrequired</p> <p>@app.route(\"/secret\") @login_required def secret():     ... While this gives an idea about how to add authentication to your web framework, you should usually not write these types of decorators yourself. For Flask, you can use the Flask-Login extension instead, which adds more security and functionality.</p> <p>Remove ads Fancy Decorators So far, you\u2019ve seen how to create simple decorators. You already have a pretty good understanding of what decorators are and how they work. Feel free to take a break from this article to practice everything you\u2019ve learned.</p> <p>In the second part of this tutorial, we\u2019ll explore more advanced features, including how to use the following:</p> <p>Decorators on classes Several decorators on one function Decorators with arguments Decorators that can optionally take arguments Stateful decorators Classes as decorators Decorating Classes There are two different ways you can use decorators on classes. The first one is very close to what you have already done with functions: you can decorate the methods of a class. This was one of the motivations for introducing decorators back in the day.</p> <p>Some commonly used decorators that are even built-ins in Python are @classmethod, @staticmethod, and @property. The @classmethod and @staticmethod decorators are used to define methods inside a class namespace that are not connected to a particular instance of that class. The @property decorator is used to customize getters and setters for class attributes. Expand the box below for an example using these decorators.</p> <p>Let\u2019s define a class where we decorate some of its methods using the @debug and @timer decorators from earlier:</p> <p>from decorators import debug, timer</p> <p>class TimeWaster:     @debug     def init(self, maxnum):         self.maxnum = max_num</p> <pre><code>@timer\ndef waste_time(self, num_times):\n    for _ in range(num_times):\n        sum([i**2 for i in range(self.max_num)])\n</code></pre> <p>Using this class, you can see the effect of the decorators:</p> <p>tw = TimeWaster(1000) Calling init(, 1000) 'init' returned None <p>tw.wastetime(999) Finished 'wastetime' in 0.3376 secs The other way to use decorators on classes is to decorate the whole class. This is, for example, done in the new dataclasses module in Python 3.7:</p> <p>from dataclasses import dataclass</p> <p>@dataclass class PlayingCard:     rank: str     suit: str The meaning of the syntax is similar to the function decorators. In the example above, you could have done the decoration by writing PlayingCard = dataclass(PlayingCard).</p> <p>A common use of class decorators is to be a simpler alternative to some use-cases of metaclasses. In both cases, you are changing the definition of a class dynamically.</p> <p>Writing a class decorator is very similar to writing a function decorator. The only difference is that the decorator will receive a class and not a function as an argument. In fact, all the decorators you saw above will work as class decorators. When you are using them on a class instead of a function, their effect might not be what you want. In the following example, the @timer decorator is applied to a class:</p> <p>from decorators import timer</p> <p>@timer class TimeWaster:     def init(self, maxnum):         self.maxnum = max_num</p> <pre><code>def waste_time(self, num_times):\n    for _ in range(num_times):\n        sum([i**2 for i in range(self.max_num)])\n</code></pre> <p>Decorating a class does not decorate its methods. Recall that @timer is just shorthand for TimeWaster = timer(TimeWaster).</p> <p>Here, @timer only measures the time it takes to instantiate the class:</p> <p>tw = TimeWaster(1000) Finished 'TimeWaster' in 0.0000 secs</p> <p>tw.waste_time(999)</p> <p>Later, you will see an example defining a proper class decorator, namely @singleton, which ensures that there is only one instance of a class.</p> <p>Remove ads Nesting Decorators You can apply several decorators to a function by stacking them on top of each other:</p> <p>from decorators import debug, do_twice</p> <p>@debug @dotwice def greet(name):     print(f\"Hello {name}\") Think about this as the decorators being executed in the order they are listed. In other words, @debug calls @dotwice, which calls greet(), or debug(do_twice(greet())):</p> <p>greet(\"Eva\") Calling greet('Eva') Hello Eva Hello Eva 'greet' returned None Observe the difference if we change the order of @debug and @do_twice:</p> <p>from decorators import debug, do_twice</p> <p>@dotwice @debug def greet(name):     print(f\"Hello {name}\") In this case, @dotwice will be applied to @debug as well:</p> <p>greet(\"Eva\") Calling greet('Eva') Hello Eva 'greet' returned None Calling greet('Eva') Hello Eva 'greet' returned None Decorators With Arguments Sometimes, it\u2019s useful to pass arguments to your decorators. For instance, @dotwice could be extended to a @repeat(numtimes) decorator. The number of times to execute the decorated function could then be given as an argument.</p> <p>This would allow you to do something like this:</p> <p>@repeat(num_times=4) def greet(name):     print(f\"Hello {name}\")</p> <p>greet(\"World\") Hello World Hello World Hello World Hello World Think about how you could achieve this.</p> <p>So far, the name written after the @ has referred to a function object that can be called with another function. To be consistent, you then need repeat(num_times=4) to return a function object that can act as a decorator. Luckily, you already know how to return functions! In general, you want something like the following:</p> <p>def repeat(numtimes):     def decoratorrepeat(func):         ...  # Create and return a wrapper function     return decorator_repeat Typically, the decorator creates and returns an inner wrapper function, so writing the example out in full will give you an inner function within an inner function. While this might sound like the programming equivalent of the Inception movie, we\u2019ll untangle it all in a moment:</p> <p>def repeat(numtimes):     def decoratorrepeat(func):         @functools.wraps(func)         def wrapperrepeat(*args, **kwargs):             for _ in range(numtimes):                 value = func(*args, **kwargs)             return value         return wrapperrepeat     return decoratorrepeat It looks a little messy, but we have only put the same decorator pattern you have seen many times by now inside one additional def that handles the arguments to the decorator. Let\u2019s start with the innermost function:</p> <p>def wrapperrepeat(*args, **kwargs):     for _ in range(numtimes):         value = func(*args, **kwargs)     return value This wrapperrepeat() function takes arbitrary arguments and returns the value of the decorated function, func(). This wrapper function also contains the loop that calls the decorated function numtimes times. This is no different from the earlier wrapper functions you have seen, except that it is using the num_times parameter that must be supplied from the outside.</p> <p>One step out, you\u2019ll find the decorator function:</p> <p>def decoratorrepeat(func):     @functools.wraps(func)     def wrapperrepeat(*args, **kwargs):         ...     return wrapperrepeat Again, decoratorrepeat() looks exactly like the decorator functions you have written earlier, except that it\u2019s named differently. That\u2019s because we reserve the base name\u2014repeat()\u2014for the outermost function, which is the one the user will call.</p> <p>As you have already seen, the outermost function returns a reference to the decorator function:</p> <p>def repeat(numtimes):     def decoratorrepeat(func):         ...     return decorator_repeat There are a few subtle things happening in the repeat() function:</p> <p>Defining decoratorrepeat() as an inner function means that repeat() will refer to a function object\u2014decoratorrepeat. Earlier, we used repeat without parentheses to refer to the function object. The added parentheses are necessary when defining decorators that take arguments. The numtimes argument is seemingly not used in repeat() itself. But by passing numtimes a closure is created where the value of numtimes is stored until it will be used later by wrapperrepeat(). With everything set up, let\u2019s see if the results are as expected:</p> <p>@repeat(num_times=4) def greet(name):     print(f\"Hello {name}\")</p> <p>greet(\"World\") Hello World Hello World Hello World Hello World Just the result we were aiming for.</p> <p>Remove ads Both Please, But Never Mind the Bread With a little bit of care, you can also define decorators that can be used both with and without arguments. Most likely, you don\u2019t need this, but it is nice to have the flexibility.</p> <p>As you saw in the previous section, when a decorator uses arguments, you need to add an extra outer function. The challenge is for your code to figure out if the decorator has been called with or without arguments.</p> <p>Since the function to decorate is only passed in directly if the decorator is called without arguments, the function must be an optional argument. This means that the decorator arguments must all be specified by keyword. You can enforce this with the special * syntax, which means that all following parameters are keyword-only:</p> <p>def name(func=None, *, kw1=val1, kw2=val2, ...):  # 1     def decoratorname(func):         ...  # Create and return a wrapper function.</p> <pre><code>if _func is None:\n    return decorator_name                      # 2\nelse:\n    return decorator_name(_func)               # 3\n</code></pre> <p>Here, the _func argument acts as a marker, noting whether the decorator has been called with arguments or not:</p> <p>If name has been called without arguments, the decorated function will be passed in as _func. If it has been called with arguments, then _func will be None, and some of the keyword arguments may have been changed from their default values. The * in the argument list means that the remaining arguments can\u2019t be called as positional arguments. In this case, the decorator was called with arguments. Return a decorator function that can read and return a function. In this case, the decorator was called without arguments. Apply the decorator to the function immediately. Using this boilerplate on the @repeat decorator in the previous section, you can write the following:</p> <p>def repeat(func=None, *, numtimes=2):     def decoratorrepeat(func):         @functools.wraps(func)         def wrapperrepeat(*args, **kwargs):             for _ in range(numtimes):                 value = func(*args, **kwargs)             return value         return wrapperrepeat</p> <pre><code>if _func is None:\n    return decorator_repeat\nelse:\n    return decorator_repeat(_func)\n</code></pre> <p>Compare this with the original @repeat. The only changes are the added _func parameter and the if-else at the end.</p> <p>Recipe 9.6 of the excellent Python Cookbook shows an alternative solution using functools.partial().</p> <p>These examples show that @repeat can now be used with or without arguments:</p> <p>@repeat def say_whee():     print(\"Whee!\")</p> <p>@repeat(numtimes=3) def greet(name):     print(f\"Hello {name}\") Recall that the default value of numtimes is 2:</p> <p>say_whee() Whee! Whee!</p> <p>greet(\"Penny\") Hello Penny Hello Penny Hello Penny Stateful Decorators Sometimes, it\u2019s useful to have a decorator that can keep track of state. As a simple example, we will create a decorator that counts the number of times a function is called.</p> <p>Note: In the beginning of this guide, we talked about pure functions returning a value based on given arguments. Stateful decorators are quite the opposite, where the return value will depend on the current state, as well as the given arguments.</p> <p>In the next section, you will see how to use classes to keep state. But in simple cases, you can also get away with using function attributes:</p> <p>import functools</p> <p>def countcalls(func):     @functools.wraps(func)     def wrappercountcalls(*args, **kwargs):         wrappercountcalls.numcalls += 1         print(f\"Call {wrappercountcalls.numcalls} of {func.name!r}\")         return func(*args, **kwargs)     wrappercountcalls.numcalls = 0     return wrappercountcalls</p> <p>@countcalls def saywhee():     print(\"Whee!\") The state\u2014the number of calls to the function\u2014is stored in the function attribute .num_calls on the wrapper function. Here is the effect of using it:</p> <p>saywhee() Call 1 of 'saywhee' Whee!</p> <p>saywhee() Call 2 of 'saywhee' Whee!</p> <p>saywhee.numcalls 2</p> <p>Remove ads Classes as Decorators The typical way to maintain state is by using classes. In this section, you\u2019ll see how to rewrite the @count_calls example from the previous section using a class as a decorator.</p> <p>Recall that the decorator syntax @mydecorator is just an easier way of saying func = mydecorator(func). Therefore, if mydecorator is a class, it needs to take func as an argument in its .init_() method. Furthermore, the class instance needs to be callable so that it can stand in for the decorated function.</p> <p>For a class instance to be callable, you implement the special .call() method:</p> <p>class Counter:     def init(self, start=0):         self.count = start</p> <pre><code>def __call__(self):\n    self.count += 1\n    print(f\"Current count is {self.count}\")\n</code></pre> <p>The .call() method is executed each time you try to call an instance of the class:</p> <p>counter = Counter() counter() Current count is 1</p> <p>counter() Current count is 2</p> <p>counter.count 2 Therefore, a typical implementation of a decorator class needs to implement .init() and .call():</p> <p>import functools</p> <p>class CountCalls:     def init(self, func):         functools.updatewrapper(self, func)         self.func = func         self.numcalls = 0</p> <pre><code>def __call__(self, *args, **kwargs):\n    self.num_calls += 1\n    print(f\"Call {self.num_calls} of {self.func.__name__!r}\")\n    return self.func(*args, **kwargs)\n</code></pre> <p>@CountCalls def saywhee():     print(\"Whee!\") The .init() method must store a reference to the function and can do any other necessary initialization. The .call() method will be called instead of the decorated function. It does essentially the same thing as the wrapper() function in our earlier examples. Note that you need to use the functools.updatewrapper() function instead of @functools.wraps.</p> <p>This @CountCalls decorator works the same as the one in the previous section:</p> <p>saywhee() Call 1 of 'saywhee' Whee!</p> <p>saywhee() Call 2 of 'saywhee' Whee!</p> <p>saywhee.numcalls 2 More Real World Examples We\u2019ve come a far way now, having figured out how to create all kinds of decorators. Let\u2019s wrap it up, putting our newfound knowledge into creating a few more examples that might actually be useful in the real world.</p> <p>Slowing Down Code, Revisited As noted earlier, our previous implementation of @slowdown always sleeps for one second. Now you know how to add parameters to decorators, so let\u2019s rewrite @slowdown using an optional rate argument that controls how long it sleeps:</p> <p>import functools import time</p> <p>def slowdown(func=None, *, rate=1):     \"\"\"Sleep given amount of seconds before calling the function\"\"\"     def decoratorslowdown(func):         @functools.wraps(func)         def wrapperslowdown(*args, **kwargs):             time.sleep(rate)             return func(*args, **kwargs)         return wrapperslowdown</p> <pre><code>if _func is None:\n    return decorator_slow_down\nelse:\n    return decorator_slow_down(_func)\n</code></pre> <p>We\u2019re using the boilerplate introduced in the Both Please, But Never Mind the Bread section to make @slow_down callable both with and without arguments. The same recursive countdown() function as earlier now sleeps two seconds between each count:</p> <p>@slowdown(rate=2) def countdown(fromnumber):     if fromnumber &lt; 1:         print(\"Liftoff!\")     else:         print(fromnumber)         countdown(from_number - 1) As before, you must run the example yourself to see the effect of the decorator:</p> <p>countdown(3) 3 2 1 Liftoff! Creating Singletons A singleton is a class with only one instance. There are several singletons in Python that you use frequently, including None, True, and False. It is the fact that None is a singleton that allows you to compare for None using the is keyword, like you saw in the Both Please section:</p> <p>if func is None:     return decoratorname else:     return decoratorname(func) Using is returns True only for objects that are the exact same instance. The following @singleton decorator turns a class into a singleton by storing the first instance of the class as an attribute. Later attempts at creating an instance simply return the stored instance:</p> <p>import functools</p> <p>def singleton(cls):     \"\"\"Make a class a Singleton class (only one instance)\"\"\"     @functools.wraps(cls)     def wrappersingleton(*args, **kwargs):         if not wrappersingleton.instance:             wrappersingleton.instance = cls(*args, **kwargs)         return wrappersingleton.instance     wrappersingleton.instance = None     return wrappersingleton</p> <p>@singleton class TheOne:     pass As you see, this class decorator follows the same template as our function decorators. The only difference is that we are using cls instead of func as the parameter name to indicate that it is meant to be a class decorator.</p> <p>Let\u2019s see if it works:</p> <p>firstone = TheOne() anotherone = TheOne()</p> <p>id(first_one) 140094218762280</p> <p>id(another_one) 140094218762280</p> <p>firstone is anotherone True It seems clear that firstone is indeed the exact same instance as anotherone.</p> <p>Note: Singleton classes are not really used as often in Python as in other languages. The effect of a singleton is usually better implemented as a global variable in a module.</p> <p>Caching Return Values Decorators can provide a nice mechanism for caching and memoization. As an example, let\u2019s look at a recursive definition of the Fibonacci sequence:</p> <p>from decorators import count_calls</p> <p>@count_calls def fibonacci(num):     if num &lt; 2:         return num     return fibonacci(num - 1) + fibonacci(num - 2) While the implementation is simple, its runtime performance is terrible:</p> <p>fibonacci(10)  55 <p>fibonacci.num_calls 177 To calculate the tenth Fibonacci number, you should really only need to calculate the preceding Fibonacci numbers, but this implementation somehow needs a whopping 177 calculations. It gets worse quickly: 21891 calculations are needed for fibonacci(20) and almost 2.7 million calculations for the 30<sup>th</sup> number. This is because the code keeps recalculating Fibonacci numbers that are already known.</p> <p>The usual solution is to implement Fibonacci numbers using a for loop and a lookup table. However, simple caching of the calculations will also do the trick:</p> <p>import functools from decorators import count_calls</p> <p>def cache(func):     \"\"\"Keep a cache of previous function calls\"\"\"     @functools.wraps(func)     def wrappercache(*args, **kwargs):         cachekey = args + tuple(kwargs.items())         if cachekey not in wrappercache.cache:             wrappercache.cache[cachekey] = func(*args, **kwargs)         return wrappercache.cache[cachekey]     wrappercache.cache = dict()     return wrappercache</p> <p>@cache @count_calls def fibonacci(num):     if num &lt; 2:         return num     return fibonacci(num - 1) + fibonacci(num - 2) The cache works as a lookup table, so now fibonacci() only does the necessary calculations once:</p> <p>fibonacci(10) Call 1 of 'fibonacci' ... Call 11 of 'fibonacci' 55</p> <p>fibonacci(8) 21 Note that in the final call to fibonacci(8), no new calculations were needed, since the eighth Fibonacci number had already been calculated for fibonacci(10).</p> <p>In the standard library, a Least Recently Used (LRU) cache is available as @functools.lru_cache.</p> <p>This decorator has more features than the one you saw above. You should use @functools.lru_cache instead of writing your own cache decorator:</p> <p>import functools</p> <p>@functools.lru_cache(maxsize=4) def fibonacci(num):     print(f\"Calculating fibonacci({num})\")     if num &lt; 2:         return num     return fibonacci(num - 1) + fibonacci(num - 2) The maxsize parameter specifies how many recent calls are cached. The default value is 128, but you can specify maxsize=None to cache all function calls. However, be aware that this can cause memory problems if you are caching many large objects.</p> <p>You can use the .cache_info() method to see how the cache performs, and you can tune it if needed. In our example, we used an artificially small maxsize to see the effect of elements being removed from the cache:</p> <p>fibonacci(10) Calculating fibonacci(10) Calculating fibonacci(9) Calculating fibonacci(8) Calculating fibonacci(7) Calculating fibonacci(6) Calculating fibonacci(5) Calculating fibonacci(4) Calculating fibonacci(3) Calculating fibonacci(2) Calculating fibonacci(1) Calculating fibonacci(0) 55</p> <p>fibonacci(8) 21</p> <p>fibonacci(5) Calculating fibonacci(5) Calculating fibonacci(4) Calculating fibonacci(3) Calculating fibonacci(2) Calculating fibonacci(1) Calculating fibonacci(0) 5</p> <p>fibonacci(8) Calculating fibonacci(8) Calculating fibonacci(7) Calculating fibonacci(6) 21</p> <p>fibonacci(5) 5</p> <p>fibonacci.cache_info() CacheInfo(hits=17, misses=20, maxsize=4, currsize=4) Adding Information About Units The following example is somewhat similar to the Registering Plugins example from earlier, in that it does not really change the behavior of the decorated function. Instead, it simply adds unit as a function attribute:</p> <p>def setunit(unit):     \"\"\"Register a unit on a function\"\"\"     def decoratorsetunit(func):         func.unit = unit         return func     return decoratorset_unit The following example calculates the volume of a cylinder based on its radius and height in centimeters:</p> <p>import math</p> <p>@set_unit(\"cm^3\") def volume(radius, height):     return math.pi * radius**2 * height This .unit function attribute can later be accessed when needed:</p> <p>volume(3, 5) 141.3716694115407</p> <p>volume.unit 'cm^3' Note that you could have achieved something similar using function annotations:</p> <p>import math</p> <p>def volume(radius, height) -&gt; \"cm^3\":     return math.pi * radius**2 * height However, since annotations are used for type hints, it would be hard to combine such units as annotations with static type checking.</p> <p>Units become even more powerful and fun when connected with a library that can convert between units. One such library is pint. With pint installed (pip install Pint), you can for instance convert the volume to cubic inches or gallons:</p> <p>import pint ureg = pint.UnitRegistry() vol = volume(3, 5) * ureg(volume.unit)</p> <p>vol <p>vol.to(\"cubic inches\") <p>vol.to(\"gallons\").m  # Magnitude 0.0373464440537444 You could also modify the decorator to return a pint Quantity directly. Such a Quantity is made by multiplying a value with the unit. In pint, units must be looked up in a UnitRegistry. The registry is stored as a function attribute to avoid cluttering the namespace:</p> <p>def useunit(unit):     \"\"\"Have a function return a Quantity with given unit\"\"\"     useunit.ureg = pint.UnitRegistry()     def decoratoruseunit(func):         @functools.wraps(func)         def wrapperuseunit(*args, **kwargs):             value = func(*args, **kwargs)             return value * useunit.ureg(unit)         return wrapperuseunit     return decoratoruse_unit</p> <p>@useunit(\"meters per second\") def averagespeed(distance, duration):     return distance / duration With the @use_unit decorator, converting units is practically effortless:</p> <p>bolt = average_speed(100, 9.58) bolt <p>bolt.to(\"km per hour\") <p>bolt.to(\"mph\").m  # Magnitude 23.350065679064745 Validating JSON Let\u2019s look at one last use case. Take a quick look at the following Flask route handler:</p> <p>@app.route(\"/grade\", methods=[\"POST\"]) def updategrade():     jsondata = request.getjson()     if \"studentid\" not in jsondata:         abort(400)     # Update database     return \"success!\" Here we ensure that the key studentid is part of the request. Although this validation works, it really does not belong in the function itself. Plus, perhaps there are other routes that use the exact same validation. So, let\u2019s keep it DRY and abstract out any unnecessary logic with a decorator. The following @validate_json decorator will do the job:</p> <p>from flask import Flask, request, abort import functools app = Flask(name)</p> <p>def validatejson(*expectedargs):                  # 1     def decoratorvalidatejson(func):         @functools.wraps(func)         def wrappervalidatejson(*args, **kwargs):             jsonobject = request.getjson()             for expectedarg in expectedargs:      # 2                 if expectedarg not in jsonobject:                     abort(400)             return func(*args, **kwargs)         return wrappervalidatejson     return decoratorvalidatejson In the above code, the decorator takes a variable length list as an argument so that we can pass in as many string arguments as necessary, each representing a key used to validate the JSON data:</p> <p>The list of keys that must be present in the JSON is given as arguments to the decorator. The wrapper function validates that each expected key is present in the JSON data. The route handler can then focus on its real job\u2014updating grades\u2014as it can safely assume that JSON data are valid:</p> <p>@app.route(\"/grade\", methods=[\"POST\"]) @validatejson(\"studentid\") def updategrade():     jsondata = request.get_json()     # Update database.     return \"success!\" Conclusion This has been quite a journey! You started this tutorial by looking a little closer at functions, particularly how they can be defined inside other functions and passed around just like any other Python object. Then you learned about decorators and how to write them such that:</p> <p>They can be reused. They can decorate functions with arguments and return values. They can use @functools.wraps to look more like the decorated function. In the second part of the tutorial, you saw more advanced decorators and learned how to:</p> <p>Decorate classes Nest decorators Add arguments to decorators Keep state within decorators Use classes as decorators You saw that, to define a decorator, you typically define a function returning a wrapper function. The wrapper function uses *args and **kwargs to pass on arguments to the decorated function. If you want your decorator to also take arguments, you need to nest the wrapper function inside another function. In this case, you usually end up with three return statements.</p> <p>You can find the code from this tutorial online.</p>"},{"location":"material/03_programming_python/34_properties/lecture/","title":"32 - Le propriet\u00e0","text":"<p>Python offre una caratteristica chiamata proriet\u00e0 o, pi\u00f9 propriamente, <code>property()</code>, con la quale possiamo creare dei cosiddetti attibuti gestiti (managed attributes) per la nostra classe. Questi possono essere utilizzati quando abbiiamo bisogno di modificare la loro implementazione interna senza cambiare l'interfaccia pubblica della classe: in tal senso, avremo un'API stabile, che ci aiuter\u00e0 ad evitare di causare die problemi a chi usa la nostra classe.</p> <p>Le propriet\u00e0 sono probabilmente il modo pi\u00f9 popolare di craer attributi gestiti velocemente e in stile pythoninc.</p> <p>In questo tutorial, vedremo come:</p> <ul> <li>creare property per le nostre classi</li> <li>effettuare la validazione lazy degli attributi e fornire dei computed attributes</li> <li>evitsre l'uso di metodi setter e getter per rendere le nostre classi pi\u00f9 Pythonic</li> <li>creare propreit\u00e0 di sola scrittura, lettura o entrambe</li> <li>creare delle API consistenti e retrocompatibili per le nostre classi</li> </ul> <p>Scriveremo anche alcuni esempi pratici che usano le property() per validare i dati di ingresso, calcolare i valori degli attributi dinamcieamente, efettuare il log del nostro codice, ed altro ancora. Per ottenere quanto pio\u00f9 possibile da questo tutiorial, dobbiamo conoscere le basi della programmazione orientata agli oggetti e dei decorator.</p>"},{"location":"material/03_programming_python/34_properties/lecture/#gestire-gli-attributi-nell-nostre-classi","title":"Gestire gli attributi nell nostre classi","text":"<p>QUando definiamo una classe in un linguaggiod i programmazione orientato agli oggetti, finiremo cone alcun  e istanze ed attributi di classe . In altre parole, avremo delle variabili che sono accessibili soltanto tattraverso l'istanza, la classe, o entrambi, a seconda del linguaggio. Gli attributi rappresentano lo stato interno di un dato oggetto, che spesso dovremo acceeere o mutare.</p> <p>Tipicamente, abbiamo almeno due modi di gestire un attributo. O accediamo e mutiamo l'attributo direttamente, oppure iusamo dei metodi. I metodi sono funzioni collegate ad una data clases. Qeusti forniscono i comportamenti e le azioni che un oggetto pu\u00f2 effettuare con i sudoi dati interni ed attributi.</p> <p>Se espponiamo i nostri attributi all'utente, questi diventaono parte dell'API pubblica della nostra classe. I nostri utenti accedreanno e muteranno questi attributi dirtatamente nel loro codice. Il problema arrtiva quando dobbiamo cambiare la rappresentazione interna di un dato attributo.</p> <p>Diciamo che stiamo lavorando sulla classe Cerchio. L'implementazione iniziale ha un soingolo attribnuto chiamato raggio. Finiamo di codificare la classe e la rendiamo disponibile a chi user\u00e0 il nsotro codice. Questi usano il Cerchio nelc odice per creare numerosi progetti ed applicazioni.</p> <p>Ora supponiamo che abbiamo un utente importante che ci chiede un nuovo requisito. Non vogliono che il Cerchio memorizzi il raggio. Hnano bisogno id un attributo poubblico chiamato diametro. </p> <p>A questo punto, rimuovere il raggio per iniziare ad usare il diatmetro pu\u00f2 romepre il codice di alcuni tra i nostri utenti. Dobbiamo gestire questa situaizone in un modo che non si limiti a rimuovere semplicemente il raggio.</p> <p>I linguaggi di programmazione come Java e C++ ci incoraggiano a non esporre mai i nsotri attributi per evitare questo tipo di pronblemi. Invece, dovrammo fornire dei metodi getter e setter, conosciuti come accessori e mutatori, rispettivamente,. Questi metodi opffrono un modo per modificare l'implementazione itnerna dei nostri attributi senza cambiare la nostra API pubblica.</p> <p>Nota</p> <p>I getter ed i setter sono spesso considerati un anti-pattern, ed un segnale di un dessign carente in termini di OOP. L'argomento principale dietro questa fraes sta nel fatto che qeusti meotdi rompono l'inscapsulamento. CI permettono dia ccedre e mutare le componenti dei nostri oggetti.</p> <p>Alla fine, questi linguaggi hanno bisogno di metodi setter e getter per H\u00e8p non forniscono un modo per cambiare l'implementazione itnerna di un attirbuto se cambia un dato rewquisito. Cambiare l'implementazione itnerna richiederebbe delle modifiche all'API, che poossono rompere il codice dell'utente finale.</p>"},{"location":"material/03_programming_python/34_properties/lecture/#lapproccio-in-python","title":"L'approccio in Python","text":"<p>https://realpython.com/primer-on-python-decorators/</p>"},{"location":"material/05_advanced_python/01_setup/","title":"Setup dell'ambiente Python","text":"<p>Note</p> <p>Questo articolo fa parte della serie di Tutorial intitolata Setup dell'ambiente Python.</p> <p>Fare il setup della propria macchina per permettere l'esecuzione di Python non \u00e8 banale: infatti, quando usato per scopi che vanno al di l\u00e0 del semplice Hello, World!, \u00e8 spesso necessario capire come gestire contestualmente diversi ambienti, molto spesso uno per ogni singolo progetto Python. Inoltre, alcuni ambienti potrebbero essere recentissimi, mentre altri potrebbero fare riferimento a codice scritto cinque o dieci anni fa.</p> <p>Per nostra fortuna, esiste una grande variet\u00e0 di strumenti in grado di semplificarci la vita: in particolare, in questo articolo vedremo quelli che sono gli strumenti disponibili per rendere la gestione delle dipendenze e dell'ambiente di lavoro pi\u00f9 semplici. In particolare, in questo articolo vedremo quali sono gli strumenti disponibili per la gestione delle dipendenze e del nostro ambiente di lavoro, in modo da risolvere tre problemi:</p> <ol> <li>installazione e modifica di versioni differenti di Python sulla stessa macchina;</li> <li>gestione delle dipendenze e degli ambienti virtuali;</li> <li>riproducibilit\u00e0 degli ambienti virtuali.</li> </ol>"},{"location":"material/05_advanced_python/01_setup/#installazione-di-python","title":"Installazione di Python","text":"<p>L'approccio \"classico\", usato dalla maggior parte di noi, \u00e8 quello di installare Python a partire dai file binari ufficiali, o magari usando il package manager del nostro sistema. Tuttavia, questi approcci prevedono che si utilizzi sempre la medesima versione di Python, il che non \u00e8 sempre vero.</p> <p>Un'ovvia soluzione pu\u00f2 essere quella di avere diverse versioni di Python installate sulla propria macchina. Tuttavia, questa procedura non \u00e8 semplice, e pu\u00f2 comportare diverse complicazioni, aggirabili usando un tool come pyenv, strumento che ci permette di mantenere una versione \"di sistema\" di Python, adattando per\u00f2 le altre agli specifici requisiti di ogni progetto.</p> <p>Compatibilit\u00e0 con Windows</p> <p>Come indicato nella documentazione ufficiale, pyenv non \u00e8 ufficialmente supportato da Windows. In tal senso, il suggerimento \u00e8 quello di usare il fork pyenv-win.</p> <p>Una volta installato pyenv seguendo le istruzioni riportate sulla repository ufficiale, potremo usarlo per installare una specifica versione di Python come segue:</p> <pre><code>$ pyenv install 3.8.5\n$ pyenv install 3.10.2\n\n$ pyenv versions\n* system\n3.8.5\n3.10.2\n</code></pre> <p>Potremo anche impostare la versione di sistema di Python usando l'istruzione <code>global</code>:</p> <pre><code>$ pyenv global 3.8.5\n\n$ pyenv versions\nsystem\n* 3.8.5\n3.10.2\n\n$ python -v\nPython 3.10.2\n</code></pre> <p>In modo analogo, possiamo selezionare uno specifico interprete per la cartella nella quale ci troviamo mediante l'istruzione <code>local</code>:</p> <pre><code>$ pyenv local 3.10.2\n\n$ pyenv versions\n  system\n  3.8.5\n* 3.10.2\n\n$ python -V\nPython 3.10.2\n</code></pre>"},{"location":"material/05_advanced_python/01_setup/#gestione-delle-dipendenze","title":"Gestione delle dipendenze","text":"<p>Vediamo adesso alcuni strumenti per la gestione delle dipendenze, cos\u00ec come degli ambienti virtuali.</p> <p>Cosa \u00e8 un ambiente virtuale?</p> <p>Per ambiente virtuale si intende una sorta di \"spazio riservato\" che permette di evitare conflitti tra progetti che usano differenti versioni dello stesso package: in pratica, potremo installare diverse versioni della stessa libreria all'interno di diversi ambienti virtuali.</p>"},{"location":"material/05_advanced_python/01_setup/#venv-e-pip","title":"venv e pip","text":"<p>venv e pip sono due tra gli strumenti pi\u00f9 popolari per la gestione, rispettivamente, degli ambienti virtuali e dei package installati. Risultano molto semplici da usare, e sono gi\u00e0 integrati nella maggior parte delle distribuzioni Python.</p>"},{"location":"material/05_advanced_python/01_setup/#creazione-attivazione-e-disattivazione-di-un-nuovo-ambiente-virtuale","title":"Creazione, attivazione e disattivazione di un nuovo ambiente virtuale","text":"<p>Per creare un nuovo ambiente virtuale, creiamo una nuova cartella, spostiamoci nella stessa, ed usiamo venv:</p> <pre><code>$ mkdir nuova_cartella\n$ cd nuova_cartella\n$ python -m venv nuovo_venv\n</code></pre> <p>In particolare, l'istruzione alla riga <code>3</code> ci permetter\u00e0 di creare un ambiente virtuale chiamato <code>nuovo_venv</code>. Dopo la creazione dello stesso, dovremo attivarlo mediante lo script <code>activate</code>, che viene creato in automatico da venv:</p> <pre><code>$ source nuovo_venv/bin/activate\n(nuovo_venv)$\n</code></pre> <p>Come funziona un ambiente virtuale?</p> <p>Ci si potrebbe chiedere come funzioni, nella pratica, l'ambiente virtuale. In poche parole, la libreria venv crea una copia dell'interprete Python, che andr\u00e0 ad inserire in una cartella sul nostro computer assieme a tutte le dipendenze che vorremo installare. Infatti, se provassimo ad eseguire l'istruzione <code>which python</code> dall'interno dell'ambiente virtuale vedremo il percorso dell'interprete Python interno all'ambiente virtuale.</p> <p>```sh   (nuovo_venv)$ which python</p> <p>/Users/username/folder/...   ```</p> <p>Per disattivare un ambiente virtuale, eseguiamo l'istruzione <code>deactivate</code> dall'interno dell'ambiente.</p> <pre><code>(nuovo_venv)$ deactivate\n</code></pre>"},{"location":"material/05_advanced_python/01_setup/#aggiunta-di-una-nuova-dipendenza-con-pip","title":"Aggiunta di una nuova dipendenza con pip","text":"<p>Possiamo aggiungere nuovi package al nostro progetto mediante l'istruzione <code>install</code> di pip:</p> <pre><code>(nuovo_venv)$ python -m pip install nome_package\n</code></pre> <p>In questo modo, pip si occuper\u00e0 di verificare che il package chiamato <code>nome_package</code> sia reperibile su PyPI, rendendolo contestualmente disponibile all'interprete Python all'interno del nostro ambiente virtuale.</p>"},{"location":"material/05_advanced_python/01_setup/#riproducibilita-dellambiente-virtuale","title":"Riproducibilit\u00e0 dell'ambiente virtuale","text":"<p>Per garantire la riproducibilit\u00e0 dell'ambiente virtuale, da parte sia nostra sia di colleghi, \u00e8 necessario definire la lista di package richiesti per il funzionamento del progetto, tipicamente usando un file chiamato <code>requirements.txt</code>. Questo file pu\u00f2 essere creato manualmente, oppure generato mediante l'istruzione <code>pip freeze</code>:</p> <pre><code>(nuovo_venv)$ python -m pip freeze &gt; requirements.txt\n\n(nuovo_venv)$ cat requirements.txt\n\nbrotlipy==0.7.0\ncertifi==2021.10.8\ncffi @ file:///opt/conda/conda-bld/cffi_1642701102775/work\ncharset-normalizer @ file:///tmp/build/80754af9/charset-normalizer_1630003229654/work\ncolorama @ file:///tmp/build/80754af9/colorama_1607707115595/work\nconda==4.12.0\nconda-content-trust @ file:///tmp/build/80754af9/conda-content-trust_1617045594566/work\nconda-package-handling @ file:///tmp/build/80754af9/conda-package-handling_1649105784853/work\ncryptography @ file:///tmp/build/80754af9/cryptography_1639414572950/work\nidna @ file:///tmp/build/80754af9/idna_1637925883363/work\npycosat==0.6.3\npycparser @ file:///tmp/build/80754af9/pycparser_1636541352034/work\npyOpenSSL @ file:///opt/conda/conda-bld/pyopenssl_1643788558760/work\nPySocks @ file:///tmp/build/80754af9/pysocks_1605305812635/work\nrequests @ file:///opt/conda/conda-bld/requests_1641824580448/work\nruamel-yaml-conda @ file:///tmp/build/80754af9/ruamel_yaml_1616016711199/work\nsix @ file:///tmp/build/80754af9/six_1644875935023/work\ntqdm @ file:///opt/conda/conda-bld/tqdm_1647339053476/work\nurllib3 @ file:///opt/conda/conda-bld/urllib3_1643638302206/work\n</code></pre>"},{"location":"material/05_advanced_python/01_setup/#oltre-venv-e-pip","title":"Oltre venv e pip","text":"<p>Ammettiamolo: venv e pip sono strumenti abbastanza semplici da usare. Tuttavia, esistono altri tool, sicuramente pi\u00f9 moderni, avanzati e flessibili, che permettono di ovviare ad alcuni limiti legati a venv e pip.</p> <p>In primis, venv e pip non hanno informazioni sulla versione di Python con la quale stiamo lavorando: infatti, potremmo stare lavorando con la versione 3.1.0, ed inviare il nostro progetto ad un collega che usa la 3.10.0, generando probabili incompatibilit\u00e0 e conflitti non sempre facili da risolvere.</p> <p>Inoltre, la gestione delle dipendenze e degli ambienti virtuali \u00e8 fatta a mano: dovremo creare e gestire il file <code>requirements.txt</code> in prima persona, e separare manualmente le librerie che useremo durante lo sviluppo da quelle che useremo in produzione.</p> <p>In tal senso, Poetry e Pipenv sono degli strumenti che combinano le funzionalit\u00e0 offerte da venv e pip, rendendo facile separare gli ambienti di sviluppo e produzione, cos\u00ec come permettendo delle build deterministiche mediante dei file di lock che specificano, oltre alle versioni di tutte le dipendenze, anche la versione di Python utilizzata.</p> <p>TODO: DA QUI</p>"},{"location":"material/05_advanced_python/01_setup/#poetry","title":"Poetry","text":"<p>Poetry \u00e8 probabilmente il tool di gestione delle dipendenze pi\u00f9 ricco di feature di Python. Arriva con una CLI potente usata per creare e gestire i progetti Python. Una volta installata, per creare un nuovo progetto eseguiamo:</p> <pre><code>$ poetry new sample-project\n$ cd sample-project\n</code></pre> <p>Eseguire questi comandi creer\u00e0 i seguenti file e cartelle:</p> <pre><code>sample-project\n|--- README.rst\n|--- pyproject.toml\n|--- sample_project\n|    |--- __init__.py\n|--- tests\n     |--- __init__.py\n     |--- test_sample_project.py\n</code></pre> <p>Le dipendenze sono gestite all'interno del file <code>pyproject.toml</code>:</p> <pre><code>TODO\n</code></pre> <p>Tip</p> <p>Per sapere di pi\u00f9 sul file <code>pyproject.tom</code>, il nuovo file di configurazione Python che tratta \"ogni progetto come un package\", diamo uno sguardo a questo articolo.</p> <p>Per aggiungere una nuova dipendenza, eseguiamo:</p> <pre><code>$ poetry add [--dev] &lt;package name&gt;\n</code></pre> <p>Tip</p> <p>Il flag <code>--dev</code> indica che la dipendenza deve essere usata soltanto in modalit\u00e0 di sviluppo. Le dipendenze di sviluppo non sono installate di default.</p> <p>Ad esempio:</p> <pre><code>$ poetry add flask\n</code></pre> <p>Questo comando scarica ed installa Flask da PyPI all'interno dell'ambiente virtuale gestito da Poetry, lo aggiunge assieme a tutte le sue sotto-dipendenze al file poetry.lock, e lo aggiunge automaticamnete (come dipendenza top-level) a pyproject.toml.</p> <pre><code>[tool.poetry.dependencies]\npython = \"^3.10\"\nFlask = \"^2.0.3\"\n</code></pre> <p>Prendiamo nota delle limitazioni alla versione: \"^2.0.3\".</p> <p>Per eseguire un comando all'interno dell'ambiente virtuale, usiamo prima poetry run. Per esempi, per eseguire dei test con pytest:</p> <pre><code>$ poetry run python -m pytest\n</code></pre> <p><code>poetry run &lt;command&gt;</code> eseguir\u00e0 dei comandi all'interno dell'ambiente virutale. Tuttavia, non sar\u00e0 attivato l'ambiente virtuale. Per farlo, dobbiamo eseguire il comando <code>poetry shell</code>. PEr disattivarlo, possiamo semplicemente eseguire il comando <code>exit</code>. Di conseguenza, possiamo attivare il nostro ambiente virutale prima di lavorare al progetto e deattivarlo una volta che abbiamo terminato oppure usare <code>poetry run &lt;command&gt;</code> senza attivare l'ambiente virutale.</p> <p>Poetry funziona anche bene con pyenv. IN tal senso, conviene dare un'occhiata alla specifica sezione sulla documentazione ufficiale.</p>"},{"location":"material/05_advanced_python/01_setup/#pipenv","title":"Pipenv","text":"<p>pipenv prova a risolvere glis tessi problemi di Poetry.</p> <ol> <li>gestire le dipendenze e gli ambienti virtuali</li> <li>riprodurre gli ambienti</li> </ol> <p>Una volta installato, creiamo un nuovo progetto con Pipenv:</p> <pre><code>$ mkdir sample-project\n$ cd sample-project\n$ pipenv --python 3.8.5\n</code></pre> <p>Questo crea un nuovo ambiente virtuale ed aggiunge un Pipfile al progetto:</p> <pre><code>[[source]]\nname = \"pypi\"\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\n\n[dev-packages]\n\n[packages]\n\n[requires]\npython_version = \"3.10\"\n</code></pre> <p>Tip</p> <p>Un Pipfile funzina praticamente come il pyproject.toml di Poetry.</p> <p>Possiamo installare una nuova dipendenza in questo modo:</p> <pre><code>$ pipenv install [--dev] &lt;package name&gt;\n</code></pre> <p>Note</p> <p>Il flag <code>--dev</code> indica che la dipendenza deve essere usata soltanto in fase di sviluppo. Le dipendenze di sviluppo non sono installate di default.</p> <p>Ad esempio:</p> <pre><code>$ pipenv install flask\n</code></pre> <p>Cos\u00ec come con Poetry, Pipenv scarica ed installa Flask all'interno dell'ambiente virutale, fissa tutte le sotto-dipendenze nel file Pipfile.lock, ed aggiunge una dipendenza ad alto livello al Pipfile.</p> <p>Per eseguire uno script all'interno dell'ambiente virutale gestito da Pipenv, dobbiamo eseguirlo con il comando <code>pipenv run</code>. A desempio, per eseguire dei test mediante <code>pytest</code>, eseguiamo:</p> <pre><code>$ pipenv run python -m pytest\n</code></pre> <p>Come con Poetry, <code>pipenv run &lt;command&gt;</code> eseguir\u00e0 dei comandi all'interno dell'ambiente virtuale. Per attivare l'ambiente virutale di Pipenv dobbiamo eseguire <code>pipenv shell</code>. Per disattivarlo, possiamo scrivere <code>exit</code>.</p> <p>Anche Pipenv lavora bene con pyenv. Ad esempio, quando vogliamo creare un ambiente virtuale da una versione di Python che non abbiamo installata, ci chieder\u00e0 se vogliamo prima instarla usando pyenv:</p> <pre><code>$ pipenv --python 3.7.5\n\nWarning: TODO\n</code></pre>"},{"location":"material/05_advanced_python/01_setup/#suggerimenti","title":"Suggerimenti","text":"<p>Cosa usare?</p> <p>Il suggerimento per i principianti \u00e8 iniziare con venv e pip. Sono i pi\u00f9 facili da utilizzare. Una volta presa un po' di confidenza, potremo capire cosa hanno e cosa gli manca.</p> <p>Per quello che riguarda Poetry e Pipenv, sono tool molto simili, e risolvono lo stesso problema, per cui tutto si riduce alla fine alle preferenze personali.</p> <p>Alcune note:</p> <ol> <li>Pubblicare su PyPI \u00e8 molto pi\u00f9 semplice usando Poetry, per cui se stiamo creando un package Python conviene usare questo tool.</li> <li>Entrambi i progetti sono abbastanza lenti quando si tratta di risolvere le dipendenze, per cui se stiamo usando Docker potremmo volerli evitare.</li> <li>Da una prospettiva open source, Poetry \u00e8 pi\u00f9 veloce, ed \u00e8 pi\u00f9 responsive ai feedback degli utenti.</li> </ol> <p>Tip</p> <p>Nonostante tutto, per\u00f2, io preferisco Pipenv.</p>"},{"location":"material/05_advanced_python/01_setup/#tool-aggiuntivi","title":"Tool aggiuntivi","text":"<p>Oltre a questi tool, \u00e8 opportuno dare uno sguardo ai seguenti tool per installare e switchare tra diverse versioni di Python sulla stessa machcina, gestire dipendenze ed ambienti virtuali, e riprodurre tali ambienti.</p> <ol> <li>Docker \u00e8 una piattaforma per costruire, fare il deploy e gestire appliczioni containerizzati. E' perfetta per creare degli ambienti facilmente riproducibili.</li> <li>Conda, che \u00e8 molto popoalre nelle community di data science e machine learning, pu\u00f2 aiutarci a gestire le dipendenze e gli ambienti virtuali, cos\u00ec come riprodurre gli ambienti.</li> <li>quando dobbiamo semplicemente switchare tra ambienti virtuali e gestirli, possiamo usare virtualenvwrapper e pyenv-virtualenv.</li> <li>pip-tools semplifica la gestione delle dipendenze e la riproducibilit\u00e0 dell'ambiente. Viene spesso usato assieme a venv.</li> </ol> Versioning Gestione delle dipendenze Ambienti virtuali Riproducibilit\u00e0 dell'ambiente pyenv :check: venv + pip :check: :check: venv + pip-tools :check: :check: :check: Poetry :check: :check: :check: Pipenv :check: :check: :check: Docker :check: Conda :check: :check: :check:"},{"location":"material/05_advanced_python/01_setup/#gestione-di-un-progetto","title":"Gestione di un progetto","text":"<p>Vediamo come gestire un progetto Flask usando pyenv e Poetry. Per prima cosa, creiamo una nuova cartella chiamata flask_exmaple e spostiamoci al suo interno:</p> <pre><code>$ mkdir flask_example\n$ cd flask_example\n</code></pre> <p>A quel punto, impostiamo la versione di Python per il progetto con pyenv:</p> <pre><code>$ pyenv local 3.8.5\n</code></pre> <p>Quindi inizializziamo un nuovo progetto Python con Poetry:</p> <pre><code>$ poetry init\n\nPackage name [flask_example]:\nVersion [0.1.0]:\nDescription []:\nAuthor [Your name &lt;your@email.com&gt;, n to skip]:\nLicense []:\nCompatible Python versions [^3.10]:\n\nWould you like to define your main dependencies interactively? (yes/no) [yes] no\nWould you like to define your development dependencies interactively? (yes/no) [yes] no\nDo you confirm generation? (yes/no) [yes]\n</code></pre> <p>Aggiungiamo Flask:</p> <pre><code>$ poetry add flask\n</code></pre> <p>Infine, aggiungiamo pytest come dipendenza di sviluppo:</p> <pre><code>poetry add --dev pytest\n</code></pre> <p>Ora che abbiamo impostato un ambiente base, possiamo scrivere un test per un singolo endpoint. Aggiungiamo un file chiamato test_app.py.</p> <pre><code>import pytest\n\nfrom app import app\n\n@pytest.fixture\ndef client():\n    app.config['TESTING'] = True\n\n    with app.test_client() as client:\n        yield client\n\n\ndef test_health_check(client):\n    response = client.get('/health-check/')\n\n    assert response.status_code == 200\n</code></pre> <p>Dopo questo, aggiungiamo una semplice app Flask ad un nuovo file chiamato <code>app.py</code>:</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/health-check/')\ndef health_check():\n    return'OK'\n\nif __name__ == '__main__':\n    app.run()\n</code></pre> <p>Ora eseguiamo i test:</p> <pre><code>$ poetry run python -m pytest\n</code></pre> <p>Possiamo quindi eseguire il server di sviluppo come segue:</p> <pre><code>$ poetry run python -m flask run\n</code></pre> <p>Tip</p> <p>Il comando <code>poetry run</code> esegue un comando all'interno dell'ambiente virtuale di Poetry.</p>"},{"location":"material/05_advanced_python/01_setup/#conclusioni","title":"Conclusioni","text":"<p>Abbiamo visto i tool pi\u00f9 popolari epr risolvere i seguenti problemi rispetto alle dipendenze ed alla gestione del workspace:</p> <ol> <li>installare e switchare tra diverse versioni di POython sulla stemssam macchina</li> <li>gestire le dipendenze e gli ambienti virtuali</li> <li>riprodurre gli ambienti</li> </ol> <p>Non \u00e8 importante quale tool specifico usiamo nel nostro flusso di lavoro, e pi\u00f9 quello che riusciamo a fare per risolvere questi problemi. Scegliamo ed usiamo i tool che rendono facile per noi sviluppare in Python.</p>"},{"location":"material/05_advanced_python/02_testing/","title":"02 - Test del codice Python","text":"<p>Il test automatico del codice \u00e8 sempre stato un topic centrale nello sviluppo del software, ed ha raggiunto una sempre maggior centralit\u00e0 con l'arrivo di paradigmi come la CI/CD. In tal senso, il linguaggio Python consta di numerosi strumenti che possono aiutarci a scrivere ed eseguire test di tutti i tipi; in questo articolo, ne vedremo alcuni tra i pi\u00f9 conosciuti ed utilizzati.</p>"},{"location":"material/05_advanced_python/02_testing/#021-pytest","title":"02.1 - pytest","text":"<p>Di suo, la libreria standard Python integra un framework di unit test chiamato <code>unittest</code>; tuttavia, lo standard de facto \u00e8 la libreria <code>pytest</code>, che ha cinque punti di forza:</p> <ol> <li>minor quantit\u00e0 di codice boilerplate, rendendo quindi le librerie meno \"verbose\" e, complessivamente, pi\u00f9 leggibili;</li> <li>supporto all'istruzione <code>assert</code>, che risulta essere molto pi\u00f9 leggibile e facile da utilizzare se comparata a metodi come <code>assertEquals</code>, <code>assertTrue</code> o <code>assertContains</code> contenuti in <code>unittest</code>;</li> <li>aggiornamento costante, dal momento che \u00e8 una libreria open source a s\u00e9 stante, mentre <code>unittest</code> \u00e8 parte integrante di Python;</li> <li>semplificazione del setup e del teardown dei casi di test con il sistema di fixture;</li> <li>uso di un approccio orientato alla programmazione funzionale.</li> </ol> <p><code>pytest</code> ci permette inoltre di avere uno stile di testing coerente tra i nostri diversi progetti Python. Immaginiamo, ad esempio, di avere due web app nel nostro stack, una creata mediante Django, e l'altra mediante Flask. Senza <code>pytest</code>, probabilmente, dovremo utilizzare il framework interno di Djano per l'unit testing per la prima, ed un'estensione Flask apposita, come Flask-Testing, per la seconda: di conseguenza, le due test suite avranno stili differenti. Usando <code>pytest</code>, invece, entrambe le test suite avranno uno stile consistente, rendendo semplice il saltare dall'una all'altra.</p> <p><code>pytest</code> offre anche un ecosistema di plugin molto esteso ed interamente mantenuto dalla community. Ad esempio, esiste il plugin <code>pytest-django</code>, che fornisce strumenti specificamente pensati per il test di web app Django, oppure anche <code>pytest-cov</code>, utile ad integrare il supporto al code coverage.</p>"},{"location":"material/05_advanced_python/02_testing/#mocking","title":"mocking","text":"<p>I test automatizzati devono essere veloci, isolati, indipendenti, deterministici e ripetiovili. Quindi, se dobbiamo testare del codice che fa una chiamata HTTP esterna ad una API di terze parti, dobbiamo effettuare il mocking della richiesta. QPErch\u00e9? se non lo facciamo, i test specifici saranno:</p> <ol> <li>lenti perch\u00e9 stanno facendo delle richieste HTTP nella rete</li> <li>dipendono dal servizio di terze parti e dalla velocit\u00e0 della rete stessa</li> <li>non sono deterministici dal momento che il test pu\u00f2d are un risultato differnete basato sula risposta dalla API</li> </ol> <p>Tip</p> <p>E' una buona idea anche effettuare il mocking di altre operazioni lunghe, come query al database e task asinmcrone, dal momento che i test automatizzati sono generalmente eseguiti frequente,ente, su ogni commit pushata al source control.</p> <p>Il mocking \u00e8 la pratica di rimpiazzare oggetti reali con oggetti simulati che mimano il loro comportamento a runtime. Per cui, invece da mandare una vera richiesta HTTP sula rete, ci limitiamo a restituire le risposte attes equando il metodo simulato viene chiamato.</p> <p>Ad esempio:</p> <pre><code>import requests\n\ndef get_my_ip():\n    response = requests.get(\n        'http://ipinfo.io/json'\n    )\n    return response.json()['ip']\n\n\ndef test_get_my_ip(monkeypatch):\n    my_ip = '123.123.123.123'\n\n    class MockResponse:\n\n        def __init__(self, json_body):\n            self.json_body = json_body\n\n        def json(self):\n            return self.json_body\n\n    monkeypatch.setattr(\n        requests,\n        'get',\n        lambda *args, **kwargs: MockResponse({'ip': my_ip})\n    )\n\n    assert get_my_ip() == my_ip\n</code></pre> <p>Cosa sta succedendo?</p> <p>Usiamo la fixture monkeypatch per rimpiazare tutte le chiamate al metodo <code>get</code> dal modulo <code>requests</code> con il callback lambda che restituisce sempre un'istanza di <code>MockedResponse</code>.</p> <p>Note</p> <p>Usiamo un oggetto perch\u00e9 <code>requests</code> restituisce un oggetto Response.</p> <p>Possiamo semplificare il test con il metodo create_autospec dal modulo unittest.mock. Questo metodo crea un oggetto mockato con le stesse propriet\u00e0 e metodi dell'oggetto passato come parametro:</p> <pre><code>from unittest import mock\n\nimport requests\nfrom requests import Response\n\n\ndef get_my_ip():\n    response = requests.get(\n        'http://ipinfo.io/json'\n    )\n    return response.json()['ip']\n\n\ndef test_get_my_ip(monkeypatch):\n    my_ip = '123.123.123.123'\n    response = mock.create_autospec(Response)\n    response.json.return_value = {'ip': my_ip}\n\n    monkeypatch.setattr(\n        requests,\n        'get',\n        lambda *args, **kwargs: response\n    )\n\n    assert get_my_ip() == my_ip\n</code></pre> <p>Anche se pytest raccomanda l'approccio monkeypatch per il mocking, l'estensieone pytest-mock e la libreria unittest.mock dalla libreria standard sono approcci ottimi entrmabi.</p>"},{"location":"material/05_advanced_python/02_testing/#code-coveratge","title":"code coveratge","text":"<p>un altro aspetto importante del test \u00e8 il code coverage. \u00e8 una metrica che ci indica che il rapproto tra il numero di linee eseguiti duranti il test esegue ed il numero totale di righe nella nostra codebase. Possiamo usare il plugin pyutest-cov per questo, che integra Coverage.py con pytest.</p> <p>Una volta installata, per eseguire i test con il report del coverage aggiungiamo l'opzione --cov:</p> <pre><code>$ python -m pytest --cov=.\n</code></pre> <p>Produrr\u00e0 un output del genere:</p> <pre><code>================================== test session starts ==================================\nplatform linux -- Python 3.7.9, pytest-5.4.3, py-1.9.0, pluggy-0.13.1\nrootdir: /home/johndoe/sample-project\nplugins: cov-2.10.1\ncollected 6 items\n\ntests/test_sample_project.py ....                                             [ 66%]\ntests/test_sample_project_mock.py .                                           [ 83%]\ntests/test_sample_project_mock_1.py .                                         [100%]\n\n----------- coverage: platform linux, python 3.7.9-final-0 -----------\nName                                  Stmts   Miss  Cover\n---------------------------------------------------------\nsample_project/__init__.py                1      1     0%\ntests/__init__.py                         0      0   100%\ntests/test_sample_project.py              5      0   100%\ntests/test_sample_project_mock.py        13      0   100%\ntests/test_sample_project_mock_1.py      12      0   100%\n---------------------------------------------------------\nTOTAL                                    31      1    97%\n\n\n==================================  6 passed in 0.13s ==================================\n</code></pre> <p>Per ogni file nel percorso del progetto otteniamo:</p> <ul> <li>Stmts: numero di righe di codice</li> <li>Miss: numero di righe che non sono state eseguitre dai test</li> <li>cover: percentuale di copertura per il file</li> </ul> <p>Alla fine, vi \u00e8 una linea con i totali per l'intero progetto.</p> <p>Teniamo a mente che anche se \u00e8 bene ottenere una percentuale di copertura alta, questo non significa che i nostri test siano buoni, e che testino tutti percorsi che possono essere seguiti dal codice. Per esempio, i test con assert sum(3, 2) == 5 pu\u00f2 avere un'alta percentuale di copertura, ma il codice non \u00e8 testato, dal momento che i percorsi delle eccezioni non sono coperte.</p>"},{"location":"material/05_advanced_python/02_testing/#mutation-testging","title":"mutation testging","text":"<p>Il mutation testing ci aiuta ad assicurarci che i nostri test coprano effettivamente l'intero comportamento del nostro codice. Messo in un altro modo, analizziamo l'efficacia o robustezza della nostra test suite. Durante il mutation testing, un tool itera attraverso ogni riga del nostro codice sorgente, facendom dei piccoli cambi (chiamati mutazioni) che potrebbero rompere il nostro codice. Dopo ogni mutazione, il tool esegue gli unit test e verifica se il nostro test fallisce o meno. Se i nostri test passano, allora il codice non \u00e8 riuscito a passare il mutation test.</p> <p>Ad esempio, imamginiamo di avere il seguente codice:</p> <pre><code>if x &gt; y:\n    z = 50\nelse:\n    z = 100\n</code></pre> <p>Il mutation tool pu\u00f2 cambiare l'operatore da &gt; a &gt;=:</p> <pre><code>if x&gt;= y:\n    z = 50\nelse:\n    z = 100\n</code></pre> <p>mutmut \u00e8 una libreria di mutation testing per Python. Vediamola in azione.</p> <p>Immaginiamo di avere la seguente classe Prestiti:</p> <pre><code># loan.py\n\nfrom dataclasses import dataclass\nfrom enum import Enum\n\n\nclass LoanStatus(str, Enum):\n    PENDING = \"PENDING\"\n    ACCEPTED = \"ACCEPTED\"\n    REJECTED = \"REJECTED\"\n\n\n@dataclass\nclass Loan:\n    amount: float\n    status: LoanStatus = LoanStatus.PENDING\n\n    def reject(self):\n        self.status = LoanStatus.REJECTED\n\n    def rejected(self):\n        return self.status == LoanStatus.REJECTED\n</code></pre> <p>Ora diciamo che vogliamo automaticamente respingere le richieste di mutuo che sono superiori a 250k:</p> <pre><code># reject_loan.py\n\ndef reject_loan(loan):\n    if loan.amount &gt; 250.000:\n        loan.reject()\n\n    return loan\n</code></pre> <p>Scriviamo quindi il seguente test:</p> <pre><code>from loan import loan\nfrom reject_loan import reject_loan\n\ndef test_reject_loan():\n    loan = loan(amount=100_000)\n\n    assert not reject_loan(loan).rejected() \n</code></pre> <p>Quando eseguiamo il mutation testing con mutmut, vedremo che avremo due mutazioni che sopravvivono:</p> <pre><code>$ mutmut run --paths-to-mutate reject_loan.py --tests-dir=.\n\n- Mutation testing starting -\n\nThese are the steps:\n1. A full test suite run will be made to make sure we\n   can run the tests successfully and we know how long\n   it takes (to detect infinite loops for example)\n2. Mutants will be generated and checked\n\nResults are stored in .mutmut-cache.\nPrint found mutants with `mutmut results`.\n\nLegend for output:\n\ud83c\udf89 Killed mutants.   The goal is for everything to end up in this bucket.\n\u23f0 Timeout.          Test suite took 10 times as long as the baseline so were killed.\n\ud83e\udd14 Suspicious.       Tests took a long time, but not long enough to be fatal.\n\ud83d\ude41 Survived.         This means your tests needs to be expanded.\n\ud83d\udd07 Skipped.          Skipped.\n\n1. Running tests without mutations\n\u280f Running...Done\n\n2. Checking mutants\n\u2838 2/2  \ud83c\udf89 0  \u23f0 0  \ud83e\udd14 0  \ud83d\ude41 2  \ud83d\udd07 0\n</code></pre> <p>Possiamo vedere le mutazioni che sopravvivono in base al loro ID:</p> <pre><code>$ mutmut show 1\n\n--- reject_loan.py\n+++ reject_loan.py\n@@ -1,7 +1,7 @@\n # reject_loan.py\n\n def reject_loan(loan):\n-    if loan.amount &gt; 250_000:\n+    if loan.amount &gt;= 250_000:\n         loan.reject()\n\n     return loan\n</code></pre> <p>$ mutmut show 2</p> <p>--- rejectloan.py +++ rejectloan.py @@ -1,7 +1,7 @@  # reject_loan.py</p> <p>def rejectloan(loan): -    if loan.amount &gt; 250000: +    if loan.amount &gt; 250001:          loan.reject()</p> <pre><code> return loan\n</code></pre> <p>Miglioriamo il nostro testO:</p> <p>from loan import Loan from rejectloan import rejectloan</p> <p>def testrejectloan():     loan = Loan(amount=100000)     assert not rejectloan(loan).rejected()</p> <pre><code>loan = Loan(amount=250_001)\nassert reject_loan(loan).rejected()\n\nloan = Loan(amount=250_000)\nassert not reject_loan(loan).rejected()\n</code></pre> <p>Se facciamo di nuovo il nsotro mutation test, vedremo che nessuna mutazione \u00e8 sopravvissuta:</p> <p>$ mutmut run --paths-to-mutate reject_loan.py --tests-dir=.</p> <ul> <li>Mutation testing starting -</li> </ul> <p>These are the steps: 1. A full test suite run will be made to make sure we    can run the tests successfully and we know how long    it takes (to detect infinite loops for example) 2. Mutants will be generated and checked</p> <p>Results are stored in .mutmut-cache. Print found mutants with <code>mutmut results</code>.</p> <p>Legend for output: \ud83c\udf89 Killed mutants.   The goal is for everything to end up in this bucket. \u23f0 Timeout.          Test suite took 10 times as long as the baseline so were killed. \ud83e\udd14 Suspicious.       Tests took a long time, but not long enough to be fatal. \ud83d\ude41 Survived.         This means your tests needs to be expanded. \ud83d\udd07 Skipped.          Skipped.</p> <ol> <li> <p>Running tests without mutations \u280f Running...Done</p> </li> <li> <p>Checking mutants \u2819 2/2  \ud83c\udf89 2  \u23f0 0  \ud83e\udd14 0  \ud83d\ude41 0  \ud83d\udd07 0</p> </li> </ol> <p>Adesso i nostri test sono molto pi\u00f9 robusti. Un qualsiasi cambio non intenzionale all'intenro di <code>reject_loan.py</code> produrr\u00e0 un test che fallisce.</p> <p>Tip</p> <p>I tool di mutation testing per Python non sono maturi come quelli per altri linguaggi.POer esempoi, mtuatn \u00e8 un mutation testing maturo per Ruby.</p> <p>Cos\u00ec come per ogni altro approccio, il mutationt esting ha un tradeoff. Mentre miglirloa la abilit\u00e0 della nostra test suite di catturare dei bug, ha il costo di velocit\u00e0 dal momento che dobbiamo eseguire l'intera test suitee centinaia di volte. Ci forza inotlre a testare davvero tutto. QUesto ci aiuta a scoprire dei path di eccezioni, ma avremo molti test case minori da mantenere.</p>"},{"location":"material/05_advanced_python/02_testing/#todo-da-hypothesis","title":"TODO: DA HYPOTHESIS","text":"<p>Hypotheisi \u00e8 una libreria per effettuare il property-based testing in Python. In pratica, pitutosto che scrivere differenti test case per ogni argomento da testare, il property-based testing genera un ampio range di dati di test casuali che sono dipendenti dalle precedenti run. Questo ci aiuta ad aumentare la robustezza della della nostra test suite e diminuire la ridondanza dei test. In breve, il codice di test sar\u00e0 pi\u00f9 pulito, pi\u00f9 DRY, e pi\u00f9 efficiente, mentre comunque copre un ampio range di dati di test.</p> <p>Per esempio, diciamo di dover scrivere dei test per la seguente funzione:</p> <pre><code>def increment(num: int) -&gt; int:\n    return num + 1\n</code></pre> <p>Possiamo scrivere i seguenti test:</p> <pre><code>import pytest\n\n@pytest.mark.parametrize(\n    'number, result',\n    [\n        (-2, -1),\n        (0, 1),\n        (3, 4),\n        (101234, 101235)\n    ]\n)\n\ndef test_increment(number, result):\n    assert increment(number) == result\n</code></pre> <p>Non vi \u00e8 niente di sbagliato in questo approccio. Il codice \u00e8 testato e la copertura \u00e8 alta (100%, per essere satti). Detto questo, quanto bene \u00e8 stato testato il codice rispetto al range dei possibili input? Vi sono molti interi che possono essere testati, ma solo quattro di loro sono usati nel test. In alcune situazioni questo \u00e8 abbastanza. In altre situazioni quattro casi non sono abbastanza, ad esempio, nel codice machine learning (che non \u00e8 detrerministico). COsa diciamo per dei numeri molto piccoli o grandi? o se la nostra funzione prende una lista di interi piuttosto che un singolo intero. E se la lista \u00e8 vuota o contiene un elemnto, centtinaia di elementi, o migliaia di elemneti? In alcune situaizoni non possiamo semplicemente fornire (o anche pensare) tutti i possibili casi. E' qui che il test propertty-based viene in gioco.</p> <p>Note</p> <p>Gli algoritmi di machine learning sono un use case ottimo per il property-based testing dal momento in cui \u00e8 dificile produrre (e mantenere)) i campioni di test per insiemi di dati complessi.</p> <p>I frmaework come hypothesis fornisce le ricette (chiamate Strategies) per generare dati di test casuali. Hypothesis memorizza anche i risultati delle precedenti run di test e le use per creare nuovi casi.</p> <p>Note</p> <p>Le strategie sono algoritmi che generano dati pseudo-casuali basate sulla forma dei dati input. E' pseudo-causuale perch\u00e9 i dati generati sono basati sui dati dai test precedenti.</p> <p>Lo stesso test che usa il property-based testing mediante Hypothesis appare come segue:</p> <pre><code>from hypothesis import given\nimport hypothesis.strategies as st\n\n@given(st.integers())\ndef test_add_one(num):\n    assert increment(num) == num - 1\n</code></pre> <p><code>st.integers()</code> \u00e8 una strategia Hypothesis che genbera deglki interti casuali per il test mentre il decorator <code>@given</code> \u00e8 usato per parametrizzare la funzione di test. Per cui quando la funzione di test \u00e8 chiamato, gli interi generati, dalla strategiua, saranno passati nei test.</p> <pre><code>$ python -m pytest test_hypothesis.py --hypothesis-show-statistics\n\n================================== test session starts ===================================\nplatform darwin -- Python 3.8.5, pytest-6.1.1, py-1.9.0, pluggy-0.13.1\nrootdir: /home/johndoe/sample-project\nplugins: hypothesis-5.37.3\ncollected 1 item\n\ntest_hypothesis.py .                                                               [100%]\n================================= Hypothesis Statistics ==================================\n\ntest_hypothesis.py::test_add_one:\n\n  - during generate phase (0.06 seconds):\n    - Typical runtimes: &lt; 1ms, ~ 50% in data generation\n    - 100 passing examples, 0 failing examples, 0 invalid examples\n\n  - Stopped because settings.max_examples=100\n\n\n=================================== 1 passed in 0.08s ====================================\n</code></pre>"},{"location":"material/05_advanced_python/02_testing/#type-checking","title":"type checking","text":"<p>I test sono codice, e devono esere trrattati di conseguenza. Come il codice di business, dobbiamo mantenerli e fare il refactoring. Possiamo dover affrontare i bug di volta in volta. A causa di questo, \u00e8 una buona pratica mantenere i test corti, semplici, e dritti al punto. Dovremmo anche occuparci di non effettuare troppi test sul codice.</p> <p>I type checker a runtime, o dinamici, come Typeguard e pydantic, possono aituare a minimizzare il numero di test. Vediamo ad un esempio di questo con pydantic.</p> <p>Per esempio, diciamo di avere un <code>User</code> che ha un singolo attributo, un indirizzo email:</p> <pre><code>class User:\n\n    def __init__(self, email: str):\n        self.email = email\n\n\nuser = User(email='john@doe.com')\n</code></pre> <p>Vogliamo assicuraci che la mail fornita sia un indirizzo effettivamente valido. PEr cui, per validarlo, dovremo aggiungere da qualche parte del codice helper. Assieme alla scrittura di test, dovremo anche spendere del tempo per scrivere le espressioni regolari per questo. pydantic pu\u00f2 aiutarci. Possiamo usarlo per derinife ril nostro modello User:</p> <pre><code>from pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    email: EmailStr\n\n\nuser = User(email='john@doe.com')\n</code></pre> <p>Ora, l'argomento email sar\u00e0 validato da pydantic prima che ogni istanza di User sia creata. Quando non \u00e8 una mail valida (ad esempio, User(email='something')) un ValidationError sar\u00e0 lanciato. Qeusto elimina la necessit\u00e0 dis crivere il nostro validatore. Non dobbiamo neanche testarlo perch\u00e9 i mantainer di pydantic lo fanno per noi.</p> <p>Possiamo ridure il numero di test per ogni dato fornito dall'utente. E, invece, dobbiamo semplciemente testare che un ValidationError sia gestito correttamente.</p> <p>Vediamo un rapido esempio in un'app Flask:</p> <pre><code>import uuid\n\nfrom flask import Flask, jsonify\nfrom pydantic import ValidationError, BaseModel, EmailStr, Field\n\n\napp = Flask(__name__)\n\n\n@app.errorhandler(ValidationError)\ndef handle_validation_exception(error):\n    response = jsonify(error.errors())\n    response.status_code = 400\n    return response\n\n\nclass Blog(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    author: EmailStr\n    title: str\n    content: str\n</code></pre> <p>Il test diventa:</p> <pre><code>import json\n\n\ndef test_create_blog_bad_request(client):\n    \"\"\"\n    GIVEN request data with invalid values or missing attributes\n    WHEN endpoint /create-blog/ is called\n    THEN it should return status 400 and JSON body\n    \"\"\"\n    response = client.post(\n        '/create-blog/',\n        data=json.dumps(\n            {\n            'author': 'John Doe',\n            'title': None,\n            'content': 'Some extra awesome content'\n        }\n        ),\n        content_type='application/json',\n    )\n\n    assert response.status_code == 400\n    assert response.json is not None\n</code></pre>"},{"location":"material/05_advanced_python/02_testing/#conclusioni","title":"Conclusioni","text":"<p>Il test pu\u00f2 essere alle volte un compito scooraggiante. Ci sono sempre delle volte in cui lo sar\u00e0, ma abbiamo visto delle tecniche e deglis trumenti che possiamo usare per rendere ilt est pi\u00f9 semplice. Focalizziamo gli sforzi di testing sul diminuire i test inutili. I nostri test dovrebbero anche essere veloci, isolati, indipendenti, deterministici e ripetibili. Alla fine, avere confidenza nella nostra suite di test ci aiuter\u00e0 ad efettuare il deploy in produzione pi\u00f9 spesso e dormire sogni tranquilli.</p>"},{"location":"material/05_advanced_python/03_tdd/","title":"03 tdd","text":"<p>Il test di codice production-grade \u00e8 duro. Alle volte pu\u00f2 prendere tutto il tempo necessario allo sviluppo delle feature. Inoltre, anche se abbiamo una copertura del 100% e tutti i test riesono, potremmo essere sempre non confidenti rispetto al fatto che la nuova feature funzioner\u00e0 bene in produzione.</p> <p>In questo articoo vedremocome sviluppare un'app usando il Test-Driven Development (TDD). Vedremo come e cosa testare. Useremo pytest per il testing, pydantic per validare i dati e ridurre il numero di test richiesti, e Flask per fornire un'interfaccia ai client con una API RESTful. Alla fine, avremo un pattern solido che possiamo usare per progetti Python generici, in modo da avere una certa confidenza sul fatto che i test passati indicano un software funzionante.</p>"},{"location":"material/05_advanced_python/03_tdd/#obiettivi","title":"Obiettivi","text":"<p>In questo articolo, vedremo come:</p> <ul> <li>Spiegare come dovremo eseguire i test sul nostro software</li> <li>Configurare pytest ed impostare una struttura di progetto per i test </li> <li>Definire dei modelli database con pydantic</li> <li>USare le fixture di pytest per gestire lo stato del test e valutare dei side effect</li> <li>Verificare le risposte JSON rispetto alle definizioni sullo Schema JSON</li> <li>Organizzare le operazioni sul database mediante comandi (che cambiano lo stao ed hanno effetti collaterali) e query (read-only, senza effetti collateriali)</li> <li>Scrivere unit test, integration test ed end-to-end test mediante pytest</li> <li>Spiegare perch\u00e9 sia importante foalizzare gli sforzi di test sul comportamento del test piuttosto che sui dettagli implementativi</li> </ul>"},{"location":"material/05_advanced_python/03_tdd/#come-testare-il-nostro-software","title":"Come testare il nostro software?","text":"<p>Gli sviluppatori software tendono ad essere molto soggettivi sul testing. A causa di questo, hanno opinioni divergenti su quanto \u00e8 importante il test, ed idee divergenti su come farlo. Detto questo, vediamo tre linee guida su cui sperabilmente la maggior parte degli sviluppatori concorder\u00e0 e che ci aiutano a scrivere test ottimali:</p> <ul> <li>i test devono indicare il comportamento atteso dell'unit\u00e0 sotto test. Quindi, \u00e8 preferibile mantenerli brevi e dritti al punto. La struttura GIVEN, WHEN, THEN pu\u00f2 aiutarci a farlo:</li> </ul> <p>GIVEN - quali sono le condizioni iniziali per il test? WHEN - cosa deve essere testato? THEN - quale \u00e8 la risposta attesa?</p> <p>Per cui dovremmo preparare il nostro ambiente per il testing, eseguire il comportamento e, alla fine, controllare che gli output rispettino le attese.</p> <p>Ogni parte di comportamento deve essere testata una ed una sola volta. Testare lo stesso comportamento non significa che il nostro software funzioner\u00e0 meglio. I test devono essere anche manutenuti. Se facciamo un piccolo cambio alla nostra code base e si rompono venti test, come sappiamo quale funzionalit\u00e0 \u00e8 rotta? Quando invece \u00e8 soltanto un singolo test a rompersi, \u00e8 molto pi\u00f9 semplice individuare il bug.</p> <p>Ogni test deve essere indipendente dagli altri. Altrimenti, avremo difficolt\u00e0 a mentenere ed eseguire la suite di test.</p> <p>Questo articolo \u00e8 soggettivo anche. Non prendiamo tutto come il sacro graal o un proiettile d'argento.</p>"},{"location":"material/05_advanced_python/03_tdd/#setup-base","title":"Setup base","text":"<p>Detto questo, \u00e8 giunto il momento di sporcarci le mani. Vediamo, in pratica, cosa significa questo nel mondo reale. Il test pi\u00f9 semplice che possiamo eseguire mediante pytest \u00e8 il seguente:</p> <pre><code>def another_sum(a, b):\n    return a + b\n\ndef test_another_sum():\n    assert another_sum(3, 2) == 5\n</code></pre> <p>Questo \u00e8 l'esempio che probabilmente tutti noi abbiamo visto almeno una volta. Per prima cosa, non scriveremo mai dei test all'interno della nostra codebase, per cui suddividiamo questo in due file e package.</p> <p>Creiamo una nuova cartella per questo progetto e spostiamoci al suo interno:</p> <pre><code>$ mkdir testing_project\n$ cd testing_project\n</code></pre> <p>A questo punto, creiamo ed attiviamo un ambiente virtuale.</p> <p>Installiamo quindi pytest:</p> <pre><code>(venv)$ pip install pytest\n</code></pre> <p>Dopo aver fatto questo, creiamo una nuova cartella chiamata <code>sum</code>. Aggiungiamo un file <code>__init__.py</code> nella cartella per trasformarla in un package, assieme ad un file <code>another_sum.py</code>:</p> <pre><code>def another_sum(a, b):\n    return a + b\n</code></pre> <p>Aggiungiamo un'altra cartella tests ed aggiungiamo i seguenti file e cartelle:</p> <pre><code>\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_sum\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 test_another_sum.py\n</code></pre> <p>Dovremmo avere quindi una struttura di questo tipo:</p> <pre><code>\u251c\u2500\u2500 sum\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 another_sum.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_sum\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 test_another_sum.py\n</code></pre> <p>Nel file <code>test_another_sum.py</code> aggiungiamo:</p> <pre><code>from sum.another_sum import another_sum\n\n\ndef test_another_sum():\n    assert another_sum(3, 2) == 5\n</code></pre> <p>A questo punto, aggiungiamo un file <code>conftest.py</code> vuoto, che viene usato per memorizzare le fixture di pytest, assieme alla cartella tests.</p> <p>Infine, aggiungiamo un file <code>pytest.ini</code> (ovvero, un file di configurazione pytest)</p> <p>La struttura finale del progetto \u00e8 come segue:</p> <pre><code>\u251c\u2500\u2500 sum\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 another_sum.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 conftest.py\n    \u251c\u2500\u2500 pytest.ini\n    \u2514\u2500\u2500 test_sum\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 test_another_sum.py\n</code></pre> <p>In definitiva, tenere i test assieme all'interno di un singolo package ci permette di:</p> <ul> <li>riutilizzare la configurazione di pytest in tutti i test</li> <li>riutilizzare le fixture in tutti i test</li> <li>semplificare l'esecuzione dei test</li> </ul> <p>Possiamo eseguire tutti i test con questo comando:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Dovremmo quindi vedere i risultati dei test, che in questo caso valgono:</p> <pre><code>============================== test session starts ==============================\nplatform darwin -- Python 3.10.1, pytest-7.0.1, pluggy-1.0.0\nrootdir: /testing_project/tests, configfile: pytest.ini\ncollected 1 item\n\ntests/test_sum.py/test_another_sum.py .                                 [100%]\n\n=============================== 1 passed in 0.01s ===============================\n</code></pre>"},{"location":"material/05_advanced_python/03_tdd/#unapplicazione-reale","title":"Un'applicazione reale","text":"<p>Ora che abbiamo l'idea base di come impostare e strutturare i nostri test, costruiamo un semplice blog. Lo costruiremo usando il TDD per vedere il test in azione. Useremo Flask come framework web e, per focalizzarci sul testing, SQLite come database.</p> <p>La nostra app avr\u00e0 i seguenti requisiti:</p> <ul> <li>potremo creare degli aritcoli</li> <li>leggere articoli</li> <li>restituire una lista di articoli</li> </ul> <p>Per prima cosa, creiamo un nuovo progetto:</p> <pre><code>$ mkdir blog_app\n$ cd blog_app\n</code></pre> <p>A questo punto, creiamo ed attiviamo un nuovo ambiente virtuale. Installiamo al suo interno pytest e pydantic, una liberia per il parsing e la validazione dei dati:</p> <pre><code>(venv)$ pip install pytest &amp;&amp; pip install \"pydantic[email]\"\n</code></pre> <p>Notiamo che stiamo installando \"pydantic[email]\", che ci permette di installare pydantic con un validatore delle email, che useremo per validare gli indirizzi email inseriti.</p> <p>A questo punto, creiamo i seguenti file e cartelle:</p> <pre><code>blog_app\n    \u251c\u2500\u2500 blog\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 app.py\n    \u2502   \u2514\u2500\u2500 models.py\n    \u2514\u2500\u2500 tests\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u2514\u2500\u2500 pytest.ini\n</code></pre> <p>Aggiungiamo il seguente codice al file <code>models.py</code> per definire il modello per un nuovo Articolo mediante pydantic:</p> <pre><code>import os\nimport sqlite3\nimport uuid\nfrom typing import List\n\nfrom pydantic import BaseModel, EmailStr, Field\n\n\nclass NotFound(Exception):\n    pass\n\n\nclass Article(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    author: EmailStr\n    title: str\n    content: str\n\n    @classmethod\n    def get_by_id(cls, article_id: str):\n        con = sqlite3.connect(os.getenv(\"DATABASE_NAME\", \"database.db\"))\n        con.row_factory = sqlite3.Row\n\n        cur = con.cursor()\n        cur.execute(\"SELECT * FROM articles WHERE id=?\", (article_id,))\n\n        record = cur.fetchone()\n\n        if record is None:\n            raise NotFound\n\n        article = cls(**record)  # Row can be unpacked as dict\n        con.close()\n\n        return article\n\n    @classmethod\n    def get_by_title(cls, title: str):\n        con = sqlite3.connect(os.getenv(\"DATABASE_NAME\", \"database.db\"))\n        con.row_factory = sqlite3.Row\n\n        cur = con.cursor()\n        cur.execute(\"SELECT * FROM articles WHERE title = ?\", (title,))\n\n        record = cur.fetchone()\n\n        if record is None:\n            raise NotFound\n\n        article = cls(**record)  # Row can be unpacked as dict\n        con.close()\n\n        return article\n\n    @classmethod\n    def list(cls) -&gt; List[\"Article\"]:\n        con = sqlite3.connect(os.getenv(\"DATABASE_NAME\", \"database.db\"))\n        con.row_factory = sqlite3.Row\n\n        cur = con.cursor()\n        cur.execute(\"SELECT * FROM articles\")\n\n        records = cur.fetchall()\n        articles = [cls(**record) for record in records]\n        con.close()\n\n        return articles\n\n    def save(self) -&gt; \"Article\":\n        with sqlite3.connect(os.getenv(\"DATABASE_NAME\", \"database.db\")) as con:\n            cur = con.cursor()\n            cur.execute(\n                \"INSERT INTO articles (id,author,title,content) VALUES(?, ?, ?, ?)\",\n                (self.id, self.author, self.title, self.content)\n            )\n            con.commit()\n\n        return self\n\n    @classmethod\n    def create_table(cls, database_name=\"database.db\"):\n        conn = sqlite3.connect(database_name)\n\n        conn.execute(\n            \"CREATE TABLE IF NOT EXISTS articles (id TEXT, author TEXT, title TEXT, content TEXT)\"\n        )\n        conn.close()\n</code></pre> <p>Questo \u00e8 un modello di tipo Active Record, che fornisce metodi per memorizzare, estrarre un singolo articolo, e creare la lista di tutti gli articoli.</p> <p>Potremmo chiederci perch\u00e9 non abbiamo scritto dei test per coprire il modello. Lo capiremo a breve.</p>"},{"location":"material/05_advanced_python/03_tdd/#creazione-di-un-nuovo-articolo","title":"Creazione di un nuovo articolo","text":"<p>Adesso, vediamo la business logic del nostro modello. Scriveremo alcuni comandi di aiuto e delle query per separare la nostra logica dal modello e delle API. Dal momento che stiamo usando pydantic, possiamo facilmente validare i dati sulla base del modello stesso.</p> <p>Creiamo quindi un package test_article nella cartella test. Aggiungiamo quindi un file chiamato test_commands.py.</p> <pre><code>blog_app\n    \u251c\u2500\u2500 blog\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 app.py\n    \u2502   \u2514\u2500\u2500 models.py\n    \u2514\u2500\u2500 tests\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u251c\u2500\u2500 pytest.ini\n        \u2514\u2500\u2500 test_article\n            \u251c\u2500\u2500 __init__.py\n            \u2514\u2500\u2500 test_commands.py\n</code></pre> <p>Aggiungiamo i seguenti test a test_commands.py:</p> <pre><code>import pytest\n\nfrom blog.models import Article\nfrom blog.commands import CreateArticleCommand, AlreadyExists\n\n\ndef test_create_article():\n    \"\"\"\n    GIVEN CreateArticleCommand with valid author, title, and content properties\n    WHEN the execute method is called\n    THEN a new Article must exist in the database with the same attributes\n    \"\"\"\n    cmd = CreateArticleCommand(\n        author=\"john@doe.com\",\n        title=\"New Article\",\n        content=\"Super awesome article\"\n    )\n\n    article = cmd.execute()\n\n    db_article = Article.get_by_id(article.id)\n\n    assert db_article.id == article.id\n    assert db_article.author == article.author\n    assert db_article.title == article.title\n    assert db_article.content == article.content\n\n\ndef test_create_article_already_exists():\n    \"\"\"\n    GIVEN CreateArticleCommand with a title of some article in database\n    WHEN the execute method is called\n    THEN the AlreadyExists exception must be raised\n    \"\"\"\n\n    Article(\n        author=\"jane@doe.com\",\n        title=\"New Article\",\n        content=\"Super extra awesome article\"\n    ).save()\n\n    cmd = CreateArticleCommand(\n        author=\"john@doe.com\",\n        title=\"New Article\",\n        content=\"Super awesome article\"\n    )\n\n    with pytest.raises(AlreadyExists):\n        cmd.execute()\n</code></pre> <p>Questi test coprono i seguenti casi d'uso:</p> <ul> <li>gli articoli devono essere creati a partire da dati validi</li> <li>i titoli degli articoli devono essere unici</li> </ul> <p>Eseguiamo i test dalla nostra cartella di progetto per vedere come falliscono:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Adesso possiamo implementare i nostri comandi. Aggiungiamo un file commands.py alla cartella blog:</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nfrom blog.models import Article, NotFound\n\n\nclass AlreadyExists(Exception):\n    pass\n\n\nclass CreateArticleCommand(BaseModel):\n    author: EmailStr\n    title: str\n    content: str\n\n    def execute(self) -&gt; Article:\n        try:\n            Article.get_by_title(self.title)\n            raise AlreadyExists\n        except NotFound:\n            pass\n\n        article = Article(\n            author=self.author,\n            title=self.title,\n            content=self.content\n        ).save()\n\n        return article\n</code></pre>"},{"location":"material/05_advanced_python/03_tdd/#test-delle-fixture","title":"Test delle fixture","text":"<p>Possiamo usare le fixture di pytest per pulire il database dopo ogni test e crearne uno nuovo prima di ogni test. Le fixture sono delle funzioni decorate con un decorator di tipo <code>@pytest.fixture</code>. Di solito, sono collocate all'interno di <code>conftest.py</code>, ma possono essere anche aggiunte ai file di test veri e propri. Queste funzioni sono eseguite di default prima di ogni test.</p> <p>Un'opzione \u00e8 quella di usare i valori restituiti all'interno dei nostri test. Ad esempio:</p> <pre><code>import random\nimport pytest\n\n\n@pytest.fixture\ndef random_name():\n    names = [\"John\", \"Jane\", \"Marry\"]\n    return random.choice(names)\n\n\ndef test_fixture_usage(random_name):\n    assert random_name\nSo, to use the value returned from the fixture inside the test you just need to add the name of the fixture function as a parameter to the test function.\n\nAnother option is to perform a side effect, like creating a database or mocking a module.\n\nYou can also run part of a fixture before and part after a test using yield instead of return. For example:\n\n@pytest.fixture\ndef some_fixture():\n    # do something before your test\n    yield # test runs here\n    # do something after your test\n</code></pre> <p>Adesso, aggiungiamo la seguente fixture a <code>conftest.py</code>, che crea un nuovo database prima di ogni test e lo rimuove immediatamente dopo:</p> <pre><code>import os\nimport tempfile\n\nimport pytest\n\nfrom blog.models import Article\n\n\n@pytest.fixture(autouse=True)\ndef database():\n    _, file_name = tempfile.mkstemp()\n    os.environ[\"DATABASE_NAME\"] = file_name\n    Article.create_table(database_name=file_name)\n    yield\n    os.unlink(file_name)\n</code></pre> <p>Il flag <code>autouse</code> \u00e8 impostato a <code>True</code> in modo che sia automaticamente usato di default prima (e dopo) ogni test nella suite di test. Dal momento che stiamo usando un database per tutti i test ha senso usare questo flag. In questo modo non dobbiamo aggiungere in maniera esplicita il nome della fixture ad ognit est come parametro.</p> <p>Se non dobbiamo avere accesso al database per un test possiamo disabilitare autouse con un test marker. Possiamo vedere un esempio di questo qui.,</p> <p>Eseguiamo nuovamente i test:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Stavolta, dovrebbero passare.</p> <p>Come possiamo vedere, i nostri test testano soltanto il comando CreateArticleCommand. Non testiamo il modello Article vero e proprio, in quatno non risulta essere responsabile per la logica di business. Sappiamo che il comando funziona come atteso. Quindi, non c'\u00e8 la necessit\u00e0 di scrivere ulteriori test.</p>"},{"location":"material/05_advanced_python/03_tdd/#lista-di-tutti-gli-articoli","title":"lista di tutti gli articoli","text":"<p>Il requisito succesivo \u00e8 quello di elencare la lista di tutti gli articoli. Useremo una query invece di un comando, per cui aggiungiamo un nuovo file chiamato testqueries.py alla cartella testarticle:</p> <pre><code>from blog.models import Article\nfrom blog.queries import ListArticlesQuery\n\n\ndef test_list_articles():\n    \"\"\"\n    GIVEN 2 articles stored in the database\n    WHEN the execute method is called\n    THEN it should return 2 articles\n    \"\"\"\n    Article(\n        author=\"jane@doe.com\",\n        title=\"New Article\",\n        content=\"Super extra awesome article\"\n    ).save()\n    Article(\n        author=\"jane@doe.com\",\n        title=\"Another Article\",\n        content=\"Super awesome article\"\n    ).save()\n\n    query = ListArticlesQuery()\n\n    assert len(query.execute()) == 2\n</code></pre> <p>Eseguiamo i test:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>I test dovrebbero adesso fallire.</p> <p>Aggiungiamo un file <code>queries.py</code> alla cartella blog:</p> <pre><code>blog_app\n    \u251c\u2500\u2500 blog\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 app.py\n    \u2502   \u251c\u2500\u2500 commands.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u2514\u2500\u2500 queries.py\n    \u2514\u2500\u2500 tests\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u251c\u2500\u2500 pytest.ini\n        \u2514\u2500\u2500 test_article\n            \u251c\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 test_commands.py\n            \u2514\u2500\u2500 test_queries.py\n</code></pre> <p>Adesso possiamo implementare la nostra query:</p> <pre><code>from typing import List\n\nfrom pydantic import BaseModel\n\nfrom blog.models import Article\n\n\nclass ListArticlesQuery(BaseModel):\n\n    def execute(self) -&gt; List[Article]:\n        articles = Article.list()\n\n        return articles\n</code></pre> <p>Anche se non abbiamo dei parametri, per consistenza, abbiamo ereditato da <code>BaseModel</code>.</p> <p>Eseguiamo nuovamente i test:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Adesso dovrebbero passare.</p>"},{"location":"material/05_advanced_python/03_tdd/#get-article-by-id","title":"Get Article by ID","text":"<p>Ottenere un articolo dal suo ID pu\u00f2 essere fatto in modo simile all'elenco di tutti gli aritcopli. Aggiungiamo un nuovo test per GetArticleByIDQuery a test_queries.py:</p> <pre><code>from blog.models import Article\nfrom blog.queries import ListArticlesQuery, GetArticleByIDQuery\n\n\ndef test_list_articles():\n    \"\"\"\n    GIVEN 2 articles stored in the database\n    WHEN the execute method is called\n    THEN it should return 2 articles\n    \"\"\"\n    Article(\n        author=\"jane@doe.com\",\n        title=\"New Article\",\n        content=\"Super extra awesome article\"\n    ).save()\n    Article(\n        author=\"jane@doe.com\",\n        title=\"Another Article\",\n        content=\"Super awesome article\"\n    ).save()\n\n    query = ListArticlesQuery()\n\n    assert len(query.execute()) == 2\n\n\ndef test_get_article_by_id():\n    \"\"\"\n    GIVEN ID of article stored in the database\n    WHEN the execute method is called on GetArticleByIDQuery with an ID\n    THEN it should return the article with the same ID\n    \"\"\"\n    article = Article(\n        author=\"jane@doe.com\",\n        title=\"New Article\",\n        content=\"Super extra awesome article\"\n    ).save()\n\n    query = GetArticleByIDQuery(\n        id=article.id\n    )\n\n    assert query.execute().id == article.id\n</code></pre> <p>Eseguiamo i test per assicurarci che falliscano:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Adesso, aggiungiamo GetArticleByIDQuery a queries.py:</p> <pre><code>from typing import List\n\nfrom pydantic import BaseModel\n\nfrom blog.models import Article\n\n\nclass ListArticlesQuery(BaseModel):\n\n    def execute(self) -&gt; List[Article]:\n        articles = Article.list()\n\n        return articles\n\n\nclass GetArticleByIDQuery(BaseModel):\n    id: str\n\n    def execute(self) -&gt; Article:\n        article = Article.get_by_id(self.id)\n\n        return article\n</code></pre> <p>I test dovrebbero adesso passare:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Bene. Abbiamo rispettato tutti i requisiti su menzionati:</p> <ul> <li>gli articoli possono essere creati</li> <li>gli articoli possono essere estratti</li> <li>gli articoli possono essere elencati</li> </ul> <p>E tutto viene coperto da test. Dal momento che stiamo usando pydantic per la validazione dei dati a runtime, non abbiamo bisogno di molti test per coprire la logica di business in quanto non dobbiamo scrivere dei test per validare i dati. Se author non \u00e8 una email valida, pydantic lancer\u00e0 un errore. Tutto quello che era necessario era impostare l'attributo author al tipo EmailStr. Non dobbiamo testarlo perch\u00e9 \u00e8 gi\u00e0 stato testato dai mantainer di pydantic.</p> <p>Con questo, siamo pronti ad esporre questa funzionalit\u00e0 al mondo mediante una API RESTful Flask.</p>"},{"location":"material/05_advanced_python/03_tdd/#esporre-lapi-con-flask","title":"Esporre l'API con Flask","text":"<p>Introdurremo tre endpoint che coprono questo requisito.</p> <ul> <li>/create-article/ - creiamo un nuovo articolo</li> <li>/article-list/ - recuperiamo tutti gli articoli</li> <li>/article// - estraiamo un singolo articolo <p>Per prima cosa, creiamo una cartella chiamata schemas in test_article, ed aggiungiamo due schemi JSON alla stessa, Article.json ed ArticleList.json.</p> <p>```json \"Article.json\" {   \"$schema\": \"http://json-schema.org/draft-07/schema#\",   \"title\": \"Article\",   \"type\": \"object\",   \"properties\": {     \"id\": {       \"type\": \"string\"     },     \"author\": {       \"type\": \"string\"     },     \"title\": {       \"type\": \"string\"     },     \"content\": {       \"type\": \"string\"     }   },   \"required\": [\"id\", \"author\", \"title\", \"content\"] } <pre><code>```json \"ArticleList.json\"\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"ArticleList\",\n  \"type\": \"array\",\n  \"items\": {\"$ref\":  \"file:Article.json\"}\n}\n</code></pre></p> <p>Gli schemi JSON usati per definire le risposte dagli endpoint API. Prima di continuare, installiamo la libreria jsonschema, che sar\u00e0 usata per validare i payload JSON, e Flask:</p> <pre><code>(venv)$ pip install jsonschema Flask\n</code></pre> <p>A questo punto, scriamo dei test di integrazione per la nostra API. Aggiungiamo un nuovo file chiamato testapp.py a testarticle:</p> <pre><code>import json\nimport pathlib\n\nimport pytest\nfrom jsonschema import validate, RefResolver\n\nfrom blog.app import app\nfrom blog.models import Article\n\n\n@pytest.fixture\ndef client():\n    app.config[\"TESTING\"] = True\n\n    with app.test_client() as client:\n        yield client\n\n\ndef validate_payload(payload, schema_name):\n    \"\"\"\n    Validate payload with selected schema\n    \"\"\"\n    schemas_dir = str(\n        f\"{pathlib.Path(__file__).parent.absolute()}/schemas\"\n    )\n    schema = json.loads(pathlib.Path(f\"{schemas_dir}/{schema_name}\").read_text())\n    validate(\n        payload,\n        schema,\n        resolver=RefResolver(\n            \"file://\" + str(pathlib.Path(f\"{schemas_dir}/{schema_name}\").absolute()),\n            schema  # it's used to resolve the file inside schemas correctly\n        )\n    )\n\n\ndef test_create_article(client):\n    \"\"\"\n    GIVEN request data for new article\n    WHEN endpoint /create-article/ is called\n    THEN it should return Article in json format that matches the schema\n    \"\"\"\n    data = {\n        'author': \"john@doe.com\",\n        \"title\": \"New Article\",\n        \"content\": \"Some extra awesome content\"\n    }\n    response = client.post(\n        \"/create-article/\",\n        data=json.dumps(\n            data\n        ),\n        content_type=\"application/json\",\n    )\n\n    validate_payload(response.json, \"Article.json\")\n\n\ndef test_get_article(client):\n    \"\"\"\n    GIVEN ID of article stored in the database\n    WHEN endpoint /article/&lt;id-of-article&gt;/ is called\n    THEN it should return Article in json format that matches the schema\n    \"\"\"\n    article = Article(\n        author=\"jane@doe.com\",\n        title=\"New Article\",\n        content=\"Super extra awesome article\"\n    ).save()\n    response = client.get(\n        f\"/article/{article.id}/\",\n        content_type=\"application/json\",\n    )\n\n    validate_payload(response.json, \"Article.json\")\n\n\ndef test_list_articles(client):\n    \"\"\"\n    GIVEN articles stored in the database\n    WHEN endpoint /article-list/ is called\n    THEN it should return list of Article in json format that matches the schema\n    \"\"\"\n    Article(\n        author=\"jane@doe.com\",\n        title=\"New Article\",\n        content=\"Super extra awesome article\"\n    ).save()\n    response = client.get(\n        \"/article-list/\",\n        content_type=\"application/json\",\n    )\n\n    validate_payload(response.json, \"ArticleList.json\")\n</code></pre> <p>Che cosa sta succedendo qui?</p> <p>Per prima cosa, definiamo il client di test Flask come una fixture, in modo che possa essere usato nei test. A questo punto, aggiungiamo una funzione per la validazione dei payload. In tal senso, usiamo due parametri:</p> <ul> <li>payload - la risposta JSON dall'API</li> <li>schema_name: il nome del file dello schema all'interno della cartella \"schemas\"</li> </ul> <p>Infine, ci sono tre test, uno per ogni endpoint. All'interno di ciascun test vi \u00e8 una chiamata all'API e la validazione del payload restituito.</p> <p>Eseguiamo i test per assicurarci che falliscano a questo punto:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Adesso possiamo scrivere le API.</p> <p>Aggiorniamo <code>app.py</code> come segue:</p> <pre><code>from flask import Flask, jsonify, request\n\nfrom blog.commands import CreateArticleCommand\nfrom blog.queries import GetArticleByIDQuery, ListArticlesQuery\n\napp = Flask(__name__)\n\n\n@app.route(\"/create-article/\", methods=[\"POST\"])\ndef create_article():\n    cmd = CreateArticleCommand(\n        **request.json\n    )\n    return jsonify(cmd.execute().dict())\n\n\n@app.route(\"/article/&lt;article_id&gt;/\", methods=[\"GET\"])\ndef get_article(article_id):\n    query = GetArticleByIDQuery(\n        id=article_id\n    )\n    return jsonify(query.execute().dict())\n\n\n@app.route(\"/article-list/\", methods=[\"GET\"])\ndef list_articles():\n    query = ListArticlesQuery()\n    records = [record.dict() for record in query.execute()]\n    return jsonify(records)\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>I nostri route handler sono abbastanza semplici dato che tutta la logica \u00e8 coperta da comandi e query. Le azioni disponibili con side effects, come mutazioni, sono rappresentate dai comandi (ad esempio, creare un nuovo articol). D'altro canto, le azioni che non hanno un side effect, quelle che stanno semplicemente leggendo lo stato corrente, sono coperte dalle query.</p> <p>I pattern delle query ed i comandi usati in questo articolo sono uina versioen semplificata del pattern CQRS. In pratica, stiamo combinando CQRS e CRUD.</p> <p>Il metodo <code>.dict()</code> di prima viene fornito dal BaseModel di pydantic, da cui tutti i nostri modelli ereditano.</p> <p>Il test dovrebbe avere successo:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Abbiamo coperto gli scenari \"corretti\". Nel mondo reale ci dovremo aspettare che i client non sempre useranno le API come dovrebbero. Ad esempio, quando la richiesta per creare un articolo \u00e8 fatta senz aun titolo, sar\u00e0 lanciato un errore dal comando CreateArticleCommand, che risulter\u00e0 in un errore interno del server ed uno status HTTP 500. Questo \u00e8 qualcosa che vogliamo evitare. Quindi, dobbiamo gestire questi errori in modo da notificare l'utente della richiesta sbagliata in maniera \"soft\".</p> <p>Scriviamo dei test per coprire questi casi. Aggiungiamo il seguente a <code>test_app.py</code>:</p> <pre><code>@pytest.mark.parametrize(\n    \"data\",\n    [\n        {\n            \"author\": \"John Doe\",\n            \"title\": \"New Article\",\n            \"content\": \"Some extra awesome content\"\n        },\n        {\n            \"author\": \"John Doe\",\n            \"title\": \"New Article\",\n        },\n        {\n            \"author\": \"John Doe\",\n            \"title\": None,\n            \"content\": \"Some extra awesome content\"\n        }\n    ]\n)\ndef test_create_article_bad_request(client, data):\n    \"\"\"\n    GIVEN request data with invalid values or missing attributes\n    WHEN endpoint /create-article/ is called\n    THEN it should return status 400\n    \"\"\"\n    response = client.post(\n        \"/create-article/\",\n        data=json.dumps(\n            data\n        ),\n        content_type=\"application/json\",\n    )\n\n    assert response.status_code == 400\n    assert response.json is not None\n</code></pre> <p>Abbiamo usato l'opzione parametrize di pytest, che semplifica il passaggio di pi\u00f9 input ad un singolo test.</p> <p>I test dovrebbero fallire a questo punto perch\u00e9 non abbiamo ancora gestito il <code>ValidationError</code>:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre> <p>Aggiungiamo un error handler all'app Flask all'interno di <code>app.py</code>:</p> <pre><code>from pydantic import ValidationError\n\n# Other code ...\n\napp = Flask(__name__)\n\n\n@app.errorhandler(ValidationError)\ndef handle_validation_exception(error):\n    response = jsonify(error.errors())\n    response.status_code = 400\n    return response\n\n# Other code ...\n</code></pre> <p>Il <code>ValidationError</code> ha un metodo per la gestione degli errori che restituisce una lista di tutti gli errori per ogni campo che \u00e8 mancante o passa un valore che non ha passato la validazione. Possiamo semplicemente restituire qeusto nel corpo ed impostare lo status della rsiposta a 400.\u00f9</p> <p>Ora che l'errore \u00e8 propriamente gestito, tutti i test dovrebbero passare:</p> <pre><code>(venv)$ python -m pytest tests\n</code></pre>"},{"location":"material/05_advanced_python/03_tdd/#code-coverage","title":"Code Coverage","text":"<p>Adesso, con l'applicazione testata, \u00e8 il momento di controlare la copertura del codice. Installiamo un plugin di pytest per far questo chiamato <code>pytest-cov</code>:</p> <pre><code>(venv)$ pip install pytest-cov\n</code></pre> <p>Dopo che il plugin \u00e8 installato, possiamo controllare il code coverage della nostra applicazione blog come segue:</p> <pre><code>(venv)$ python -m pytest tests --cov=blog\n</code></pre> <p>Dovremmo vedere qualcosa di simile:</p> <pre><code>---------- coverage: platform darwin, python 3.10.1-final-0 ----------\nName               Stmts   Miss  Cover\n--------------------------------------\nblog/__init__.py       0      0   100%\nblog/app.py           25      1    96%\nblog/commands.py      16      0   100%\nblog/models.py        57      1    98%\nblog/queries.py       12      0   100%\n--------------------------------------\nTOTAL                110      2    98%\n</code></pre> <p>Il 98% \u00e8 un buon risultato, ma dobbiamo sempre ricordarci che un'alta percentuale di copertura \u00e8p buyona, ma la qualit\u00e0 dei nostri test \u00e8 molto pi\u00f9 importante. Se soltanto il 70% o meno del codice \u00e8 coiperto, dovremmo pensare a come aumentare la percentuale di copertura; in generale, per\u00f2, non ha senso scrivere test che vadano dal 98 al 100$ (di nuovo, i test devono essere mantenuti proprio come la nostra logica di business).</p>"},{"location":"material/05_advanced_python/03_tdd/#test-end-to-end","title":"Test end-to-end","text":"<p>Abbiamo un'API funzionante a questo punto che \u00e8 completamente testata. Possiamo adesso guardare a come scrivere dei test end-to-end (e2e). Dal momento che abbiamo una semplice API, possiamos crivere un singolo test e2e per coprire il seguente scenario:</p> <ul> <li>creare un nuovo articolo</li> <li>redigere la lista degli articoli</li> <li>ottenere il primo articolo della lsita</li> </ul> <p>Per prima cosa, installiamo la libreria requests:</p> <pre><code>(venv)$ pip install requests\n</code></pre> <p>A  questo punto, aggiungiamo un nuovo test a <code>test_app.py</code>:</p> <pre><code>import requests\n# other code ...\n\n@pytest.mark.e2e\ndef test_create_list_get(client):\n    requests.post(\n        \"http://localhost:5000/create-article/\",\n        json={\n            \"author\": \"john@doe.com\",\n            \"title\": \"New Article\",\n            \"content\": \"Some extra awesome content\"\n        }\n    )\n    response = requests.get(\n        \"http://localhost:5000/article-list/\",\n    )\n\n    articles = response.json()\n\n    response = requests.get(\n        f\"http://localhost:5000/article/{articles[0]['id']}/\",\n    )\n\n    assert response.status_code == 200\n</code></pre> <p>Ci sono due cose che dobbiamo fare prima di eseguire questo test. Per prima cosa, registriamo un marker chiamato e2e con pytest aggiungendo il seguente codice a <code>pytest.ini</code>:</p> <pre><code>[pytest]\nmarkers =\n    e2e: marks tests as e2e (deselect with '-m \"not e2e\"')\n</code></pre> <p>I marker pytest sono usati per escludere dei test dall'esecuzione, o per includere i test selezionati indipendentemente dalla loro posizione.</p> <p>Per eseguire soltanto i test e2e, eseguiamo:</p> <pre><code>(venv)$ python -m pytest tests -m 'e2e'\n</code></pre> <p>Per eseguire tutti i test ad eccezione degli e2e:</p> <pre><code>(venv)$ python -m pytest tests -m 'not e2e'\n</code></pre> <p>I test e2e sono pi\u00f9 costosi da eseguire e richiedono che l'app sia configurata ed in esecuzione, per cui probabilmente non vorremo eseguirli sempre.</p> <p>Dal momento che i nostri test e2e vanno a riguardare un server live, dovremo lanciare l'app. Navighiamo nel progetto in un nuovo terminale, attiviamo l'am,biente virtuale, ed esegfuiamo l'app:</p> <pre><code>(venv)$ FLASK_APP=blog/app.py python -m flask run\n</code></pre> <p>Adesso possiamo eseguire il nostro test e2e:</p> <pre><code>(venv)$ python -m pytest tests -m 'e2e'\n</code></pre> <p>Dovremmo vedere un errore 500. Perch\u00e9? Non \u00e8 passato l'unit test? S\u00ec. Il problema \u00e8 che non abbiamo creato la tabella del database. Abbiamo suato delle fixture per questo nei nostri test che lo fanno per noi. Creiamo quindi una tabella ed un datrabase.</p> <p>Aggiungiamo un file <code>inti_db.py</code> nella cartella blog:</p> <pre><code>if __name__ == \"__main__\":\n    from blog.models import Article\n    Article.create_table()\n</code></pre> <p>Eseguiamo il nuovo script e lanciamo di nuovo il server:</p> <pre><code>(venv)$ python blog/init_db.py\n(venv)$ FLASK_APP=blog/app.py python -m flask run\n</code></pre> <p>Se abbiamo dei problemi nell'eseguire <code>init_db.py</code>, dovremmo voler impostare il pathg Python:</p> <pre><code>export PYTHONPATH=$PYTHONPATH:$PWD.\n</code></pre> <p>I test dovrebbero adesso passare.</p> <pre><code>(venv)$ python -m pytest tests -m 'e2e'\n</code></pre>"},{"location":"material/05_advanced_python/03_tdd/#testing-pyramid","title":"Testing Pyramid","text":"<p>Abbiamo iniziato con gli unit test (per testare i comandi e le query) seguiti dagli integration test (per testare gli endpoint), ed abbiamo finito con i test e2e. In semplici applicazioni, come in questo esempio, possiamo finire con un unmero simile di unit ed integration test. In generale, maggiore \u00e8 la complessit\u00e0, pi\u00f9 dovremmo vedere una forma simile ad una piramide in termini della relazione tra unit, integration e test e2e. Qui \u00e8 da dove viene il termine \"test pyramid\".</p> <p>La Test Pyramid \u00e8 un framework che ci aiuta a creare del software di alta qualit\u00e0.</p>"},{"location":"material/05_advanced_python/03_tdd/#test-pyramid","title":"Test Pyramid","text":"<p>Usando il concetto di Test Pyramid come guida, vogliamo tipicamente che il 50% dei test nella nostra test suite sia unit test, il 30% integration test, ed il 20% e2e test.</p> Tipo di test Descrizione Unit test Testa una singola unit\u00e0 di codice Integration test Testa che pi\u00f9 unit\u00e0 lavorino insieme Test e2e Testa l'intera applicazione in un ambiente simile a quello di produzione <p>Pi\u00f9 in alto andiamo nella piramide, pi\u00f9 BRITTLE e meno predicibili sono i nostri test. Inoltre, i test e2e sono di gran lunga i pi\u00f9 lenti da eseguire, per cui anche se possono assicurarci che la nsotra applicazione stia facendo quello per cui ci si aspetta che funzioni, non dovremmo averne cos\u00ec tanti come gli unit o integration test.</p>"},{"location":"material/05_advanced_python/03_tdd/#cosa-e-una-unit","title":"Cosa \u00e8 una Unit?","text":"<p>E' semplice capire cosa sono i test e2e e quelli di integration. Vi \u00e8 molta pi\u00f9 discussione a riguardo degli unit test dal momento che dobbiamo per prima cosa definire quello che \u00e8 in effetti una \"unit\". La maggior parte dei tutotrial ci mostra che una unit \u00e8 una singola funzione o metodo. Purtroppo, il codice nei casi reali non \u00e8 quasi mai cos\u00ec semplice.</p> <p>Tuttavia, prima di definire quello che \u00e8 una unit, vediamo qual \u00e8 il motivo per cui effettuare il test, e cosa dovrebbe essere testato.</p>"},{"location":"material/05_advanced_python/03_tdd/#perche-testare","title":"Perch\u00e9 testare?","text":"<p>Scriviamo dei test per:</p> <ul> <li>assicurarci che il nostro codice funzioni come atteso</li> <li>proteggiamo i software contro i problemi di regressione</li> </ul> <p>Nonostante questo, quando i cicli di feedback sono troppo lunghi, gli sviluppatori tendono ad iniziare a pensare pi\u00f9 sui tipi di test da scrivere dal momento che il tempo \u00e8 un vincolo importante nello sviluppo software. Ecco perch\u00e9 vogliamo avere pi\u00f9 unit test che altri tipi di test. Vogliamo trovare e fixare il difetto quanto prima possibile.</p>"},{"location":"material/05_advanced_python/03_tdd/#cosa-testare","title":"Cosa testare?","text":"<p>Ora che sappiamo che cosa dobbiamo testare, dobbiamo vedere quello che stiamo testando.</p> <p>Dovremmo testare il comportamento del nostro software. E, s\u00ec, questo si applica al TDD, non solo al BDD. Questo \u00e8 il motivo per cui non dovremmo dover cambiare i nostri test ogni volta che vi \u00e8 un cambio nella codebase.</p> <p>Pensiamo di nuovo all'esempio dell'applicazione reale. Da una prospettiva di testing, non ci interessa dove gli articoli sono mermozizati. Potrebbe trattarsi di un file di testo, un database relazionale, un insieme di coppie chiave/valore - non importa. Di nuovo, l'app ha i seguenti requisiti:</p> <ul> <li>gli articoli possono essere creati</li> <li>gli articoli possono essere estratti</li> <li>gli articoli possono essere messi in lista</li> </ul> <p>Fino a che questi requisiti non cambiano, un cambio nel mezzo di storage non romper\u00e0 i nostri test. In modo simile, sappiamo che fino a che questi test passano, sappiamo che i software rispettano i requisiti preposti, per cui sta funzionando.</p>"},{"location":"material/05_advanced_python/03_tdd/#per-cui-cosa-e-ununit","title":"Per cui cosa \u00e8 un'unit?","text":"<p>Ogni funzione/metodo \u00e8 tecnicamente un'unit\u00e0, ma non dobbiamo comunque testare ognuno di loro. Invece, dobbiamo focalizzarci sul test delle funzioni e metodi che sono pubblicamente esposti da un modulo/package.</p> <p>Nel nostro caso, questi erano i metodi execute. Non ci aspettiamo di chiamare il modello Article direttamente dall'API Flask, per cui non ci focalizziamo molto sul suo test. Per essere pi\u00f9 precisi, nel nostro caso, le \"unit\u00e0\" che devono essere testato sono i metodi execute dai comandi e dalle query. Se alcuni metodi non devono essere chiamati direttamente da altre parti del software o da un utilizzatore finale, siamo di fronte a dettagli implementativi, probabilmente. Di conseguenza, i nostri test sono resistenti al refacotring per i dettagli implementativi, che \u00e8 una delle qualit\u00e0 dei buoni test.</p> <p>Ad esempio, i nostri test passano se wrappiamo la logica per <code>get_by_id</code> e <code>get_by_title</code> in un metodo protetto chiamato getby_attribute:</p> <pre><code># other code ...\n\nclass Article(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    author: EmailStr\n    title: str\n    content: str\n\n    @classmethod\n    def get_by_id(cls, article_id: str):\n        return cls._get_by_attribute(\"SELECT * FROM articles WHERE id=?\", (article_id,))\n\n    @classmethod\n    def get_by_title(cls, title: str):\n        return cls._get_by_attribute(\"SELECT * FROM articles WHERE title = ?\", (title,))\n\n    @classmethod\n    def _get_by_attribute(cls, sql_query: str, sql_query_values: tuple):\n        con = sqlite3.connect(os.getenv(\"DATABASE_NAME\", \"database.db\"))\n        con.row_factory = sqlite3.Row\n\n        cur = con.cursor()\n        cur.execute(sql_query, sql_query_values)\n\n        record = cur.fetchone()\n\n        if record is None:\n            raise NotFound\n\n        article = cls(**record)  # Row can be unpacked as dict\n        con.close()\n\n        return article\n\n# other code ..\n</code></pre> <p>D'altro lato, se facciamo un breaking change all'interno di Article i test falliranno. E questo \u00e8 esattamente quello che vogliamo. In questa situazione, possiamo sia invertire il breaking change, o adattarlo all'interno del nostro comando o query-</p> <p>PErch\u00e9 c'\u00e8 una cosa per la quale stiamo STRIVING FOR: i test che passano significa che il nostro software funziona.</p>"},{"location":"material/05_advanced_python/03_tdd/#quando-usare-i-mocks","title":"Quando usare i mocks?","text":"<p>Non abbiamo usato dei mocks nei nostri test, perch\u00e9 non ne abbiamo avuto bisogno. I metodi di mocking o le classi all'interno dei moduli o package producono dei test che non sono resistenti al refactoring perch\u00e9 sono accoppiati ai dettagli implementativi. Questi test si \"rompono\" spesso e sono costosi da manuentere. D'altro canto, ha senso effettuare il mock di risorse esterne quando la velicit\u00e0 \u00e8 un problema (chiamata ad API eterne, invio di email, processi asincroni lunghi, etc.).</p> <p>Per esempio, possiamo testare il modello Article separatamente, ed effettuarne il mock all'interno dei nostri test per CreateArticleCommand come segue:</p> <pre><code>def test_create_article(monkeypatch):\n    \"\"\"\n    GIVEN CreateArticleCommand with valid properties author, title and content\n    WHEN the execute method is called\n    THEN a new Article must exist in the database with same attributes\n    \"\"\"\n    article = Article(\n        author=\"john@doe.com\",\n        title=\"New Article\",\n        content=\"Super awesome article\"\n    )\n    monkeypatch.setattr(\n        Article,\n        \"save\",\n        lambda self: article\n    )\n    cmd = CreateArticleCommand(\n        author=\"john@doe.com\",\n        title=\"New Article\",\n        content=\"Super awesome article\"\n    )\n\n    db_article = cmd.execute()\n\n    assert db_article.id == article.id\n    assert db_article.author == article.author\n    assert db_article.title == article.title\n    assert db_article.content == article.content\n</code></pre> <p>S\u00ec, questo \u00e8 perfettamente ok da fare, ma adesso abbiamo pi\u00f9 test da manutenere -- ovvero, tutti i test di prima pi\u00f9 tutti i nuovi test per i metodi in Article. Oltre questo, l'unica cosa che \u00e8 adesso testata da testcreatearticle \u00e8 che un articlo restituito dal metodo save \u00e8 lo stesso di quelli restituiti da exeute. Quando rompiamo qualcosa all'interno di Article questo test passer\u00e0 comunque perch\u00e9 ne abbiamo fatto il mocking. E questo \u00e8 qualcosa che vogliamo evitare: vogliamo testare il comportamento del software per assicurarci che funzionasse come atteso. In questo caso, il comportamento \u00e8 rotto ma i nostri test non lo mostreranno.</p>"},{"location":"material/05_advanced_python/03_tdd/#pensieri-finali","title":"Pensieri finali","text":"<p>Non c'\u00e8 un singolo modo giusto per testare il nostro software. Inoltre, \u00e8 pi\u00f9 facile testare la logica quando non \u00e8 accoppiata con il nostro database. Possiamo in tal senso usare il pattern Active Record with command adn queries (CQRS) per aiutarci in tal senso.</p> <p>E' opportuno focalizzarci sul valore di business del nostro codice.</p> <p>Non testiamo i metodi giusto per dire che sono stati testati. Abbiamo bisogno di software funzionale, non meotdi testati. Il TDD \u00e8 semplicemente un tool per dare software migliore pi\u00f9 velocemente ed in maniera pi\u00f9 affidabile. Lo stesso si pu\u00f2 dire per la copertura del codice: proviamo a mantenerla alta, ma non dobbiamo necessariamente aggiungere test semplicemente per averla al 100%.</p> <p>Un test ha valore soltanto quando ci protegge dalla regressione, ci permette il refacoring ,e ci offre un feedback rapido. Quindi, dovremmo fare in modo che i test assomiglino ad una forma piramidale (50% unit, 30% integraiton, 20% e2e). Questo anche se in applicazioni semplici pu\u00f2 sembrare pi\u00f9 una casa (40 unit, 40 integration, 20 e2e), il che va comunque bene.</p> <p>Pi\u00f9 rapidamente notiamo la regressione, pi\u00f9 velocemente possiamo intercettarla e correggerla. Pi\u00f9 velocemente la correggiamo, pi\u00f9 breve \u00e8 il ciclo di sviluppo. Per avere feedback pi\u00f9 rapidi, possiamo usare i marker di pytest per escludere e2e ed altri test lenti durante lo sviluppo. Possiaom eseguirli meno frequentemente.</p> <p>Usiamo i mock solo quanod necessario, come per le API di terze parit. Questi rendono il setup dei nostri test pi\u00f9 complicati ed i test meno resistenti al refactoring. Inoltre, possono risultare in falsi positivi.</p> <p>Di nuvoo, i test sono una vulnerabilit\u00f9\u00e0 e non un asset: dovremmo coprire il comportamento del software, ma non crearne un numero eccessivo.</p>"},{"location":"material/05_advanced_python/03_tdd/#conclusione","title":"Conclusione","text":"<p>C'\u00e8 molto da digerire qui. Teniamo a mente che questi sono solo esempi usati per mostrare le idee. Possiamo usare le stesse idee con il Domain-driven design (DDD), il Behavior-Driven design (BDD), e molti altri approcci. Teniamo a mente che i test dovrebbero essere trattati come altro codice: sono una vulnerabilit\u00e0, e non una risorsa. Scriviamo i test per proteggere i software dai bug, ma non permettiamo loro di bruciare il nostro tempo.</p>"},{"location":"material/05_advanced_python/04_code_quality/","title":"Cosa \u00e8 la code quality?","text":"<p>Cosa intendiamo per code quality? Come facciamo a misurarla? Come miglioriamo la code quality ed il nostro codice Python?</p> <p>In generale, la code quality si riferisce a quanto \u00e8 funzionale e manutenibile il nostro codice. Il codice viene considerato di alta qualit\u00e0 quando:</p> <ul> <li>segue il suo scopo;</li> <li>il suo comportamento pu\u00f2 essere testato;</li> <li>segue uno stile consistente;</li> <li>\u00e8 comprensibile;</li> <li>non contiene vulnerabilit\u00e0 di sicurezza;</li> <li>\u00e8 ben documentato;</li> <li>\u00e8 semplice da manutenere.</li> </ul> <p>DAl momento che abbiamo gi\u00e0 affrontato i primi due punti negli articoli precedenti, il focus di questo articolo \u00e8 sui punti successivi. In particolare, vedremo come migliorare la qualit\u00e0 del nostro codice Python mediante l'uso di linter, code formatter e scanner per le vulnerabilit\u00e0 di sicurezza.</p>"},{"location":"material/05_advanced_python/04_code_quality/#linter","title":"Linter","text":"<p>I linter evidenziano gli errori di programmazione, stile, i bug, ed i costrutti \"sospetti\" mediante l'analisi del codice sorgente. I tool di linting sono semplici da impostare, forniscono dei buoni valori di defautl, e migliorano l'esperienza complessiva di sviluppo rimuovendo le frizioni tra gli sviluppatori che hanno diverse opinioni sullo stile.</p> <p>Anche se il linting \u00e8 una pratica comune, \u00e8 ancora FROWNED da molti sviluppatori, dal momento che questi tendono ad essere molto spesso molto soggettivi.</p> <p>Vediamo un rapido esempio.</p> Prima versione<pre><code>numbers = []\n\nwhile True:\n    answer = input('Enter a number: ')\n    if answer != 'quit':\n        numbers.append(answer)\n    else:\n        break\n\nprint('Numbers: %s' % numbers)\n</code></pre> Versione due<pre><code>numbers = []\n\nwhile (answer := input(\"Enter a number: \")) != \"quit\":\n    numbers.append(answer)\n\nprint(f\"Numbers: {numbers}\")\n</code></pre> Versione tre<pre><code>numbers = []\n\nwhile True:\n    answer = input(\"Enter a number: \")\n    if answer == \"quit\":\n        break\n    numbers.append(answer)\n\nprint(f\"Numbers: {numbers}\")\n</code></pre> <p>Quale tra le precedenti \u00e8 migliore?</p> <p>In termini di funzionalit\u00e0, fanno praticamente la stessa cosa. Qual \u00e8 quella che preferiamo con i nostri collaboratori?</p> <p>Come sviluppatore, molto probabilmente lavirimo in team. E, in un team, \u00e8 molto importante che tutti gli sviluppatori seguano gli stessi standard di codice. Altrimenti, risulta essere molto pi\u00f9 complesso leggere il codice di qualcun altro. Il focus delle code reviews dovrebbe essere sui problemi ad alto livello, piuttosto che sui problemi sintattici di formattazione.</p> <p>Ad esempio, se decidiamo di terminare ogni frase con un punto esclamativo, sarebbe molto difficile per un lettore inferire il tono. Se andiamo avanti e ignoraiamo gli standard comuni come le lettere maiuscole e le regole per lo spacing, le frasi saranno molto difficili da leggere. Sar\u00e0 necessario molto pi\u00f9 \"cervello\" per leggerle. Perderemmo lettori e collaboratori. Lo stesso vale per il codice. USiamo le linee guida per rendere pi\u00f9 semplice ai nostri compagni sviluppatori (inclusi noi stessi) per trasferire gli intenti e collaborare ocn noi.</p> <p>Siamo fortunati come sviluppatori Python ad avere la guida PEP-8 a nostra disposizione, che fornisce un insieme di convenzioni, linee guida e best practices per rendere il nostro codice pi\u00f9 semplice da leggere e manutenere. Si focalizza sulle convenzioni dei nomi, commenti ai codici, e problemi al layout, come indentazioni e spazi. d esempio:</p> <ul> <li>una singola istruzione deve essere lunga al massimo 79 caratteri</li> <li>usare lo spazio al posto dei tab</li> <li>usare nomi di funzioni in minuscolo</li> </ul> <p>Per quello che riguarda i tool di linting, anche se ve ne sono molti in giro, per la maggior parte cercano gli errori nella logica del codice, o forzano gli standard di codice:</p> <ul> <li>code logic: questi controllano gli errori di programmazione, forzano gli standard, cercano i code smells, e controllano la complessit\u00e0 del codice. Pyflakes e McCabe sono i tool pi\u00f9 popolari per il linting della code logic.</li> <li>code style: questi controllano semplicemente gli standard del codcie sulla base del PEP-8. Un esempio di tool di questo tipo \u00e8 pycodestyle.</li> </ul>"},{"location":"material/05_advanced_python/04_code_quality/#flake8","title":"Flake8","text":"<p>Flake8 \u00e8 un wrapper di Pyflakes, pycodestyle e McCabe. Pu\u00f2 essere installato come qualsiasi altro package PyPI:</p> <pre><code>$ pip install flake8\n</code></pre> <p>Diciamo che abbiamo il seguente codice slavato in un file chiamato <code>my_module.py</code>:</p> <pre><code>from requests import *\n\ndef get_error_message(error_type):\n    if error_type == 404:\n        return 'red'\n    elif error_type == 403:\n        return 'orange'\n    elif error_type == 401:\n        return 'yellow'\n    else:\n        return 'blue'\n\n\ndef main():\n    res = get('https://api.github.com/events')\n    STATUS = res.status_code\n    if res.ok:\n        print(f'{STATUS}')\n    else:\n        print(get_error_message(STATUS))\n\n\n\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Per effettuare il linting di questo file, possiamo semplicemente eseguire il comando:</p> <pre><code>$ python -m flake8 my_module.py\n</code></pre> <p>Questo dovrebbe produrre il seguente output:</p> <pre><code>my_module.py:1:1: F403 'from requests import *' used; unable to detect undefined names\nmy_module.py:3:1: E302 expected 2 blank lines, found 1\nmy_module.py:15:11: F405 'get' may be undefined, or defined from star imports: requests\nmy_module.py:25:1: E303 too many blank lines (4)\n</code></pre> <p>Potremmo anche vedere un errore <code>my_module.py:26:11: W292 no newline at end of file</code> a seconda della configurazione della nostra IDE.</p> <p>Per ogni violazione viene stampata a schermo una riga che contiene i seguenti dati:</p> <ul> <li>percorso del file (relativo alla cartella da dove \u00e8 stato eseguito Flake8)</li> <li>numero di riga</li> <li>numero di colonna</li> <li>identificativo della regola violata</li> <li>descrizione della regola violata</li> </ul> <p>Le violazioni segnalate che iniziano con la F sono degli errori da Pyflakes, mentre quelle che iniziano con la E sono da pycodestyle.</p> <p>Dopo aver corretto le violazioni, dovremmo avere:</p> <pre><code>from requests import get\n\n\ndef get_error_message(error_type):\n    if error_type == 404:\n        return 'red'\n    elif error_type == 403:\n        return 'orange'\n    elif error_type == 401:\n        return 'yellow'\n    else:\n        return 'blue'\n\n\ndef main():\n    res = get('https://api.github.com/events')\n    STATUS = res.status_code\n    if res.ok:\n        print(f'{STATUS}')\n    else:\n        print(get_error_message(STATUS))\n\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Oltre a PyFlakes e pycodestile, possiamo usare Flake8 per controllare la CYCLOMATIC COMPLEXITY. Ad esempio, la funzione <code>get_error_message</code> ha una complessit\u00e0 pari a quattro, dal momento che ci sono quattro possibili branch (o percoris del codice):</p> <pre><code>def get_error_message(error_type):\n    if error_type == 404:\n        return 'red'\n    elif error_type == 403:\n        return 'orange'\n    elif error_type == 401:\n        return 'yellow'\n    else:\n        return 'blue'\n</code></pre> <p>Per forzare, ad esempio, una complessit\u00e0 massima di 3, eseguiamo la seguente istruzione:</p> <pre><code>$ python -m flake8 --max-complexity 3 my_module.py\n</code></pre> <p>Flake8 dovrebbe segnalare un errore del tipo:</p> <pre><code>my_module.py:4:1: C901 'get_error_message' is too complex (4)\n</code></pre> <p>Possiamo quindi effettuare un refactoring del tipo:</p> <pre><code>def get_error_message(error_type):\n    colors = {\n        404: 'red',\n        403: 'orange',\n        401: 'yellow',\n    }\n    return colors[error_type] if error_type in colors else 'blue'\n</code></pre> <p>Flake8 dovrebbe adesso dare esito positivo:</p> <pre><code>$ python -m flake8 --max-complexity 3 my_module.py\n</code></pre> <p>Possiamo aggiungere ulteriori controlli a Flake8 mediante il suo sistema di plugin. Ad esempio, per forzare le naming convention di PEP-8, isntalliamo pep8-naming:</p> <pre><code>$ pip install pep8-naming\n</code></pre> <p>Eseguendo:</p> <pre><code>$ python -m flake8 my_module.py\n</code></pre> <p>Dovremmo vedere:</p> <pre><code>my_module.py:15:6: N806 variable 'STATUS' in function should be lowercase\n</code></pre> <p>Per correggere:</p> <pre><code>def main():\n    res = get('https://api.github.com/events')\n    status = res.status_code\n    if res.ok:\n        print(f'{status}')\n    else:\n        print(get_error_message(status))\n</code></pre> <p>Tip</p> <p>Diamo un'occhiata ad Awesome Flake8 Extension per una lista delle estensioni pi\u00f9 popolari per Flake8.</p> <p>Tip</p> <p>Un altro tool popolare per il linting \u00e8 Pylama che, come Flake8, mette insieme diversi linter.</p>"},{"location":"material/05_advanced_python/04_code_quality/#code-formatters","title":"Code formatters","text":"<p>Mentre i linter si limitano a valutare problemi nel codice, i code formatter effettuano delle modifiche al codice sulla base di un insieme di standard.</p> <p>Note</p> <p>Mantenere un codice ben formattato che segue una precisa guida per il suo stile lo rende pi\u00f9 semplice da leggere, il che rende pi\u00f9 semplice individuare bug ed aggiungere nuovi sviluppatori. Riduce inoltre i conflitti che possono emergere in fase di merge.</p> <p>Di nuovo, dato che questo \u00e8 un compito stupido sul quale gli sviluppatori hanno spesso pareri soggettivi (tab vs spazi, singole vs doppie virgolette), usare un tool di code formatting per riformattare automaticamente il codice \u00e8 meglio.</p>"},{"location":"material/05_advanced_python/04_code_quality/#isort","title":"isort","text":"<p>isort viene usato per separare automaticamente gli import nei seguenti gruppi:</p> <ul> <li>standard library</li> <li>librerie di terze parti</li> <li>locali</li> </ul> <p>I diversi gruppi sono quindi ordinati in ordine alfabetico. Ad esempio:</p> <pre><code># standard library\nimport datetime\nimport os\n\n# third-party\nimport requests\nfrom flask import Flask\nfrom flask.cli import AppGroup\n\n# local\nfrom your_module import some_method\n</code></pre> <p>Per installare il tool:</p> <pre><code>$ pip install isort\n</code></pre> <p>Volendo, \u00e8 disponibile anche come plugin per Flake8, ed \u00e8 chiamato <code>flake8-isort</code>.</p> <p>Per eseguirlo su tutti i file nella cartella attuale e nelle sottocartelle:</p> <pre><code>$ python -m isort .\n</code></pre> <p>Invece, per eseguirlo su un singolo file:</p> <pre><code>$ python -m isort my_module.py\n</code></pre> <p>Prima avevamo:</p> <pre><code>import os\nimport datetime\nfrom your_module import some_method\nfrom flask.cli import AppGroup\nimport requests\nfrom flask import Flask\n</code></pre> <p>Dopo otteniamo:</p> <pre><code>import datetime\nimport os\n\nimport requests\nfrom flask import Flask\nfrom flask.cli import AppGroup\n\nfrom your_module import some_method\n</code></pre> <p>Per controllare se i nostri import sono ordinati in maniera corretta, possiamo usare il flag --check-only:</p> <pre><code>$ python -m isort my_module.py --check-only\n\nERROR: my_module.py Imports are incorrectly sorted and/or formatted.\n</code></pre> <p>Per vedere i cambi che saranno applicati (senza applicarli) usiamo il flag --diff:</p> <pre><code>$ python -m isort my_module.py --diff\n\n--- my_module.py:before      2022-02-28 22:04:45.977272\n+++ my_module.py:after       2022-02-28 22:04:48.254686\n@@ -1,6 +1,7 @@\n+import datetime\n import os\n-import datetime\n+\n+import requests\n+from flask import Flask\n+from flask.cli import AppGroup\n from your_module import some_method\n-from flask.cli import AppGroup\n-import requests\n-from flask import Flask\n</code></pre> <p>Dobbiamo usare l'opzione <code>--profile black</code> quando si usa isort con Black per evitare delle collisioni di code style:</p> <pre><code>$ python -m isort --profile black .\n</code></pre>"},{"location":"material/05_advanced_python/04_code_quality/#black","title":"Black","text":"<p>Black \u00e8 un formatter che viene usato per riformattare il codice sulla base delle style guide di Black, che \u00e8 molto simile a PEP-8.</p> <pre><code>$ pip install black\n</code></pre> <p>Tip</p> <p>Possiamo anche usare un plugin per Flake8, ovvero flake8-black.</p> <p>Al solito, per riformattare i file in maniera ricorsiva all'interno della cartella attuale:</p> <pre><code>$ python -m black .\n</code></pre> <p>Al solito, pu\u00f2 essere eseguito su un singolo file:</p> <pre><code>$ python -m black my_module.py\n</code></pre> <p>Prima abbiamo:</p> <pre><code>import pytest\n\n@pytest.fixture(scope=\"module\")\ndef authenticated_client(app):\n    client = app.test_client()\n    client.post(\"/login\", data=dict(email=\"dummy@email.ai\", password=\"notreal\"), follow_redirects=True)\n    return client\n</code></pre> <p>Dopo:</p> <pre><code>import pytest\n\n\n@pytest.fixture(scope=\"module\")\ndef authenticated_client(app):\n    client = app.test_client()\n    client.post(\n        \"/login\",\n        data=dict(email=\"dummy@email.ai\", password=\"notreal\"),\n        follow_redirects=True,\n    )\n    return client\n</code></pre> <p>Se vogliamo semplicemente vedere se il nostro codice segue gli standard dello stile Black, possiamo usare il flag <code>--check</code>:</p> <pre><code>$ python -m black my_module.py --check\n\nwould reformat my_module.py\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n1 file would be reformatted.\n</code></pre> <p>Il flag --diff invece ci mostra la differenza tra il codice attuale e quello che sar\u00e0 quello riformattato:</p> <pre><code>$ python -m black my_module.py --diff\n\n--- my_module.py        2022-02-28 22:04:45.977272 +0000\n+++ my_module.py        2022-02-28 22:05:15.124565 +0000\n@@ -1,7 +1,12 @@\n import pytest\n+\n\n @pytest.fixture(scope=\"module\")\n def authenticated_client(app):\n     client = app.test_client()\n-    client.post(\"/login\", data=dict(email=\"dummy@email.ai\", password=\"notreal\"), follow_redirects=True)\n-    return client\n\\ No newline at end of file\n+    client.post(\n+        \"/login\",\n+        data=dict(email=\"dummy@email.ai\", password=\"notreal\"),\n+        follow_redirects=True,\n+    )\n+    return client\nwould reformat my_module.py\n\nAll done! \u2728 \ud83c\udf70 \u2728\n1 file would be reformatted.\n</code></pre> <p>YAPF e autopep8 sono dei formatter simili a Black che meritano uno sguardo.</p>"},{"location":"material/05_advanced_python/04_code_quality/#security-vulnerability-scanners","title":"Security Vulnerability Scanners","text":"<p>Le vulnerabilit\u00e0 di sicurezza sono probabilmente l'aspetto pi\u00f9 importante della code quality, ma spesso sono ignorate. Il nostro codice \u00e8 sicuro solo come la sua parte meno sicura. Per fortuna, c'\u00e8 un gran numero di strumenti che ci aiutano ad individuare possibili vulnerabilit\u00e0 nel nostro codice. Vediamone un paio.</p>"},{"location":"material/05_advanced_python/04_code_quality/#bandit","title":"Bandit","text":"<p>Bandit \u00e8 uno strumento progettato per trovare dei problemi di sicurezza comuni nel codice Python, come stringhe con password in chiaro, codice untrusted che effettua la deserializzazione, usare pass in blocchi except, ed altro.</p> <pre><code>$ pip install bandit\n</code></pre> <p>Anche in questo caso abbiamo un plugin per Flake8, ovvero <code>flake8-bandit</code>. Eseguiamolo come segue:</p> <p><pre><code>$ bandit my_module.py\n</code></pre> Dato questo codice:</p> <pre><code>evaluate = 'print(\"Hi!\")'\neval(evaluate)\n\n\nevaluate = 'open(\"secret_file.txt\").read()'\neval(evaluate)\n</code></pre> <p>Dovremmo vedere i seguenti avvisi:</p> <pre><code>&gt;&gt; Issue: [B307:blacklist] Use of possibly insecure function - consider using safer\n    ast.literal_eval.\n   Severity: Medium   Confidence: High\n   Location: my_module.py:2\n   More Info:\n    https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b307-eval\n1   evaluate = 'print(\"Hi!\")'\n2   eval(evaluate)\n3\n\n--------------------------------------------------\n&gt;&gt; Issue: [B307:blacklist] Use of possibly insecure function - consider using safer\n    ast.literal_eval.\n   Severity: Medium   Confidence: High\n   Location: my_module.py:6\n   More Info:\n    https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b307-eval\n5   evaluate = 'open(\"secret_file.txt\").read()'\n6   eval(evaluate)\n\n--------------------------------------------------\n</code></pre>"},{"location":"material/05_advanced_python/04_code_quality/#safety","title":"Safety","text":"<p>Safety \u00e8 un altro tool che \u00e8 utile per mantenere il nostro codice libero da problemi di sicurezza. Viene usato per controllare le dipendenze installate per vulnerabilit\u00e0 di sicurezza conosciute rispetto a Safety DB, che \u00e8 un database di vulnerability di sicurezza conosciute nei package Python.</p> <pre><code>$ pip install safety\n</code></pre> <p>Con l'ambiente virtuale attivato, possiamo eseguirlo come segue:</p> <pre><code>$ safety check\n</code></pre> <p>Ecco un esempio di output con Flask v0.12.2:</p> <pre><code>+==============================================================================+\n|                                                                              |\n|                               /$$$$$$            /$$                         |\n|                              /$$__  $$          | $$                         |\n|           /$$$$$$$  /$$$$$$ | $$  \\__//$$$$$$  /$$$$$$   /$$   /$$           |\n|          /$$_____/ |____  $$| $$$$   /$$__  $$|_  $$_/  | $$  | $$           |\n|         |  $$$$$$   /$$$$$$$| $$_/  | $$$$$$$$  | $$    | $$  | $$           |\n|          \\____  $$ /$$__  $$| $$    | $$_____/  | $$ /$$| $$  | $$           |\n|          /$$$$$$$/|  $$$$$$$| $$    |  $$$$$$$  |  $$$$/|  $$$$$$$           |\n|         |_______/  \\_______/|__/     \\_______/   \\___/   \\____  $$           |\n|                                                          /$$  | $$           |\n|                                                         |  $$$$$$/           |\n|  by pyup.io                                              \\______/            |\n|                                                                              |\n+==============================================================================+\n| REPORT                                                                       |\n| checked 37 packages, using default DB                                        |\n+============================+===========+==========================+==========+\n| package                    | installed | affected                 | ID       |\n+============================+===========+==========================+==========+\n| flask                      | 0.12.2    | &lt;0.12.3                  | 36388    |\n| flask                      | 0.12.2    | &lt;1.0                     | 38654    |\n+==============================================================================+\n</code></pre> <p>Ora che conosciamo i tool, la prossima domanda \u00e8: quando usarli?</p> <p>Tipicamente, dovremmo usarli:</p> <ul> <li>mentre si fa il coding (all'interno della nostra IDE)</li> <li>a momento della commit</li> <li>quando il codice viene controllato nel source control mediante una pipeline di CI</li> <li>all'interno della nostra IDE</li> </ul> <p>E' meglio controllare dei problemi che possono avere un impatto negativo sulla qualit\u00e0 il prima possibile. Quindi, \u00e8 fortemente raccomandato effettuare il linting e la formattazione del codice durante lo sviluppo. Molti degli IDE pi\u00f9 popolari hanno dei linter e dei formatter integrati. Saremo in grado di trovare un plugin per il nostro editor per la maggior parte dei tool sopra menzionati. Alcuni plugin ci avvertono in tempo reale sulle violaizoni del code style e degli errori di programmazione.</p>"},{"location":"material/05_advanced_python/04_code_quality/#pre-commit-hooks","title":"pre-commit hooks","text":"<p>Dal momento che, inevitabilmente, ci perderemo un warning alle volte mentre scriviamo il nostro codice, \u00e8 una buona pratica controllare i problemi di qualit\u00e0 mentre facciamo la commit con dei pre-commit git hooks. Possiamo per prima cosa formattare il codice prima di effettuarne il linting. IN questo modo possiamo evitare di fear il commit di codice che non passer\u00e0 i controlli di qualit\u00e0 nella nostra pipeline di CI.</p> <p>Il framework di pre-commit \u00e8 raccomandato per gestire i git hooks.</p> <pre><code>$ pip install pre-commit\n</code></pre> <p>Una volta installato, aggiungiamo un file di configurazione pre-commit chiamato <code>.pre-commit-config.yaml</code> al nostro progetto. Per eseguire ad esempio Flake8, aggiungiamo la seguente configurazione:</p> <pre><code>repos:\n-   repo: https://gitlab.com/PyCQA/flake8\n    rev: 4.0.1\n    hooks:\n    -   id: flake8\n</code></pre> <p>Infine, impostiamo gli script git hook:</p> <pre><code>(venv)$ pre-commit install\n</code></pre> <p>Ora, ogni volta che effettuiamo una commit Flake8 sar\u00e0 eseguito prima della commit attuale. E se vi sono dei problemi, la commit sar\u00e0 abbandonata.</p>"},{"location":"material/05_advanced_python/04_code_quality/#ci-pipeline","title":"CI Pipeline","text":"<p>Anche se potremmo usare dei tool per la code qualit\u00e0 nel nostro editor e negli hook pre-commit, non possiamo sempre contare sul fatto che i nostri collaboratori facciano lo stesso. Di cosneguenza, dovremmo eseguire dei controlli per la code quality all'interno della nostra pipeline di CI. A questo punto, dovremmo eseguire dei linter e dei security vulnerability detector, assicurandoci che il codice segua un certo stile. Possiamo eseguire questi controlli in parallelo ai nostri test.</p>"},{"location":"material/05_advanced_python/04_code_quality/#un-esempio-reale","title":"Un esempio reale","text":"<p>Creiamo un semplice progetto di esempio per vedere come tutto questo funziona.</p> <p>PEr prima cosa, creiamo una nuova cartella:</p> <pre><code>$ mkdir flask_example\n$ cd flask_example\n</code></pre> <p>Adesso inizializziamo il nostro progetto con pipenv:</p> <pre><code>$ pipenv --three\n</code></pre> <p>A questo punto, installiamo Flask, pytest, Flake8, Black, isort, Bandit, e Safety:</p> <pre><code>$ pipenv install flask\n$ pipenv install --dev pytest flake8 black isort safety bandit\n</code></pre> <p>Creiamo un file che contenga i test chiamato <code>test_app.py</code>:</p> <pre><code>from app import app\nimport pytest\n\n\n@pytest.fixture\ndef client():\n    app.config['TESTING'] = True\n\n    with app.test_client() as client:\n        yield client\n\n\ndef test_home(client):\n    response = client.get('/')\n\n    assert response.status_code == 200\n</code></pre> <p>Aggiungiamo adesso un file per l'app Flask chiamato <code>app.py</code>:</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n\n@app.route('/')\ndef home():\n    return 'OK'\n\n\nif __name__ == '__main__':\n    app.run()\n</code></pre> <p>Adesso siamo pronti ad aggiungere la configurazione pre-commit.</p> <p>Per prima cosa, inizializziamo una nuova repository git:</p> <pre><code>$ git init\n</code></pre> <p>A questo punto, installiamo la pre-commit, ed impostiamo gli script di git hook:</p> <pre><code>$ pipenv install --dev pre-commit\n$ pipenv run pre-commit install\n</code></pre> <p>Creiamo un file di configurazione chiamato <code>.pre-commit-config.yaml</code>:</p> <pre><code>repos:\n-   repo: https://gitlab.com/PyCQA/flake8\n    rev: 4.0.1\n    hooks:\n    -   id: flake8\n</code></pre> <p>Prima di fare la commit, eseguiamo <code>isort</code> e Black:</p> <pre><code>$ pipenv run isort . --profile black\n$ pipenv run black .\n</code></pre> <p>Effettuiamo la commit per lanciare l'hook pre-commit:</p> <pre><code>$ git add .\n$ git commit -m 'Initial commit'\n</code></pre> <p>Infine, configuriamo una CI pipeline mediante GitHub Actions. Per farlo, creiamo la seguente struttura di file e cartelle:</p> <pre><code>.github\n\u2514\u2500\u2500 workflows\n    \u2514\u2500\u2500 main.yaml\n</code></pre> <p>Nel file <code>.github/workflows/main.yaml</code> inseriamo il seguente codice:</p> <pre><code>name: CI\non: [push]\n\njobs:\n  test:\n    strategy:\n      fail-fast: false\n      matrix:\n        python-version: [3.10.2]\n        poetry-version: [1.1.13]\n        os: [ubuntu-latest]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Run image\n        uses: abatilo/actions-poetry@v2.0.0\n        with:\n          poetry-version: ${{ matrix.poetry-version }}\n      - name: Install dependencies\n        run: poetry install\n      - name: Run tests\n        run: poetry run pytest\n  code-quality:\n    strategy:\n      fail-fast: false\n      matrix:\n        python-version: [3.10.2]\n        poetry-version: [1.1.13]\n        os: [ubuntu-latest]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Run image\n        uses: abatilo/actions-poetry@v2.0.0\n        with:\n          poetry-version: ${{ matrix.poetry-version }}\n      - name: Install dependencies\n        run: poetry install\n      - name: Run black\n        run: poetry run black . --check\n      - name: Run isort\n        run: poetry run isort . --check-only --profile black\n      - name: Run flake8\n        run: poetry run flake8 .\n      - name: Run bandit\n        run: poetry run bandit .\n      - name: Run saftey\n        run: poetry run safety check\n</code></pre> <p>Questa configurazione:</p> <ul> <li>viene eseguita ad ogni push (<code>on: [push]</code>)</li> <li>viene eseguita sull'ultima versione di Ubuntu (<code>ubuntu-latest</code>)</li> <li>usa Python 3.10.2 (<code>python-version: [3.10.2], python-version: ${{ matrix.python-version }}</code>)</li> <li>usa Pipenv nella versione X.X.X (<code>poetry-version: [1.1.13], poetry-version: ${{ matrix.poetry-version }}</code>)</li> </ul> <p>Vengono definiti due job: il test e la verifica della qualit\u00e0 del codice. Come suggerisce il nome, i test sono eseguiti nel job <code>test</code>, mentre i controlli per la code quality sono eseguiti nel job <code>code-quality</code>.</p> <p>Aggiungiamo la configurazione CI a git ed effettuiamo la commit:</p> <pre><code>$ git add .github/workflows/main.yaml\n$ git commit -m 'Add CI config'\n</code></pre> <p>Creiamo infine una nuova repository su GitHub, ed effettuiamo il push del nostro progetto al remote appena creato. Ad esempio:</p> <pre><code>$ git remote add origin git@github.com:jangia/flask_example.git\n$ git branch -M main\n$ git push -u origin main\n</code></pre> <p>Dovremmo vedere il nostro workflow eseguito sul tab Actions sulla nostra repository GitHub.</p>"},{"location":"material/05_advanced_python/04_code_quality/#conclusioni","title":"Conclusioni","text":"<p>Quello della qualit\u00e0 del codice \u00e8 uno dei topic pi\u00f9 soggettivi nello sviluppo software. Lo stile del codice, in particolare, \u00e8 un topic sensibile tra gli sviluppatori, dato che spendiamo molto del tempo di sviluppo leggendo codice. E' molto pi\u00f9 semplice leggere e comprendere quando il codice ha uno stile ocnsistente che aderisce agli standard PEP-8. Dal momento che questo \u00e8 un procedimento noioso, dovrebbe essere gestito da un computer mediante dei code formatter come Black ed isort. In modo simile, Flake8, Bandit e Safety ci aiutano ad assicurare che il codice sia sicuro e privo di errori.</p>"},{"location":"material/05_advanced_python/05_type_checking/","title":"Type checking","text":"<p>Note</p> <p>Cosa \u00e8 il type checking? Perch\u00e9 ne abbiamo bisogno? Qual \u00e8 la differentra tra type checking statico ed a runtime?</p> <p>Python \u00e8 un linguaggio fortemente tipizzato e che sfrutta la programmazione dinamica. In particolare, \u00e8 tipizzato in maniera dinamica: in pratica, i tipi sono inferiti dinamicamente, per cui possiamo imostare i valori di una vairbabile direttamente senza definirne il tipo come nei linguaggi di programmazione tipizzati staticamente come Java.</p> <p>What is type checking? Why do we need it? What's the difference between static and runtime type checking?</p>"},{"location":"material/05_advanced_python/05_type_checking/#linguaggi-di-programmazione-statici-vs-linguaggi-di-programmazione-dinamici","title":"Linguaggi di programmazione statici vs linguaggi di programmazione dinamici","text":"<p>I termini forte e dinamico indicano che i tipi sono inferiti a runtime, ma non possono essere tra loro mescolati. Ad esempio, <code>a = 1 + '0'</code> ci mostrer\u00e0 un errore. D'altro canto, JavaScript \u00e8 debolmente tipizzato e dinamico, per cui i tipi sono inferiti a runtime e pososno essere mescolati. Ad esempio, <code>a = 1 + '0'</code> ci dar\u00e0 10 come risultato.</p> <p>La tipizzazione dinamica ci porta una maggiore flessibilit\u00e0, ma non \u00e8 sempre desiderabile, per cui ci sono stati diversi sforzi per portare l'inferenza statica nei linguaggi dinamici.</p> <p>In questo articolo vedremo a cosa sono i type hints e come possono aituarci. Vedremo anche come possiamo usare il sistema di tipizzazione di Python per il type checking statico con mypy e come effettuar eil type checking a runtime con pydantic, marshmallow e typeguard.</p> <p>Tool per il type checking</p> <p>Esistono numerosi strumenti che usano i type hints per il type checking statico ed a runtime. Per una lista completa, consultiamo Awesome Python Typing.</p>"},{"location":"material/05_advanced_python/05_type_checking/#type-hints","title":"Type Hints","text":"<p>Il concetto di type hints \u00e8 stato aggiungo a Python nella versione 3.5. Questi hanno permesso aglis viluppatori di annotare i tipi attesi per le variabili, i parametri di funzione, ed i valori restituiti da una funzione all'interno del codice Python. Questi tipi non vengono forzati dall'interprete Python; tuttavia, offrono un certo numero di benefici. Per prima cosa, con i type hints, possiamo esprimere al meglio l'intento di ci\u00f2 che \u00e8 nel nostro codice, e di come utilizzarlo. Una migliore comprensione comporta meno bug.</p> <p>Ad esempio, diciamo di avere la seguente funzione epr calcolare la temperatura media in un giorno:</p> <pre><code>def daily_average(temperatures):\n    return sum(temperatures) / len(temperatures)\n</code></pre> <p>Finch\u00e9 forniamo una lista di temperature, la funzione lavora come previsto e restituisce il risultato atteso:</p> <pre><code>average_temperature = daily_average([22.8, 19.6, 25.9])\nprint(average_temperature)  # =&gt; 22.76666666666667\n</code></pre> <p>Cosa accade se chiamiamo la funzione con un dizionario dove le chiavi sono i timestamp delle misure ed i valori sono le temperature?</p> <pre><code>average_temperature = daily_average({1599125906: 22.8, 1599125706: 19.6, 1599126006: 25.9})\nprint(average_temperature)  # =&gt; 1599125872.6666667\n</code></pre> <p>In pratica, questa funzione restituisce la somma delle chiavi diviso il numero dichiavi, il che \u00e8 chiaramente sbagliato. Dal momento che la chiamata a funzione non ha lanciato un errore, questo potrebbe non essere individuato, specialmente se l'utente finale fornisce le temperature.</p> <p>Per evitare questa confusione, possiamo aggiungere i type hints marcando l'argomento ed il valore di ritorno:</p> <pre><code>from typing import List\n\n\ndef daily_average(temperatures: List[float]) -&gt; float:\n    return sum(temperatures) / len(temperatures)\n</code></pre> <p>Adesso la definizione della funzione ci dice che:</p> <ul> <li>le temperature dovrebbero essere una lista di float: <code>temperatures: List[float]</code></li> <li>la funzione dovrebbe restituire un float: <code>-&gt; float</code></li> </ul> <p>Verifichiamolo:</p> <pre><code>print(daily_average.__annotations__)\n# {'temperatures': typing.List[float], 'return': &lt;class 'float'&gt;}\n</code></pre> <p>I type hints permettono di usare dei tool di type checking statico. Le IDE li usano, mettendo in guardia l'utente quando l'uso di una certa funzione o metdono non \u00e8 quello atteso sulla base dei type hint e fornendo un'ottima funzione di autocompletamento.</p> <p>Di conmseguenza, i type hint sono nei fatti soltanto dei suggerimenti. Non sono vincolanti come le definizioni di tipo nei linguaggi tipizzati staticamente, in altre parole. Detto questo, anche se sono abbastanza flessibili, ci aiutano a migliorare la qualit\u00e0 del codice esprimendo pi\u00f9 chiaramente le nostre intenzioni. Oltre questo possiamo usare una serie di strumenti che ci aiutano a trarne beneficio.</p>"},{"location":"material/05_advanced_python/05_type_checking/#type-annotation-vs-type-hints","title":"Type annotation vs type hints","text":"<p>Le type annotation sono soltanto una sintassi per annotare gli input, output e variabili di una funzione:</p> <pre><code>def sum_xy(x: 'an integer', y: 'another integer') -&gt; int:\n    return x + y\n\nprint(sum_xy.__annotations__)\n# {'x': 'an integer', 'y': 'another integer', 'return': &lt;class 'int'}\n</code></pre> <p>I type hints sono costruiti \"sopra\" le annotation, per renderle pi\u00f9 utili. Gli hint e le annotation sono spesso usati in maniera intercambiabile, ma in realt\u00e0 sono differenti.</p>"},{"location":"material/05_advanced_python/05_type_checking/#il-modulo-typing","title":"Il modulo <code>typing</code>","text":"<p>Potremmo chiederci perch\u00e9 possiamo usare il float built-in per definire il tipo di ritorno di una funzione, ma la List invece viene importata direttamente dal modulo <code>typing</code>:</p> <pre><code>from typing import List\n\ndef daily_average(temperatures: List[float]) -&gt; float:\n    return sum(temperatures) / len(temperatures)\n</code></pre> <p>Prima di Python 3.9, l'interprete Python non supportava l'uso di built-in come argomenti per il type hinting. Ad ese mpio, era possibile usare una list come type hint come segue:</p> <pre><code>def daily_average(temperatures: list) -&gt; float:\n    return sum(temperatures) / len(temperatures)\n</code></pre> <p>Ma non era possibile definire il tipo atteso degli elementi di una lista (<code>List[float]</code>) senza il modulo <code>typing</code>. Lo stesso pu\u00f2 essere detto per i dizionari e le altre sequenze e tipi complessi:</p> <pre><code>from typing import Tuple, Dict\n\ndef generate_map(points: Tuple[float, float]) -&gt; Dict[str, int]:\n    return map(points)\n</code></pre> <p>Oltre questo, il modulo <code>typing</code> ci permette di defninire nuovi tipi, alias per tipi esistenti, usare il tipo <code>Any</code> e molte altre cose.</p> <p>Ad esempio, potremmo voler permettere pi\u00f9 tipi. In questo caso, possiamo suare una <code>Union</code>:</p> <pre><code>from typing import Union\n\ndef sum_ab(a: Union[int, float], b: Union[int, float]) -&gt; Union[int, float]:\n    return a + b\n</code></pre> <p>A partire da Python 3.9, possiamo usare i built-ins come segue:</p> <pre><code>def sort_names(names: list[str]) -&gt; list[str]:\n    return sorted(names)\n</code></pre>"},{"location":"material/05_advanced_python/05_type_checking/#static-type-checking-con-mypy","title":"Static Type Checking con mypy","text":"<p>mypy \u00e8 un tool per il type checking a compile time. Possiamo installarlo come ogni altro package Python:</p> <pre><code>$ pip install mypy\n</code></pre> <p>Per controllare il nostro modulo Python possiamo eseguirlo come segue:</p> <pre><code>$ python -m mypy my_module.py\n</code></pre> <p>Diamo di nuovo uno sguardo all'esempio <code>daily_average</code>:</p> <pre><code>def daily_average(temperatures):\n    return sum(temperatures) / len(temperatures)\n\naverage_temperature = daily_average(\n    {1599125906: 22.8, 1599125706: 19.6, 1599126006: 25.9}\n)\n</code></pre> <p>Quando effettuiamo il type checking con mypy su questo codice, non ci sono errori, dal momento che la funzione non usa dei type hints:</p> <pre><code>Success: no issues found in 1 source file\n</code></pre> <p>Aggiungiamo i type hint:</p> <pre><code>from typing import List\n\n\ndef daily_average(temperatures: List[float]) -&gt; float:\n    return sum(temperatures) / len(temperatures)\n\n\naverage_temperature = daily_average(\n    {1599125906: 22.8, 1599125706: 19.6, 1599126006: 25.9}\n)\n</code></pre> <p>Eseguiamo di nuovo <code>mypy</code>:</p> <pre><code>$ python -m mypy my_module.py\n</code></pre> <p>Dovremmo vedere un output di questo tipo:</p> <pre><code>my_module.py:9: error: Argument 1 to \"daily_average\" has incompatible\ntype \"Dict[int, float]\"; expected \"List[float]\"\n\nFound 1 error in 1 file (checked 1 source file)\n</code></pre> <p>mypy ha riconosciuto che la funzione era chiamata in maniera non corretta. Aveva riportato il nome del file, il numero di linea, e la descrizione dell'errore. Usare i type hint assieme a mypy pu\u00f2 aiutare a ridurre il numero di errori risultanti dall'uso sbagliato di funzioni, metodi, e classi. Questo risulta in loop di feedback pi\u00f9 rapidi. Non abbiamo bisogno di eseguire tutti i nostri test o effettuare il deploy dell'intera applicazione. Siamo notificati di questi errori immediatamente.</p> <p>E' anche una buona idea aggiungere mypy alla nostra CI pipeline, cos\u00ec come effetutare il type checking prima che sia fatto il merge o il deploy del nostro codice, come abbiamo detto nell'articolo sulla qualit\u00e0 del codice Python.</p> <p>Anche se rappresenta un grosos miglioramento in termini di qualit\u00e0 del codice, il type chekcing statico non forza i tipi a runtime. Questo \u00e8 il motivo per cui abbiamop anche dei type checker a runtime, che vedremo a brevev.</p> <p>mypy contiene anche typeshed, che contiene delle annotazioni di tipo esterne per la libreria standard Python e per i tipi integrati in Python, cos\u00ec come package di terze parti.</p> <p>mypy controlla i programmi Python senza alcun overhead a runtime. Anche se controlla i tipi, il duck typing \u00e8 sempre valido. Quindi, non pu\u00f2 essere usato per compilare le estensioni CPython.</p>"},{"location":"material/05_advanced_python/05_type_checking/#type-checking-a-runtime","title":"Type Checking a runtime","text":""},{"location":"material/05_advanced_python/05_type_checking/#pydantic","title":"pydantic","text":"<p>I type checker statici non ci aiutano con i dati da sorgenti esterne come gli utenti della nostra applciazione. Qui \u00e8 dove i runtime type checker entrano in gioco. Un tool per far questo \u00e8 pydantic, che viene usato per validare i dati. Lancia un errore di validazione quando i dati forniti non combaciano con un tipo definito con un type hint.</p> <p>pydantic usa il type casting per convertire i dati di input per forzarlo a conformarsi al tipo atteso.</p> <pre><code>$ pip install pydantic\n</code></pre> <p>E' abbastanza semplice da usare. Per esempio, definiamo una classe <code>Song</code> con alcuni attributi:</p> <pre><code>from datetime import date\nfrom typing import List\n\nfrom pydantic import BaseModel\n\n\nclass Song(BaseModel):\n    id: int\n    name: str\n    release: date\n    genres: List[str]\n</code></pre> <p>Ora, quando inizializziamo una nuova <code>Song</code> con dati validi, tutto funziona come atteso:</p> <pre><code>song = Song(\n    id=101,\n    name='Bohemian Rhapsody',\n    release='1975-10-31',\n    genres=[\n        'Hard Rock',\n        'Progressive Rock'\n    ]\n)\nprint(song)\n# id=101 name='Bohemian Rhapsody' release=datetime.date(1975, 10, 31)\n# genres=['Hard Rock', 'Progressive Rock']\n</code></pre> <p>Tuttavia, quando proviamoa d inizializzare una nuova Song con una data non valida viene lanciato un <code>ValidationError</code>:</p> <pre><code>song = Song(\n    id=101,\n    name='Bohemian Rhapsody',\n    release='1975-31-31',\n    genres=[\n        'Hard Rock',\n        'Progressive Rock'\n    ]\n)\nprint(song)\n# pydantic.error_wrappers.ValidationError: 1 validation error for Song\n# release\n#   invalid date format (type=value_error.date)\n</code></pre> <p>Con pydantic, possiamo assicurarci che soltanto i dati che combaciano con i tipi che abbiamo definito siano usati nella nostram applicazione. Questo comporta non solo meno bug, ma dovremo anche scrivere meno test. Usando strumenti come <code>pydantic</code> non dobbiamo scrivere test per i casi dove l'utente manda dei dati completamente errati. Tutto ci\u00f2 viene gestito da pydantic: infatti, viene lanciato un <code>ValidationError</code>. Ad esempio, FastAPI valida le richieste e le risposte HTTP mediante <code>pydantic</code>:</p> <pre><code>from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item):\n    return item\n</code></pre> <p>L'handler <code>create_item</code> si attende un payload con un nome (<code>string</code>) ed un prezzo (<code>float</code>). La risposta dovrebbe essere simile. Adesso, se c'\u00e8 un problema con il payload fornito, viene subito lanciato un errore. Lanciarlo in ritardo rende pi\u00f9 difficile effettuare il debug e determianre da dove \u00e8 venuto il dato di tipo errato. Inoltre, dal momento che \u00e8 gestito da pydantic, possiamo tenere i nostri handler pi\u00f9 puliti.</p> <p>Assieme allo sfruttare i type hiunts per la validazione dei dati possiamo anche aggiungere dei validator custom per assicurare la correttezza dei dati oltre al loro tipo. Aggiungere una validazione custom per un attirbuto \u00e8 abbastanza semplice. Per esempio, per prevenire i duplicati di genere nella classe <code>Song</code>, possiamo aggiugnere una validazione come segue:</p> <pre><code>from datetime import date\nfrom typing import List\n\nfrom pydantic import BaseModel, validator\n\n\nclass Song(BaseModel):\n    id: int\n    name: str\n    release: date\n    genres: List[str]\n\n    @validator('genres')\n    def no_duplicates_in_genre(cls, v):\n        if len(set(v)) != len(v):\n            raise ValueError(\n                'No duplicates allowed in genre.'\n            )\n        return v\n\n\nsong = Song(\n    id=101,\n    name='Bohemian Rhapsody',\n    release='1975-10-31',\n    genres=[\n        'Hard Rock',\n        'Progressive Rock',\n        'Progressive Rock',\n    ]\n)\nprint(song)\n# pydantic.error_wrappers.ValidationError: 1 validation error for Song\n# genre\n#   No duplicates allowed in genre. (type=value_error)\n</code></pre> <p>Per cui il metodo di validazione, <code>no_duplicates_in_genre</code>, deve essere decorato con un validator, che prende il nome dell'attributo come argomento. Il metodo di validazione deve essere un meotod di classe dal momento che la validazione avviene prima che l'istanza sia creata. Per i dati che falliscono la validazione dovrebbe lanciare un ValueError standard.</p> <p>Possiamo anche usare i metodi di validazioen per alterare un valore prima che avvenga la validazione. Per farlo, aggiungiamo <code>pre=True</code> ed <code>always=True</code> al decorator validator:</p> <pre><code>@validator('genres', pre=True, always=True)\n</code></pre> <p>Per esempio potremmo convertire i generi in minuscolo come segue:</p> <pre><code>from datetime import date\nfrom typing import List\n\nfrom pydantic import BaseModel, validator\n\n\nclass Song(BaseModel):\n    id: int\n    name: str\n    release: date\n    genres: List[str]\n\n    @validator('genres', pre=True, always=True)\n    def to_lower_case(cls, v):\n        return [genre.lower() for genre in v]\n\n    @validator('genres')\n    def no_duplicates_in_genre(cls, v):\n        if len(set(v)) != len(v):\n            raise ValueError(\n                'No duplicates allowed in genre.'\n            )\n        return v\n\n\nsong = Song(\n    id=101,\n    name='Bohemian Rhapsody',\n    release='1975-10-31',\n    genres=[\n        'Hard Rock',\n        'PrOgReSsIvE ROCK',\n        'Progressive Rock',\n    ]\n)\nprint(song)\n# pydantic.error_wrappers.ValidationError: 1 validation error for Song\n# genre\n#   No duplicates allowed in genre. (type=value_error)\n</code></pre> <p>In particolare, <code>to_lower_case</code> converte ogni elemento nella lista dei genere in minuscolo. Siccome <code>pre</code> \u00e8 impostato a <code>True</code>, questo metodo \u00e8 chiamato prima che pydantic validi i tipi. Tutti i generi sono convertiti in minuscolo e quindi validati con <code>no_duplicates_in_genre</code>.</p> <p>pydantic ci offre anche dei tipi pi\u00f9 stretti, come PositiveInt ed EmailStr, pre rendere le validazioni migliori. In tal senso, possiamo dare un'occhiata alla sezione Field Types della documentazione.</p>"},{"location":"material/05_advanced_python/05_type_checking/#marshmallow","title":"Marshmallow","text":"<p>Un altro tool degno di nota \u00e8 marshmallow, che ci aiuta a validare dati complessi e caricare o effettuare il dump di dati dao verso tipi Python nativi. Al solito, marshmallow si installa come ogni altro package Python:</p> <pre><code>$ pip install marshmallow\n</code></pre> <p>Come per pydantic, possiamo aggiungere la validazione di tipo ad una classe:</p> <pre><code>from marshmallow import Schema, fields, post_load\n\n\nclass Song:\n    def __init__(\n            self,\n            id,\n            name,\n            release,\n            genres\n    ):\n        self.id = id\n        self.name = name\n        self.release = release\n        self.genres = genres\n\n    def __repr__(self):\n        return (\n            f'&lt;Song(id={self.id}, name={self.name}), '\n            f'release={self.release.isoformat()}, genres={self.genres}&gt;'\n        )\n\n\nclass SongSchema(Schema):\n    id = fields.Int()\n    name = fields.Str()\n    release = fields.Date()\n    genres = fields.List(fields.String())\n\n    @post_load\n    def make_song(self, data, **kwargs):\n        return Song(**data)\n\n\nexternal_data = {\n    'id': 101,\n    'name': 'Bohemian Rhapsody',\n    'release': '1975-10-31',\n    'genres': ['Hard Rock', 'Progressive Rock']\n}\n\nsong = SongSchema().load(external_data)\nprint(song)\n# &lt;Song(id=101, name=Bohemian Rhapsody), release=1975-10-31, genres=['Hard Rock', 'Progressive Rock']&gt;\n</code></pre> <p>A differenza di pydantic, marshmallow non usa il type casting, per cui dobbiamo definire lo schemae la classe separatamente. Ad esempio, la data di uscita in <code>external_data</code> deve essere una stringa ISO. Non funziona con un oggetto di tipo <code>datetime</code>.</p> <p>Per abilitare la deserializzazione dei dati in un oggetto di tipo <code>Song</code>, dobbiamo aggiungere un metodo decorato con il decorator <code>@post_load</code> allo schema:</p> <pre><code>class SongSchema(Schema):\n    id = fields.Int()\n    name = fields.Str()\n    release = fields.Date()\n    genres = fields.List(fields.String(), validate=no_duplicates)\n\n    @post_load\n    def make_song(self, data, **kwargs):\n        return Song(**data)\n</code></pre> <p>Lo schema valida i dati e se tutti i campi sono validi crea un'istanza della classe chiamando <code>make_song</code> con i dati validati.</p> <p>Come pydantic, possiamo aggiungere delle validazioni custom per ogni attributo a partire dallo schema. Ad esempio, possiamo prevenire dei duplicati:</p> <pre><code>import datetime\n\nfrom marshmallow import Schema, fields, post_load, ValidationError\n\n\nclass Song:\n    def __init__(\n            self,\n            id,\n            name,\n            release,\n            genres\n    ):\n        self.id = id\n        self.name = name\n        self.release = release\n        self.genres = genres\n\n    def __repr__(self):\n        return (\n            f'&lt;Song(id={self.id}, name={self.name}), '\n            f'release={self.release.isoformat()}, genres={self.genres}&gt;'\n        )\n\n\ndef no_duplicates(genres):\n    if isinstance(genres, list):\n        genres = [\n            genre.lower()\n            for genre in genres\n            if isinstance(genre, str)\n        ]\n\n        if len(set(genres)) != len(genres):\n            raise ValidationError(\n                'No duplicates allowed in genres.'\n            )\n\n\nclass SongSchema(Schema):\n    id = fields.Int()\n    name = fields.Str()\n    release = fields.Date()\n    genres = fields.List(fields.String(), validate=no_duplicates)\n\n    @post_load\n    def make_song(self, data, **kwargs):\n        return Song(**data)\n\n\nexternal_data = {\n    'id': 101,\n    'name': 'Bohemian Rhapsody',\n    'release': '1975-10-31',\n    'genres': ['Hard Rock', 'Progressive Rock', 'ProgressivE Rock']\n}\n\nsong = SongSchema().load(external_data)\nprint(song)\n# marshmallow.exceptions.ValidationError:\n# {'genres': ['No duplicates allowed in genres.']}\n</code></pre> <p>Come possiamo vedere, possiamo sia usare pydantic sia marshmallow per assicurarci che i dati abbiano il tipo corretto man mano che la nostra applciazione viene eseguita. Il consiglio \u00e8 quello di scegliere quello che pi\u00f9 si adatta al nostro stile.</p>"},{"location":"material/05_advanced_python/05_type_checking/#typeguard","title":"Typeguard","text":"<p>Mentre pydantic e marshmallow si focalizzano sulla validazione e serializzazione dei dati, typeguard si focalizza sul controllo dei tipi man mano che le funzioni vengono chiamate. Mentre mypy efefttua soltanto il type checking statico, typeguard forza i tipi mentre il nostro prgramma \u00e8 in esecuzione.</p> <pre><code>$ pip install typeguard\n</code></pre> <p>Vediamo lo stesso esempio di prima (quello della classe Song). Questa volta definiamo il suo metodo <code>__init__</code> con gli argomenti hinted:</p> <pre><code>from datetime import date\nfrom typing import List\n\nfrom typeguard import typechecked\n\n\n@typechecked\nclass Song:\n\n    def __init__(\n            self,\n            id: int,\n            name: str,\n            release: date,\n            genres: List[str]\n\n    ) -&gt; None:\n        self.id = id\n        self.name = name\n        self.release = release\n        self.genres = genres\n\n\nsong = Song(\n    id=101,\n    name='Bohemian Rhapsody',\n    release=date(1975, 10, 31),\n    genres={\n        'Hard Rock',\n        'Progressive Rock',\n    }\n)\nprint(song)\n# TypeError: type of argument \"genres\" must be a list; got set instead\n</code></pre> <p>Il decorator <code>typechecked</code> pu\u00f2 essere usato sia per classi, sia per funzioni, quando vogliamo forzare il type checking a runtime. Eseguire questo codice lancer\u00e0 un <code>TypeError</code>, dal momento che i generi sono un set invece di una lista. Possiamo usare in modo simile un decorator per le funzioni:</p> <pre><code>from typeguard import typechecked\n\n@typechecked\ndef sum_ab(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <p>Viene anche fornito un plugin per pytest. Per controllare i tipi per il package <code>my_package</code> mentre eseguiamo i test possiamo eseguire questo comando:</p> <pre><code>$ python -m pytest --typeguard-packages=my_package\n</code></pre> <p>Quando eseguiamo il comando con pytest non dobbiamo usare il decorator <code>@typechecked</code>. Di conseguenza, possiamo o decorare le nostre funzioni e classi per forzare i tipi a runtime oppure semplicemente durante l'esecuzione dei test. Ad ogni modo, typeguard pu\u00f2 essere una rete di salvezza per la nostra applicazione, in modo da assicurarci che venga eseguita come ci si aspetta.</p>"},{"location":"material/05_advanced_python/05_type_checking/#flask-con-pydantic","title":"Flask con pydantic","text":"<p>Mettiamo insieme i diversi pezzi in un'applicazione web. Come detto prima, FastAPI usa pydantic di default. Anche se Flask non ha il supporto integrato di default per ppydantic, possiamo usare dei buinding per aggiungerlo alle nostre API. Creiamo quindi un nuovo progetto Flask per vederlo in azione.</p> <p>Per prima cosa, creiamo una nuova cartella:</p> <pre><code>$ mkdir flask_example\n$ cd flask_example\n</code></pre> <p>Quindi, inizializziamo il nostro progetto con Pipenv:</p> <pre><code>$ pipenv install flask Flask-Pydantic\n$ pipenv isntall -d pytest\n</code></pre> <p>Creiamo un file per i nostri test e chiamiamolo <code>test_app.py</code>:</p> <pre><code>import json\n\nimport pytest\n\nfrom app import app\n\n\n@pytest.fixture\ndef client():\n    app.config[\"TESTING\"] = True\n\n    with app.test_client() as client:\n        yield client\n\n\ndef test_create_todo(client):\n    response = client.post(\n        \"/todos/\",\n        data=json.dumps(\n            {\n                'title': 'Wash the dishes',\n                'done': False,\n                'deadline': '2020-12-12'\n            }\n        ),\n        content_type='application/json'\n    )\n\n    assert response.status_code == 201\n\n\ndef test_create_todo_bad_request(client):\n    response = client.post(\n        \"/todos/\",\n        data=json.dumps(\n            {\n                'title': 'Wash the dishes',\n                'done': False,\n                'deadline': 'WHENEVER'\n            }\n        ),\n        content_type='application/json'\n    )\n\n    assert response.status_code == 400\n</code></pre> <p>Qui abbiamo due test per creare nuovi todo. Uno controlla che  lo stato di <code>201</code> sia restituito quando tutto va bene. Un altro controlla che lo status <code>400</code> sia restituito quando i dati forniti non sono quelli attesi. </p> <p>Quindi, aggiungiamo un file per l'app Flask chiamato <code>app.py</code>:</p> <pre><code>import datetime\n\nfrom flask import Flask, request\nfrom flask_pydantic import validate\nfrom pydantic import BaseModel\n\napp = Flask(__name__)\n\n\nclass CreateTodo(BaseModel):\n    title: str\n    done: bool\n    deadline: datetime.date\n\n\nclass Todo(BaseModel):\n    title: str\n    done: bool\n    deadline: datetime.date\n    created_at: datetime.datetime\n\n\n@app.route(\"/todos/\", methods=['POST'])\n@validate(body=CreateTodo)\ndef todos():\n    todo = Todo(\n        title=request.body_params.title,\n        done=request.body_params.done,\n        deadline=request.body_params.deadline,\n        created_at=datetime.datetime.now()\n    )\n\n    return todo, 201\n\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre> <p>Abbiamo definito un endpoint per creare i todo assieme ad uno schema di richieste chiamato <code>CreateTodo</code> ed uno di risposte chiamato <code>Todo</code>. Ora, quando i dati sono mandati all'API che non rispetta lo schema della richiest,a uno status di <code>400</code> con errori di validazione nel corpo viene restituito. Possiamo eseguire i test per controllare che l'API si stia comportando come descritto:</p> <pre><code>$ pipenv run pytest\n</code></pre>"},{"location":"material/05_advanced_python/05_type_checking/#eseguire-i-type-checker","title":"Eseguire i type checker","text":"<p>Ora che conosciamo gli strumenti, la domanda \u00e8: quando usarli?</p> <p>In maneira simile ai tool di controllo di qualit\u00e0 del codice, tipicamente eseguiamo i type checker:</p> <ul> <li>quando stiamo programmando (all'interno quindi della nostra IDE);</li> <li>al momento della commit (mediante gli hook pre-commit);</li> <li>quando il codice viene mandato su una repository (mediante una pipeline di CI);</li> <li>durante l'esecuzione del nostro programma (a runtime).</li> </ul>"},{"location":"material/05_advanced_python/05_type_checking/#allinterno-della-nostra-ide","title":"All'interno della nostra IDE","text":"<p>E' bene controallare problemi che possano avere un impatto negativo sulla qualit\u00e0 del codice spesso. QUindi, \u00e8 raccomadnato effettuare il check statico del codice durante lo sviluppo. Molte delle IDE pi\u00f9 popolari hanno dei type checkers simili a mypy (o mypy stesso) gi\u00e0 integrati. Per quelle che non li hanno, vi \u00e8 probabilmente un plugin disponibile. Questi plugin ci avvertono in tempo reale su eventuali violazioni di tipo e potenziali errori di programmazione.</p>"},{"location":"material/05_advanced_python/05_type_checking/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Dal momento che inevitabilmente ci perderemo qualche warning mentre stiamo programmando, \u00e8 una buona pratica controllare problemi sui tipi al momento della commit mediante dei pre-commit hooks. In questo modo possiamoe vitare di effettaure la commit di codice che non passer\u00e0 i type check all'interno della nostra pipeline di CI.</p> <p>Il framework pre-commit \u00e8 quello raccomandato per la gestione dei git hooks:</p> <pre><code>$ pip install pre-commit\n</code></pre> <p>Una volta installato, aggiungiamo un file di cofnigurazione pre-commit chiamato <code>.pre-commit-config.yaml</code> al nostro progetto. Per eseguire mypy, aggiungiamo la seguente configurazione:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: 'v0.790'\n    hooks:\n      - id: mypy\n</code></pre> <p>Infine, per impostare gli script di git hook:</p> <pre><code>(venv)$ pre-commit install\n</code></pre> <p>Adesso, ogni volta che eseguiamo <code>git commit</code> mypy verr\u00e0 eseguito prima della commit vera e propria. E se vi sono dei problemi la commit verr\u00e0 annullata.</p>"},{"location":"material/05_advanced_python/05_type_checking/#ci-pipeline","title":"CI Pipeline","text":"<p>Ha senso eseguire il type check statico all'interno della nostra pipeline CI per prevenire che problemi sui tipi siano portati nella code base. Questo \u00e8 probabilmente il momento pi\u00f9 importante per eseguire mypy o altre tecniche di type checking statico.</p> <p>Potremmo avere dei problemi quando eseguiamo i type check statici con mypy, specialmente quando usiamo librerie di terze parti senza dei type hints. Probabilmente questa \u00e8 la ragione principale per la quale molti evitano di effettuare dei controlli con mypy all'interno della pipeline di CI.</p>"},{"location":"material/05_advanced_python/05_type_checking/#a-runtime","title":"A runtime","text":"<p>Per il tipe checking dinamico abbiamo bisogno di un programma effettivamente in esecuzione. Come detto prima, usare dei type checker di questo tipo richiede meno test, produce meno bug, e ci aiuta ad inidividuarli prima. Possiamo usarli per la validazione dei dati (con pydantic e marshmallow) e p\u00e8er forzare i tipi durante l'esecuzione dle porogramma (con typeguard).</p>"},{"location":"material/05_advanced_python/05_type_checking/#conclusioni","title":"Conclusioni","text":"<p>Il type checking potrebbe sembrare non necessario quando si ha una ridotta code base, ma man mano che aumenta di dimensioni, pi\u00f9 importante diventa. E' uno strato utleriore che ci protegge da bug facilmente prevenibili. I type hints, anche se non sono forzati dall'interprete, ci aiutano ad esprimere al meglio lo scopo di una variabile, funzione, o classe. La maggior parte delle IDE moderne fornisce dei plugin per avvisare gli sviluppatori di problemi sui tipi sulla base dei type hiunts. Per forzarli, possiamo includere  mypy nel nostro workflow per controllare in maniera statica se l'uso dei metodi combacia con i loro type hints. Anche se l'analisi statica pu\u00f2 migliorare il nsotro codice, dobbiamo tener conto che il nostro software sta comunicando con il mondo esterno. Di consegeunza, \u00e8 preferibile aggiungere dei type checker dinamici a runtime come pydantic o marshmallow. Questi ci aiuteranno a validare l'input dell'utente e lancaire gli errori il prima possibile. Pi\u00f9 rapidamente troviamo un errore, pi\u00f9 facile \u00e8 correggerlo.</p>"},{"location":"material/05_advanced_python/06_documenting/","title":"Documentazione","text":"<p>Perch\u00e9 dobbiamo documentare il nostro codice Python? Che cosa dovrebbe includere la documentazione? Come scriviamo e generiamo la comunicazione?</p> <p>La documentazione \u00e8 una parte importante dello sviluppo software. Senza propria documentazione, pu\u00f2 essere molto difficile o impossibile per stakeholder interni ed esterni che usano e/o mantengono il nostro codice. Rende anche molto pi\u00f9 complesso avere altri sviluppatori. Facendo un passo in avanti, senza una cultura di documentare ed apprendere in generale, spesso faremo gli stessi errori molte volte. Sfortunatamente, diversi sviluppatori trattano la documentazione successivamente - qualcosa da non prendere troppo in considerazione.</p> <p>Questo articola affronta il perch\u00e9 dovremmo documentare il nostro codice Python, e come farlo.</p>"},{"location":"material/05_advanced_python/06_documenting/#cosa-e-la-documentazione","title":"Cosa \u00e8 la documentazione?","text":"<p>La documentazione \u00e8 una risorsa standalone che aiuta gli altri ad usare il nostro API, package, libreria o framework senza dover leggere ilcodice sorgente. I commenti, d'altra parte, sono per gli sviluppatori che leggono il nostro codice sorgente. La documentaione \u00e8 qualcosa ch dovremmo sempre tenere presente, ma lo stesso non pu\u00f2 essere detto per i commenti. Infatti, questi sono buoni da avere, ma non sono strettamente richiesti. La documentazione dovrebbe dire ad altri quando e come usare qualcosa, mentre i commenti dovrebbero rispondere a domande del tipo:</p> <ul> <li>perch\u00e9 \u00e8 stato fatto in questo modo?</li> <li>perch\u00e9 questa parte di codice \u00e8 qui?</li> </ul> <p>La questione \"cosa\" dovrebbe essere teoricamente risposta dal codice:</p> <ul> <li>cosa \u00e8 questo?</li> <li>che fa questo metodo?</li> </ul> <p>Riassumendo:</p> Tipo Risposta Attore Documentazione QUando e Come Utenti Commenti al codice Perch\u00e8 Sviluppatori Codice Cosa Sviluppatori"},{"location":"material/05_advanced_python/06_documenting/#docstring","title":"Docstring","text":"<p>Come specificato dalla PEP-257, una stringa di documentazione Python (o docstring) \u00e8 una stringa speciale che avviene come prima istruzione in un modulo, funzione, classe, o definizione di metodo, per formare l'attributo doc del dato oggetto. Ci permette di integrare la documentazione direttamente nel nostro codice sorgente.</p> <p>Immaginiamo per esempio di avere un modulo chiamato <code>temperature.py</code> con una singola funzione che calcola la temperatura media giornaliera. Usando i docstring, possiamo documentarla come segue:</p> <pre><code>\"\"\"\nThe temperature module: Manipulate your temperature easily\n\nEasily calculate daily average temperature\n\"\"\"\n\nfrom typing import List\n\n\nclass HighTemperature:\n    \"\"\"Class representing very high temperatures\"\"\"\n\n    def __init__(self, value: float):\n        \"\"\"\n        :param value: value of temperature\n        \"\"\"\n\n        self.value = value\n\n\ndef daily_average(temperatures: List[float]) -&gt; float:\n    \"\"\"\n    Get average daily temperature\n\n    Calculate average temperature from multiple measurements\n\n    :param temperatures: list of temperatures\n    :return: average temperature\n    \"\"\"\n\n    return sum(temperatures)/len(temperatures)\n</code></pre> <p>Possiamo vedere le docstring specificate per la funzione <code>daily_average</code> accedendo al suo attributo <code>__doc__</code>:</p> <pre><code>&gt;&gt;&gt; from temperature import daily_average\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(daily_average.__doc__)\n\n    Get average daily temperature\n\n    :param temperatures: list of temperatures\n    :return: average temperature\n</code></pre> <p>Possiamo anche vedere la docstring a livello dell'intero modulo usando la funzione di help integrata:</p> <pre><code>&gt;&gt;&gt; import temperature\n&gt;&gt;&gt;\n&gt;&gt;&gt; help(temperature)\n</code></pre> <p>E' il caso di notare che possiamo usare la funzione help con keywords integrate (<code>int</code>, <code>float</code>, <code>def</code>, e cos\u00ec via), classi, funzioni, e moduli.</p>"},{"location":"material/05_advanced_python/06_documenting/#singola-vs-multi-line","title":"Singola vs. multi-line","text":"<p>Le docstring possono essere a singola linea o a pi\u00f9 linee. In ogni modo, la prima linea \u00e8 sempre trattata come sommario. La riga di sommario pu\u00f2 essere usata dai tool di indicizzazione automatica per cui \u00e8 importante che entri in un'unica rioga. Quando si usa la docstring a riga singola, tutto dovrebbe essere sulla stessa riga: virgolette di apertura, sommario, e virgolette di chiusura. Ad esempio:</p> <pre><code>class HighTemperature:\n    \"\"\"Class representing very high temperatures\"\"\"\n\n    # code starts here\n</code></pre> <p>Quando si usa una docstring multilinea, la struttura \u00e8 la seguente: virgolette di apertura, riga vuota, descrizione pi\u00f9 elabroata, e virgolette di chiusura.</p> <pre><code>def daily_average(temperatures: List[float]) -&gt; float:\n    \"\"\"\n    Get average daily temperature\n\n    Calculate average temperature from multiple measurements\n\n    :param temperatures: list of temperatures\n    :return: average temperature\n    \"\"\"\n\n    return sum(temperatures) / len(temperatures)\n</code></pre> <p>Oltre a descrivere quello che una certa funzione, classe o metodo fa, possiamo anche specificare:</p> <ul> <li>argomenti di funzione</li> <li>valori di ritorno di funzione</li> <li>attributi di classe</li> <li>errori lanciati</li> <li>limitazioni</li> <li>esempin di codice</li> </ul>"},{"location":"material/05_advanced_python/06_documenting/#formati","title":"Formati","text":"<p>I quattro tipi di formato pi\u00f9 comune sono:</p> <ul> <li>Google</li> <li>reStructuredText</li> <li>NumPy</li> <li>Epytext</li> </ul> <p>Il consiglio \u00e8 quello di scegliere quello che pi\u00f9 si adatta a noi ed essere consistenti lungo l'arco dell'intero progetto.</p> <p>Usando le docstring possiamo esprimere i nostri intenti in maniera esplicita in linguaggio parlato per aiutare gli altri (e i noi stgessi del futuro) a capire al meglio quando, dove e come usare una determinata parte del codice.</p>"},{"location":"material/05_advanced_python/06_documenting/#linting","title":"Linting","text":"<p>Possiamoe ffettuare il lint delle nostre docstring proprio come faremmo per il codice. I linters si assicurano che le nostre docstring siano ben formattate e che rispettino l'implementazione vera e propria, il che aiuta nella stesura dell anostra documentazione.</p> <p>Darglint \u00e8 un linter per la documentazione abbastanza popolare.</p> <pre><code>$ pip install darglint\n</code></pre> <p>Proviamo ad effettuare il lint del modulo <code>temperature.py</code>.</p> <pre><code>def daily_average(temperatures: List[float]) -&gt; float:\n    \"\"\"\n    Get average daily temperature\n\n    Calculate average temperature from multiple measurements\n\n    :param temperatures: list of temperatures\n    :return: average temperature\n    \"\"\"\n\n    return sum(temperatures) / len(temperatures)\n</code></pre> <p>Per fare il lint:</p> <pre><code>$ darglint --docstring-style sphinx temperature.py\n</code></pre> <p>Cosa accade se cambiamo il nome del parametro da <code>temperatures</code> a <code>temperatures_list</code>?</p> <pre><code>$ darglint --docstring-style sphinx temperature.py\n\ntemperature.py:daily_average:27: DAR102: + temperatures\ntemperature.py:daily_average:27: DAR101: - temperatures_list\n</code></pre>"},{"location":"material/05_advanced_python/06_documenting/#esempi-di-codice","title":"Esempi di codice","text":"<p>Possiamo anche aggiungere degli esempi di codice alle docstring, mostrando usi di esempiop della funzione, metodo o classe. Ad esempio:</p> <pre><code>def daily_average(temperatures: List[float], new_param=None) -&gt; float:\n    \"\"\"\n    Get average daily temperature\n\n    Calculate average temperature from multiple measurements\n\n    &gt;&gt;&gt; daily_average([10.0, 12.0, 14.0])\n    12.0\n\n    :param temperatures: list of temperatures\n    :return: Average temperature\n    \"\"\"\n\n    return sum(temperatures)/len(temperatures)\n</code></pre> <p>Gli esempi di codice possono anche essere eseguiti da pytest come ogni altro test mediante <code>doctest</code>. Assieme al linting, questo ci aiuta ad assicurarci che la nostra documentazione sia sempre sincronizzata al codice.</p> <p>Per cui, con l'esempio precedente, pytest controller\u00e0 che <code>daily_average([10.0, 12.0, 14.0])</code> sia uguale a <code>12.0</code>. Per eseguire questo campione di codice come test abbiamo bisogno di eseguire pytest con l'opzione <code>doctest-modules</code>:</p> <pre><code>$ python -m pytest --doctest-modules temperature.py\n\n==================================================== test session starts =====================================================\nplatform darwin -- Python 3.9.0, pytest-6.1.2, py-1.9.0, pluggy-0.13.1\nrootdir: /Users/michael/repos/testdriven/python_developer_2020/docs\ncollected 1 item\n\ntemperature.py .                                                                                                       [100%]\n\n===================================================== 1 passed in 0.01s ======================================================\nWhat happens if you change the code example to:\n\n&gt;&gt;&gt; daily_average([10.0, 12.0, 14.0])\n13.0\n$ python -m pytest --doctest-modules temperature.py\n\n==================================================== test session starts =====================================================\nplatform darwin -- Python 3.9.0, pytest-6.1.2, py-1.9.0, pluggy-0.13.1\nrootdir: /Users/michael/repos/testdriven/python_developer_2020/docs\ncollected 1 item\n\ntemperature.py F                                                                                                       [100%]\n\n========================================================== FAILURES ==========================================================\n____________________________________________ [doctest] temperature.daily_average _____________________________________________\n020\n021     Get average daily temperature\n022\n023     Calculate average temperature from multiple measurements\n024\n025     &gt;&gt;&gt; daily_average([10.0, 12.0, 14.0])\nExpected:\n    13.0\nGot:\n    12.0\n\n/Users/michael/repos/testdriven/python_developer_2020/docs/temperature.py:25: DocTestFailure\n================================================== short test summary info ===================================================\nFAILED temperature.py::temperature.daily_average\n===================================================== 1 failed in 0.02s =====================================================\n</code></pre>"},{"location":"material/05_advanced_python/06_documenting/#sphinx","title":"Sphinx","text":"<p>Aggiungere le docstring al nostro codice \u00e8 ottimo, ma dobbiamo comunque mostrarle in qualche modo ai nostri utenti.</p> <p>Qui \u00e8 dove tool come Sphinx, Epydoc e MKDocs entrano in gioco, che converftiranno le docstring del nostro progetto in HTML e CSS.</p> <p>Sphinx \u00e8 di gran lunga il tool pi\u00f9 popolare. Viene usatop per generare la documentazione per un gran numero di progetti open-source come Python e Flask. E' anche uno dei tool di documentazione supportati da Read the Docs, che \u00e8 usato da migliaia di progetti open-source, come Requests, Flask8, e pytest, per nominarne alcuni.</p> <p>Vediamolo in azione. Iniziamo seguendo la guida ufficiale per scaricare ed installare Sphinx.</p> <pre><code>$ sphinx-quickstart --version\n\nsphinx-quickstart 3.3.1\n</code></pre> <p>Creiamo la cartello per un nuovo progetto:</p> <pre><code>$ mkdir sphinx_example\n$ cd sphinx_example\n</code></pre> <p>A questo p\u00e8unto, aggiungiamo nuvo file chiamato <code>temperature.py</code>:</p> <pre><code>\"\"\"\nThe temperature module: Manipulate your temperature easily\n\nEasily calculate daily average temperature\n\"\"\"\n\nfrom typing import List\n\n\nclass HighTemperature:\n    \"\"\"Class representing very high temperatures\"\"\"\n\n    def __init__(self, value: float):\n        \"\"\"\n        :param value: value of temperature\n        \"\"\"\n\n        self.value = value\n\n\ndef daily_average(temperatures: List[float]) -&gt; float:\n    \"\"\"\n    Get average daily temperature\n\n    :param temperatures: list of temperatures\n    :return: average temperature\n    \"\"\"\n\n    return sum(temperatures)/len(temperatures)\n</code></pre> <p>Per effettuare lo scaffolding dei file e delel cartelle per Sphinx per creare la documentazione per <code>temperature.py</code>, all'interno della radice di progetto, eseguiamo:</p> <pre><code>$ sphinx-quickstart docs\n</code></pre> <p>Ci verranno fatte alcune domande:</p> <pre><code>&gt; Separate source and build directories (y/n) [n]: n\n&gt; Project name: Temperature\n&gt; Author name(s): Your Name\n&gt; Project release []: 1.0.0\n&gt; Project language [en]: en\n</code></pre> <p>Una volta fatto, la cartella docs conterr\u00e0 i seguenti file e cartelle:</p> <pre><code>docs\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 _build\n\u251c\u2500\u2500 _static\n\u251c\u2500\u2500 _templates\n\u251c\u2500\u2500 conf.py\n\u251c\u2500\u2500 index.rst\n\u2514\u2500\u2500 make.bat\n</code></pre> <p>Quindi, aggiungiamo la configurazione di progetto. Apriamo <code>docs/conf.py</code> e rimpiazziamo queste righe:</p> <pre><code># import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\n</code></pre> <p>con queste:</p> <pre><code>import os\nimport sys\nsys.path.insert(0, os.path.abspath('..'))\n</code></pre> <p>Adesso, autodoc, che \u00e8 usato per creare la documentazione dalle docstring, cercher\u00e0 i moduli nella cartella padre di docs.</p> <p>Aggiungiamo le seguenti estensioni alla lista di estensioni:</p> <pre><code>extensions = [\n    'sphinx.ext.autodoc',\n]\n</code></pre> <p>Apriamo <code>docs/index.rst</code> e modifichiamolo come segue:</p> <pre><code>Welcome to Temperature documentation!\n=====================================\n\n.. automodule:: temperature\n    :members:\n\n\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n</code></pre> <p>I contenuti di <code>index.rst</code> sono scritti in reStructuredText, che \u00e8 un fomrato di file per dati testuali simile a Markdown, ma molto pi\u00f9 potente perch\u00e9 progettato per scrivere la documentaizone tecnica.</p> <p>Note:</p> <ul> <li>i titoli sono creati sottolineando (ed opzionalmente OVERLINING) il titolo con un carattere <code>=</code>, almeno lunga come il testo</li> </ul> <p>La direttiva automodule \u00e8 usata per raccogliere le docstring dai moduli Python. Di conseguenza, <code>automodule:: temperature</code> dice a Sphinx di raccogliere le docstring dal modulo <code>temperature.py</code>.</p> <p>Le direttive genindex, modindex e search sono usate per generare un indice generico, un indice di moduli documentati, ed una pagina di ricerca, rispettivamente.</p> <p>Dalla cartella \"docs\", costruiamo la documentazione:</p> <pre><code>$ make html\n</code></pre> <p>Apriamo <code>docs/_build/html/index.html</code> nel nostro browser. Dovremmo vedere:</p>"},{"location":"material/05_advanced_python/06_documenting/#sphinx-docs","title":"Sphinx docs","text":"<p>Ora possiamo servire i docs noi stessi, usando un tool come Netlify, o mediante un servizio esterno come Read the Docs.</p>"},{"location":"material/05_advanced_python/06_documenting/#documentazione-delle-api","title":"Documentazione delle API","text":"<p>QUando parliamo della documentazione non dobbiamo dimenticarci della documentazione delle nostre API. Abbiamo degli endpoint con i loro URL, parametri, status code, corpi delle richieste e delle risposte. Anche una semplice API pu\u00f2 avere un numero di parametri che sono difficili da ricordare.</p> <p>Le specifiche OpenAPI (prima chiamate Swagger) forniscono un formato standard per descrivere, produrre, consumare e visualizzare le API RESTful. Questa specifica \u00e8 usata per generarre la documentazione con Swagger UI o ReDoc. Pu\u00f2 essere anche importata in tool come Postman. Possiamo generare diversi stub e client SDK cos\u00ec come dei tool come Swagger Codegen e OpenAPI Generator.</p> <p>Per una lista completa di editor, linter, parser, generotri di codice, documetnazione, testing e tool di validazione schema/dati per OpenAPI, vediamo i tool di OpenAPI.</p> <p>Le specifiche stesse devono essere scritte in YAML o JSON. Ad esempio:</p> <pre><code>---\nopenapi: 3.0.2\ninfo:\n  title: Swagger Petstore - OpenAPI 3.0\n  description: |-\n    This is a sample Open API\n  version: 1.0.0\nservers:\n- url: \"/api/v3\"\npaths:\n  \"/pet\":\n    post:\n      summary: Add a new pet to the store\n      description: Add a new pet to the store\n      operationId: addPet\n      requestBody:\n        description: Create a new pet in the store\n        content:\n          application/json:\n            schema:\n              \"$ref\": \"#/components/schemas/Pet\"\n        required: true\n      responses:\n        '200':\n          description: Successful operation\n          content:\n            application/json:\n              schema:\n                \"$ref\": \"#/components/schemas/Pet\"\n        '405':\n          description: Invalid input\ncomponents:\n  schemas:\n    Pet:\n      required:\n      - name\n      - photoUrls\n      type: object\n      properties:\n        id:\n          type: integer\n          format: int64\n          example: 10\n        name:\n          type: string\n          example: doggie\n        photoUrls:\n          type: array\n          items:\n            type: string\n        status:\n          type: string\n          description: pet status in the store\n          enum:\n          - available\n          - pending\n          - sold\n  requestBodies:\n    Pet:\n      description: Pet object that needs to be added to the store\n      content:\n        application/json:\n          schema:\n            \"$ref\": \"#/components/schemas/Pet\"\n</code></pre> <p>Scrivere uno schema di questo tipo a mano \u00e8 duro e soggetto ad errori. Fortunatamente, ci sono diversi tool che ci aiutano ad automatizzare queto processo:</p> <ul> <li>Django: drf-yasg</li> <li>Flask - Flask-RESTX, Connexion, Flask-Rebar</li> <li>FastAPI - OpenAPI integrato</li> </ul>"},{"location":"material/05_advanced_python/06_documenting/#test-come-documentazione","title":"Test come documentazione","text":"<p>Finora, abbiamo parlato della documentrazione per gli utenti (documentazione del progetto) e sviluppatori (commenti del codice). Un altro tipo di documentazione per gli sviluppatori viene dai test stessi.</p> <p>Come sviluppatore che lavora su un progetto dobbiamo sapere pi\u00f9 di come usare un metodo. Dobbiamo sapere se funziona come atteso e come usarlo per ulteriori sviluppi. Anche se aggiungere degli esempi di codice alla docstring ci aiuta, questi non sono intesi per nient'altro che esempi. Dobbiamo aggiungere dei test per coprire pi\u00f9 che il percorso atteso di una funzione.</p> <p>I test documentano tre cose:</p> <ul> <li>quello che \u00e8 l'output atteso di un dato input</li> <li>come i percorsi delle eccezioni sono gestiti</li> <li>come usare una data funzione, metodo o classe</li> </ul> <p>Dato che stiamo scrivendo dei test, assicuriamoci di usare della nomenclatura propria e specificare chiaramente quello che stiamo testando. Qeusto ci rende molto pi\u00f9 semplice effettaure la review della test suite per trovare una certa funzione o metodo da usare.</p> <p>Inoltre, quando scriviamo un test, in pratica definiamo quello che dovrebbe andare nella docstring. La struttura GIVEN, WHEN, THEN pu\u00f2 essere facilmente convertita nella docstring di una funzione.</p> <p>Ad esempio:</p> <ul> <li>DATA una lista di misure di temperatura -&gt; :param temperatures: list of temperatures</li> <li>QUANDO 'mediagiornaliera' viene chiamata -&gt; &gt;&gt;&gt; dailyaverage([10.0, 12.0, 14.0])</li> <li>ALLORA la temperatura media viene restituita -&gt; Get average temperature, :return: Average temperature</li> </ul> <pre><code>def daily_average(temperatures: List[float]) -&gt; float:\n    \"\"\"\n    Get average temperature\n\n    Calculate average temperature from multiple measurements\n\n    &gt;&gt;&gt; daily_average([10.0, 12.0, 14.0])\n    12.0\n\n    :param temperatures: list of temperatures\n    :return: Average temperature\n    \"\"\"\n\n    return sum(temperatures)/len(temperatures)\n</code></pre> <p>Quindi, possiamo trattare il TDD come una sorta di approccio \"documentation-driven\" allo sviluppo creando la nostra docstring sotto forma di codice:</p> <ul> <li>Scriviamo un test</li> <li>Ci assicuriamo che il test fallisca</li> <li>Scriviamo il codice</li> <li>Ci assicuriamo che il test passo</li> <li>effettuiamo il refacotring ed aggiuingiamo la docstring</li> </ul>"},{"location":"material/05_advanced_python/06_documenting/#documentare-una-api-rest-flask","title":"Documentare una API REST Flask","text":"<p>Finora, abbiamo semplicemente coperto la teoria, per cui andiamo su un esempio reale. Creeremo una API RESTful con Flask per la misurazione della temperatura. Ogni misura avr\u00e0 i seguenti attributi: timestamp, temperatura, note. Flask-RESTX verr\u00e0 usato per auto-generare una specifica OpenAPI.</p> <p>Per prima cosa, creiamo una nuova cartella:</p> <pre><code>$ mkdir flask_temperature\n$ cd flask_temperature\n</code></pre> <p>A questo punto, inizializziamo il progetto usando Poetry:</p> <pre><code>$ poetry init\nPackage name [flask_temperature]:\nVersion [0.1.0]:\nDescription []:\nAuthor [Your name &lt;your@email.com&gt;, n to skip]:\nLicense []:\nCompatible Python versions [^3.7]:  &gt;3.7\n\nWould you like to define your main dependencies interactively? (yes/no) [yes] no\nWould you like to define your development dependencies interactively? (yes/no) [yes] no\nDo you confirm generation? (yes/no) [yes]\n</code></pre> <p>Aggiungiamo quindi Flask e Flask-RESTX:</p> <pre><code>$ poetry add flask flask-restx\n</code></pre> <p>Creiamo adesso la nostra API documentata. Aggiungiamo un file per l'app Flask chiamato <code>app.py</code>:</p> <pre><code>import uuid\n\nfrom flask import Flask, request\nfrom flask_restx import Api, Resource\n\napp = Flask(__name__)\napi = Api(app)\n\nmeasurements = []\n\n\n@api.route('/measurements')\nclass Measurement(Resource):\n    def get(self):\n        return measurements\n\n    def post(self):\n        measurement = {\n            'id': str(uuid.uuid4()),\n            'timestamp': request.json['timestamp'],\n            'temperature': request.json['temperature'],\n            'notes': request.json.get('notes'),\n        }\n        measurements.append(measurement)\n\n        return measurement\n\n\nif __name__ == '__main__':\n    app.run()\n</code></pre> <p>Flask-RESTX usa delle view class-based per organizzare le risorse, route e metodi HTTP. Nell'esempio precedente, la classe Measurement supporta i metodi HTTP GET e POST. Altri metori restiuiranno un errore <code>MethodNotAllowed</code>. Flask-RESTX generer\u00e0 anche lo schema OpenAPI quando l'app viene eseguita.</p> <pre><code>$ python app.py\n</code></pre> <p>Possiamo vedere lo schema all'indirizzo http://localhost:5000/swagger.json. Saremo anche in grado di vedere l'API navigabile a http://localhost:5000.</p>"},{"location":"material/05_advanced_python/06_documenting/#swaggerui","title":"SwaggerUI","text":"<p>Al momento, lo schema contiene soltnato degli endpoint. POssiamo definire i corpi delle richieste e delle risposte per dire ai nostri utenti quello che \u00e8 atteso da loro, cos\u00ec come quello che sar\u00e0 restituito. Aggiorniamo <code>app.py</code>:</p> <pre><code>import uuid\n\nfrom flask import Flask, request\nfrom flask_restx import Api, Resource, fields\n\napp = Flask(__name__)\napi = Api(app)\n\nmeasurements = []\n\nadd_measurement_request_body = api.model(\n    'AddMeasurementRequestBody', {\n        'timestamp': fields.Integer(\n            description='Timestamp of measurement',\n            required=True,\n            example=1606509272\n        ),\n        'temperature': fields.Float(\n            description='Measured temperature',\n            required=True, example=22.3),\n        'notes': fields.String(\n            description='Additional notes',\n            required=False, example='Strange day'),\n    }\n)\n\nmeasurement_model = api.model(\n    'Measurement', {\n        'id': fields.String(\n            description='Unique ID',\n            required=False,\n            example='354e405c-136f-4e03-b5ce-5f92e3ed3ff8'\n        ),\n        'timestamp': fields.Integer(\n            description='Timestamp of measurement',\n            required=True,\n            example=1606509272\n        ),\n        'temperature': fields.Float(\n            description='Measured temperature',\n            required=True,\n            example=22.3\n        ),\n        'notes': fields.String(\n            description='Additional notes',\n            required=True,\n            example='Strange day'\n        ),\n    }\n)\n\n\n@api.route('/measurements')\nclass Measurement(Resource):\n    @api.doc(model=[measurement_model])\n    def get(self):\n        return measurements\n\n    @api.doc(model=[measurement_model], body=add_measurement_request_body)\n    def post(self):\n        measurement = {\n            'id': str(uuid.uuid4()),\n            'timestamp': request.json['timestamp'],\n            'temperature': request.json['temperature'],\n            'notes': request.json.get('notes'),\n        }\n        measurements.append(measurement)\n\n        return measurement\n\n\nif __name__ == '__main__':\n    app.run()\n</code></pre> <p>Per definire dei modelli per i corpi delle nostre richieste e risposte abbiamo usato <code>api.model</code>. Abbiamo definito i nomi ed i campi appropriati. Per ciascun campo, abbiamo definito il tipo, descrizione, esempio, e se \u00e8 richiesto.</p>"},{"location":"material/05_advanced_python/06_documenting/#swagger-ui-models","title":"Swagger UI models","text":"<p>Per aggiungere i modelli agli endpoint, abbiamo usato il decorator @api.doc. Il parametro body definisce il corpo della richiesta, m,entre il modello definisce il corpo della risposta.</p>"},{"location":"material/05_advanced_python/06_documenting/#swagger-ui-models_1","title":"Swagger UI models","text":"<p>Ora dovremmo avere l'idea base di come docuemntare la nostra API RESTful Flask con Flask-RestX. Abbiamo soltanto scalfito la superficie. Controlliamo la documentaizone Swagger per dettagli su come definire le info di autenticazione, i parametri degli URL, gli status code e molto altro.</p>"},{"location":"material/05_advanced_python/06_documenting/#conclusion","title":"Conclusion","text":"<p>Molti di noi possono migliorare nello scrivere documentazione. Fortunatamente, ci sono molti tool disponibili per semplificare il processo di scrittura. Quando scriviamo i package e le librerie, usiamo Sphinx per organizzare ed aituarci a generar ela nostra documentazione a partire da delle docstring. Quando lavoriamo su un'API RESTful, usiamo un tool che genera uno schema OpenAPI, dal momento che lo schema pu\u00f2 essere usato da molti altri strumenti, ovverto tutto dai data validator ai code generator.</p>"},{"location":"material/05_advanced_python/07_workflow/","title":"Workflow","text":"<p>In questo articolo, metteremo assieme tutto quello che abbiamo visto negli articoli precedenti creando un singolo progetto dall'inizio alla fine. Al termine dell'articolo:</p> <ul> <li>creeremo una pipeline di CI/CD mediante GitHub Actions</li> <li>configureremo il coverage reporting mediante CodeCov</li> <li>pubblicheremo il package su PyPi ed la documentazione su Read the Docs</li> <li>aggiorneremo PyPI e Read the Docs mediante delle GitHub Actions</li> </ul>"},{"location":"material/05_advanced_python/07_workflow/#setup-del-progetto","title":"Setup del progetto","text":"<p>Creiamo un generatore di citazioni casuali che restituisca una citazione a caso da un certo insieme.</p>"},{"location":"material/05_advanced_python/07_workflow/#inizializzazione-del-progetto","title":"Inizializzazione del progetto","text":"<p>Per prima cosa, creiamo una nuova cartella per il nostro progetto:</p> <pre><code>$ mkdir random-quote-generator\n$ cd random-quote-generator\n</code></pre> <p>Inizializziamo il progetto usando Pipenv. Ricordiamoci di assegnare un nome univoco in modo tale da evitare collisioni con altri package su PyPI.</p> <p>Creiamo quindi una nuova repository su GitHub, ed inizializziamo una repository git all'interno del nostro progetto.</p> <pre><code>$ git init\n$ git add pyproject.toml\n$ git commit -m \"first commit\"\n$ git branch -M main\n$ git remote add origin git@github.com:&lt;your-github-username&gt;/random-quote-generator.git\n$ git fetch\n$ git branch --set-upstream-to=origin/main main\n$ git pull origin main --rebase\n$ git push -u origin main\n</code></pre> <p>Una volta completato il setup base, continuiamo aggiungendo le seguenti dipendenze:</p> <ul> <li>pytest</li> <li>pytest-cov</li> <li>Black</li> <li>isort</li> <li>Flake8</li> <li>Bandit</li> <li>Safety</li> </ul> <p>Install:</p> <pre><code>$ poetry add --dev pytest pytest-cov black isort flake8 bandit safety\n</code></pre> <p>Aggiungiamo i nuovi file pipenv.lock assieme al pipfile a git:</p> <pre><code>$ git add Pipfile Pipfile.lock\n</code></pre>"},{"location":"material/05_advanced_python/07_workflow/#build-del-progetto","title":"Build del progetto","text":"<p>Creiamo adesso una nuova cartella chiamata \"randomquotegenerator\". All'interno della cartella. aggiungiamo un file <code>__init__.py</code>, in modo che venga trattata come un package, assieme ad un file chiamato <code>quotes.py</code>.</p> <pre><code>random-quote-generator\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 random_quote_generator\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 quotes.py\n</code></pre> <p>All'interno di <code>quotes.py</code> aggiungiamo:</p> <pre><code>quotes = [\n    {\n        \"quote\": \"A long descriptive name is better than a short \"\n        \"enigmatic name. A long descriptive name is better \"\n        \"than a long descriptive comment.\",\n        \"author\": \"Robert C. Martin\",\n    },\n    {\n        \"quote\": \"You should name a variable using the same \"\n        \"care with which you name a first-born child.\",\n        \"author\": \"Robert C. Martin\",\n    },\n    {\n        \"quote\": \"Any fool can write code that a computer \"\n        \"can understand. Good programmers write code\"\n        \" that humans can understand.\",\n        \"author\": \"Martin Fowler\",\n    },\n]\n</code></pre> <p>Ovviamente non c'\u00e8 niente di speciale qui. Soltanto una lista di dizionari, uno per ogni citazione. Quindi, creiamo una nuova cartella nella radice di progetto chiamata <code>tests</code> ed aggiungiamo i file seguenti:</p> <pre><code>tests\n\u251c\u2500\u2500 __init__.py\n\u2514\u2500\u2500 test_get_quote.py\n</code></pre> <p>Modifichiamo il file <code>test_get_quote.py</code> come segue:</p> <pre><code>from random_quote_generator import get_quote\nfrom random_quote_generator.quotes import quotes\n\n\ndef test_get_quote():\n    \"\"\"\n    GIVEN\n    WHEN get_quote is called\n    THEN random quote from quotes is returned\n    \"\"\"\n\n    quote = get_quote()\n\n    assert quote in quotes\n</code></pre> <p>Eseguiamo i test:</p> <pre><code>$ pipenv run python -m pytest tests\n</code></pre> <p>Questi dovrebbero fallire:</p> <pre><code>E   ImportError: cannot import name 'get_quote' from 'random_quote_generator'\n</code></pre> <p>A questo punto, aggiungiamo un nuovo file chiamato <code>get_quote.py</code>:</p> <pre><code>import random\n\nfrom random_quote_generator.quotes import quotes\n\n\ndef get_quote() -&gt; dict:\n    \"\"\"\n    Get random quote\n\n    Get randomly selected quote from database our programming quotes\n\n    :return: selected quote\n    :rtype: dict\n    \"\"\"\n\n    return quotes[random.randint(0, len(quotes) - 1)]\n</code></pre> <p>In pratica, stiamo scegliendo una citazione generando un intero casuale mediante <code>random.randint</code> tra 0 e l'ultimo indice.</p> <p>Esportiamo la funzione in <code>random_quote_generator/__init__.py</code>:</p> <pre><code>\"\"\"\nRandom Quote Generator\n======================\n\nGet random quote from our database of programming wisdom\n\"\"\"\nfrom .get_quote import get_quote\n\n__all__ = [\"get_quote\"]\n</code></pre> <p>La funzione viene importata ed elencata all'interno dell'attributo <code>__all__</code>, che \u00e8 una lista di oggetti pubblici per il modulo. In altre parole, quando qualcuno usa <code>from random_quote_generator import *</code>, soltanto i nomi elencati in <code>__all__</code> saranno importati.</p> <p>Il test dovrebbe adesso avere successo:</p> <pre><code>$ pipenv run python -m pytest tests\n</code></pre> <p>Creiamo un file <code>.gitignore</code> alla radice del nostro progetto, ed aggiungiamo le cartelle <code>random_quote_generator</code> e <code>test</code> a git assieme al file <code>.gitignore</code>:</p> <pre><code>$ git add random_quote_generator/ tests/ .gitignore\n</code></pre> <p>Abbiamo finito. Il package \u00e8 pronto per essere inviato su PyPI.</p>"},{"location":"material/05_advanced_python/07_workflow/#documentare-il-progetto","title":"Documentare il progetto","text":"<p>Il nostro package funziona, ma i nostri utenti dovranno controllarne il codice sorgente per vedere come usarlo. Abbiamo gi\u00e0 incluso le docstring, per cui possiamo facilmente creare la documentazione del progetto \"standalone\" mediante Sphinx.</p> <p>Con Sphinx installato, eseguiamo la seguente istruzione per fare lo scaffold dei file e delle cartelle per Sphinx dalla radice di progetto:</p> <pre><code>$ sphinx-quickstart docs\n</code></pre> <p>Ci verranno fatte alcune domande:</p> <pre><code>&gt; Separate source and build directories (y/n) [n]: n\n&gt; Project name: Random Quote Generator\n&gt; Author name(s): Your Name\n&gt; Project release []: 0.1.0\n&gt; Project language [en]: en\n</code></pre> <p>A questo punto, aggiorniamo la configurazione del progetto. Apriamo <code>docs/conf.py</code> e rimpiazziamo questa parte:</p> <pre><code># import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\n</code></pre> <p>con questa:</p> <pre><code>import os\nimport sys\nsys.path.insert(0, os.path.abspath('..'))\n</code></pre> <p>Adesso, autodoc, che \u00e8 usato per prendere la documentazione dalle docstring, cercher\u00e0 i moduli nella cartella padre di \"docs\".</p> <p>Aggiungiamo la seguente estensione alla lista delle estensioni:</p> <pre><code>extensions = [\n    'sphinx.ext.autodoc',\n]\n</code></pre> <p>Aggiorniamo <code>docs/index.rst</code> come segue:</p> <pre><code>.. Random Quote Generator documentation master file, created by\n   sphinx-quickstart on Mon Dec 21 22:27:23 2020.\n   You can adapt this file completely to your liking, but it should at least\n   contain the root `toctree` directive.\n\nWelcome to Random Quote Generator's documentation!\n==================================================\n\n.. automodule:: random_quote_generator\n    :members:\n\nIndices and tables\n==================\n\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n</code></pre> <p>Questo file dovrebbe essere escluso da Flake8, che aggiungeremo a breve. Per cui creiamo un file <code>.flake8</code> nella cartella radice del progetto:</p> <pre><code>[flake8]\nexclude =\n    docs/conf.py,\n</code></pre> <p>Aggiungiamo la cartella <code>docs</code> e <code>.flake8</code> a git:</p> <pre><code>$ git add docs/ .flake8\n</code></pre>"},{"location":"material/05_advanced_python/07_workflow/#github-actions","title":"GitHub Actions","text":"<p>Adesso \u00e8 il momento di collegare una pipeline di CI con GitHub Actions. Aggiungiamo i seguenti file e cartelle alla radice di progetto.</p> <pre><code>.github\n\u2514\u2500\u2500 workflows\n    \u2514\u2500\u2500 branch.yaml\n</code></pre> <p>All'interno di branch.yaml, aggiungiamo:</p> <pre><code>name: Push\non: [push]\n\njobs:\n  test:\n    strategy:\n      fail-fast: false\n      matrix:\n        python-version: ['3.10']\n        poetry-version: ['1.1.13']\n        os: [ubuntu-latest]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Run image\n        uses: abatilo/actions-poetry@v2.1.4\n        with:\n          poetry-version: ${{ matrix.poetry-version }}\n      - name: Install dependencies\n        run: poetry install\n      - name: Run tests\n        run: poetry run pytest --cov=./ --cov-report=xml\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v2\n  code-quality:\n    strategy:\n      fail-fast: false\n      matrix:\n        python-version: ['3.10']\n        poetry-version: ['1.1.13']\n        os: [ubuntu-latest]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Run image\n        uses: abatilo/actions-poetry@v2.1.4\n        with:\n          poetry-version: ${{ matrix.poetry-version }}\n      - name: Install dependencies\n        run: poetry install\n      - name: Run black\n        run: poetry run black . --check\n      - name: Run isort\n        run: poetry run isort . --check-only --profile black\n      - name: Run flake8\n        run: poetry run flake8 .\n      - name: Run bandit\n        run: poetry run bandit .\n      - name: Run saftey\n        run: poetry run safety check\n</code></pre> <p>Questa configurazione:</p> <ul> <li>viene eseguita ad ogni push su ogni singolo branch (on: [push])</li> <li>esegue l'ultima versione di Ubuntu (ubuntu-latest)</li> <li>usa Python 3.10 (python-version: [3.10], python-version: ${{ matrix.python-version }})</li> <li>usa Poetry versione 1.1.13 (poetry-version: [1.1.13], poetry-version: ${{ matrix.poetry-version }})</li> </ul> <p>Vengono definiti due job: test e code-quality. Come suggerisce il nome, i test sono eseguiti nel job test, mentre i controlli sulla qualit\u00e0 del codice sono eseguiti nel job code-quality.</p> <p>Ora ad ogni push nella repository GitHub, i job test e code quality saranno eseguiti.</p> <p>Aggiungiamo .github a git:</p> <pre><code>$ git add .github/\n</code></pre> <p>Eseguiamo tutti i controlli per la qualit\u00e0 del codice:</p> <pre><code>$ pipenv run black .\n$ pipenv run isort . --profile black\n$ pipenv run flake8 .\n$ pipenv run bandit .\n$ pipenv run safety check\n</code></pre> <p>Assicuriamoci di aggiungere ogni file che pu\u00f2 essere cambiato a git. Quindi, effettuiamo la commit ed il push delle nostre modifiche a GitHub.</p> <pre><code>$ git add docs/ random_quote_generator/ tests/\n$ git commit -m 'Package ready'\n$ git push -u origin main\n</code></pre> <p>Dovremmo vedere il nostro workflow eseguito sul tab \"Actions\" nella nostra repository GitHub. Assicuriamoci che passi prima di proseguire.</p>"},{"location":"material/05_advanced_python/07_workflow/#codecov","title":"CodeCov","text":"<p>A questo punto potremo configurare CodeCov per tracciare la code coverage. Navighiamo su http://codecov.io/, e logghiamo con il nostro account GitHub per trovare la nostra repository.</p> <p>Seguiamo la guida Quick Start per impostare ed eseguire CodeCov.</p> <p>Eseguiamo nuovamente il workflow definito dalle GitHub Actions. Una volta termianto, dovremmo essere in grado di vedre il coverage report su CodeCov.</p> <p>Adesso, ogni volta che viene eseguito il nostro workflow, un coverage report sar\u00e0 generato e caricato su CodeCov. Possiamo analizzare le modifiche nelle percentuali di coverage per branch, commit e pull request, focalizzandoci sugli aumenti e decrementi nel coverage nel tempo.</p>"},{"location":"material/05_advanced_python/07_workflow/#read-the-docs","title":"Read the docs","text":"<p>Useremo Read the Docs per ospitare la nostra documentazione. Navighiamo su https://readthedocs.org, e logghiamoci usando il nostro account GitHub.</p> <p>Adesso, clicchiamo su \"Import a Project\". Dopo averlo fatto, aggiorniamo i nostri progetti, ed aggiungiamo quello che abbiamo appena pushato su GitHub. Apriamo il progetto e navighiamo nella sezione \"Admin\". Quindi, su \"Advanced Settings\", impostiamo il branch di default su main. Non dimentichiamo di salvare le nostre modifiche.</p> <p>Avremo bisogno di alcuni minuti per costruire la documentazione. Una volta fatto, dovremmo essere in grado di vedere la documentazione del progetto ad un link simile a https://your-project-slug-on-readthedocs.readthedocs.io.</p> <p>Di default, la documentazione sar\u00e0 ricostruita ad ogni push sul branch main. Con questo, l'unica cosa rimasta da fare \u00e8 pubblicare il package su PyPI.</p>"},{"location":"material/05_advanced_python/07_workflow/#pypi","title":"PyPI","text":"<p>Iniziamo aggiungendo la seguente sezione a pyproject.toml in modo che il modulo \"randomquotegenerator\" sia incluso nella distribuzione su PyPI:</p> <pre><code>packages = [\n    { include = \"random_quote_generator\" },\n]\n</code></pre> <p>Il nostro file diventer\u00e0 quindi:</p> <pre><code>[tool.poetry]\nname = \"random-quote-generator-93618\"\npackages = [\n    { include = \"random_quote_generator\" },\n]\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Amir Tadrisi &lt;notreal@gmail.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.1.2\"\npytest-cov = \"^3.0.0\"\nblack = \"^22.3.0\"\nisort = \"^5.10.1\"\nflake8 = \"^4.0.1\"\nbandit = \"^1.7.4\"\nsafety = \"^1.10.3\"\n\n[build-system]\nrequires = [\"poetry-core&gt;=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\nAdd a new file called release.yaml to \".github/workflows\":\n\nname: Release\non:\n  release:\n    types:\n      - created\n\njobs:\n  publish:\n    strategy:\n      fail-fast: false\n      matrix:\n        python-version: ['3.10']\n        poetry-version: ['1.1.13']\n        os: [ubuntu-latest]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Run image\n        uses: abatilo/actions-poetry@v2.1.4\n        with:\n          poetry-version: ${{ matrix.poetry-version }}\n      - name: Publish\n        env:\n          PYPI_TOKEN: ${{ secrets.PYPI_TOKEN }}\n        run: |\n          poetry config pypi-token.pypi $PYPI_TOKEN\n          poetry publish --build\n</code></pre> <p>Quindi, quando si crea una nuova release, il package sar\u00e0 pubblicato su PyPI.</p> <p>Quindi dovremo creare un token PyPI. Creiamo un account su PyPI, se non ne abbiamo gi\u00e0 uno. Quindi, una volta loggati, clicchiamo su \"Account settings\" per aggiungere un nuovo API token. Copiamo il token. Dovremo adesso aggiungerlo ai secrets della nostra repository GitHub. Per farlo, clicchiamo sul tab \"Settings\", e quindi \"Secrets\" e poi \"Actions\". Usiamo PYPI_TOKEN per il nome al secret ed il valore del token come valore.</p> <p>Adesso siamo pronti per creare la nostra prima release.</p> <p>Aggiungiamo il file <code>release.yaml</code> a git cos\u00ec come il file <code>pyproject.toml</code> aggiornato, effettuiamone la commit, e pushiamo:</p> <pre><code>$ git add .github/workflows/release.yaml pyproject.toml\n$ git commit -m 'Ready for first release'\n$ git push -u origin main\n</code></pre> <p>Per creare una nuova release, navighiamo su https://github.com///releases/. Clicchiamo su \"Create a new release\". Indichiamo 0.1.0 come tag, ed Initial Release per il titolo. <p>Questo lancer\u00e0 un nuovo workflow sulle GitHub Actions. Una volta completato, dovremmo essere in grado div ered il nostro package su PyPI.</p> <p>A questo punto dovremmo essere in grado di installare il nostro package da PyPI.</p>"},{"location":"material/05_advanced_python/07_workflow/#conclusioni","title":"Conclusioni","text":"<p>Impostiamo una semplice pipeline di CI/CD per un package Python pubblicato su PyPI. Il codice su ogni branch viene controllato con i test e la code quality. Possiamo controllare la code coverage all'interno di CodeCov. Alla release, nuove versioni vengono deployate su PyPI, ed i documenti sono aggionrati. Quesot pu\u00f2 semplificare di molto la nostra vita.</p> <p>Le pipeline automatizzate come questa ci assicurano che il nostro worfklow rimanga lo stesso giorno dopo giorno. Tuttavia, dovremo sempre essere attenti alla cultura di lavoro del nostro team. Eseguiamo i test sul push, ma devono essere presenti. Infatti, automatizzare i test non dar\u00e0 alcun esito se non ci sono test. L'automatizzazione non far\u00e0 alcuna differenza anche alla dimensione dei nostri cambi. Cerchiamo di mantenerli piccoli, facendo spesso dei merge sul main. I piccoli cambi assieme al TDD ed una pipeline di CI/CD possono fare un'enorme differenza alla qualit\u00e0 del software che stiamo producendo. Non dimentichiamo che si inizia e finisce sempre con la team culture.</p>"},{"location":"material/12_prog_lang/03_assembly_ml/","title":"Assembly e linguaggio macchina","text":"<p>I computer odierni sono delle macchine di Von Neumann (concetto che riprenderemo pi\u00f9 in avanti) in grado di eseguire i programmi memorizzati nella memoria di massa, ovvero un insieme di istruzioni che indicano al processore il da farsi. </p> <p>Le istruzioni sono sostanzialmente dei numeri definiti sotto forma di un insieme di bit, la cui lunghezza dipende dalla specifica architettura utilizzata; ad esempio, le istruzioni per un processore di tipo ARM, come quelli presenti nella maggior parte degli smartphone, possono essere a 32 o 64 bit, ma sono incompatibili con quelle scritte per processori con architettura x64 (ovvero, quella comunemente usata su desktop e notebook).</p> <p>Un esempio di istruzione \u00e8 il numero <code>0x0120</code>, che potrebbe istruire il processore ad inserire <code>1</code> nel registro <code>0</code>; tale numero rappresenta una (piccola) porzione di codice macchina. Ovviamente, scrivere programmi moderni in questo modo \u00e8 estremamente complesso ed inefficiente, per cui nessun programmatore utilizza direttamente il codice macchina; tuttavia, esiste un linguaggio che si colloca ad un livello di astrazione leggermente pi\u00f9 alto, chiamato assembly, che ne fornisce una sorta di \"rappresentazione testuale\". In altre parole, l'assembly \u00e8 un linguaggio di programmazione a basso livello le cui istruzioni sono facilmente riconducibili al codice macchina.</p> <p>Approfondiamo brevemente i due linguaggi.</p>"},{"location":"material/12_prog_lang/03_assembly_ml/#il-linguaggio-macchina","title":"Il linguaggio macchina","text":""},{"location":"material/12_prog_lang/03_assembly_ml/#un-po-di-storia","title":"Un po' di storia","text":"<p>L'utilizzo della rappresentazione binaria per le istruzioni di un calcolatore deriva dai primi lavori compiuti da pionieri dell'informatica come John Mauchly e John Atanasoff nella prima met\u00e0 dello scorso secolo, e che port\u00f2 alla sua implementazione sui primi computer a partire dagli anni '50. Prima di quel momento, infatti, macchine come l'UNIVAC o l'ENIAC richiedevano agli (sfortunati) programmatori l'utilizzo di rel\u00e9, collegamenti analogici ed interruttori di vario tipo, che rendevano l'utilizzo di queste macchine complesso e dispendioso in termini di tempo.</p> <p>Con l'evoluzione dei calcolatori vennero anche nuove versioni del linguaggio macchina: una volta inventato il transistor, nel 1947, non pass\u00f2 molto tempo prima della commercializzazione del primo calcolatore digitale, l'UNIVAC I, programmabile inizialmente esclusivamente utilizzando il linguaggio macchina. Successivamente, negli anni '50, venne introdotto anche il corrispondente linguaggio assembly, chiamato PAL-11R; nonostante questo richiedesse comunque una dettagliata conoscenza del linguaggio macchina sottostante, era in grado di facilitare notevolmente il compito ai programmatori.</p> <p>Fu con l'arrivo di linguaggi ad alto livello come il COBOL, il BASIC ed il FORTRAN che si diffusero istruzioni pi\u00f9 simili al linguaggio naturale (in questo caso, l'inglese), e la platea di programmatori si ampli\u00f2 a dismisura. Tuttavia, il linguaggio macchina continu\u00f2 ad essere utilizzato per sviluppare software ad elevate prestazioni, come ad esempio i sistemi operativi. Avvicinandosi al nuovo millennio, tuttavia, vennero introdotti linguaggi pi\u00f9 complessi come il C ed il C++, che resero possibile ai programmatori scrivere del codice portabile tra diverse macchina. Anche allora, tuttavia, il linguaggio macchina rimase un must nello sviluppo di software a basso livello, come firmware e driver. Con l'avvento dei linguaggi pi\u00f9 moderni, come Java o Python, la pratica di sviluppare in codice macchina \u00e8 definitivamente andata in disuso.</p>"},{"location":"material/12_prog_lang/03_assembly_ml/#programmare-in-linguaggio-macchina","title":"Programmare in linguaggio macchina","text":"<p>Il linguaggio macchina, come abbiamo gi\u00e0 detto, permette di controllare direttamente la CPU. Ogni istruzione fa in modo che la CPU esegua un task specifico, come memorizzare o caricare un valore, o eseguire un'operazione aritmetico/logica, modificando di conseguenza una o pi\u00f9 unit\u00e0 di dati all'interno della memoria o dei registri del processore. Normalmente, il codice macchina \u00e8 considerato come l'interfaccia maggiormente \"a basso livello\" verso la CPU, tuttavia, esistono alcuni processori che includono un'interfaccia ancora pi\u00f9 a basso livello chiamata microcode.</p> <p>In teoria, quindi, \u00e8 possibile scrivere programmi direttamente in linguaggio macchina. Tuttavia, farlo \u00e8 estremamente complesso e dispendioso, in quanto il programmatore dovrebbe gestire manualmente i singoli bit del processore. Ci\u00f2 limita l'applicazione pratica di questo paradigma nei moderni processori a situazioni limite, nelle quali l'interazione a bassissimo livello \u00e8 inaggirabile; di conseguenza, i linguaggi moderni vengono tradotti in codice macchina mediante appositi programmi chiamati assembler, linker e compilatori.</p> <p>Interpreti e linguaggio macchina</p> <p>Un'eccezione notevole al paradigma precedente \u00e8 data dagli interpreti, che non traducono il codice sorgente in linguaggio macchina. Ci\u00f2 \u00e8 legato al fatto che questi traduttori sono delle vere e proprie \"macchine virtuali\" che eseguono le istruzioni indicate nel cordice sorgente.</p>"},{"location":"material/12_prog_lang/03_assembly_ml/#il-linguaggio-assembly","title":"Il linguaggio assembly","text":"<p>Abbiamo visto come il linguaggio macchina sia estremamente ostico da utilizzare ma, al contempo, offra possibilit\u00e0 semplicemente inarrivabili dai linguaggi di programmazione ad alto livello. Per rendere in qualche modo disponibili dette potenzialit\u00e0 ai programmatori ne \u00e8 stata quindi creata una versione human-readable che si occupa di \"mappare\" il codice macchina in stringhe ed istruzioni che, per quanto complesse, risultino essere leggibili da parte di un essere umano; questo linguaggio \u00e8 chiamato assembly.</p>"},{"location":"material/12_prog_lang/03_assembly_ml/#un-po-di-storia_1","title":"Un po' di storia","text":"<p>Il linguaggio assembly non esisteva quando i comptuer</p> <p>Assembly languages did not exist when stored-program computers were first introduced. The credit for inventing assembly language goes to Kathleen Booth, who began theoretical work on the concept in 1947. It was late 1948 when the Electronic Delay Storage Automatic Calculator (EDSAC) had an assembler integrated into its bootstrap program. It leveraged one-letter mnemonics developed by David Wheeler, credited as the creator of the first \u201cassembler.\u201d</p> <p>A few years later, in 1955, an assembly language known as the Symbolic Optimal Assembly Program (SOAP) was written by Stan Poley for the IBM 650 computer.</p> <p>Assembly languages went one step ahead of machine language. They eliminated much of the tedious, time-consuming, and error-prone operations seen in the first-generation programming of the earliest computers. They freed programmers from tasks such as calculating addresses and remembering numeric codes, thereby becoming the standard for many types of programming.</p> <p>Several programs were written using only assembly language. It was only in 1961 that the Burroughs MCP was introduced \u2014 this was the first computer whose operating system was not developed using only assembly language. Instead, its OS was written in Executive Systems Problem Oriented Language (ESPOL).</p> <p>Assembly language had (and, to a certain extent, still has) commercial applications. For instance, a considerable portion of the IBM mainframe software by corporations was written using assembly language.</p> <p>In commercial applications, the biggest advantages of assembly language included minimal bloat and overhead, as well as greater reliability and speed.</p> <p>However, assembly language was not only used commercially. As computers became more commonplace, assembly language also entered people\u2019s homes.</p> <p>Il linguaggio assembly d\u00e0 all\u2019utente la capacit\u00e0 di influenzare il funzionamento dell\u2019hardware e del software dlela macchina. Possiamo vederlo come un mezzo per collegare l\u2019hardware del computer al sistema operativo, e fare in modo che questi lavorino insieme. Il linguaggio fornisce inoltre un ponte per fare in modo che il sistema operativo comunichi con i programmi applicativi (e viceversa).</p> <p>A differenza dei linguaggi di alto livello, l\u2019assembly varia a seconda della macchina, in quanto ogni microprocessore si affida al suo insieme di istruzioni supportate. Ad esempio, il linguaggio assemvbly per un PC IBM consiste dell\u2019instruction set Intel 8086/8088.</p> <p>Imparare il linguaggio assembly comportra diversi benefici. Ad esempio, il programmatore pu\u00f2 comprendre al meglio l\u2019architettura del sistema. Inoltre, alcuni programmi che richiedono una stretta interazione a livello hardware (pensiamo ad un programma di telecomunicazion) e queste sono spesso difficili (e alle vlote impossibili) da scrivere in linguaggi ad alto livello.</p> <p>PEr rendere pi\u00f9 semplice la programmazione, la mggior parte dei linguaggi ad alto livello impongono delle regole che restgringono quello che pu\u00f2 fare il programmatore. Ad esempio, il Pascal non permette che i programmatori asseegnino caatteri a valori di tipo intero. Di converso l\u2019assembly ha un numero molto basso di regole e restrizuioni, in quanto praticamente gutti gli aspetti si affidano alla discrezionalit\u00e0 del program,ma. Anche se questo d\u00e0 ai programmatori esperti la libert\u00e0 di cui hanno bisogno per spingere i limiti del linguaggio assembly, richiede anche di gestire molte situazioni che la programmazione ad alto livello invece gestisce automaticamente.</p> <p>Per esempio, se un programma ad alto livello \u00e8 usato per comparare due stringhe, il codice sar\u00e0 traslato usando delle istruzioni semplici. Tuttavia, il programma sar\u00e0 molto pi\u00f9 denso usando istruzioni complesse che effettuano lo stessa operazione.</p> <p>Un altro vantaggio dell\u2019assembly rispetto ai linguaggi ad alto livello \u00e8 l\u2019efficienza sia in termini di memoria sia in termini di tempo: il coldice scritto in linguaggio assembly \u00e8 generalemnte pi denso dello stesso codice generato da un linguaggio ad alto livello. Questo \u00e8 legato al fatto che molti compilatori utilizzano in maniera subottimale le istruzioni complesse.</p> <p>Prima abbiamo detto che 0x0120 significa \u201cmetti 1 nel registro 0\u201d. Un registro \u00e8 una piccola partizione di memoria che pu\u00f2 contenere un numero. Dato che normalmente ve ne sono pochi, non possono rimpiazzare la memoria principale della macchian; ttuavia, sono estremamente pi\u00f9 veloci di quest\u2019ultima, quindi maneggiarli diventa fondamentale.</p> <p>NEl linguaggio assembly, l\u2019inserimento del numero 1 nel registro 0 \u00e8 scritto come moves r0, #1. Di conseguenza, quando l\u2019asesembler vede un\u2019operazione MOVS pu\u00f2 generare il corretto codice macchina, a seconda del registro usatgo.</p> <p>Ecco un esempio di linguaggio assembly:</p> <pre><code>// i = 15;\nmov r3, #15\nstr r3, [r11, #-8]\n\n//j = 25;\nmov r3, #25\nstr r3, [r11, #-12]\n\n// i = i + j;\nldr r2, [r11, #-8]\nldr r3, [r11, #-12]\nadd r3, r2, r3\nstr r3, [r11, #-8]\n</code></pre> <p>Le righe che iniziano con // sono dei commenti che contengono l\u2019equivalente in linguaggio C di quello che si fa in linguaggio assembly. Come possiamo vedere, questo codice crea una variabile i, che \u00e8 memorizzata nella memoria stack, e la imposta a 15. Infine, aggiunge i a j, caricando o i in r2 e j in r3, e quindi memorizza i risultati in i.</p> <p>In altre parole, impsotare due variabili e sommarle richiede otto righe di codice. Questo ci fa capire quanto sforzo richiederebbe lo sviluppo di linguaggi pi\u00f9 complessi: il programma equivalente in 3 \u00e8 lungo solo tre righe, e diventa ancora pi\u00f9 compatto in linguaggi ancora a pi\u00f9 alto livello.</p>"},{"location":"material/12_prog_lang/03_assembly_ml/#machine-language-vs-assembly-language","title":"Machine language vs Assembly language","text":"<p>ASSEMBLY</p> <p>Assembly languages did not exist when stored-program computers were first introduced. The credit for inventing assembly language goes to Kathleen Booth, who began theoretical work on the concept in 1947. It was late 1948 when the Electronic Delay Storage Automatic Calculator (EDSAC) had an assembler integrated into its bootstrap program. It leveraged one-letter mnemonics developed by David Wheeler, credited as the creator of the first \u201cassembler.\u201d</p> <p>A few years later, in 1955, an assembly language known as the Symbolic Optimal Assembly Program (SOAP) was written by Stan Poley for the IBM 650 computer.</p> <p>Assembly languages went one step ahead of machine language. They eliminated much of the tedious, time-consuming, and error-prone operations seen in the first-generation programming of the earliest computers. They freed programmers from tasks such as calculating addresses and remembering numeric codes, thereby becoming the standard for many types of programming.</p> <p>Several programs were written using only assembly language. It was only in 1961 that the Burroughs MCP was introduced \u2014 this was the first computer whose operating system was not developed using only assembly language. Instead, its OS was written in Executive Systems Problem Oriented Language (ESPOL).</p> <p>Assembly language had (and, to a certain extent, still has) commercial applications. For instance, a considerable portion of the IBM mainframe software by corporations was written using assembly language.</p> <p>In commercial applications, the biggest advantages of assembly language included minimal bloat and overhead, as well as greater reliability and speed.</p> <p>However, assembly language was not only used commercially. As computers became more commonplace, assembly language also entered people\u2019s homes.</p> <p>SVILUPPO</p> <p>LINGUAGGIO MACCHINA</p> <p>ASSEMBLY</p> <p>Assembly language was the primary development language for several well-known home computers in the 1980s and 1990s, including the Sinclair ZX Spectrum, MSX, Atari ST, Commodore 64, and Commodore Amiga. One reason for this was the interpreted BASIC dialects on these systems leading to insufficient execution speed and unsatisfactory facilities for taking complete advantage of available system hardware.</p> <p>Popular examples of assembly language programs included the Turbo Pascal compiler, the IBM PC DOS operating systems, and even early programs such as the spreadsheet processor Lotus 1-2-3 and the 1993 arcade game NBA Jam. Interestingly, assembly language was chosen to enhance the performance of the Sega Saturn, a gaming console well-known for its development challenges.</p> <p>The use of hand-coded assembly language was even seen in early microcomputers, including in operating systems and large applications. Assembly language allowed developers to address system challenges such as severe resource constraints, imposed idiosyncratic display and memory architectures, limited and buggy services, and the lack of first-class high-level language compilers for microcomputers.</p> <p>FORTRAN, COBOL, and PL/I eventually went on to displace assembly language; however, numerous large organizations still relied on assembly language application infrastructures until the turn of the millennium.</p> <p>While it did not take long for the use of assembly languages to be supplanted by higher-level languages, they still see usage even today for direct hardware manipulation, addressing critical performance issues, and accessing specialized processor instructions. The typical applications of modern-day assembly languages include low-level embedded systems, real-time systems, and device drivers.</p> <p>APPLICAZIONI</p> <p>LINGUAGGIO MACHCINA</p> <p>ASSEMBLY</p> <p>Assembly language is used for several applications. For instance,\u00a0it is useful for standalone, compact executables that must run without recourse to the libraries or runtime components found in high-level languages. Examples include</p> <p>firmware</p> <p>for telephones, air-conditioning control systems, automobile ignition and fuel systems, sensors, and security systems.</p> <p>Assembly language is also used in programs with performance-sensitive inner loops, where it provides opportunities for optimization that are otherwise difficult to achieve when using a high-level language (think linear algebra with BLAS or discrete cosine transformation).</p> <p>Assembly language is useful for programs that build vectorized functions for programs in C and other higher-level languages.</p> <p>It is also used in real-time programs such as flight navigation systems, medical equipment, and simulations. For instance, fly-by-wire systems require telemetry to be interpreted and executed within stringent time constraints. Thus, sources of unpredictable delays must be removed, making some interpreted languages incompatible with the application. Here, assembly language gives programmers greater transparency and management capabilities over processing details.</p> <p>Similarly, assembly language can be useful for cryptographic algorithms that strictly require the same execution time every time to thwart\u00a0timing attacks.</p> <p>Assembly language is used in solutions that require end-to-end control over the environment. It can also be found in applications without high-level language and for new or specialized processors with no cross-compilers available.</p> <p>Aside from this, it is used in instruction set simulators for tracing, debugging, and monitoring while keeping additional overhead to a minimum.</p> <p>\u201cROM hacking\u201d of video games can also occur by modifying program code at the assembly language level.</p> <p>It can also be used for reverse-engineering and altering program files, such as existing binaries that could have been initially written in either assembly or higher-level languages.</p> <p>Finally, fundamental topics like binary arithmetic, stack processing, memory allocation, character set encoding, compiler design, and interrupt processing would be difficult to study without learners first understanding how computers operate at the hardware level.</p> <p>PROGRAMMAZIONE</p> <p>Assembly language is the preferred language for programming on systems with older processors featuring limited high-level language options, such as the Commodore 64 and Atari 2600.</p> <p>It is also used in the boot code for many newer systems. Here, it serves as the low-level code that initializes and runs tests on the\u00a0system hardware\u00a0before the operating system is booted. It is often stored in ROM.</p> <p>It is also used for low-level code like operating system kernels, which cannot depend on the availability of pre-existing system calls.</p> <p>Assembly language is also used for writing code that interacts directly with hardware, such as interrupt handlers and device drivers.</p> <p>Finally, this language is used for programs requiring processor-specific instructions not implemented at the compiler level. This can include, for instance, the bitwise rotation instruction that is a key part of many encryption algorithms.</p> <p>FeATURE DEL LINGUAGGIO</p> <p>Human comprehension:</p> <p>Unlike assembly language, machine language is so unreadable that even the US Copyright Office has stated its inability to identify whether specific encoded programs are original work. Comparisons have been made between machine language and genetic code. However, the machine code used for a program can be decompiled or disassembled in cases where its functioning needs to be made more easily understandable to humans, although this output will be without the relevant symbolic references and comments.</p> <p>Microcode:\u00a0Some computers implement machine language using a more fundamental layer called microcode. This underlying layer provides a common interface for machine language for various computer models with varying underlying dataflows. Using microcode facilitates the porting of machine language programs between computing models.</p> <p>Bytecode:\u00a0Bytecode, also called p-code, is different from machine language and is either compiled into machine language for direct execution or executed through an interpreter. However, some processors (like Java) are designed to execute specific bytecode directly as machine language.</p> <p>In-memory storage:\u00a0When a computer runs a program, it is stored in RAM as machine code. The CPU uses this code to perform its tasks. To improve program performance, the machine code is sometimes cached, and the CPU tracks the part of the machine code that needs to be executed by using a program counter, which is a value that guides the CPU to where in memory the next set of instructions can be found. It can be set to any memory address, but an error will be generated if the address is invalid. To help prevent this, some systems use special bits called \u201cexecute bits\u201d to indicate if a section of memory contains code that is allowed to be executed.</p> <p>Code space:\u00a0When multiple programs run on the computer simultaneously, each program has its own memory section dedicated to machine language. These sections are called code spaces. In multithreading environments, different threads of a single program share the same code space, which can reduce the amount of time needed to switch between tasks. However, this can also be a\u00a0security concern, as malicious actors can execute code stored in the code</p> <p>Fundamental elements:</p> <p>Assembly languages typically consist of three types of instruction statements: opcode mnemonics, assembly directives, and data definitions. These fundamental elements are leveraged to define program operations. Apart from these, assembler authors can categorize the statements and nomenclature they use in various ways. For instance, some authors may classify any element other than a machine mnemonic or extended mnemonic as a pseudo-operation, or pseudo-op for short.</p> <p>Mnemonics:\u00a0In assembly language, instructions are simple and represented by a symbolic name known as a mnemonic. The mnemonic refers to a machine language instruction, which typically consists of an operation (opcode) and one or more operands. Operands can be immediate values, registers, or data addresses stored elsewhere in memory. The assembler reflects the underlying processor architecture in how it handles the operands. Some assemblers include extended mnemonics for specialized uses and macro-instructions that generate multiple machine instructions.</p> <p>Data directives:\u00a0These directives allow users to define data elements to hold variables and data. They define a data type, length, alignment, and data availability for outside programs assembled separately. Data directives are classified as pseudo-ops by some assemblers.</p> <p>Assembly directives:\u00a0Assembly language has special commands called assembly directives or pseudo-opcodes. These directives instruct the assembler to perform operations other than assembling instructions. They can impact the object code, symbol table, and the values of internal assembler parameters. Assembly language allows programmers to associate names with memory locations and constants, making the code more self-documenting. Some assemblers also provide flexible symbol management and support for comments in the code. These comments are important as the raw assembly language can be challenging to understand without them.</p> <p>Macros:\u00a0These are sequences of text lines in assembly language that can include variables and constants. Macros are typically used to make assembly language programs appear shorter and to add structure to the code. Assembler macro instructions can be lengthy and include high-level language elements like variables, arithmetic operations, and string manipulation. Macros can take parameters and generate assembly language instructions based on the arguments. Despite their power, macro processing has fallen into disuse in many high-level languages but remains a staple in assembly language.</p>"},{"location":"material/12_prog_lang/03_assembly_ml/#takeaway","title":"Takeaway","text":"<p>Both machine and assembly languages are low-level programming languages used to write programs. Machine language is the binary code computers understand and execute directly, while assembly language is a human-readable machine language representation.</p> <p>One of the key differences between the two languages is their level of abstraction. Machine language is much closer to the hardware, consisting of a series of binary instructions that the CPU can execute directly. On the other hand, assembly language uses mnemonics and symbols to represent machine language instructions, making it easier for humans to read and write.</p> <p>Another difference is the level of control offered by the two languages. Assembly language provides a higher level of control over the system, allowing direct manipulation of memory locations, register values, and system calls. Machine language, on the other hand, only allows direct manipulation of the binary code.</p> <p>Higher-level programming languages have largely replaced both languages; however, the two still serve specific functions.</p>"},{"location":"material/algobuild/","title":"Diagrammi Algobuild","text":"Argomento Diagramma Link Programmazione strutturata Soluzione di un'equazione di secondo grado Algoritmi iterativi Somma di tre interi consecutivi Algoritmi iterativi Calcolo della media Algoritmi iterativi Calcolo del massimo in un vettore Algoritmi iterativi Somma di due vettori Algoritmi ricorsivi Calcolo del fattoriale"},{"location":"material/appendix/01_vs_comm/guide/","title":"Appendice A - Installazione di Visual Studio Community","text":"<ol> <li>Andare al seguente indirizzo, e selezionare l'opzione Scarica Visual Studio.</li> <li>Si aprir\u00e0 un'altra pagina, e verr\u00e0 scaricato un file chiamato <code>VisualStudioSetup.exe</code> (o similari nel caso di installazione via MacOS). Lanciarlo per avviare il programma di installazione.</li> <li>Confermare la procedura di installazione di Visual Studio Installer.</li> <li>Una volta terminato il download dei file necessari, apparir\u00e0 la schermata di Visual Studio Installer. Selezionare la versione Community, ed attendere il termine della procedura di installazione.</li> <li>Selezionare Modifica. Si aprir\u00e0 l'interfaccia mostrata in figura.</li> </ol> <ol> <li>Selezioniamo la casella di spunta a destra di Sviluppo di applicazioni desktop con C++, premiamo il pulsante Modifica in basso a destra, ed attendiamo il termine dell'installazione.</li> </ol>"},{"location":"material/appendix/02_python_vs_code/guide/","title":"Appendice B - Configurazione dell'ambiente di sviluppo Python","text":""},{"location":"material/appendix/02_python_vs_code/guide/#installazione-di-python","title":"Installazione di Python","text":"<ol> <li>Andare al seguente indirizzo, e selezionare la versione adatta al proprio sistema operativo.</li> <li>Iniziare la procedura di installazione (ad esempio, in Windows, cliccando sull'eseguibile appena scaricato). E' fortemente consigliato aggiungere Python al proprio PATH spuntando l'opportuna casella durante l'installazione, come mostrato in figura.</li> </ol> <ol> <li>Una volta completata la procedura di installazione, aprire uno shell (ad esempio, il prompt dei comandi), e digitare <code>python</code>. Se tutto \u00e8 andato per il verso giusto, apparir\u00e0 una schermata simile alla successiva.</li> </ol>"},{"location":"material/appendix/02_python_vs_code/guide/#installazione-di-visual-studio-code","title":"Installazione di Visual Studio Code","text":"<ol> <li>Andare al seguente indirizzo, e selezionare la versione adatta al proprio sistema operativo.</li> <li>Seguire la procedura di installazione mostrata a schermo. E' anche in questo caso consigliata l'aggiunta di Visual Studio Code al path, come mostrato in figura.</li> </ol>"},{"location":"material/appendix/03_sample_project/lecture/","title":"Appendice E - Tema d'esempio","text":"<p>Addendum A.A. 2022/2023</p> <p>A questo indirizzo potete trovare un esempio di tema d'anno effettivamente mostrato dallo studente Antonio De Leo durante l'esame per l'A.A. 2021/2022.</p> <p>In questa appendice descriviamo un esempio di tema d'anno.</p> <p>In particolare, l'argomento trattato da questo esempio \u00e8:</p> <p>Implementazione di un metodo di ordinamento vettoriale basato sull'algoritmo selection sort.</p>"},{"location":"material/appendix/03_sample_project/lecture/#parti-da-evidenziare","title":"Parti da evidenziare","text":"<ol> <li>Struttura del programma. Evidenziare la struttura del programma, descrivendo cartelle e file utilizzati. Ad esempio: nella cartella <code>algs</code> sono contenuti i moduli appartenenti al package omonimo, il cui compito \u00e8 quello di contenere il codice usato per gli algoritmi, oppure lo script <code>run.py</code> rappresenta il punto di accesso principale al programma, e contiene il metodo omonimo, che effettua l'ordinamento di un vettore in ingresso ricavato a partire dall'input ricevuto mediante il modulo <code>argparse</code> invocando i metodi definiti nel packae <code>algs</code>.</li> <li>Eventuali algoritmi utilizzati. In questo caso, vanno elencati e spiegati brevemente gli eventuali algoritmi utilizzati. Ad esempio: il programma implementa l'algoritmo di ordinamento su vettori chiamato selection sort, il quale ordina in maniera iterativa un vettore suddividendolo in due sottoinsiemi, che saranno comparati ad ogni iterazione ed eventualmente modificati scambiando l'ultimo valore dell'array a sinistra con il primo dell'array a destra fino al termine dell'algoritmo.</li> </ol> <p>Il codice va inoltre commentato, spiegando nel dettaglio il funzionamento di ciascun metodo o classe.</p>"},{"location":"material/appendix/03_sample_project/lecture/#codice","title":"Codice","text":"<p>Il codice \u00e8 organizzato secondo questa struttura:</p> <pre><code>|src                    # Package principale\n|---__init__.py\n    |algs               # Package dedicato agli algoritmi\n    |---__init__.py\n        sorting.py      # Modulo per le classi per l'ordinamento\n|run.py                 # Script principale\n</code></pre> <p>Di seguito il link ai due file di rilievo (gli <code>__init__.py</code> sono file vuoti):</p> File Link Script principale (run.py) Modulo per le classi per l'ordinamento (sorting.py)"},{"location":"material/appendix/04_homeworks/lecture/","title":"Esempio di risoluzione degli esercizi svolti a casa","text":""},{"location":"material/appendix/04_homeworks/lecture/#compito-1-","title":"Compito 1 -","text":""},{"location":"material/appendix/04_homeworks/lecture/#compito-2-applicazione-dei-concetti-teorici","title":"Compito 2 - Applicazione dei concetti teorici","text":"<p>Si applichino i concetti teorici visti a lezione alla risoluzione del seguente problema.</p> <p>Si supponga di avere l'insieme dei numeri che vanno da 1 a 10 (ovvero 1, 2, 3, ..., 9, 10). Si vuole creare un algoritmo che restituisca soltanto i numeri pari, ovvero divisibili per 2 senza resto. Per far questo:</p> <ul> <li>definire il problema nei termini indicati a lezione (obiettivo, ente risolutore, etc.);</li> <li>definire, in maniera descrittiva, un algoritmo che possa risolvere il problema;</li> <li>definire il diagramma di flusso associato all'algoritmo precedentemente descritto.</li> </ul>"},{"location":"material/appendix/04_homeworks/lecture/#punto-21-definizione-del-problema-nei-termini-indicati-a-lezione","title":"Punto 2.1 - Definizione del problema nei termini indicati a lezione","text":"Elemento Definizione Obiettivo L'obiettivo del problema \u00e8 quello di restituire i numeri pari compresi nell'intervallo che va tra 1 a 10. Ente risolutore In senso lato, chi implementa l'algoritmo; in senso stretto, il calcolatore. Elementi noti Insieme dei numeri da valutare, regola per la quale un numero \u00e8 pari se il resto della divisione per due \u00e8 zero."},{"location":"material/appendix/04_homeworks/lecture/#punto-22-definizione-descrittiva-di-un-algoritmo-che-possa-risolvere-il-problema","title":"Punto 2.2 - Definizione descrittiva di un algoritmo che possa risolvere il problema","text":"<ol> <li>Al primo punto, l'algoritmo considerer\u00e0 la lista <code>numeri</code> contenente i valori che vanno da 1 a 10. Opzionalmente, potrebbe anche leggerli da un supporto esterno.</li> <li>Successivamente, sar\u00e0 usato un ciclo FOR per contare dieci iterazioni, una per ogni elemento della lista <code>numeri</code>. Per il conteggio, sar\u00e0 usata una variabile contatore chiamata <code>i</code> con valore iniziale pari a 0.</li> <li>Ad ogni iterazione, l'algoritmo valuter\u00e0 se l'<code>i</code>-mo elemento della lista <code>numeri</code> \u00e8 divisibile per 2. Nel caso questo sia vero, lo stamper\u00e0 a schermo; in caso contrario, non sar\u00e0 effettuata alcuna operazione.</li> <li>Si incrementa la variabile contatore di 1, e si torna al punto 2.</li> <li>Quando la variabile contatore assumer\u00e0 valore maggiore od uguale a 10, l'algoritmo terminer\u00e0 la sua esecuzione.</li> </ol>"},{"location":"material/appendix/04_homeworks/lecture/#punto-23-definire-il-diagramma-di-flusso-del-problema-nei-termini-indicati-a-lezione","title":"Punto 2.3 - Definire il diagramma di flusso del problema nei termini indicati a lezione","text":"<pre><code>flowchart TD\n    A((Start)) --&gt; B[\"numeri = [1, ..., 10]\"];\n    B --&gt; C[i = 0];\n    C --&gt; D{i &lt; 10?};\n    D --&gt; |S\u00ec| E{\"numeri[i] % 2 == 0?\"};\n    E --&gt; |S\u00ec| F[/\"print(numeri[i])\"/];\n    F --&gt; G[i = i+1];\n    E --&gt; |No| G;\n    G --&gt; D;\n    D --&gt; |No| H((End));\n</code></pre>"},{"location":"material/matlab/","title":"Codice sorgente MATLAB","text":"<p>IN ARRIVO</p>"},{"location":"material/slides/","title":"Slides proiettate a lezione","text":"Argomento Link 00 - Introduzione al corso 01 - Introduzione all'informatica 02 - Rappresentazione dell'informazione 03 - Conversioni di base 04 - Algebra booleana 05 - Introduzione agli algoritmi 06 - Costanti e variabili 07 - Istruzioni, proposizioni e predicati 08 - Vettori e matrici 09 - Programmazione strutturata 10 - Algoritmi iterativi e ricorsivi 11 - Pseudocodifica 12 - Linguaggi di programmazione 13 - Introduzione a MATLAB 14 - Switch case in MATLAB"}]}